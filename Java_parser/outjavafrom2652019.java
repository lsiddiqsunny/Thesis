@Override
public void setUp() throws Exception {
    context = new RenamingDelegatingContext(getContext(), "test-");
    dbHelper = new DatabaseHelper(context);
    db = new DatabaseAdapter(context);
    db.dbHelper = db.dbHelper = dbHelper;
    categoryRepository = new CategoryRepository(context);
    categoryRepository.db = db;
}

######


@Override
public void tearDown() throws Exception {
    dbHelper.close();
}

######


public void assertAccountTotal(Account account, long total) {
    Account a = db.getAccount(account.id);
    assertEquals("Account " + account.id + " total", total, a.totalAmount);
}

######


public void assertLastTransactionDate(Account account, DateTime dateTime) {
    Account a = db.getAccount(account.id);
    assertEquals("Account " + account.id + " last transaction date", dateTime.asLong(), a.lastTransactionDate);
}

######


public void assertFinalBalanceForAccount(Account account, long expectedBalance) {
    long balance = db.getLastRunningBalanceForAccount(account);
    assertEquals("Account " + account.id + " final balance", expectedBalance, balance);
}

######


public void assertAccountBalanceForTransaction(Transaction t, Account a, long expectedBalance) {
    long balance = db.getAccountBalanceForTransaction(a, t);
    assertEquals(expectedBalance, balance);
}

######


public void assertTransactionsCount(Account account, long expectedCount) {
    long count = DatabaseUtils.rawFetchLongValue(db, "select count(*) from transactions where from_account_id=?", new String[] { String.valueOf(account.id) });
    assertEquals("Transaction for account " + account.id, expectedCount, count);
}

######


public void assertCategory(String name, boolean isIncome, Category c) {
    assertEquals(name, c.title);
    assertEquals(isIncome, c.isIncome());
}

######


public static <T> Set<T> asSet(T... values) {
    return new HashSet<T>(Arrays.asList(values));
}

######


public abstract T getSelf();

######


public T UPDATE(String table) {
    sql().statementType = SQLStatement.StatementType.UPDATE;
    sql().tables.add(table);
    return getSelf();
}

######


public T SET(String sets) {
    sql().sets.add(sets);
    return getSelf();
}

######


public T SET(String... sets) {
    sql().sets.addAll(Arrays.asList(sets));
    return getSelf();
}

######


public T INSERT_INTO(String tableName) {
    sql().statementType = SQLStatement.StatementType.INSERT;
    sql().tables.add(tableName);
    return getSelf();
}

######


public T VALUES(String columns, String values) {
    sql().columns.add(columns);
    sql().values.add(values);
    return getSelf();
}

######


public T INTO_COLUMNS(String... columns) {
    sql().columns.addAll(Arrays.asList(columns));
    return getSelf();
}

######


public T INTO_VALUES(String... values) {
    sql().values.addAll(Arrays.asList(values));
    return getSelf();
}

######


public T SELECT(String columns) {
    sql().statementType = SQLStatement.StatementType.SELECT;
    sql().select.add(columns);
    return getSelf();
}

######


public T SELECT(String... columns) {
    sql().statementType = SQLStatement.StatementType.SELECT;
    sql().select.addAll(Arrays.asList(columns));
    return getSelf();
}

######


public T SELECT_DISTINCT(String columns) {
    sql().distinct = true;
    SELECT(columns);
    return getSelf();
}

######


public T SELECT_DISTINCT(String... columns) {
    sql().distinct = true;
    SELECT(columns);
    return getSelf();
}

######


public T DELETE_FROM(String table) {
    sql().statementType = SQLStatement.StatementType.DELETE;
    sql().tables.add(table);
    return getSelf();
}

######


public T FROM(String table) {
    sql().tables.add(table);
    return getSelf();
}

######


public T FROM(String... tables) {
    sql().tables.addAll(Arrays.asList(tables));
    return getSelf();
}

######


public T JOIN(String join) {
    sql().join.add(join);
    return getSelf();
}

######


public T JOIN(String... joins) {
    sql().join.addAll(Arrays.asList(joins));
    return getSelf();
}

######


public T INNER_JOIN(String join) {
    sql().innerJoin.add(join);
    return getSelf();
}

######


public T INNER_JOIN(String... joins) {
    sql().innerJoin.addAll(Arrays.asList(joins));
    return getSelf();
}

######


public T LEFT_OUTER_JOIN(String join) {
    sql().leftOuterJoin.add(join);
    return getSelf();
}

######


public T LEFT_OUTER_JOIN(String... joins) {
    sql().leftOuterJoin.addAll(Arrays.asList(joins));
    return getSelf();
}

######


public T RIGHT_OUTER_JOIN(String join) {
    sql().rightOuterJoin.add(join);
    return getSelf();
}

######


public T RIGHT_OUTER_JOIN(String... joins) {
    sql().rightOuterJoin.addAll(Arrays.asList(joins));
    return getSelf();
}

######


public T OUTER_JOIN(String join) {
    sql().outerJoin.add(join);
    return getSelf();
}

######


public T OUTER_JOIN(String... joins) {
    sql().outerJoin.addAll(Arrays.asList(joins));
    return getSelf();
}

######


public T WHERE(String conditions) {
    sql().where.add(conditions);
    sql().lastList = sql().where;
    return getSelf();
}

######


public T WHERE(String... conditions) {
    sql().where.addAll(Arrays.asList(conditions));
    sql().lastList = sql().where;
    return getSelf();
}

######


public T OR() {
    sql().lastList.add(OR);
    return getSelf();
}

######


public T AND() {
    sql().lastList.add(AND);
    return getSelf();
}

######


public T GROUP_BY(String columns) {
    sql().groupBy.add(columns);
    return getSelf();
}

######


public T GROUP_BY(String... columns) {
    sql().groupBy.addAll(Arrays.asList(columns));
    return getSelf();
}

######


public T HAVING(String conditions) {
    sql().having.add(conditions);
    sql().lastList = sql().having;
    return getSelf();
}

######


public T HAVING(String... conditions) {
    sql().having.addAll(Arrays.asList(conditions));
    sql().lastList = sql().having;
    return getSelf();
}

######


public T ORDER_BY(String columns) {
    sql().orderBy.add(columns);
    return getSelf();
}

######


public T ORDER_BY(String... columns) {
    sql().orderBy.addAll(Arrays.asList(columns));
    return getSelf();
}

######


private SQLStatement sql() {
    return sql;
}

######


public <A extends Appendable> A usingAppender(A a) {
    sql().sql(a);
    return a;
}

######


@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sql().sql(sb);
    return sb.toString();
}

######


public SafeAppendable append(CharSequence s) {
    try {
        if (empty && s.length() > 0) {
            empty = false;
        }
        a.append(s);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
    return this;
}

######


public boolean isEmpty() {
    return empty;
}

######


private void sqlClause(SafeAppendable builder, String keyword, List<String> parts, String open, String close, String conjunction) {
    if (!parts.isEmpty()) {
        if (!builder.isEmpty()) {
            builder.append("\n");
        }
        builder.append(keyword);
        builder.append(" ");
        builder.append(open);
        String last = "________";
        for (int i = 0, n = parts.size(); i < n; i++) {
            String part = parts.get(i);
            if (i > 0 && !part.equals(AND) && !part.equals(OR) && !last.equals(AND) && !last.equals(OR)) {
                builder.append(conjunction);
            }
            builder.append(part);
            last = part;
        }
        builder.append(close);
    }
}

######


private String selectSQL(SafeAppendable builder) {
    if (distinct) {
        sqlClause(builder, "SELECT DISTINCT", select, "", "", ", ");
    } else {
        sqlClause(builder, "SELECT", select, "", "", ", ");
    }
    sqlClause(builder, "FROM", tables, "", "", ", ");
    joins(builder);
    sqlClause(builder, "WHERE", where, "(", ")", " AND ");
    sqlClause(builder, "GROUP BY", groupBy, "", "", ", ");
    sqlClause(builder, "HAVING", having, "(", ")", " AND ");
    sqlClause(builder, "ORDER BY", orderBy, "", "", ", ");
    return builder.toString();
}

######


private void joins(SafeAppendable builder) {
    sqlClause(builder, "JOIN", join, "", "", "\nJOIN ");
    sqlClause(builder, "INNER JOIN", innerJoin, "", "", "\nINNER JOIN ");
    sqlClause(builder, "OUTER JOIN", outerJoin, "", "", "\nOUTER JOIN ");
    sqlClause(builder, "LEFT OUTER JOIN", leftOuterJoin, "", "", "\nLEFT OUTER JOIN ");
    sqlClause(builder, "RIGHT OUTER JOIN", rightOuterJoin, "", "", "\nRIGHT OUTER JOIN ");
}

######


private String insertSQL(SafeAppendable builder) {
    sqlClause(builder, "INSERT INTO", tables, "", "", "");
    sqlClause(builder, "", columns, "(", ")", ", ");
    sqlClause(builder, "VALUES", values, "(", ")", ", ");
    return builder.toString();
}

######


private String deleteSQL(SafeAppendable builder) {
    sqlClause(builder, "DELETE FROM", tables, "", "", "");
    sqlClause(builder, "WHERE", where, "(", ")", " AND ");
    return builder.toString();
}

######


private String updateSQL(SafeAppendable builder) {
    sqlClause(builder, "UPDATE", tables, "", "", "");
    joins(builder);
    sqlClause(builder, "SET", sets, "", "", ", ");
    sqlClause(builder, "WHERE", where, "(", ")", " AND ");
    return builder.toString();
}

######


public String sql(Appendable a) {
    SafeAppendable builder = new SafeAppendable(a);
    if (statementType == null) {
        return null;
    }
    String answer;
    switch(statementType) {
        case DELETE:
            answer = deleteSQL(builder);
            break;
        case INSERT:
            answer = insertSQL(builder);
            break;
        case SELECT:
            answer = selectSQL(builder);
            break;
        case UPDATE:
            answer = updateSQL(builder);
            break;
        default:
            answer = null;
    }
    return answer;
}

######


@Override
public void initialize(URL location, ResourceBundle resources) {
    dataInfo();
    setAdmin();
    if (ControlLogin.getInstance().userName().equals("Admin")) {
        setListUser();
        delAccount();
    }
    changePass();
    addUser();
    huyThaoTac();
}

######


private void setListUser() {
    listuser.clear();
    Connection conn = SQLiteConnection.connector();
    PreparedStatement pre;
    ResultSet rs;
    String u = "select User from ADMIN where User not in (select User from ADMIN where User = 'Admin')";
    try {
        pre = conn.prepareStatement(u);
        rs = pre.executeQuery();
        while (rs.next()) {
            listuser.add(rs.getString("User"));
        }
        lvUser.setItems(listuser);
        pre.close();
        rs.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


private void clear() {
    txtUser.clear();
    txtEmail.clear();
    txtConfirm.clear();
    txtPhone.clear();
    txtNewPass.clear();
    txtOldPass.clear();
}

######


private void enableTextBut() {
    txtUser.setEditable(true);
    txtEmail.setEditable(true);
    txtConfirm.setEditable(true);
    txtPhone.setEditable(true);
    txtNewPass.setEditable(true);
    txtOldPass.setEditable(true);
    btnOk.setDisable(false);
}

######


private void enablePassBut() {
    txtConfirm.setEditable(true);
    txtNewPass.setEditable(true);
    txtOldPass.setEditable(true);
    btnOk.setDisable(false);
}

######


private void disableTextBut() {
    txtUser.setEditable(false);
    txtEmail.setEditable(false);
    txtConfirm.setEditable(false);
    txtPhone.setEditable(false);
    txtNewPass.setEditable(false);
    txtOldPass.setEditable(false);
    btnOk.setDisable(true);
}

######


private void dataInfo() {
    Connection conn = SQLiteConnection.connector();
    PreparedStatement pre;
    ResultSet rs;
    String EmailPhone = "select Email,Phone from ADMIN where User = ?";
    try {
        pre = conn.prepareStatement(EmailPhone);
        pre.setString(1, ControlLogin.getInstance().userName());
        rs = pre.executeQuery();
        txtUser.setText(ControlLogin.getInstance().userName());
        txtEmail.setText(rs.getString(1));
        txtPhone.setText(rs.getString(2));
        pre.close();
        rs.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


private void setAdmin() {
    if (ControlLogin.getInstance().userName().equals("Admin")) {
        btnAdd.setDisable(false);
        btnXoa.setDisable(false);
    }
}

######


private String selectOldPass() {
    Connection conn = SQLiteConnection.connector();
    PreparedStatement pre;
    ResultSet rs;
    String EmailPhone = "select Pass from ADMIN where User = ?";
    try {
        pre = conn.prepareStatement(EmailPhone);
        pre.setString(1, ControlLogin.getInstance().userName());
        rs = pre.executeQuery();
        txtUser.setText(ControlLogin.getInstance().userName());
        oldPass = rs.getString(1);
        pre.close();
        rs.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return oldPass;
}

######


private void clearPass() {
    txtNewPass.clear();
    txtOldPass.clear();
    txtConfirm.clear();
}

######


private void changePass() {
    btnChange.setOnAction(e -> {
        enablePassBut();
        btnHuy.setDisable(false);
        btnOk.setOnAction(event -> {
            if (selectOldPass().equals(txtOldPass.getText()) && txtNewPass.getText().equals(txtConfirm.getText())) {
                Connection connection = SQLiteConnection.connector();
                PreparedStatement pre1;
                String change = "update ADMIN set Pass = ? where User = ?";
                try {
                    pre1 = connection.prepareStatement(change);
                    pre1.setString(1, txtNewPass.getText());
                    pre1.setString(2, txtUser.getText());
                    pre1.executeUpdate();
                    dataInfo();
                    pre1.close();
                    clearPass();
                    btnHuy.setDisable(true);
                    Alert alertp = new Alert(Alert.AlertType.INFORMATION);
                    alertp.setHeaderText(null);
                    alertp.setContentText("Đổi Thành Công!");
                    alertp.showAndWait();
                } catch (Exception m) {
                    m.printStackTrace();
                }
            } else if (!selectOldPass().equals(txtOldPass.getText())) {
                Alert alert1 = new Alert(Alert.AlertType.ERROR);
                alert1.setHeaderText(null);
                alert1.setContentText("Sai Old Pass!");
                alert1.showAndWait();
            } else if (!txtNewPass.getText().equals(txtConfirm.getText())) {
                Alert alert2 = new Alert(Alert.AlertType.ERROR);
                alert2.setHeaderText(null);
                alert2.setContentText("Pass mới phải giống nhau!");
                alert2.showAndWait();
            }
        });
    });
}

######


private void addUser() {
    btnAdd.setOnAction(e -> {
        clear();
        enableTextBut();
        btnHuy.setDisable(false);
        txtOldPass.setDisable(true);
        btnOk.setOnAction(event -> {
            if (checkNull() && checkUser()) {
                if (txtNewPass.getText().equals(txtConfirm.getText())) {
                    Connection conn = SQLiteConnection.connector();
                    PreparedStatement pre;
                    String in = "insert into ADMIN (User,Pass,Email,Phone) values (?,?,?,?)";
                    try {
                        pre = conn.prepareStatement(in);
                        pre.setString(1, txtUser.getText());
                        pre.setString(2, txtNewPass.getText());
                        pre.setString(3, txtEmail.getText());
                        pre.setString(4, txtPhone.getText());
                        pre.executeUpdate();
                        pre.close();
                        disableTextBut();
                        dataInfo();
                        clear();
                        Alert alert2 = new Alert(Alert.AlertType.INFORMATION);
                        alert2.setHeaderText(null);
                        alert2.setContentText("Thêm thành công!");
                        alert2.showAndWait();
                        btnHuy.setDisable(true);
                        setListUser();
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }
                } else {
                    Alert alert2 = new Alert(Alert.AlertType.ERROR);
                    alert2.setHeaderText(null);
                    alert2.setContentText("Pass phải giống nhau!");
                    alert2.showAndWait();
                }
            }
        });
    });
}

######


private void huyThaoTac() {
    btnHuy.setOnAction(e -> {
        disableTextBut();
        txtNewPass.clear();
        txtOldPass.clear();
        txtConfirm.clear();
        dataInfo();
        btnHuy.setDisable(true);
    });
}

######


private boolean checkNull() {
    if (txtUser.getText().isEmpty() | txtEmail.getText().isEmpty() | txtPhone.getText().isEmpty()) {
        Alert alert2 = new Alert(Alert.AlertType.ERROR);
        alert2.setHeaderText(null);
        alert2.setContentText("Đệ nghị nhập đầy đủ thông tin!");
        alert2.showAndWait();
        return false;
    }
    if (txtNewPass.getText().isEmpty() | txtConfirm.getText().isEmpty()) {
        Alert alert2 = new Alert(Alert.AlertType.ERROR);
        alert2.setHeaderText(null);
        alert2.setContentText("Nhập Pass!");
        alert2.showAndWait();
        return false;
    }
    return true;
}

######


private boolean checkUser() {
    Connection conn = SQLiteConnection.connector();
    PreparedStatement pre;
    ResultSet rs;
    String user = "select User from ADMIN";
    try {
        pre = conn.prepareStatement(user);
        rs = pre.executeQuery();
        while (rs.next()) {
            if (txtUser.getText().equals(rs.getString(1))) {
                Alert alert2 = new Alert(Alert.AlertType.ERROR);
                alert2.setHeaderText(null);
                alert2.setContentText("Username đã tốn tại!");
                alert2.showAndWait();
                return false;
            }
        }
        pre.close();
        rs.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return true;
}

######


private void delAccount() {
    btnXoa.setOnAction(e -> {
        if (lvUser.getSelectionModel().getSelectedItems() == null) {
            Alert alert = new Alert(Alert.AlertType.WARNING);
            alert.setHeaderText(null);
            alert.setContentText("Bạn chưa chọn user muốn xoá");
            alert.showAndWait();
        } else {
            Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
            alert.setHeaderText(null);
            alert.setContentText("Bạn có muốn xoá tài khoản " + lvUser.getSelectionModel().getSelectedItems() + " ?");
            ButtonType Yes = new ButtonType("Yes", ButtonBar.ButtonData.YES);
            ButtonType No = new ButtonType("No", ButtonBar.ButtonData.NO);
            alert.getButtonTypes().setAll(Yes, No);
            Optional<ButtonType> res = alert.showAndWait();
            if (res.get() == Yes) {
                Connection conn = SQLiteConnection.connector();
                PreparedStatement pre;
                String del = "delete from ADMIN where User = ?";
                try {
                    pre = conn.prepareStatement(del);
                    pre.setString(1, lvUser.getSelectionModel().getSelectedItem());
                    pre.executeUpdate();
                    pre.close();
                    setListUser();
                    Alert alert1 = new Alert(Alert.AlertType.INFORMATION);
                    alert1.setHeaderText(null);
                    alert1.setContentText("Đã xoá thành công!");
                    alert1.showAndWait();
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
        }
    });
}

######


@Override
public Account doRetriveById(Object... id) {
    String email = (String) id[0];
    Account account = null;
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveByIdQuery);
        prst.setString(1, email);
        try {
            ResultSet rs = prst.executeQuery();
            con.commit();
            if (rs.next()) {
                account = new Account(rs.getString("email"), rs.getString("password"), rs.getString("tipo"));
            }
            rs.close();
            return account;
        } catch (SQLException e) {
            con.rollback();
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
        return null;
    }
    return account;
}

######


@Override
public List<Account> doRetriveAll() {
    List<Account> accounts = new ArrayList<Account>();
    Account account = null;
    Connection con;
    try {
        con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveAllQuery);
        try {
            ResultSet rs = prst.executeQuery();
            con.commit();
            while (rs.next()) {
                account = new Account(rs.getString("email"), rs.getString("password"), rs.getString("tipo"));
                accounts.add(account);
            }
            rs.close();
            return accounts;
        } catch (SQLException e) {
            con.rollback();
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
        return null;
    }
    return accounts;
}

######


@Override
public int doInsert(Account account) {
    return 0;
}

######


@Override
public int doUpdate(Account account) {
    return 0;
}

######


@Override
public void setUp() throws Exception {
    super.setUp();
    a1 = AccountBuilder.createDefault(db);
    a2 = AccountBuilder.createDefault(db);
    categoriesMap = CategoryBuilder.createDefaultHierarchy(categoryRepository);
    TransactionBuilder.withDb(db).dateTime(date(2012, 5, 29)).account(a1).amount(10).create();
    TransactionBuilder.withDb(db).dateTime(date(2012, 5, 28)).account(a1).amount(-20).create();
    TransferBuilder.withDb(db).dateTime(date(2012, 5, 27)).fromAccount(a1).fromAmount(-100).toAccount(a2).toAmount(20).create();
    TransactionBuilder.withDb(db).dateTime(date(2012, 5, 26)).account(a1).amount(100).create();
    TransferBuilder.withDb(db).dateTime(date(2012, 5, 25)).fromAccount(a2).fromAmount(-50).toAccount(a1).toAmount(10).create();
    TransactionBuilder.withDb(db).dateTime(date(2012, 5, 24)).account(a1).amount(200).create();
    TransactionBuilder.withDb(db).dateTime(date(2012, 5, 24)).account(a2).amount(-20).create();
    TransactionBuilder.withDb(db).dateTime(date(2012, 5, 23)).account(a1).amount(-150).withSplit(categoriesMap.get("A1"), -100).withTransferSplit(a2, -50, 10).create();
    TransactionBuilder.withDb(db).dateTime(date(2012, 5, 22)).account(a1).amount(-20).create();
    TransactionBuilder.withDb(db).dateTime(date(2012, 5, 21)).account(a1).amount(10).create();
}

######


public void test_should_delete_first_account_correctly() {
    db.deleteAccount(a1.id);
    assertAccount(a2, -40);
    assertAccountBlotter(a2, 20, -50, -20, 10);
    assertAccountRunningBalance(a2, -40, -60, -10, 10);
}

######


public void test_should_delete_second_account_correctly() {
    db.deleteAccount(a2.id);
    assertAccount(a1, 40);
    assertAccountBlotter(a1, 10, -20, -100, 100, 10, 200, -150, -20, 10);
    assertAccountRunningBalance(a1, 40, 30, 50, 150, 50, 40, -160, -10, 10);
}

######


public void test_should_purge_transactions_older_than_specified_date() {
    assertAccounts();
    assertTransactionsCount(a1, 10);
    assertTransactionsCount(a2, 2);
    assertOldestTransaction(a1, date(2012, 5, 21), 10);
    assertAccountBlotter(a1, 10, -20, -100, 100, 10, 200, -150, -20, 10);
    assertAccountRunningBalance(a1, 40, 30, 50, 150, 50, 40, -160, -10, 10);
    assertAccountBlotter(a2, 20, -50, -20, 10);
    assertAccountRunningBalance(a2, -40, -60, -10, 10);
    assertAccounts();
    db.purgeAccountAtDate(a1, date(2012, 5, 20).asLong());
    assertOldestTransaction(a1, date(2012, 5, 21), 10);
    assertAccountBlotter(a1, 10, -20, -100, 100, 10, 200, -150, -20, 10);
    assertAccountRunningBalance(a1, 40, 30, 50, 150, 50, 40, -160, -10, 10);
    assertAccountBlotter(a2, 20, -50, -20, 10);
    assertAccountRunningBalance(a2, -40, -60, -10, 10);
    assertAccounts();
    db.purgeAccountAtDate(a1, date(2012, 5, 21).asLong());
    assertOldestTransaction(a1, date(2012, 5, 21).atDayEnd(), 10);
    assertAccountBlotter(a1, 10, -20, -100, 100, 10, 200, -150, -20, 10);
    assertAccountRunningBalance(a1, 40, 30, 50, 150, 50, 40, -160, -10, 10);
    assertAccountBlotter(a2, 20, -50, -20, 10);
    assertAccountRunningBalance(a2, -40, -60, -10, 10);
    assertAccounts();
    db.purgeAccountAtDate(a1, date(2012, 5, 22).asLong());
    assertArchiveTransaction(a1, date(2012, 5, 22).atDayEnd(), -10);
    assertAccountBlotter(a1, 10, -20, -100, 100, 10, 200, -150, -10);
    assertAccountRunningBalance(a1, 40, 30, 50, 150, 50, 40, -160, -10);
    assertAccountBlotter(a2, 20, -50, -20, 10);
    assertAccountRunningBalance(a2, -40, -60, -10, 10);
    assertAccounts();
    db.purgeAccountAtDate(a1, date(2012, 5, 23).asLong());
    assertArchiveTransaction(a1, date(2012, 5, 23).atDayEnd(), -160);
    assertAccountBlotter(a1, 10, -20, -100, 100, 10, 200, -160);
    assertAccountRunningBalance(a1, 40, 30, 50, 150, 50, 40, -160);
    assertAccountBlotter(a2, 20, -50, -20, 10);
    assertAccountRunningBalance(a2, -40, -60, -10, 10);
    assertAccounts();
    db.purgeAccountAtDate(a1, date(2012, 5, 24).asLong());
    assertArchiveTransaction(a1, date(2012, 5, 24).atDayEnd(), 40);
    assertAccountBlotter(a1, 10, -20, -100, 100, 10, 40);
    assertAccountRunningBalance(a1, 40, 30, 50, 150, 50, 40);
    assertAccountBlotter(a2, 20, -50, -20, 10);
    assertAccountRunningBalance(a2, -40, -60, -10, 10);
    assertAccounts();
    db.purgeAccountAtDate(a1, date(2012, 5, 27).asLong());
    assertArchiveTransaction(a1, date(2012, 5, 27).atDayEnd(), 50);
    assertAccountBlotter(a1, 10, -20, 50);
    assertAccountRunningBalance(a1, 40, 30, 50);
    assertAccountBlotter(a2, 20, -50, -20, 10);
    assertAccountRunningBalance(a2, -40, -60, -10, 10);
    assertAccounts();
    db.purgeAccountAtDate(a1, date(2012, 5, 29).asLong());
    assertArchiveTransaction(a1, date(2012, 5, 29).atDayEnd(), 40);
    assertAccountBlotter(a1, 40);
    assertAccountRunningBalance(a1, 40);
    assertAccountBlotter(a2, 20, -50, -20, 10);
    assertAccountRunningBalance(a2, -40, -60, -10, 10);
    assertAccounts();
}

######


private void assertAccountBlotter(Account account, long... expectedAmounts) {
    WhereFilter filter = WhereFilter.empty();
    filter.eq(BlotterFilter.FROM_ACCOUNT_ID, String.valueOf(account.id));
    Cursor c = db.getBlotterForAccount(filter);
    long[] actualAmounts = new long[c.getCount()];
    try {
        int i = 0;
        while (c.moveToNext()) {
            Transaction t = Transaction.fromBlotterCursor(c);
            actualAmounts[i++] = t.fromAmount;
        }
    } finally {
        c.close();
    }
    assertAmountsForAccount(account, expectedAmounts, actualAmounts);
}

######


private void assertAccountRunningBalance(Account account, long... expectedBalance) {
    Cursor c = db.db().rawQuery("select balance from running_balance where account_id=? order by datetime desc, transaction_id desc", new String[] { String.valueOf(account.id) });
    long[] actualBalance = new long[c.getCount()];
    try {
        int i = 0;
        while (c.moveToNext()) {
            actualBalance[i++] = c.getLong(0);
        }
    } finally {
        c.close();
    }
    assertAmountsForAccount(account, expectedBalance, actualBalance);
}

######


private void assertAmountsForAccount(Account account, long[] expectedAmounts, long[] amounts) {
    String expectedVsActual = "Account " + account.id + " -> Expected:" + Arrays.toString(expectedAmounts) + ", Actual:" + Arrays.toString(amounts);
    assertEquals("Too few or too many transactions. " + expectedVsActual, expectedAmounts.length, amounts.length);
    assertTrue(expectedVsActual, Arrays.equals(expectedAmounts, amounts));
}

######


private Transaction assertOldestTransaction(Account account, DateTime date, long expectedAmount) {
    Transaction t = getOldestTransaction(account);
    assertEquals(date.asLong(), t.dateTime);
    assertEquals(expectedAmount, t.fromAmount);
    assertAccountBalanceForTransaction(t, account, expectedAmount);
    return t;
}

######


private void assertArchiveTransaction(Account account, DateTime date, long expectedAmount) {
    Transaction t = assertOldestTransaction(account, date, expectedAmount);
    Payee payee = db.get(Payee.class, t.payeeId);
    assertEquals(getContext().getString(R.string.purge_account_payee), payee.title);
    assertEquals(TransactionStatus.CL, t.status);
}

######


private Transaction getOldestTransaction(Account account) {
    long id = DatabaseUtils.rawFetchId(db, "select _id from transactions where from_account_id=? and is_template=0 order by datetime limit 1", new String[] { String.valueOf(account.id) });
    return db.get(Transaction.class, id);
}

######


private void assertAccounts() {
    assertAccount(a1, 40);
    assertAccount(a2, -40);
}

######


private void assertAccount(Account account, long accountTotal) {
    assertAccountTotal(account, accountTotal);
    assertFinalBalanceForAccount(account, accountTotal);
    db.rebuildRunningBalanceForAccount(account);
    assertAccountTotal(account, accountTotal);
    assertFinalBalanceForAccount(account, accountTotal);
}

######


@Query("select a from Account a where a.name=:name")
Optional<Account> getByIdentity(@Param("name") String name);

######


Account getByName(String name);

######


public PreparedStatement getPs() {
    return ps;
}

######


public void setPs(PreparedStatement ps) {
    this.ps = ps;
}

######


public String getPass() {
    return pass;
}

######


public void setPass(String pass) {
    this.pass = pass;
}

######


public boolean actualizarPass(String usu, String newpass) {
    boolean rsp = false;
    try {
        con = DataConnect.getConnection();
        ps = con.prepareStatement("update usuario set usu_password=? where usu_usuario=?;");
        ps.setString(1, newpass);
        ps.setString(2, usu);
        rsp = ps.execute();
    } catch (SQLException ex) {
        System.out.println("Login error -->" + ex.getMessage());
        return rsp = false;
    } finally {
        DataConnect.close(con);
    }
    return rsp;
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType("text/html");
    int empid = Integer.parseInt(request.getParameter("empid"));
    try {
        HttpSession session = request.getSession();
        AddLocations(session, request, response);
    } catch (Exception e) {
        e.printStackTrace();
        if (empid == 11) {
            RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
            ReqDis.forward(request, response);
        } else {
            RequestDispatcher ReqDis = request.getRequestDispatcher("error.jsp");
            ReqDis.forward(request, response);
        }
    }
}

######


private void AddLocations(HttpSession session, HttpServletRequest request, HttpServletResponse response) throws SQLException, ServletException, IOException {
    int empid = Integer.parseInt(request.getParameter("empid"));
    String truckType = request.getParameter("cap");
    int prority = Integer.parseInt(request.getParameter("priority"));
    int Volume = Integer.parseInt(request.getParameter("volume"));
    int cap = 0;
    Connection con = Connect.getconnection();
    PreparedStatement ps1 = con.prepareStatement("select capacity from truckparam where typeofgood=?  ");
    ps1.setString(1, truckType);
    ResultSet rs1 = ps1.executeQuery();
    while (rs1.next()) {
        cap = rs1.getInt("capacity");
    }
    double lat = Double.parseDouble(request.getParameter("lat"));
    double lon = Double.parseDouble(request.getParameter("long"));
    String location = org.apache.commons.lang3.StringUtils.capitalize(request.getParameter("location"));
    PreparedStatement ps = con.prepareStatement("INSERT INTO `mckc`.`autoparam` (`typeofgood`,`capacity`, `Origin`, `lat`, `long`,`Pirority`,`Volume Rating`) VALUES  (?,?,?,?,?,?,?) ");
    ps.setString(1, truckType);
    ps.setInt(2, cap);
    ps.setString(3, location);
    ps.setDouble(4, lat);
    ps.setDouble(5, lon);
    ps.setInt(6, prority);
    ps.setInt(7, Volume);
    ps.executeUpdate();
    RequestDispatcher ReqDis = request.getRequestDispatcher("adminAuto.jsp");
    ReqDis.forward(request, response);
}

######


public static int extractInt(String str) {
    Matcher matcher = Pattern.compile("\\d+").matcher(str);
    if (!matcher.find())
        throw new NumberFormatException("For input string [" + str + "]");
    return Integer.parseInt(matcher.group());
}

######


protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
}

######


protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
    request.setCharacterEncoding("utf-8");
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setContentType("text/html;charset=utf-8");
    Status status = new Status();
    DBConnect dbConnect = new DBConnect();
    String account = request.getParameter("account");
    String userToken = request.getParameter("userToken");
    String courseName = request.getParameter("courseName");
    String courseInfo = request.getParameter("courseInfo");
    String coursePlan = request.getParameter("coursePlan");
    if (account == null) {
        account = "";
    }
    if (userToken == null) {
        userToken = "";
    }
    if (courseName == null) {
        courseName = "";
    }
    if (courseInfo == null) {
        courseInfo = "";
    }
    if (coursePlan == null) {
        coursePlan = "";
    }
    JSONObject jsonRet;
    if (userToken.equals("") || courseName.equals("") || courseInfo.equals("") || coursePlan.equals("")) {
        status.setStatus(false);
        status.setInfo("空参数");
        jsonRet = JSONObject.fromObject(status);
        jsonRet.put("courseID", -1);
    } else {
        try {
            String querySting;
            PreparedStatement preparedStatement;
            ResultSet rs;
            querySting = "SELECT * FROM user WHERE account = ?";
            preparedStatement = dbConnect.prepareStatement(querySting);
            preparedStatement.setString(1, account);
            rs = preparedStatement.executeQuery();
            rs.next();
            String teacherId = rs.getString("id");
            rs.close();
            querySting = "INSERT INTO course (name, info, plan, teacherid) VALUES (?,?,?,?) ";
            preparedStatement = dbConnect.prepareStatement(querySting);
            preparedStatement.setString(1, courseName);
            preparedStatement.setString(2, courseInfo);
            preparedStatement.setString(3, coursePlan);
            preparedStatement.setString(4, teacherId);
            preparedStatement.executeUpdate();
            querySting = "SELECT MAX(id) AS max_id FROM course WHERE name = ?";
            preparedStatement = dbConnect.prepareStatement(querySting);
            preparedStatement.setString(1, courseName);
            rs = preparedStatement.executeQuery();
            rs.next();
            String courseId = rs.getString("max_id");
            rs.close();
            status.setStatus(true);
            status.setInfo("新建课程成功");
            jsonRet = JSONObject.fromObject(status);
            jsonRet.put("courseID", courseId);
        } catch (SQLException e) {
            status.setStatus(false);
            status.setInfo("空参数 " + e.getMessage());
            jsonRet = JSONObject.fromObject(status);
            jsonRet.put("courseID", -1);
            e.printStackTrace();
        }
    }
    PrintWriter out = response.getWriter();
    out.print(jsonRet.toString());
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    submitActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    resetActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    backActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    cardnoActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    jLabel4 = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    jLabel6 = new javax.swing.JLabel();
    submit = new javax.swing.JButton();
    reset = new javax.swing.JButton();
    back = new javax.swing.JButton();
    cardno = new javax.swing.JTextField();
    fname = new javax.swing.JTextField();
    lname = new javax.swing.JTextField();
    address = new javax.swing.JTextField();
    phone = new javax.swing.JTextField();
    jLabel1.setFont(new java.awt.Font("Imprint MT Shadow", 0, 18));
    jLabel1.setForeground(new java.awt.Color(51, 51, 51));
    jLabel1.setText("Membership");
    jLabel2.setFont(new java.awt.Font("Times New Roman", 0, 12));
    jLabel2.setText("Card Number");
    jLabel3.setFont(new java.awt.Font("Times New Roman", 0, 12));
    jLabel3.setText("First Name");
    jLabel4.setFont(new java.awt.Font("Times New Roman", 0, 12));
    jLabel4.setText("Last Name");
    jLabel5.setFont(new java.awt.Font("Times New Roman", 0, 12));
    jLabel5.setText("Address");
    jLabel6.setFont(new java.awt.Font("Times New Roman", 0, 12));
    jLabel6.setText("Phone");
    submit.setText("SUBMIT");
    submit.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            submitActionPerformed(evt);
        }
    });
    reset.setText("RESET");
    reset.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            resetActionPerformed(evt);
        }
    });
    back.setText("BACK");
    back.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            backActionPerformed(evt);
        }
    });
    cardno.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            cardnoActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(54, 54, 54).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addGroup(layout.createSequentialGroup().addComponent(submit).addGap(52, 52, 52).addComponent(reset)).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(jLabel3, javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel5, javax.swing.GroupLayout.Alignment.LEADING)).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(30, 30, 30).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(fname, javax.swing.GroupLayout.PREFERRED_SIZE, 119, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(address, javax.swing.GroupLayout.PREFERRED_SIZE, 119, javax.swing.GroupLayout.PREFERRED_SIZE))).addGroup(layout.createSequentialGroup().addGap(81, 81, 81).addComponent(jLabel1)))))).addGroup(layout.createSequentialGroup().addGap(143, 143, 143).addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE))).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel4, javax.swing.GroupLayout.Alignment.TRAILING).addComponent(cardno, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 119, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel6, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 52, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(lname, javax.swing.GroupLayout.DEFAULT_SIZE, 108, Short.MAX_VALUE).addComponent(phone)).addGap(34, 34, 34)).addGroup(layout.createSequentialGroup().addGap(57, 57, 57).addComponent(back).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(jLabel1).addGap(25, 25, 25).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(cardno, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(37, 37, 37).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(fname, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(lname, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel4).addComponent(jLabel3)).addGap(32, 32, 32).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel5).addComponent(address, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)).addComponent(phone, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE))).addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 119, Short.MAX_VALUE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(reset).addComponent(back).addComponent(submit)).addGap(69, 69, 69)));
    pack();
}

######


private void cardnoActionPerformed(java.awt.event.ActionEvent evt) {
}

######


public void close() {
    WindowEvent winclosingevent = new WindowEvent(this, WindowEvent.WINDOW_CLOSING);
    Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(winclosingevent);
}

######


private void backActionPerformed(java.awt.event.ActionEvent evt) {
    close();
    HomePage hp = new HomePage();
    hp.setVisible(true);
}

######


private void submitActionPerformed(java.awt.event.ActionEvent evt) {
    try {
        conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/librarynew?user=root&password=shravya92");
        Statement stmt = conn.createStatement();
        String cno = cardno.getText();
        String fna = fname.getText();
        String lna = lname.getText();
        String adr = address.getText();
        String phn = phone.getText();
        String add = "insert into Borrower values('" + cno + "','" + fna + "','" + lna + "','" + adr + "','" + phn + "');";
        stmt.executeUpdate(add);
        JOptionPane.showMessageDialog(null, "Succesfull");
        cardno.setText("");
        fname.setText("");
        lname.setText("");
        address.setText("");
        phone.setText("");
        conn.close();
    } catch (SQLException ex) {
        JOptionPane.showMessageDialog(null, ex);
    }
}

######


private void resetActionPerformed(java.awt.event.ActionEvent evt) {
    cardno.setText("");
    fname.setText("");
    lname.setText("");
    address.setText("");
    phone.setText("");
}

######


public void run() {
    new addmember().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(addmember.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(addmember.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(addmember.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(addmember.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new addmember().setVisible(true);
        }
    });
}

######


@Autowired
@Qualifier("readWriteDataSource")
public void setDS(DataSource ds) {
    setDataSource(ds);
}

######


@Override
public Address mapRow(ResultSet rs, int rowNum) throws SQLException {
    Address address = new Address();
    address.setId(rs.getInt("id"));
    address.setUserId(rs.getInt("addressId"));
    address.setCity(rs.getString("city"));
    return address;
}

######


@Override
public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
    PreparedStatement psst = con.prepareStatement(sql, new String[] { "id" });
    psst.setInt(1, address.getUserId());
    psst.setString(2, address.getCity());
    return psst;
}

######


public void save(final Address address) {
    final String sql = "insert into address(userId, city) values(?,?)";
    KeyHolder generatedKeyHolder = new GeneratedKeyHolder();
    getJdbcTemplate().update(new PreparedStatementCreator() {

        @Override
        public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
            PreparedStatement psst = con.prepareStatement(sql, new String[] { "id" });
            psst.setInt(1, address.getUserId());
            psst.setString(2, address.getCity());
            return psst;
        }
    }, generatedKeyHolder);
    address.setId(generatedKeyHolder.getKey().intValue());
}

######


public Address findById(int id) {
    String sql = "select id, userId, city from address where id=?";
    List<Address> addressList = getJdbcTemplate().query(sql, rowMapper, id);
    if (addressList.size() == 0) {
        return null;
    }
    return addressList.get(0);
}

######


@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getSupportActionBar().hide();
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
    setContentView(R.layout.add_student_layout);
    initViews();
    oldData = getIntent();
    if (oldData.getStringExtra("haveData").equals("true")) {
        initInfo();
    }
}

######


public void initViews() {
    name = (EditText) findViewById(R.id.add_name);
    sex = (EditText) findViewById(R.id.add_sex);
    id = (EditText) findViewById(R.id.add_id);
    phone = (EditText) findViewById(R.id.add_phone);
    password = (EditText) findViewById(R.id.add_password);
    math = (EditText) findViewById(R.id.add_math);
    chinese = (EditText) findViewById(R.id.add_chinese);
    english = (EditText) findViewById(R.id.add_english);
    dbHelper = MydatabaseHelper.getInstance(this);
}

######


public void query(View v) {
    String id_ = id.getText().toString().trim();
    String name_ = name.getText().toString().trim();
    String sex_ = sex.getText().toString().trim();
    String password_ = password.getText().toString().trim();
    String phone_ = phone.getText().toString().trim();
    String mathScore = math.getText().toString().trim();
    String chineseScore = chinese.getText().toString().trim();
    String englishScore = english.getText().toString().trim();
    if (!TextUtils.isEmpty(id_) && !TextUtils.isEmpty(name_) && !TextUtils.isEmpty(sex_) && !TextUtils.isEmpty(password_)) {
        if (sex_.matches("[男|女]")) {
            SQLiteDatabase db = dbHelper.getReadableDatabase();
            db.beginTransaction();
            db.execSQL("delete from student where id=?", new String[] { oldID });
            Cursor cursor = db.rawQuery("select * from student where id=?", new String[] { id_ });
            if (cursor.moveToNext()) {
                Toast.makeText(this, "该学号已有学生注册,请重新输入!", Toast.LENGTH_LONG).show();
            } else {
                db.execSQL("insert into student(id,name,sex,phone,password,mathScore,chineseScore,englishScore) values (?,?,?,?,?,?,?,?)", new String[] { id_, name_, sex_, phone_, password_, mathScore, chineseScore, englishScore });
                db.setTransactionSuccessful();
                db.endTransaction();
                Intent intent = new Intent(this, Manager_Activity.class);
                startActivity(intent);
            }
        } else {
            Toast.makeText(this, "请输入正确的性别!", Toast.LENGTH_LONG).show();
        }
    } else {
        Toast.makeText(this, "姓名,性别,学号,密码不能为空!", Toast.LENGTH_LONG).show();
    }
}

######


public void cancle(View v) {
    finish();
}

######


public void initInfo() {
    String oldName = oldData.getStringExtra("name");
    name.setText(oldName);
    String oldSex = oldData.getStringExtra("sex");
    sex.setText(oldSex);
    String oldId = oldData.getStringExtra("id");
    oldID = oldId;
    id.setText(oldId);
    String oldPhone = oldData.getStringExtra("phone");
    phone.setText(oldPhone);
    String oldPassword = oldData.getStringExtra("password");
    password.setText(oldPassword);
    int mathScore = oldData.getIntExtra("mathScore", 0);
    math.setText(String.valueOf(mathScore));
    int chineseScore = oldData.getIntExtra("chineseScore", 0);
    chinese.setText(String.valueOf(chineseScore));
    int englishScore = oldData.getIntExtra("englishScore", 0);
    english.setText(String.valueOf(englishScore));
}

######


public AdminModel loginAdmin(AdminModel adminModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM AdminModel e WHERE e.userId = :USER_ID AND e.password = :PASSWORD");
    query.setParameter("USER_ID", adminModel.getUserId());
    query.setParameter("PASSWORD", Encryptor.encrypt(adminModel.getPassword()));
    if (query.getResultList().size() > 0) {
        return (AdminModel) query.getResultList().get(0);
    } else {
        return null;
    }
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
}

######


public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


public List<AdminGuestBook> guestBookList(String key, String value) {
    List<AdminGuestBook> result = new ArrayList<AdminGuestBook>();
    String sql = "SELECT gid, name_, content, regDate, clientIP, blind FROM guestbook";
    switch(key) {
        case "name_":
            sql += " WHERE INSTR(name_, ?)";
            break;
        case "content":
            sql += " WHERE INSTR(content, ?)";
            break;
        case "regDate":
            sql += " WHERE INSTR(CAST(regDate AS CHAR), ?)";
            break;
        case "ALL":
            break;
    }
    sql += " ORDER BY gid DESC";
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = MySQLConnection.connect();
        pstmt = conn.prepareStatement(sql);
        if (!key.equals("ALL")) {
            pstmt.setString(1, value);
        }
        ResultSet rs = pstmt.executeQuery();
        while (rs.next()) {
            String gid = rs.getString("gid");
            String name_ = rs.getString("name_");
            String content = rs.getString("content");
            LocalDate regDate = rs.getDate("regDate").toLocalDate();
            String clientIP = rs.getString("clientIP");
            int blind = rs.getInt("blind");
            AdminGuestBook gb = new AdminGuestBook();
            gb.setGid(gid);
            gb.setName_(name_);
            gb.setContent(content);
            gb.setRegDate(regDate);
            gb.setClientIP(clientIP);
            gb.setBlind(blind);
            result.add(gb);
        }
        rs.close();
    } catch (SQLException se) {
        se.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (pstmt != null)
                pstmt.close();
        } catch (SQLException se) {
        }
        try {
            MySQLConnection.close();
        } catch (SQLException se) {
            se.printStackTrace();
        }
    }
    return result;
}

######


public int totalCount() {
    int result = 0;
    String sql = "SELECT COUNT(*) AS totalcount FROM guestbook";
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = MySQLConnection.connect();
        pstmt = conn.prepareStatement(sql);
        ResultSet rs = pstmt.executeQuery();
        while (rs.next()) {
            result = rs.getInt("totalCount");
        }
        rs.close();
    } catch (SQLException se) {
        se.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (pstmt != null)
                pstmt.close();
        } catch (SQLException se) {
        }
        try {
            MySQLConnection.close();
        } catch (SQLException se) {
            se.printStackTrace();
        }
    }
    return result;
}

######


public int blind(AdminGuestBook gb) {
    int result = 0;
    String sql = "UPDATE guestbook SET blind=? WHERE gid=?";
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = MySQLConnection.connect();
        pstmt = conn.prepareStatement(sql);
        pstmt.setInt(1, gb.getBlind());
        pstmt.setString(2, gb.getGid());
        result = pstmt.executeUpdate();
    } catch (SQLException se) {
        se.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (pstmt != null)
                pstmt.close();
        } catch (SQLException se) {
        }
        try {
            MySQLConnection.close();
        } catch (SQLException se) {
            se.printStackTrace();
        }
    }
    return result;
}

######


public List<AdminGuestBook> picList(String key, String value) {
    List<AdminGuestBook> result = new ArrayList<AdminGuestBook>();
    String sql = "SELECT pid, picName, picContent FROM pictureList";
    if (key.equals("pid")) {
        sql += " WHERE pid =? ";
    }
    sql += " ORDER BY pid";
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = MySQLConnection.connect();
        pstmt = conn.prepareStatement(sql);
        if (key.equals("pid")) {
            pstmt.setString(1, value);
        }
        ResultSet rs = pstmt.executeQuery();
        while (rs.next()) {
            String pid = rs.getString("pid");
            String picName = rs.getString("picName");
            String picContent = rs.getString("picContent");
            AdminGuestBook gb = new AdminGuestBook();
            gb.setPid(pid);
            gb.setPicName(picName);
            gb.setPicContent(picContent);
            result.add(gb);
        }
        rs.close();
    } catch (SQLException se) {
        System.out.print(se.getMessage());
    } catch (Exception e) {
        System.out.print(e.getMessage());
    } finally {
        try {
            if (pstmt != null)
                pstmt.close();
        } catch (SQLException se) {
        }
        try {
            MySQLConnection.close();
        } catch (SQLException se) {
            System.out.print(se.getMessage());
        }
    }
    return result;
}

######


public int pictureAdd(AdminGuestBook gb) {
    int result = 0;
    String sql = "INSERT INTO pictureList (pid, picName, picContent) VALUES ((SELECT * FROM (SELECT CONCAT('P', LPAD(IFNULL(SUBSTRING(MAX(pid), 2), 0) + 1, 3, 0)) AS newPid FROM pictureList) p), ?, ?)";
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = MySQLConnection.connect();
        pstmt = conn.prepareStatement(sql);
        pstmt.setString(1, gb.getPicName());
        pstmt.setString(2, gb.getPicContent());
        result = pstmt.executeUpdate();
    } catch (SQLException se) {
        System.out.println(se.getMessage());
    } catch (Exception e) {
        System.out.println(e.getMessage());
    } finally {
        try {
            if (pstmt != null)
                pstmt.close();
        } catch (SQLException se) {
        }
        try {
            MySQLConnection.close();
        } catch (SQLException se) {
            System.out.println(se.getMessage());
        }
    }
    return result;
}

######


public int pictureRemove(String pid) {
    int result = 0;
    String sql = "DELETE FROM picturelist WHERE pid = ?";
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = MySQLConnection.connect();
        pstmt = conn.prepareStatement(sql);
        pstmt.setString(1, pid);
        result = pstmt.executeUpdate();
    } catch (SQLException se) {
        System.out.println(se.getMessage());
    } catch (Exception e) {
        System.out.println(e.getMessage());
    } finally {
        try {
            if (pstmt != null)
                pstmt.close();
        } catch (SQLException se) {
        }
        try {
            MySQLConnection.close();
        } catch (SQLException se) {
            System.out.println(se.getMessage());
        }
    }
    return result;
}

######


@Before
public void runBeforeEachTest() {
    adminService = Context.getAdministrationService();
    implementationHttpClient = mock(HttpClient.class);
    adminService.setImplementationIdHttpClient(implementationHttpClient);
    cacheManager = Context.getRegisteredComponent("apiCacheManager", CacheManager.class);
}

######


@Test
public void executeSQL_shouldExecuteSqlContainingGroupBy() {
    String sql = "select encounter1_.location_id, encounter1_.creator, encounter1_.encounter_type, encounter1_.form_id, location2_.location_id, count(obs0_.obs_id) from obs obs0_ right outer join encounter encounter1_ on obs0_.encounter_id=encounter1_.encounter_id inner join location location2_ on encounter1_.location_id=location2_.location_id inner join users user3_ on encounter1_.creator=user3_.user_id inner join person user3_1_ on user3_.user_id=user3_1_.person_id inner join encounter_type encountert4_ on encounter1_.encounter_type=encountert4_.encounter_type_id inner join form form5_ on encounter1_.form_id=form5_.form_id where encounter1_.date_created>='2007-05-05' and encounter1_.date_created<= '2008-05-05' group by encounter1_.location_id, encounter1_.creator , encounter1_.encounter_type , encounter1_.form_id";
    adminService.executeSQL(sql, true);
    String sql2 = "select encounter_id, count(*) from encounter encounter_id group by encounter_id";
    adminService.executeSQL(sql2, true);
}

######


@Test
public void setImplementationId_shouldNotFailIfGivenImplementationIdIsNull() {
    adminService.setImplementationId(null);
    ImplementationId afterNull = adminService.getImplementationId();
    assertNull("There shouldn't be an impl id defined after setting a null impl id", afterNull);
}

######


@Test()
public void setImplementationId_shouldThrowAPIExceptionIfGivenEmptyImplementationIdObject() {
    try {
        adminService.setImplementationId(new ImplementationId());
        fail("An exception should be thrown on a blank impl id save");
    } catch (APIException e) {
    }
    ImplementationId afterBlank = adminService.getImplementationId();
    assertNull("There shouldn't be an impl id defined after setting a blank impl id", afterBlank);
}

######


@Test
public void setImplementationId_shouldThrowAPIExceptionIfGivenACaretInTheImplementationIdCode() {
    ImplementationId invalidId = new ImplementationId();
    invalidId.setImplementationId("caret^caret");
    invalidId.setName("an invalid impl id for a unit test");
    invalidId.setPassphrase("some valid passphrase");
    invalidId.setDescription("Some valid description");
    try {
        adminService.setImplementationId(invalidId);
        fail("An exception should be thrown on an invalid impl id save");
    } catch (APIException e) {
    }
    ImplementationId afterInvalid = adminService.getImplementationId();
    assertNull("There shouldn't be an impl id defined after setting an invalid impl id", afterInvalid);
}

######


@Test
public void setImplementationId_shouldThrowAPIExceptionIfGivenAPipeInTheImplementationIdCode() {
    ImplementationId invalidId2 = new ImplementationId();
    invalidId2.setImplementationId("pipe|pipe");
    invalidId2.setName("an invalid impl id for a unit test");
    invalidId2.setPassphrase("some valid passphrase");
    invalidId2.setDescription("Some valid description");
    try {
        adminService.setImplementationId(invalidId2);
        fail("An exception should be thrown on an invalid impl id save");
    } catch (APIException e) {
    }
    ImplementationId afterInvalid2 = adminService.getImplementationId();
    assertNull("There shouldn't be an impl id defined after setting an invalid impl id", afterInvalid2);
}

######


@Test
@Ignore
public void setImplementationId_shouldCreateImplementationIdInDatabase() {
    ImplementationId validId = new ImplementationId();
    validId.setImplementationId("JUNIT-TEST");
    validId.setName("JUNIT-TEST implementation id");
    validId.setPassphrase("This is the junit test passphrase");
    validId.setDescription("This is the junit impl id used for testing of the openmrs API only.");
    adminService.setImplementationId(validId);
    assertEquals(validId, adminService.getImplementationId());
}

######


@Test
@Ignore
public void setImplementationId_shouldOverwriteImplementationIdInDatabaseIfExists() {
    executeDataSet("org/openmrs/api/include/AdministrationServiceTest-general.xml");
    assertNotNull(adminService.getImplementationId());
    Context.clearSession();
    ImplementationId validId2 = new ImplementationId();
    validId2.setImplementationId("JUNIT-TEST 2");
    validId2.setName("JUNIT-TEST (#2) implementation id");
    validId2.setPassphrase("This is the junit test passphrase 2");
    validId2.setDescription("This is the junit impl id (2) used for testing of the openmrs API only.");
    adminService.setImplementationId(validId2);
    assertEquals(validId2, adminService.getImplementationId());
}

######


@Test
@Ignore
public void setImplementationId_shouldSetUuidOnImplementationIdGlobalProperty() {
    ImplementationId validId = new ImplementationId();
    validId.setImplementationId("JUNIT-TEST");
    validId.setName("JUNIT-TEST implementation id");
    validId.setPassphrase("This is the junit test passphrase");
    validId.setDescription("This is the junit impl id used for testing of the openmrs API only.");
    adminService.setImplementationId(validId);
    GlobalProperty gp = adminService.getGlobalPropertyObject(OpenmrsConstants.GLOBAL_PROPERTY_IMPLEMENTATION_ID);
    assertNotNull(gp.getUuid());
}

######


@Test
public void getGlobalProperty_shouldNotFailWithNullPropertyName() {
    adminService.getGlobalProperty(null);
}

######


@Test
public void getGlobalProperty_shouldGetPropertyValueGivenValidPropertyName() {
    executeDataSet("org/openmrs/api/include/AdministrationServiceTest-globalproperties.xml");
    String propertyValue = adminService.getGlobalProperty("a_valid_gp_key");
    assertEquals("correct-value", propertyValue);
}

######


@Test
public void getGlobalProperty_shouldNotFailWithNullDefaultValue() {
    adminService.getGlobalProperty("asdfsadfsafd", null);
}

######


@Test
public void updateGlobalProperty_shouldUpdateGlobalPropertyInDatabase() {
    executeDataSet("org/openmrs/api/include/AdministrationServiceTest-globalproperties.xml");
    String propertyValue = adminService.getGlobalProperty("a_valid_gp_key");
    assertEquals("correct-value", propertyValue);
    adminService.updateGlobalProperty("a_valid_gp_key", "new-value");
    String newValue = adminService.getGlobalProperty("a_valid_gp_key");
    assertEquals("new-value", newValue);
}

######


@Test(expected = IllegalStateException.class)
public void updateGlobalProperty_shouldFailIfGlobalPropertyBeingUpdatedDoesNotAlreadyExist() {
    executeDataSet("org/openmrs/api/include/AdministrationServiceTest-globalproperties.xml");
    adminService.updateGlobalProperty("a_invalid_gp_key", "asdfsadfsafd");
}

######


@Test
public void updateGlobalProperty_shouldUpdateAGlobalPropertyWhoseTypedvalueIsHandledByACustomDatatype() {
    GlobalProperty gp = new GlobalProperty();
    gp.setProperty("Flag");
    gp.setDatatypeClassname(BooleanDatatype.class.getName());
    gp.setValue(Boolean.FALSE);
    adminService.saveGlobalProperty(gp);
    assertEquals(adminService.getGlobalProperty("Flag"), "false");
    adminService.updateGlobalProperty("Flag", Boolean.TRUE.toString());
    assertEquals(adminService.getGlobalProperty("Flag"), "true");
}

######


@Test
public void setGlobalProperty_shouldCreateGlobalPropertyInDatabase() {
    String newKey = "new_gp_key";
    String initialValue = adminService.getGlobalProperty(newKey);
    assertNull(initialValue);
    adminService.setGlobalProperty(newKey, "new_key");
    String newValue = adminService.getGlobalProperty(newKey);
    assertNotNull(newValue);
}

######


@Test
public void setGlobalProperty_shouldOverwriteGlobalPropertyIfExists() {
    executeDataSet("org/openmrs/api/include/AdministrationServiceTest-globalproperties.xml");
    String propertyValue = adminService.getGlobalProperty("a_valid_gp_key");
    assertEquals("correct-value", propertyValue);
    adminService.setGlobalProperty("a_valid_gp_key", "new-value");
    String newValue = adminService.getGlobalProperty("a_valid_gp_key");
    assertEquals("new-value", newValue);
}

######


@Test
public void setGlobalProperty_shouldSaveAGlobalPropertyWhoseTypedValueIsHandledByACustomDatatype() {
    String newKey = "Flag";
    String initialValue = adminService.getGlobalProperty(newKey);
    assertNull(initialValue);
    adminService.setGlobalProperty(newKey, Boolean.FALSE.toString());
    assertEquals(adminService.getGlobalProperty("Flag"), "false");
}

######


@Test
public void getGlobalProperty_shouldReturnDefaultValueIfPropertyNameDoesNotExist() {
    String invalidKey = "asdfasdf";
    String propertyValue = adminService.getGlobalProperty(invalidKey);
    assertNull(propertyValue);
    String value = adminService.getGlobalProperty(invalidKey, "default");
    assertEquals("default", value);
}

######


@Test
public void getGlobalPropertiesByPrefix_shouldReturnAllRelevantGlobalPropertiesInTheDatabase() {
    executeDataSet("org/openmrs/api/include/AdministrationServiceTest-globalproperties.xml");
    List<GlobalProperty> properties = adminService.getGlobalPropertiesByPrefix("fake.module.");
    for (GlobalProperty property : properties) {
        assertTrue(property.getProperty().startsWith("fake.module."));
        assertTrue(property.getPropertyValue().startsWith("correct-value"));
    }
}

######


@Test
public void getAllowedLocales_shouldNotFailIfNotGlobalPropertyForLocalesAllowedDefinedYet() {
    adminService.purgeGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST));
    adminService.getAllowedLocales();
}

######


@Test
public void getGlobalPropertyByUuid_shouldFindObjectGivenValidUuid() {
    String uuid = "4f55827e-26fe-102b-80cb-0017a47871b3";
    GlobalProperty prop = adminService.getGlobalPropertyByUuid(uuid);
    assertEquals("locale.allowed.list", prop.getProperty());
}

######


@Test
public void getGlobalPropertyByUuid_shouldReturnNullIfNoObjectFoundWithGivenUuid() {
    assertNull(adminService.getGlobalPropertyByUuid("some invalid uuid"));
}

######


@Test
public void saveGlobalProperties_shouldNotFailWithEmptyList() {
    adminService.saveGlobalProperties(new ArrayList<>());
}

######


@Test
public void saveGlobalProperties_shouldSaveAllGlobalPropertiesToTheDatabase() {
    List<GlobalProperty> globalProperties = adminService.getAllGlobalProperties();
    globalProperties.add(new GlobalProperty("new prop1", "new prop value1", "desc"));
    globalProperties.add(new GlobalProperty("new prop2", "new prop value2", "desc"));
    adminService.saveGlobalProperties(globalProperties);
    assertEquals("new prop value1", adminService.getGlobalProperty("new prop1"));
    assertEquals("new prop value2", adminService.getGlobalProperty("new prop2"));
}

######


@Test
public void saveGlobalProperties_shouldAssignUuidToAllNewProperties() {
    List<GlobalProperty> globalProperties = adminService.getAllGlobalProperties();
    globalProperties.add(new GlobalProperty("new prop", "new prop value", "desc"));
    adminService.saveGlobalProperties(globalProperties);
    assertNotNull(adminService.getGlobalPropertyObject("new prop").getUuid());
}

######


@Test
public void getAllGlobalProperties_shouldReturnAllGlobalPropertiesInTheDatabase() {
    executeDataSet(ADMIN_INITIAL_DATA_XML);
    assertEquals(21, adminService.getAllGlobalProperties().size());
}

######


@Test
public void getAllowedLocales_shouldReturnAtLeastOneLocaleIfNoLocalesDefinedInDatabaseYet() {
    assertTrue(adminService.getAllowedLocales().size() > 0);
}

######


@Test
public void getGlobalPropertyObject_shouldReturnNullWhenNoGlobalPropertyMatchGivenPropertyName() {
    executeDataSet(ADMIN_INITIAL_DATA_XML);
    assertNull(adminService.getGlobalPropertyObject("magicResistSkill"));
}

######


@Test
public void getImplementationId_shouldReturnNullIfNoImplementationIdIsDefinedYet() {
    executeDataSet(ADMIN_INITIAL_DATA_XML);
    assertNull(adminService.getImplementationId());
}

######


@Test
@Ignore
public void getPresentationLocales_shouldReturnAtLeastOneLocaleIfNoLocalesDefinedInDatabaseYet() {
    assertTrue(adminService.getPresentationLocales().size() > 0);
}

######


@Test
public void getPresentationLocales_shouldNotReturnMoreLocalesThanMessageSourceServiceLocales() {
    assertFalse(adminService.getPresentationLocales().size() > Context.getMessageSourceService().getLocales().size());
}

######


@Test
public void getSystemVariables_shouldReturnAllRegisteredSystemVariables() {
    assertEquals(11, adminService.getSystemVariables().size());
}

######


@Test
public void purgeGlobalProperty_shouldDeleteGlobalPropertyFromDatabase() {
    executeDataSet(ADMIN_INITIAL_DATA_XML);
    assertEquals(21, adminService.getAllGlobalProperties().size());
    adminService.purgeGlobalProperty(adminService.getGlobalPropertyObject("a_valid_gp_key"));
    assertEquals(20, adminService.getAllGlobalProperties().size());
}

######


@Test
public void saveGlobalProperty_shouldCreateGlobalPropertyInDatabase() {
    executeDataSet(ADMIN_INITIAL_DATA_XML);
    adminService.saveGlobalProperty(new GlobalProperty("detectHiddenSkill", "100"));
    assertNotNull(adminService.getGlobalProperty("detectHiddenSkill"));
}

######


@Test
public void saveGlobalProperty_shouldOverwriteGlobalPropertyIfExists() {
    executeDataSet(ADMIN_INITIAL_DATA_XML);
    GlobalProperty gp = adminService.getGlobalPropertyObject("a_valid_gp_key");
    assertEquals("correct-value", gp.getPropertyValue());
    gp.setPropertyValue("new-even-more-correct-value");
    adminService.saveGlobalProperty(gp);
    assertEquals("new-even-more-correct-value", adminService.getGlobalProperty("a_valid_gp_key"));
}

######


@Test
public void saveGlobalProperty_shouldFailIfGivenAllowedLocaleListDoesNotContainDefaultLocale() {
    String localeList = "fr,es";
    assertThat("localeList contains default locale but should not for this test case", localeList, not(containsString(LocaleUtility.getDefaultLocale().toString())));
    expectedException.expect(APIException.class);
    expectedException.expectMessage("can not be removed from allowed locales list because it is the default locale");
    adminService.saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, localeList));
}

######


@Test
public void saveGlobalProperty_shouldFailIfDefaultLocaleNotInAllowedLocaleList() {
    Locale defaultLocale = new Locale("fr");
    expectedException.expect(APIException.class);
    expectedException.expectMessage("is not in allowed locales list");
    adminService.saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_LOCALE, defaultLocale.toString()));
}

######


@Test
public void getAllowedLocales_shouldNotReturnDuplicatesEvenIfTheGlobalPropertyHasThem() {
    adminService.saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, "en_GB,fr,es,en_GB"));
    assertEquals(3, adminService.getAllowedLocales().size());
}

######


@Test
public void getGlobalPropertyValue_shouldReturnValueInTheSpecifiedIntegerType() {
    executeDataSet("org/openmrs/api/include/AdministrationServiceTest-globalproperties.xml");
    Object value = adminService.getGlobalPropertyValue("valid.integer", 4);
    assertTrue(value instanceof Integer);
    assertEquals(1234, value);
}

######


@Test
public void getGlobalPropertyValue_shouldReturnDefaultValueForMissingProperty() {
    executeDataSet("org/openmrs/api/include/AdministrationServiceTest-globalproperties.xml");
    Object value = adminService.getGlobalPropertyValue("does.not.exist", 1234);
    assertEquals(1234, value);
}

######


@Test
public void getGlobalPropertyValue_shouldReturnValueInTheSpecifiedDoubleType() {
    executeDataSet("org/openmrs/api/include/AdministrationServiceTest-globalproperties.xml");
    Object retValue = adminService.getGlobalPropertyValue("valid.double", 4.34);
    assertTrue(retValue instanceof Double);
    assertEquals(1234.54, retValue);
}

######


@Test
public void getGlobalProperty_shouldGetPropertyInCaseInsensitiveWay() {
    executeDataSet("org/openmrs/api/include/AdministrationServiceTest-globalproperties.xml");
    String orig = adminService.getGlobalProperty("another-global-property");
    assertEquals("anothervalue", orig);
    String noprop = adminService.getGlobalProperty("ANOTher-global-property");
    assertEquals(orig, noprop);
}

######


@Test
public void saveGlobalProperty_shouldNotAllowDifferentPropertiesToHaveTheSameStringWithDifferentCase() {
    executeDataSet("org/openmrs/api/include/AdministrationServiceTest-globalproperties.xml");
    String orig = adminService.getGlobalProperty("another-global-property");
    assertEquals("anothervalue", orig);
    GlobalProperty gp = new GlobalProperty("ANOTher-global-property", "somethingelse");
    adminService.saveGlobalProperty(gp);
    String prop = adminService.getGlobalProperty("ANOTher-global-property", "boo");
    assertEquals("somethingelse", prop);
    orig = adminService.getGlobalProperty("another-global-property");
    assertEquals("somethingelse", orig);
}

######


@Test
public void saveGlobalProperties_shouldSavePropertiesWithCaseDifferenceOnly() {
    int originalSize = adminService.getAllGlobalProperties().size();
    List<GlobalProperty> props = new ArrayList<>();
    props.add(new GlobalProperty("a.property.key", "something"));
    props.add(new GlobalProperty("a.property.KEY", "somethingelse"));
    adminService.saveGlobalProperties(props);
    props = adminService.getAllGlobalProperties();
    assertEquals(originalSize + 1, props.size());
    assertTrue(props.contains(adminService.getGlobalPropertyObject("a.property.KEY")));
}

######


@Test
public void purgeGlobalProperties_shouldDeleteGlobalPropertiesFromDatabase() {
    int originalSize = adminService.getAllGlobalProperties().size();
    List<GlobalProperty> props = new ArrayList<>();
    props.add(new GlobalProperty("a.property.key", "something"));
    props.add(new GlobalProperty("a.property.KEY", "somethingelse"));
    adminService.saveGlobalProperties(props);
    int afterSaveSize = adminService.getAllGlobalProperties().size();
    assertEquals(originalSize + 1, afterSaveSize);
    adminService.purgeGlobalProperties(props);
    int afterPurgeSize = adminService.getAllGlobalProperties().size();
    assertEquals(originalSize, afterPurgeSize);
}

######


@Test
public void saveGlobalProperty_shouldSaveAGlobalPropertyWhoseTypedValueIsHandledByACustomDatatype() {
    GlobalProperty gp = new GlobalProperty();
    gp.setProperty("What time is it?");
    gp.setDatatypeClassname(DateDatatype.class.getName());
    gp.setValue(new Date());
    adminService.saveGlobalProperty(gp);
    assertNotNull(gp.getValueReference());
}

######


@Test
public void getSearchLocales_shouldExcludeNotAllowedLocales() {
    adminService.saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, "en_US, en_GB, pl, es"));
    User user = Context.getAuthenticatedUser();
    user.setUserProperty(OpenmrsConstants.USER_PROPERTY_PROFICIENT_LOCALES, "es_CL, en_US, pl");
    Context.getUserService().saveUser(user);
    List<Locale> searchLocales = adminService.getSearchLocales();
    assertTrue("en_US", searchLocales.contains(new Locale("en", "US")));
    assertTrue("pl", searchLocales.contains(new Locale("pl")));
    assertTrue("es", searchLocales.contains(new Locale("es")));
    assertFalse("es_CL", searchLocales.contains(new Locale("es", "CL")));
}

######


@Test
public void getSearchLocales_shouldIncludeCurrentlySelectedFullLocaleAndLangugage() {
    adminService.saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, "en_GB"));
    User user = Context.getAuthenticatedUser();
    user.setUserProperty(OpenmrsConstants.USER_PROPERTY_PROFICIENT_LOCALES, "");
    Context.getUserService().saveUser(user);
    Context.setLocale(new Locale("en", "GB"));
    List<Locale> searchLocales = adminService.getSearchLocales();
    assertEquals(Context.getLocale(), searchLocales.get(0));
    assertEquals(new Locale(Context.getLocale().getLanguage()), searchLocales.get(1));
}

######


@Test
public void getSearchLocales_shouldIncludeUsersProficientLocales() {
    adminService.saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, "en_GB, en_US, pl"));
    User user = Context.getAuthenticatedUser();
    user.setUserProperty(OpenmrsConstants.USER_PROPERTY_PROFICIENT_LOCALES, "en_GB, en_US");
    Context.getUserService().saveUser(user);
    List<Locale> searchLocales = adminService.getSearchLocales();
    assertTrue("en_GB", searchLocales.contains(new Locale("en", "GB")));
    assertTrue("en_US", searchLocales.contains(new Locale("en", "US")));
    assertFalse("pl", searchLocales.contains(new Locale("pl")));
}

######


@Test(expected = APIException.class)
public void validate_shouldThrowThrowAPIExceptionIfTheInputIsNull() {
    BindException errors = new BindException(new Object(), "");
    adminService.validate(null, errors);
}

######


@Test
public void getPresentationLocales_shouldReturnOnlyCountryLocaleIfBothCountryLocaleAndLanguageLocaleAreSpecifiedInAllowedList() {
    adminService.saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, "en_GB, es, es_CL"));
    List<Locale> locales = new ArrayList<>();
    locales.add(new Locale("pl", "PL"));
    locales.add(new Locale("en"));
    locales.add(new Locale("es"));
    locales.add(new Locale("es", "CL"));
    MutableResourceBundleMessageSource mutableResourceBundleMessageSource = Mockito.mock(MutableResourceBundleMessageSource.class);
    Mockito.when(mutableResourceBundleMessageSource.getLocales()).thenReturn(locales);
    MutableMessageSource mutableMessageSource = Context.getMessageSourceService().getActiveMessageSource();
    Context.getMessageSourceService().setActiveMessageSource(mutableResourceBundleMessageSource);
    Set<Locale> presentationLocales = adminService.getPresentationLocales();
    Context.getMessageSourceService().setActiveMessageSource(mutableMessageSource);
    assertEquals(2, presentationLocales.size());
    assertTrue("en", presentationLocales.contains(new Locale("en")));
    assertTrue("es_CL", presentationLocales.contains(new Locale("es", "CL")));
}

######


@Test
public void getPresentationLocales_shouldReturnAllCountryLocalesIfLanguageLocaleAndNoCountryLocalesAreSpecifiedInAllowedList() {
    adminService.saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, "en_GB, es"));
    List<Locale> locales = new ArrayList<>();
    locales.add(new Locale("pl", "PL"));
    locales.add(new Locale("en"));
    locales.add(new Locale("es"));
    locales.add(new Locale("es", "CL"));
    locales.add(new Locale("es", "SN"));
    MutableResourceBundleMessageSource mutableResourceBundleMessageSource = Mockito.mock(MutableResourceBundleMessageSource.class);
    Mockito.when(mutableResourceBundleMessageSource.getLocales()).thenReturn(locales);
    MutableMessageSource mutableMessageSource = Context.getMessageSourceService().getActiveMessageSource();
    Context.getMessageSourceService().setActiveMessageSource(mutableResourceBundleMessageSource);
    Set<Locale> presentationLocales = adminService.getPresentationLocales();
    Context.getMessageSourceService().setActiveMessageSource(mutableMessageSource);
    assertEquals(3, presentationLocales.size());
    assertTrue("es_CL", presentationLocales.contains(new Locale("es", "CL")));
    assertTrue("es_SN", presentationLocales.contains(new Locale("es", "SN")));
    assertTrue("en", presentationLocales.contains(new Locale("en")));
}

######


@Test
public void getPresentationLocales_shouldReturnLanguageLocaleIfCountryLocaleIsSpecifiedInAllowedListButCountryLocaleMessageFileIsMissing() {
    adminService.saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, "en_GB, es_CL"));
    List<Locale> locales = new ArrayList<>();
    locales.add(new Locale("pl", "PL"));
    locales.add(new Locale("en"));
    locales.add(new Locale("es"));
    MutableResourceBundleMessageSource mutableResourceBundleMessageSource = Mockito.mock(MutableResourceBundleMessageSource.class);
    Mockito.when(mutableResourceBundleMessageSource.getLocales()).thenReturn(locales);
    MutableMessageSource mutableMessageSource = Context.getMessageSourceService().getActiveMessageSource();
    Context.getMessageSourceService().setActiveMessageSource(mutableResourceBundleMessageSource);
    Set<Locale> presentationLocales = adminService.getPresentationLocales();
    Context.getMessageSourceService().setActiveMessageSource(mutableMessageSource);
    assertEquals(2, presentationLocales.size());
    assertTrue("en", presentationLocales.contains(new Locale("en")));
    assertTrue("es", presentationLocales.contains(new Locale("es")));
}

######


@Test
public void getPresentationLocales_shouldReturnLanguageLocaleIfItIsSpecifiedInAllowedListAndThereAreNoCountryLocaleMessageFilesAvailable() {
    adminService.saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, "en_GB, es"));
    List<Locale> locales = new ArrayList<>();
    locales.add(new Locale("pl", "PL"));
    locales.add(new Locale("en"));
    locales.add(new Locale("es"));
    MutableResourceBundleMessageSource mutableResourceBundleMessageSource = Mockito.mock(MutableResourceBundleMessageSource.class);
    Mockito.when(mutableResourceBundleMessageSource.getLocales()).thenReturn(locales);
    MutableMessageSource mutableMessageSource = Context.getMessageSourceService().getActiveMessageSource();
    Context.getMessageSourceService().setActiveMessageSource(mutableResourceBundleMessageSource);
    Set<Locale> presentationLocales = adminService.getPresentationLocales();
    Context.getMessageSourceService().setActiveMessageSource(mutableMessageSource);
    assertEquals(2, presentationLocales.size());
    assertTrue("en", presentationLocales.contains(new Locale("en")));
    assertTrue("es", presentationLocales.contains(new Locale("es")));
}

######


@Test
public void getPresentationLocales_shouldPreserveInsertionOrderInSetReturnedByMethod() {
    String globalPropertyLocaleListAllowedData = "en_GB, es, ja_JP, it_IT, pl_PL";
    adminService.saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, globalPropertyLocaleListAllowedData));
    List<Locale> locales = new ArrayList<>();
    locales.add(new Locale("pl", "PL"));
    locales.add(new Locale("es"));
    locales.add(new Locale("en"));
    locales.add(new Locale("it", "IT"));
    MutableResourceBundleMessageSource mutableResourceBundleMessageSource = Mockito.mock(MutableResourceBundleMessageSource.class);
    Mockito.when(mutableResourceBundleMessageSource.getLocales()).thenReturn(locales);
    MutableMessageSource mutableMessageSource = Context.getMessageSourceService().getActiveMessageSource();
    Context.getMessageSourceService().setActiveMessageSource(mutableResourceBundleMessageSource);
    List<Locale> presentationLocales = new ArrayList<>(adminService.getPresentationLocales());
    Context.getMessageSourceService().setActiveMessageSource(mutableMessageSource);
    assertEquals(new Locale("en"), presentationLocales.get(0));
    assertEquals(new Locale("es"), presentationLocales.get(1));
    assertEquals(new Locale("it", "IT"), presentationLocales.get(2));
    assertEquals(new Locale("pl", "PL"), presentationLocales.get(3));
}

######


@Test
public void getSearchLocales_shouldCacheResultsForAnUser() {
    adminService.saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, "en_GB, en_US, pl"));
    User user = Context.getAuthenticatedUser();
    user.setUserProperty(OpenmrsConstants.USER_PROPERTY_PROFICIENT_LOCALES, "en_GB, en_US");
    Context.getUserService().saveUser(user);
    adminService.getSearchLocales();
    List<Locale> cachedSearchLocales = getCachedSearchLocalesForCurrentUser();
    assertThat(cachedSearchLocales, hasItem(Locale.ENGLISH));
    assertThat(cachedSearchLocales, hasItem(new Locale("en", "US")));
    assertThat(cachedSearchLocales, not(hasItem(new Locale("pl"))));
}

######


@Test
public void saveGlobalProperty_shouldEvictCachedResults() {
    adminService.saveGlobalProperty(new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST, "en_GB, en_US, pl"));
    User user = Context.getAuthenticatedUser();
    user.setUserProperty(OpenmrsConstants.USER_PROPERTY_PROFICIENT_LOCALES, "en_GB, en_US");
    Context.getUserService().saveUser(user);
    adminService.getSearchLocales();
    List<Locale> cachedSearchLocales = getCachedSearchLocalesForCurrentUser();
    assertThat(cachedSearchLocales, hasItem(new Locale("en", "US")));
    adminService.saveGlobalProperty(new GlobalProperty("test", "TEST"));
    assertThat(getCacheForCurrentUser(), nullValue());
}

######


private Cache.ValueWrapper getCacheForCurrentUser() {
    Object[] params = { Context.getLocale(), Context.getAuthenticatedUser() };
    Object key = (new SimpleKeyGenerator()).generate(null, null, params);
    return cacheManager.getCache("userSearchLocales").get(key);
}

######


private List<Locale> getCachedSearchLocalesForCurrentUser() {
    return (List<Locale>) getCacheForCurrentUser().get();
}

######


private Connection getConnection() throws SQLException {
    java.sql.Connection con;
    con = ConnectionFactory.getInstance().getConnection();
    return con;
}

######


public String execute() throws SQLException, ClassNotFoundException {
    adminLoginUsername = getadminLoginUsername();
    adminLoginPassword = getadminLoginPassword();
    connection = getConnection();
    checkDuplicate = connection.prepareStatement("SELECT username, password FROM admin WHERE username=? AND password= ?");
    checkDuplicate.setString(1, adminLoginUsername);
    checkDuplicate.setString(2, adminLoginPassword);
    ResultSet results = checkDuplicate.executeQuery();
    System.out.println("#result" + results);
    if (results.next()) {
        System.out.println("hey gals");
        Map session = ActionContext.getContext().getSession();
        return "success";
    } else {
        return "success";
    }
}

######


public void setSession(Map m) {
    this.m = m;
}

######


public void setadminLoginUsername(String adminLoginUsername) {
    this.adminLoginUsername = adminLoginUsername;
}

######


public String getadminLoginUsername() {
    return this.adminLoginUsername;
}

######


public void setadminLoginPassword(String adminLoginPassword) {
    this.adminLoginPassword = adminLoginPassword;
}

######


public String getadminLoginPassword() {
    return this.adminLoginPassword;
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButtonUyeAraActionPerformed(evt);
}

######


public void mouseClicked(java.awt.event.MouseEvent evt) {
    jTableUyelerMouseClicked(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButtonUyeCikarActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButtonUyeEkle2ActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButtonKitapAraActionPerformed(evt);
}

######


public void mouseClicked(java.awt.event.MouseEvent evt) {
    jTableKitapIslemMouseClicked(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButton4ActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButton3ActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButtonDuyuruEkleActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jTabbedPane1 = new javax.swing.JTabbedPane();
    jPanel1 = new javax.swing.JPanel();
    jPanel6 = new javax.swing.JPanel();
    jLabel1 = new javax.swing.JLabel();
    jTextUyeAra = new javax.swing.JTextField();
    jButtonUyeAra = new javax.swing.JButton();
    jPanel7 = new javax.swing.JPanel();
    jScrollPane1 = new javax.swing.JScrollPane();
    jTableUyeler = new javax.swing.JTable();
    jButtonUyeCikar = new javax.swing.JButton();
    jButtonUyeEkle1 = new javax.swing.JButton();
    jButtonUyeEkle2 = new javax.swing.JButton();
    jPanel3 = new javax.swing.JPanel();
    jPanel13 = new javax.swing.JPanel();
    jTextKitapIslemAra = new javax.swing.JTextField();
    jButtonKitapAra = new javax.swing.JButton();
    jScrollPane2 = new javax.swing.JScrollPane();
    jTableKitapIslem = new javax.swing.JTable();
    jButton4 = new javax.swing.JButton();
    jButton3 = new javax.swing.JButton();
    jPanel4 = new javax.swing.JPanel();
    jPanel11 = new javax.swing.JPanel();
    jScrollPane3 = new javax.swing.JScrollPane();
    jTable3 = new javax.swing.JTable();
    jButton6 = new javax.swing.JButton();
    jPanel2 = new javax.swing.JPanel();
    jLabel14 = new javax.swing.JLabel();
    jTextDuyuru = new javax.swing.JTextField();
    jLabel15 = new javax.swing.JLabel();
    jScrollPane4 = new javax.swing.JScrollPane();
    jTextArea = new javax.swing.JTextArea();
    jButtonDuyuruEkle = new javax.swing.JButton();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    jPanel6.setForeground(new java.awt.Color(255, 255, 255));
    jLabel1.setText("Üye ARA");
    jButtonUyeAra.setText("Ara");
    jButtonUyeAra.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButtonUyeAraActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
    jPanel6.setLayout(jPanel6Layout);
    jPanel6Layout.setHorizontalGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel6Layout.createSequentialGroup().addGap(66, 66, 66).addComponent(jLabel1).addGap(51, 51, 51).addComponent(jTextUyeAra, javax.swing.GroupLayout.PREFERRED_SIZE, 184, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(60, 60, 60).addComponent(jButtonUyeAra).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    jPanel6Layout.setVerticalGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel6Layout.createSequentialGroup().addGap(58, 58, 58).addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel1).addComponent(jTextUyeAra, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jButtonUyeAra)).addContainerGap(63, Short.MAX_VALUE)));
    jTableUyeler.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jTableUyeler.addMouseListener(new java.awt.event.MouseAdapter() {

        public void mouseClicked(java.awt.event.MouseEvent evt) {
            jTableUyelerMouseClicked(evt);
        }
    });
    jScrollPane1.setViewportView(jTableUyeler);
    jButtonUyeCikar.setText("Çıkar");
    jButtonUyeCikar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButtonUyeCikarActionPerformed(evt);
        }
    });
    jButtonUyeEkle1.setText("Uye Ekle");
    jButtonUyeEkle2.setText("Uye Ekle");
    jButtonUyeEkle2.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButtonUyeEkle2ActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);
    jPanel7.setLayout(jPanel7Layout);
    jPanel7Layout.setHorizontalGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel7Layout.createSequentialGroup().addGap(230, 230, 230).addComponent(jButtonUyeCikar).addGap(65, 65, 65).addComponent(jButtonUyeEkle2).addContainerGap(147, Short.MAX_VALUE)).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel7Layout.createSequentialGroup().addContainerGap().addComponent(jScrollPane1).addContainerGap()).addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel7Layout.createSequentialGroup().addContainerGap(249, Short.MAX_VALUE).addComponent(jButtonUyeEkle1).addContainerGap(250, Short.MAX_VALUE))));
    jPanel7Layout.setVerticalGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel7Layout.createSequentialGroup().addContainerGap().addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jButtonUyeCikar, javax.swing.GroupLayout.DEFAULT_SIZE, 39, Short.MAX_VALUE).addComponent(jButtonUyeEkle2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addContainerGap()).addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel7Layout.createSequentialGroup().addContainerGap(109, Short.MAX_VALUE).addComponent(jButtonUyeEkle1, javax.swing.GroupLayout.PREFERRED_SIZE, 48, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(135, Short.MAX_VALUE))));
    javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
    jPanel1.setLayout(jPanel1Layout);
    jPanel1Layout.setHorizontalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addContainerGap().addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jPanel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(jPanel7, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addContainerGap()));
    jPanel1Layout.setVerticalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addContainerGap().addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18, 18, 18).addComponent(jPanel7, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addContainerGap()));
    jTabbedPane1.addTab("Üye İşlem", jPanel1);
    jButtonKitapAra.setText("ara");
    jButtonKitapAra.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButtonKitapAraActionPerformed(evt);
        }
    });
    jTableKitapIslem.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jTableKitapIslem.addMouseListener(new java.awt.event.MouseAdapter() {

        public void mouseClicked(java.awt.event.MouseEvent evt) {
            jTableKitapIslemMouseClicked(evt);
        }
    });
    jScrollPane2.setViewportView(jTableKitapIslem);
    jButton4.setText("ekle");
    jButton4.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButton4ActionPerformed(evt);
        }
    });
    jButton3.setText("Çikar");
    jButton3.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButton3ActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout jPanel13Layout = new javax.swing.GroupLayout(jPanel13);
    jPanel13.setLayout(jPanel13Layout);
    jPanel13Layout.setHorizontalGroup(jPanel13Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel13Layout.createSequentialGroup().addGroup(jPanel13Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel13Layout.createSequentialGroup().addGap(116, 116, 116).addComponent(jTextKitapIslemAra, javax.swing.GroupLayout.PREFERRED_SIZE, 216, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(37, 37, 37).addComponent(jButtonKitapAra)).addGroup(jPanel13Layout.createSequentialGroup().addGap(20, 20, 20).addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addGroup(jPanel13Layout.createSequentialGroup().addGap(164, 164, 164).addComponent(jButton4).addGap(78, 78, 78).addComponent(jButton3))).addContainerGap(28, Short.MAX_VALUE)));
    jPanel13Layout.setVerticalGroup(jPanel13Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel13Layout.createSequentialGroup().addGap(18, 18, 18).addGroup(jPanel13Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jTextKitapIslemAra, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jButtonKitapAra)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 167, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(jPanel13Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jButton4).addComponent(jButton3)).addContainerGap(215, Short.MAX_VALUE)));
    javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
    jPanel3.setLayout(jPanel3Layout);
    jPanel3Layout.setHorizontalGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel3Layout.createSequentialGroup().addGap(42, 42, 42).addComponent(jPanel13, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(50, Short.MAX_VALUE)));
    jPanel3Layout.setVerticalGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel3Layout.createSequentialGroup().addContainerGap().addComponent(jPanel13, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(17, Short.MAX_VALUE)));
    jTabbedPane1.addTab("Kitap İşlem", jPanel3);
    jTable3.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane3.setViewportView(jTable3);
    jButton6.setText("onay");
    javax.swing.GroupLayout jPanel11Layout = new javax.swing.GroupLayout(jPanel11);
    jPanel11.setLayout(jPanel11Layout);
    jPanel11Layout.setHorizontalGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel11Layout.createSequentialGroup().addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel11Layout.createSequentialGroup().addGap(19, 19, 19).addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 487, javax.swing.GroupLayout.PREFERRED_SIZE)).addGroup(jPanel11Layout.createSequentialGroup().addGap(182, 182, 182).addComponent(jButton6, javax.swing.GroupLayout.PREFERRED_SIZE, 149, javax.swing.GroupLayout.PREFERRED_SIZE))).addContainerGap(18, Short.MAX_VALUE)));
    jPanel11Layout.setVerticalGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel11Layout.createSequentialGroup().addContainerGap().addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 283, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(28, 28, 28).addComponent(jButton6, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(123, Short.MAX_VALUE)));
    javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
    jPanel4.setLayout(jPanel4Layout);
    jPanel4Layout.setHorizontalGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup().addContainerGap(48, Short.MAX_VALUE).addComponent(jPanel11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(20, 20, 20)));
    jPanel4Layout.setVerticalGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel4Layout.createSequentialGroup().addContainerGap().addComponent(jPanel11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    jTabbedPane1.addTab("Kitap Onayla", jPanel4);
    jLabel14.setText("Başlık");
    jLabel15.setText("Duyuru");
    jTextArea.setColumns(20);
    jTextArea.setRows(5);
    jScrollPane4.setViewportView(jTextArea);
    jButtonDuyuruEkle.setText("Ekle");
    jButtonDuyuruEkle.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButtonDuyuruEkleActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
    jPanel2.setLayout(jPanel2Layout);
    jPanel2Layout.setHorizontalGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel2Layout.createSequentialGroup().addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel2Layout.createSequentialGroup().addGap(217, 217, 217).addComponent(jLabel14)).addGroup(jPanel2Layout.createSequentialGroup().addGap(221, 221, 221).addComponent(jLabel15)).addGroup(jPanel2Layout.createSequentialGroup().addGap(238, 238, 238).addComponent(jButtonDuyuruEkle)).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup().addGap(20, 20, 20).addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jTextDuyuru, javax.swing.GroupLayout.PREFERRED_SIZE, 472, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 472, javax.swing.GroupLayout.PREFERRED_SIZE)))).addContainerGap(100, Short.MAX_VALUE)));
    jPanel2Layout.setVerticalGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel2Layout.createSequentialGroup().addGap(39, 39, 39).addComponent(jLabel14).addGap(26, 26, 26).addComponent(jTextDuyuru, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(52, 52, 52).addComponent(jLabel15).addGap(34, 34, 34).addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 174, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18, 18, 18).addComponent(jButtonDuyuruEkle).addContainerGap(72, Short.MAX_VALUE)));
    jTabbedPane1.addTab("Duyuru", jPanel2);
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(19, 19, 19).addComponent(jTabbedPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 597, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(69, Short.MAX_VALUE)));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addContainerGap(44, Short.MAX_VALUE).addComponent(jTabbedPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 514, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(32, 32, 32)));
    pack();
}

######


private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {
    kitapSil();
}

######


private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {
    new KitapKayit().setVisible(true);
    dispose();
}

######


private void jTableKitapIslemMouseClicked(java.awt.event.MouseEvent evt) {
    id = "" + jTableKitapIslem.getValueAt(jTableKitapIslem.getSelectedRow(), 0);
}

######


private void jButtonKitapAraActionPerformed(java.awt.event.ActionEvent evt) {
    String kitp = jTextKitapIslemAra.getText();
    jTableKitapIslem.setModel(tb.kitaplar(kitp));
    kitp = "";
}

######


private void jButtonUyeCikarActionPerformed(java.awt.event.ActionEvent evt) {
    uyeCikar();
}

######


private void jTableUyelerMouseClicked(java.awt.event.MouseEvent evt) {
    id = "" + jTableUyeler.getValueAt(jTableUyeler.getSelectedRow(), 0);
}

######


private void jButtonUyeAraActionPerformed(java.awt.event.ActionEvent evt) {
    String gelenAd = jTextUyeAra.getText();
    jTableUyeler.setModel((uyeler(gelenAd)));
    tableAlanGizle(jTableUyeler);
    jTextUyeAra.setText("");
}

######


private void jButtonUyeEkle2ActionPerformed(java.awt.event.ActionEvent evt) {
    new YetkiliKayit().setVisible(true);
    dispose();
}

######


private void jButtonDuyuruEkleActionPerformed(java.awt.event.ActionEvent evt) {
    String baslik = jTextDuyuru.getText();
    String duyuru = jTextArea.getText();
    DB db = new DB();
    try {
        String query = "insert into duyurular values(null,'" + duyuru + "','" + baslik + "')";
        int ekle = db.baglan().executeUpdate(query);
        if (ekle > 0) {
            JOptionPane.showMessageDialog(this, "Ekleme işlemi başarılı");
        }
    } catch (Exception e) {
        JOptionPane.showMessageDialog(this, "Duyuru ekleme hatası");
    }
}

######


public void kitapSil() {
    if (id.equals("")) {
        JOptionPane.showMessageDialog(this, "lütfen bir değer giriniz");
    } else {
        try {
            DB db = new DB();
            String id = "" + jTableKitapIslem.getValueAt(jTableKitapIslem.getSelectedRow(), 0);
            String query = "DELETE FROM kitaplar WHERE kitapID = " + id + "";
            int ekle = db.baglan().executeUpdate(query);
            if (ekle > 0) {
                JOptionPane.showMessageDialog(this, "Silme işlemi başarılı");
                id = "";
            }
        } catch (SQLException ex) {
            Logger.getLogger(AdminMenu.class.getName()).log(Level.SEVERE, null, ex);
        }
        String kitp = jTextKitapIslemAra.getText();
        jTableKitapIslem.setModel(tb.kitaplar(kitp));
        tableAlanGizle(jTableKitapIslem);
    }
}

######


public void uyeCikar() {
    if (id.equals("")) {
        JOptionPane.showMessageDialog(this, "lütfen seçim yapınız");
    }
    DB db = new DB();
    try {
        id = "" + jTableUyeler.getValueAt(jTableUyeler.getSelectedRow(), 0);
        String query = "DELETE FROM uyeler WHERE `uyeID` = " + id + "";
        int ekle = db.baglan().executeUpdate(query);
        if (ekle > 0) {
            JOptionPane.showMessageDialog(this, "Silme işlemi başarılı");
            id = "";
        }
    } catch (SQLException ex) {
        Logger.getLogger(AdminMenu.class.getName()).log(Level.SEVERE, null, ex);
    } finally {
        db.kapat();
    }
    String gelenAd = jTextUyeAra.getText();
    jTableUyeler.setModel(uyeler(gelenAd));
    tableAlanGizle(jTableUyeler);
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
}

######


public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType("text/html");
    int empid = Integer.parseInt(request.getParameter("empid"));
    try {
        HttpSession session = request.getSession();
        calculateAdvanced(session, request, response);
    } catch (Exception e) {
        e.printStackTrace();
        if (empid == 11) {
            RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
            ReqDis.forward(request, response);
        } else {
            RequestDispatcher ReqDis = request.getRequestDispatcher("error.jsp");
            ReqDis.forward(request, response);
        }
    }
}

######


private void calculateAdvanced(HttpSession session, HttpServletRequest request, HttpServletResponse response) throws SQLException, ServletException, IOException {
    PrintWriter out = response.getWriter();
    DecimalFormat df = new DecimalFormat("#.##");
    int empid = Integer.parseInt(request.getParameter("empid"));
    String truckType = request.getParameter("Capacity");
    String param = request.getParameter("param");
    float backhaul = 100;
    String type = request.getParameter("good");
    String start = org.apache.commons.lang3.StringUtils.capitalize(request.getParameter("headstart"));
    String destnation = org.apache.commons.lang3.StringUtils.capitalize(request.getParameter("backstart"));
    String end = org.apache.commons.lang3.StringUtils.capitalize(request.getParameter("end"));
    session.setAttribute("start", start);
    session.setAttribute("backstart", end);
    session.setAttribute("end", destnation);
    session.setAttribute("type", type);
    session.setAttribute("cap", truckType);
    float distance1 = Float.parseFloat(request.getParameter("distance1"));
    float dist = Float.parseFloat(request.getParameter("distance"));
    float distance;
    distance = distance1 + dist;
    session.setAttribute("distance", distance);
    float intrest1 = 0, costOfTyre = 0, costOfTruck = 0, loan = 0, noOfYears = 0, residualValue = 0, noOfTyre = 0, costOfTyreUsed = 0, tyreLife = 0, tyreLifeUsed = 0, mileage = 0, noTrips = 0;
    float mileageWithLoad = 0, diesel = 0, roi = 0;
    int cap = 0;
    Connection con = Connect.getconnection();
    PreparedStatement ps = con.prepareStatement("select * from truckparam where typeofgood=?");
    ps.setString(1, truckType);
    ResultSet rs = ps.executeQuery();
    while (rs.next()) {
        costOfTruck = rs.getFloat("costoftruck");
        loan = rs.getFloat("loanpercentage");
        intrest1 = rs.getFloat("rateofintrest");
        roi = rs.getFloat("flatroi");
        costOfTyre = rs.getFloat("tyrecost");
        noOfYears = rs.getFloat("yearsemi");
        residualValue = rs.getFloat("residualvalueoftruck");
        noOfTyre = rs.getFloat("tyres");
        costOfTyreUsed = rs.getFloat("reusedtyrecost");
        tyreLife = rs.getFloat("tyrelife");
        tyreLifeUsed = rs.getFloat("reusedtyrelife");
        mileage = rs.getFloat("dieselmileage");
        mileageWithLoad = rs.getFloat("diesealmileagewithload");
        diesel = rs.getFloat("dieselcost");
        cap = rs.getInt("capacity");
    }
    PreparedStatement ps0 = con.prepareStatement("select `NoofTrip` from `slabtable` WHERE `Min Distance` <= ? AND `Max Distance` >?");
    ps0.setInt(1, (int) distance);
    ps0.setInt(2, (int) distance);
    ResultSet rs0 = ps0.executeQuery();
    while (rs0.next()) {
        noTrips = rs0.getFloat("NoofTrip");
    }
    float cost = calculateTyreCostPerKM(noOfTyre, costOfTyre, costOfTyreUsed, tyreLife, tyreLifeUsed);
    float loanamount = calculateLoanAmount(loan, costOfTruck);
    float paid = calculatePaid(costOfTruck, loanamount);
    float residualValueTruck = calulateResidualValueOfTruck(residualValue, costOfTruck);
    float depreciation = calculateDepreciation(costOfTruck, residualValueTruck, noOfYears);
    float interestcost = calculateInterestCostPerMonth(roi, loanamount);
    float netMileage = calculateNetMilage(mileageWithLoad, backhaul, mileage);
    float roundtrip = calculateRoundTrip(distance);
    float distanceTravled = calculateKmRunPerMonthAvg(roundtrip, noTrips);
    PreparedStatement ps1 = con.prepareStatement("UPDATE truckparam SET loanamount=" + loanamount + ",amountpaid=" + paid + ",kmrunpermonthaverage=" + distanceTravled + ",tyrecostperkm=" + cost + ",roundTrip=" + roundtrip + "WHERE typeofgood=?");
    ps1.setString(1, truckType);
    ps1.executeUpdate();
    float Salary = 0, batta = 0, maintenance = 0, Admin = 0, tarpaulin = 0;
    float expense = 0, totaltoll = 0, insurancepercent = 0, permit = 0, tax = 0;
    float maintenancePerKm = 0, loading = 0;
    float pro = 0;
    PreparedStatement ps2 = con.prepareStatement("select * from routeparam where typeofgood=?");
    ps2.setString(1, truckType);
    ResultSet rs1 = ps2.executeQuery();
    while (rs1.next()) {
        expense = rs1.getFloat("routeexpenses");
        totaltoll = rs1.getFloat("toll");
        insurancepercent = rs1.getFloat("insuranceaspercentageofvechiclecost");
        permit = rs1.getFloat("roadpermityear");
        tax = rs1.getFloat("roadtaxyear");
        Salary = rs1.getFloat("driver/cleaner salary");
        batta = rs1.getFloat("driver/cleaner bhatta");
        maintenance = rs1.getFloat("maintenancepermonth");
        Admin = rs1.getFloat("admin costs");
        maintenancePerKm = rs1.getFloat("maintenancecostperkm");
        tarpaulin = rs1.getFloat("tarpaulin");
        loading = rs1.getFloat("loadingcharges");
        pro = rs1.getInt("profitmargin");
    }
    float toll = calculateTollPerKm(totaltoll, distance);
    float unloading = calculateUnloadingCharges(cap);
    float unloadingloading = unloading + loading;
    float dieselCost = calculateDieselCostPerKm(diesel, netMileage);
    float variableCost = calculateVaribleCostperKm(dieselCost, toll, cost, maintenancePerKm, expense);
    float variable = calculateVaribleCostperMonth(variableCost, distanceTravled, unloadingloading);
    float insuranceMonth = calculateInsurancePerMonth(costOfTruck, insurancepercent);
    float roadPermit = calculateRoadPermitPerMonth(permit);
    float roadTax = calculateRoadTaxPerMonth(tax);
    float fixedcostperMonth = calculatefixedCostPerMonth(roadTax, roadPermit, insuranceMonth, Salary, batta, maintenance, Admin, tarpaulin, depreciation, interestcost);
    float monthlyoperating = calculateMonthlyOperatingCost(fixedcostperMonth, variable);
    float profit = calculateProfitMargin(fixedcostperMonth, pro);
    double perKmCost = calculatePerKmCost(profit, monthlyoperating, distanceTravled);
    float monthlyTon = calculateMonthlyTons(cap, backhaul, noTrips);
    float fixedPTPK = calculateFixedPTPK(fixedcostperMonth, roundtrip, cap, noTrips, backhaul);
    float variablePTPK = calculateVariablePTPK(variable, roundtrip, cap, noTrips, backhaul);
    float profitPTPK = calculateProfitPTPK(profit, roundtrip, cap, noTrips, backhaul);
    float totalPTPK = calculateTotalPTPK(profitPTPK, variablePTPK, fixedPTPK);
    float freightPerTon = calculateFreightPerTon(totalPTPK, distance);
    float emi = 0;
    float cashInflow = 0;
    float cashFlowPerMonth = 0;
    float irr = 0;
    float workingCapital = 0;
    session.setAttribute("fixedptpk", fixedPTPK);
    session.setAttribute("variableptpk", variablePTPK);
    session.setAttribute("profitptpk", profitPTPK);
    session.setAttribute("ptpk", totalPTPK);
    session.setAttribute("freightPerTon", freightPerTon);
    PreparedStatement ps3 = con.prepareStatement("UPDATE routeparam SET backhaul='" + backhaul + "',distance='" + distance + "',unloadingchages='" + unloading + "',loadingunloadingcharges='" + unloadingloading + "',variblecostperkm='" + variableCost + "',variblecostpermonth='" + variable + "',insurancepermonth='" + insuranceMonth + "',workingcapitalinterestcost='" + workingCapital + "',roadpermitmonth='" + roadPermit + "',roadtaxmonth='" + roadTax + "',monthlyoperatingcost='" + monthlyoperating + "',perkmcost='" + perKmCost + "',monthlytons='" + monthlyTon + "',fixedptpk='" + fixedPTPK + "',variableptpk='" + variablePTPK + "', profitptpk='" + profitPTPK + "', totalptpk='" + totalPTPK + "', freightperton='" + freightPerTon + "' WHERE typeofgood=?");
    PreparedStatement ps31 = con.prepareStatement("UPDATE routeparam SET origin=? ,destination=? WHERE typeofgood=?");
    ps3.setString(1, truckType);
    ps3.executeUpdate();
    ps31.setString(1, start);
    ps31.setString(2, end);
    ps31.setString(3, truckType);
    ps31.executeUpdate();
    float costs = cap * distance * totalPTPK;
    session.setAttribute("cost", costs);
    session.setAttribute("profitkm", df.format(profit / distanceTravled));
    session.setAttribute("variablekm", variableCost);
    session.setAttribute("fixedkm", df.format((fixedcostperMonth + profit) / distanceTravled));
    session.setAttribute("variableton", df.format(variable / monthlyTon));
    session.setAttribute("profitton", df.format(profit / monthlyTon));
    session.setAttribute("fixedton", df.format((fixedcostperMonth + profit) / monthlyTon));
    session.setAttribute("dep", df.format(depreciation));
    session.setAttribute("intres", df.format(interestcost));
    session.setAttribute("salr", df.format(Salary));
    session.setAttribute("insu", df.format(insuranceMonth));
    session.setAttribute("rota", df.format(roadTax));
    session.setAttribute("dies", df.format(dieselCost));
    session.setAttribute("tole", df.format(totaltoll));
    session.setAttribute("tyres", df.format(cost));
    session.setAttribute("routes", df.format(expense));
    session.setAttribute("maint", df.format(maintenancePerKm));
    if (empid == 11) {
        RequestDispatcher ReqDis = request.getRequestDispatcher("AdminResultAdvanced.jsp");
        ReqDis.forward(request, response);
    } else {
        RequestDispatcher ReqDis = request.getRequestDispatcher("ResultAdvanced.jsp");
        ReqDis.forward(request, response);
    }
}

######


private float calculateProfitMargin(float fixedcostperMonth, float pro) {
    return (fixedcostperMonth * pro) / 100;
}

######


private float calculateProfit(float monthlyoperating) {
    return (float) ((0.0752688172043011) * monthlyoperating);
}

######


private float calculateKmRunPerMonthAvg(float roundtrip, float noTrips) {
    return (roundtrip * noTrips);
}

######


private float calculateVaribleCostperMonth(float variableCost, float distanceTravled, float unloadingloading) {
    return ((variableCost * distanceTravled) + unloadingloading);
}

######


private float calculateTotalPTPK(float profitPTPK, float variablePTPK, float fixedPTPK) {
    return (profitPTPK + variablePTPK + fixedPTPK);
}

######


private float calculateProfitPTPK(float profit, float roundtrip, int cap, float noTrips, float backhaul) {
    return (profit / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateVariablePTPK(float variable, float roundtrip, int cap, float noTrips, float backhaul) {
    return (variable / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateFixedPTPK(float fixedcostperMonth, float roundtrip, int cap, float noTrips, float backhaul) {
    return (fixedcostperMonth / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateFreightPerTon(float totalPTPK, float distance) {
    return (totalPTPK * distance);
}

######


private float calculateRoundTrip(float distance) {
    return (distance * 2);
}

######


private float calculateTotalCostPerTon(float totalPTPK, float distance, int cap) {
    return (totalPTPK * distance * cap);
}

######


private float calculateMonthlyTons(int cap, float backhaul, float noTrips) {
    return (noTrips * cap * (1 + (backhaul / 100)));
}

######


private float calculatePerKmCost(float profitMargin, float monthlyoperating, float distanceTravled) {
    return ((profitMargin + monthlyoperating) / distanceTravled);
}

######


private float calculateMonthlyOperatingCost(float fixedcostperMonth, float variable) {
    return (fixedcostperMonth + variable);
}

######


private float calculatefixedCostPerMonth(float roadTax, float roadPermit, float insuranceMonth, float salary, float batta, float maintenance, float admin, float tarpaulin, float depreciation, float interestcost) {
    return (admin + batta + insuranceMonth + maintenance + roadPermit + roadTax + salary + tarpaulin + depreciation + interestcost);
}

######


private float calculateRoadTaxPerMonth(float tax) {
    return (tax / 12);
}

######


private float calculateRoadPermitPerMonth(float permit) {
    return (permit / 12);
}

######


private float calculateInsurancePerMonth(float costOfTruck, float insurancepercent) {
    return ((costOfTruck * insurancepercent) / 1200);
}

######


private float calculateVaribleCostperKm(float dieselCost, float toll, float cost, float maintenancePerKm, float route) {
    return (dieselCost + toll + cost + maintenancePerKm + route);
}

######


private float calculateRouteExpence(float expense, float distance) {
    return (expense / distance);
}

######


private float calculateUnloadingCharges(int cap) {
    return (45 * cap);
}

######


private float calculateDieselCostPerKm(float diesel, float netMileage) {
    return (diesel / netMileage);
}

######


private float calculateNetMilage(float mileageWithLoad, float backhaul, float mileage) {
    return (((mileageWithLoad * 100 + (mileageWithLoad * backhaul)) + (mileage) * (100 - backhaul)) / 200);
}

######


private float calculateTollPerKm(float totaltoll, float distance) {
    return (totaltoll / distance);
}

######


private float calulateResidualValueOfTruck(float residualValue, float costOfTruck) {
    return (costOfTruck * residualValue / 100);
}

######


private float calculateInterestCostPerMonth(float roi, float loanamount) {
    return ((roi * loanamount) / 1200);
}

######


private float calculateDepreciation(float costOfTruck, float residualValue, float noOfYears) {
    return (((costOfTruck - residualValue) / noOfYears) / 12);
}

######


private float calculatePaid(float costOfTruck, float loanamount) {
    return (costOfTruck - loanamount);
}

######


private float calculateLoanAmount(float loan, float costOfTruck) {
    return ((costOfTruck * loan) / 100);
}

######


private float calculateTyreCostPerKM(float noOfTyre, float costOfTyre, float costOfTyreUsed, float tyreLife, float tyreLifeUsed) {
    return (noOfTyre * (costOfTyre + costOfTyreUsed) / (tyreLife + tyreLifeUsed));
}

######


@Nullable
@Override
public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
    Bundle klantGegevens = this.getArguments();
    klant = (Klant) klantGegevens.getSerializable("klantGegevens");
    return inflater.inflate(R.layout.afspraak_registreer_fragment, container, false);
}

######


@Override
public void onDateSet(DatePicker datePicker, int year, int monthOfYear, int dayOfMonth) {
    gekozenDatum = dayOfMonth + "-" + (monthOfYear + 1 < 10 ? ("0" + (monthOfYear + 1)) : monthOfYear + 1) + "-" + year;
    etDatepicker.setText(gekozenDatum);
}

######


@Override
public void onClick(View view) {
    datepicker = new DatePickerDialog(view.getContext(), date, calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH));
    datepicker.show();
}

######


@Override
public void onClick(View view) {
    Afspraak afspraak = new Afspraak(klant.getKlantId(), etDatepicker.getText().toString(), spinnerTijden.getSelectedItem().toString());
    Log.d("Afspraak", "Afspraak gegevens: " + afspraak.getDatum() + afspraak.getTijd() + afspraak.getKlantId());
}

######


@Override
public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    ArrayList<String> afspraakTijden = new ArrayList<>();
    afspraakTijden.add("09:00");
    afspraakTijden.add("10:00");
    afspraakTijden.add("11:00");
    etDatepicker = view.findViewById(R.id.afspraakfragment_etDatum);
    String datumVandaag = new SimpleDateFormat("dd-MM-yyyy", Locale.getDefault()).format(new Date());
    etDatepicker.setText(datumVandaag);
    final Spinner spinnerTijden = view.findViewById(R.id.afsrpaakfragment_spinnerTijden);
    calendar = Calendar.getInstance();
    final DatePickerDialog.OnDateSetListener date = new DatePickerDialog.OnDateSetListener() {

        @Override
        public void onDateSet(DatePicker datePicker, int year, int monthOfYear, int dayOfMonth) {
            gekozenDatum = dayOfMonth + "-" + (monthOfYear + 1 < 10 ? ("0" + (monthOfYear + 1)) : monthOfYear + 1) + "-" + year;
            etDatepicker.setText(gekozenDatum);
        }
    };
    etDatepicker.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            datepicker = new DatePickerDialog(view.getContext(), date, calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH));
            datepicker.show();
        }
    });
    final String sql = "SELECT * FROM Afspraak WHERE datum = \"" + etDatepicker.getText().toString() + "\"";
    Log.d("Afspraak", "SQL statement: " + sql);
    try {
        DatabaseConnector db = new DatabaseConnector();
        db.execute(sql);
        Object oResult = db.get();
        String strResult = oResult.toString();
        String strResultReplace = strResult.replace("\"", "");
        Log.d("Afspraak", "strResult: " + strResultReplace);
        if (strResultReplace.equals("msg:select:empty")) {
            ArrayAdapter<String> adapter = new ArrayAdapter<String>(getContext(), android.R.layout.simple_spinner_dropdown_item, afspraakTijden);
            spinnerTijden.setAdapter(adapter);
        } else {
            Log.d("Afspraak", "strResultTijden: " + strResult);
            JSONArray jsonArray = new JSONArray(strResult);
            ArrayList<String> tijdenBezet = new ArrayList<>();
            for (int i = 0; i < jsonArray.length(); i++) {
                JSONObject jsonObject = (JSONObject) jsonArray.get(i);
                String tijd = (String) jsonObject.get("Tijd");
                tijdenBezet.add(tijd);
                Log.d("Afspraakfragment", "opgehaalde json: " + tijd);
            }
            afspraakTijden.removeAll(tijdenBezet);
            if (afspraakTijden.size() > 0) {
                ArrayAdapter<String> adapter = new ArrayAdapter<>(getContext(), android.R.layout.simple_spinner_dropdown_item, afspraakTijden);
                spinnerTijden.setAdapter(adapter);
            } else {
                Toast.makeText(getContext(), "Er zijn geen tijden beschikbaar op deze datum", Toast.LENGTH_SHORT).show();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    final Button btnVersturen = view.findViewById(R.id.afspraakfragment_btnVersturen);
    btnVersturen.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            Afspraak afspraak = new Afspraak(klant.getKlantId(), etDatepicker.getText().toString(), spinnerTijden.getSelectedItem().toString());
            Log.d("Afspraak", "Afspraak gegevens: " + afspraak.getDatum() + afspraak.getTijd() + afspraak.getKlantId());
        }
    });
}

######


private void insertKlant(Klant k) {
    String sql = "INSERT INTO Klant(klantID, Voornaam, Achternaam, Telefoon, Email, Adres, Bedrijfsnaam, isGoedgekeurd) " + "VALUES('" + k.getKlantId() + "','" + k.getVoornaam() + "','" + k.getAchternaam() + "','" + k.getTelefoonnummer() + "','" + k.getEmail() + "','" + k.getAdres() + "','" + k.getBedrijfsnaam() + "'," + 0 + ");";
    try {
        DatabaseConnector db = new DatabaseConnector();
        db.execute(sql);
        Log.d("Afspraak", "Db.execute aangeroepen");
        Object oResult = db.get();
        String strResult = oResult.toString();
        strResult = strResult.replace("\"", "");
        Log.d("AfspraakFr:insertKlant", "strResult: " + strResult);
        if (strResult.equals("msg:insert:succes")) {
            Toast.makeText(getContext(), "Klant succesvol toegevoegd", Toast.LENGTH_SHORT).show();
        } else {
            Toast.makeText(getContext(), "Er is iets misgegaan", Toast.LENGTH_SHORT).show();
        }
    } catch (Exception e) {
        Log.d("Afspraak", "Er is iets misgegaan");
        e.printStackTrace();
    }
}

######


private void insertAfspraak(Afspraak af) {
    String sql = "INSERT INTO Afspraak VALUES('" + af.getDatum() + "','" + af.getTijd() + "','" + af.getKlantId() + "');";
    try {
        DatabaseConnector db = new DatabaseConnector();
        db.execute(sql);
        Object oResult = db.get();
        String strResult = oResult.toString();
        strResult = strResult.replace("\"", "");
        Log.d("Afspraak:insertAfsrpaak", "strResult: " + strResult);
        if (strResult.equals("msg:insert:succes")) {
            Toast.makeText(getContext(), "Afspraak succesvol toegevoegd", Toast.LENGTH_SHORT).show();
        } else {
            Toast.makeText(getContext(), "Er is iets misgegaan", Toast.LENGTH_SHORT).show();
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void salvar(Agenda agenda) throws Exception {
    if (agenda.getIdAgendamento() == 0) {
        inserir(agenda);
    } else {
        alterar(agenda);
    }
}

######


public void alterar(Agenda agenda) throws Exception {
    try {
        PreparedStatement ps = getConnection().prepareStatement(UPDATE);
        parseAgenda(agenda, ps);
        ps.setLong(6, agenda.getIdAgendamento());
        ps.executeUpdate();
    } catch (SQLException e) {
        e.printStackTrace();
        throw new Exception("Erro ao tentar salvar o a agenda");
    }
}

######


private void inserir(Agenda agenda) throws Exception {
    try {
        PreparedStatement ps = getConnection().prepareStatement(INSERT);
        parseAgenda(agenda, ps);
        ps.executeUpdate();
    } catch (Exception e) {
        e.printStackTrace();
        throw new Exception("Erro ao tentar salvar o agendamento");
    }
}

######


public void excluir(Long idAgendamento) throws Exception {
    try {
        PreparedStatement ps = getConnection().prepareStatement(DELETE);
        ps.setLong(1, idAgendamento);
        ps.executeUpdate();
    } catch (SQLException e) {
        e.printStackTrace();
        throw new Exception("Erro ao tentar salvar o usuario");
    }
}

######


public List<Agenda> listarTodos() throws Exception {
    List<Agenda> agendamento = new ArrayList<Agenda>();
    try {
        PreparedStatement ps = getConnection().prepareStatement(SELECT);
        ResultSet rs = ps.executeQuery();
        while (rs.next()) {
            Agenda agenda = parseAgenda(rs);
            agendamento.add(agenda);
        }
    } catch (SQLException ex) {
        System.out.println("Erro ao executar o select da loca��o: " + ex);
    }
    return agendamento;
}

######


public Agenda buscarPorId(Long idAgendamento) {
    try {
        PreparedStatement ps = getConnection().prepareStatement(SELECT_ID);
        ps.setLong(1, idAgendamento);
        ResultSet rs = ps.executeQuery();
        if (rs.next()) {
            Agenda agenda = parseAgenda(rs);
            return agenda;
        }
    } catch (SQLException e) {
        e.printStackTrace();
        System.out.println("Erro ao executar o select de user: " + e);
    }
    return null;
}

######


private void parseAgenda(Agenda agenda, PreparedStatement ps) throws SQLException {
    ps.setObject(1, agenda.getData());
    ps.setObject(2, agenda.getHora());
    ps.setString(3, agenda.getProcedimento());
    ps.setLong(4, agenda.getFuncionario().getIdFuncionario());
    ps.setLong(5, agenda.getCliente().getIdCliente());
}

######


private Agenda parseAgenda(ResultSet rs) throws SQLException {
    Agenda agenda = new Agenda();
    agenda.setFuncionario(new Funcionario());
    agenda.setCliente(new Cliente());
    agenda.setIdAgendamento(rs.getLong("idAgendamento"));
    agenda.setData(rs.getDate("data"));
    agenda.setHora(rs.getTime("hora"));
    agenda.setProcedimento(rs.getString("procedimento"));
    agenda.getFuncionario().setIdFuncionario(rs.getLong("idFuncionario"));
    agenda.getCliente().setIdCliente(rs.getLong("idCliente"));
    return agenda;
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
}

######


public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


@Override
public void validateBuild() throws IndexerException {
    Long numFound = getDocumentCount(alleleCore);
    if (numFound <= MINIMUM_DOCUMENT_COUNT)
        throw new IndexerException(new ValidationException("Actual allele document count is " + numFound + "."));
    if (numFound != documentCount)
        logger.warn("WARNING: Added " + documentCount + " allele documents but SOLR reports " + numFound + " documents.");
    else
        logger.info("validateBuild(): Indexed " + documentCount + " allele documents.");
}

######


@Override
protected Logger getLogger() {
    return logger;
}

######


@Override
public void run() throws IndexerException {
    int start = 0;
    long rows = 0;
    long startTime = new Date().getTime();
    try {
        connection = komp2DataSource.getConnection();
        initializeSolrCores();
        SolrQuery query = new SolrQuery("mgi_accession_id:MGI* OR mgi_accession_id:CGI*");
        query.addFilterQuery("feature_type:* AND -feature_type:Pseudogene AND -feature_type:\"heritable+phenotypic+marker\" AND type:gene");
        query.setRows(BATCH_SIZE);
        logger.info("Populating lookups");
        populateStatusLookup();
        logger.info("Populated status lookup, {} records", statusLookup.size());
        populateHumanSymbolLookup();
        logger.info("Populated human symbol lookup, {} records", humanSymbolLookup.size());
        populateDiseaseLookup();
        logger.info("Populated disease lookup, {} records", diseaseLookup.size());
        populateLegacyLookup();
        logger.info("Populated legacy project lookup, {} records", legacyProjectLookup.size());
        populateMgiGeneId2EnsemblGeneId();
        logger.info("Populated Ensembl id to MGI gene id lookup, {} records", mgiGeneId2EnsemblGeneId.size());
        populateGoTermLookup();
        logger.info("Populated go terms lookup, {} records", goTermLookup.size());
        populateMgi2UniprotLookup();
        logger.info("Populated mgi to uniprot lookup, {} records", mgi2UniprotLookup.size());
        logger.info("Populated uniprot to pfamA lookup is skipped for now");
        alleleCore.deleteByQuery("*:*");
        alleleCore.commit();
        while (start <= rows) {
            query.setStart(start);
            QueryResponse response = sangerAlleleCore.query(query);
            rows = response.getResults().getNumFound();
            List<SangerGeneBean> sangerGenes = response.getBeans(SangerGeneBean.class);
            Map<String, AlleleDTO> alleles = convertSangerGeneBeans(sangerGenes);
            lookupMarkerSynonyms(alleles);
            lookupMgiGeneId2EnsemblGeneId(alleles);
            lookupHumanMouseSymbols(alleles);
            lookupEsCellStatus(alleles);
            lookupDiseaseData(alleles);
            lookupGoData(alleles);
            lookupUniprotAcc(alleles);
            documentCount += alleles.size();
            indexAlleles(alleles);
            start += BATCH_SIZE;
            logger.info("Indexed {} records", start);
        }
        alleleCore.commit();
    } catch (SQLException | SolrServerException | IOException | ClassNotFoundException e) {
        throw new IndexerException(e);
    }
    logger.debug("Complete - took {}ms", (new Date().getTime() - startTime));
}

######


private void initializeSolrCores() {
    final String SANGER_ALLELE_URL = config.get("imits.solrserver");
    final String PHENODIGM_URL = config.get("phenodigm.solrserver");
    if (System.getProperty("externalProxyHost") != null && System.getProperty("externalProxyPort") != null) {
        String PROXY_HOST = System.getProperty("externalProxyHost");
        Integer PROXY_PORT = Integer.parseInt(System.getProperty("externalProxyPort"));
        HttpHost proxy = new HttpHost(PROXY_HOST, PROXY_PORT);
        DefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);
        CloseableHttpClient client = HttpClients.custom().setRoutePlanner(routePlanner).build();
        logger.info("Using Proxy Settings: " + PROXY_HOST + " on port: " + PROXY_PORT);
        this.sangerAlleleCore = new HttpSolrServer(SANGER_ALLELE_URL, client);
        this.phenodigmCore = new HttpSolrServer(PHENODIGM_URL, client);
    } else {
        this.sangerAlleleCore = new HttpSolrServer(SANGER_ALLELE_URL);
        this.phenodigmCore = new HttpSolrServer(PHENODIGM_URL);
    }
}

######


public Map<String, List<String>> populateMgiGeneId2EnsemblGeneId() {
    String query = "SELECT acc, xref_acc FROM xref WHERE db_id=3 AND xref_db_id=18";
    try (PreparedStatement p = connection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            String mgiGeneId = resultSet.getString("acc");
            String ensemblGeneId = resultSet.getString("xref_acc");
            if (!mgiGeneId2EnsemblGeneId.containsKey(mgiGeneId)) {
                mgiGeneId2EnsemblGeneId.put(mgiGeneId, new ArrayList<String>());
            }
            mgiGeneId2EnsemblGeneId.get(mgiGeneId).add(ensemblGeneId);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return mgiGeneId2EnsemblGeneId;
}

######


@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + getOuterType().hashCode();
    result = prime * result + ((goTermDomain == null) ? 0 : goTermDomain.hashCode());
    result = prime * result + ((goTermEvid == null) ? 0 : goTermEvid.hashCode());
    result = prime * result + ((goTermId == null) ? 0 : goTermId.hashCode());
    result = prime * result + ((goTermName == null) ? 0 : goTermName.hashCode());
    result = prime * result + ((goUniprot == null) ? 0 : goUniprot.hashCode());
    return result;
}

######


@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    GoAnnotations other = (GoAnnotations) obj;
    if (!getOuterType().equals(other.getOuterType()))
        return false;
    if (goTermDomain == null) {
        if (other.goTermDomain != null)
            return false;
    } else if (!goTermDomain.equals(other.goTermDomain))
        return false;
    if (goTermEvid == null) {
        if (other.goTermEvid != null)
            return false;
    } else if (!goTermEvid.equals(other.goTermEvid))
        return false;
    if (goTermId == null) {
        if (other.goTermId != null)
            return false;
    } else if (!goTermId.equals(other.goTermId))
        return false;
    if (goTermName == null) {
        if (other.goTermName != null)
            return false;
    } else if (!goTermName.equals(other.goTermName))
        return false;
    if (goUniprot == null) {
        if (other.goUniprot != null)
            return false;
    } else if (!goUniprot.equals(other.goUniprot))
        return false;
    return true;
}

######


private AlleleIndexer getOuterType() {
    return AlleleIndexer.this;
}

######


@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    PfamAnnotations that = (PfamAnnotations) o;
    if (scdbId != null ? !scdbId.equals(that.scdbId) : that.scdbId != null) {
        return false;
    }
    if (scdbLink != null ? !scdbLink.equals(that.scdbLink) : that.scdbLink != null) {
        return false;
    }
    if (clanId != null ? !clanId.equals(that.clanId) : that.clanId != null) {
        return false;
    }
    if (clanAcc != null ? !clanAcc.equals(that.clanAcc) : that.clanAcc != null) {
        return false;
    }
    if (clanDesc != null ? !clanDesc.equals(that.clanDesc) : that.clanDesc != null) {
        return false;
    }
    if (pfamAacc != null ? !pfamAacc.equals(that.pfamAacc) : that.pfamAacc != null) {
        return false;
    }
    if (pfamAId != null ? !pfamAId.equals(that.pfamAId) : that.pfamAId != null) {
        return false;
    }
    return true;
}

######


@Override
public int hashCode() {
    int result = scdbId != null ? scdbId.hashCode() : 0;
    result = 31 * result + (scdbLink != null ? scdbLink.hashCode() : 0);
    result = 31 * result + (clanId != null ? clanId.hashCode() : 0);
    result = 31 * result + (clanAcc != null ? clanAcc.hashCode() : 0);
    result = 31 * result + (clanDesc != null ? clanDesc.hashCode() : 0);
    result = 31 * result + (pfamAacc != null ? pfamAacc.hashCode() : 0);
    result = 31 * result + (pfamAId != null ? pfamAId.hashCode() : 0);
    return result;
}

######


public String getScdbId() {
    return scdbId;
}

######


public void setScdbId(String scdbId) {
    this.scdbId = scdbId;
}

######


public String getScdbLink() {
    return scdbLink;
}

######


public void setScdbLink(String scdbLink) {
    this.scdbLink = scdbLink;
}

######


public String getClanId() {
    return clanId;
}

######


public void setClanId(String clanId) {
    this.clanId = clanId;
}

######


public String getClanAcc() {
    return clanAcc;
}

######


public void setClanAcc(String clanAcc) {
    this.clanAcc = clanAcc;
}

######


public String getClanDesc() {
    return clanDesc;
}

######


public void setClanDesc(String clanDesc) {
    this.clanDesc = clanDesc;
}

######


public String getUniprotAcc() {
    return uniprotAcc;
}

######


public void setUniprotAcc(String uniprotAcc) {
    this.uniprotAcc = uniprotAcc;
}

######


public String getUniprotId() {
    return uniprotId;
}

######


public void setUniprotId(String uniprotId) {
    this.uniprotId = uniprotId;
}

######


public String getPfamAacc() {
    return pfamAacc;
}

######


public void setPfamAacc(String pfamAacc) {
    this.pfamAacc = pfamAacc;
}

######


public String getPfamAId() {
    return pfamAId;
}

######


public void setPfamAId(String pfamAId) {
    this.pfamAId = pfamAId;
}

######


public String getPfamAgoId() {
    return pfamAgoId;
}

######


public void setPfamAgoId(String pfamAgoId) {
    this.pfamAgoId = pfamAgoId;
}

######


public String getPfamAgoTerm() {
    return pfamAgoTerm;
}

######


public void setPfamAgoTerm(String pfamAgoTerm) {
    this.pfamAgoTerm = pfamAgoTerm;
}

######


public String getPfamAgoCat() {
    return pfamAgoCat;
}

######


public void setPfamAgoCat(String pfamAgoCat) {
    this.pfamAgoCat = pfamAgoCat;
}

######


public String getPfamAjson() {
    return pfamAjson;
}

######


public void setPfamAjson(String pfamAjson) {
    this.pfamAjson = pfamAjson;
}

######


private void populateGoTermLookup() throws IOException, SQLException, ClassNotFoundException {
    String queryString = "select distinct m.accession, m.gene_name, a.go_id, t.name as go_name, t.category as go_domain, evi.go_evidence " + "from go.annotations a " + "join " + "go.cv_sources s on (s.code = a.source) " + "join " + "go.eco2evidence evi on (evi.eco_id = a.eco_id) " + "join " + "go.terms t on (t.go_id = a.go_id) " + "join " + "go.uniprot_protein_metadata m on (m.accession = a.canonical_id) " + "where " + "s.is_public = 'Y' " + "and m.tax_id = 10090 " + "and m.gene_name is not null " + "and t.category in ('F', 'P') ";
    Connection conn = goaproDataSource.getConnection();
    try (PreparedStatement p = conn.prepareStatement(queryString)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            GoAnnotations ga = new GoAnnotations();
            ga.mgiSymbol = resultSet.getString("gene_name");
            ga.goTermId = resultSet.getString("go_id");
            ga.goUniprot = ga.goTermId + "__" + resultSet.getString("accession");
            ga.goTermName = resultSet.getString("go_name");
            ga.goTermEvid = resultSet.getString("go_evidence");
            ga.goTermDomain = resultSet.getString("go_domain").toString().equals("F") ? "molecular_function" : "biological_process";
            if (!goTermLookup.containsKey(ga.mgiSymbol)) {
                goTermLookup.put(ga.mgiSymbol, new HashSet<GoAnnotations>());
            }
            goTermLookup.get(ga.mgiSymbol).add(ga);
        }
        logger.info("Populated goTerm lookup, {} records", goTermLookup.size());
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("AllowMultiQueriesTest", "id int not null primary key auto_increment, test varchar(10)");
    createTable("AllowMultiQueriesTest2", "id int not null primary key auto_increment, test varchar(10)");
    if (testSingleHost) {
        try (Statement stmt = sharedConnection.createStatement()) {
            stmt.execute("INSERT INTO AllowMultiQueriesTest(test) VALUES ('a'), ('b')");
        }
    }
}

######


@Test
public void allowMultiQueriesSingleTest() throws SQLException {
    try (Connection connection = setConnection("&allowMultiQueries=true")) {
        try (Statement statement = connection.createStatement()) {
            statement.execute("SELECT 1; SELECT 2; SELECT 3;");
            int counter = 1;
            do {
                ResultSet resultSet = statement.getResultSet();
                assertEquals(-1, statement.getUpdateCount());
                assertTrue(resultSet.next());
                assertEquals(counter++, resultSet.getInt(1));
            } while (statement.getMoreResults());
            assertEquals(4, counter);
        }
    }
}

######


@Test
public void checkMultiGeneratedKeys() throws SQLException {
    try (Connection connection = setConnection("&allowMultiQueries=true")) {
        Statement stmt = connection.createStatement();
        stmt.execute("SELECT 1; SET @TOTO=3; SELECT 2", Statement.RETURN_GENERATED_KEYS);
        ResultSet rs = stmt.getResultSet();
        assertTrue(rs.next());
        assertEquals(1, rs.getInt(1));
        assertFalse(stmt.getMoreResults());
        stmt.getGeneratedKeys();
        assertTrue(stmt.getMoreResults());
        rs = stmt.getResultSet();
        assertTrue(rs.next());
        assertEquals(2, rs.getInt(1));
    }
}

######


@Test
public void allowMultiQueriesFetchTest() {
    try (Connection connection = setConnection("&allowMultiQueries=true")) {
        try (Statement statement = connection.createStatement()) {
            statement.setFetchSize(1);
            statement.execute("SELECT * from AllowMultiQueriesTest;SELECT * from AllowMultiQueriesTest;");
            do {
                ResultSet resultSet = statement.getResultSet();
                assertEquals(-1, statement.getUpdateCount());
                assertTrue(resultSet.next());
                assertEquals("a", resultSet.getString(2));
            } while (statement.getMoreResults());
        }
        try (Statement statement = connection.createStatement()) {
            statement.execute("SELECT 1");
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


@Test
public void allowMultiQueriesFetchKeepTest() throws SQLException {
    try (Connection connection = setConnection("&allowMultiQueries=true")) {
        try (Statement statement = connection.createStatement()) {
            statement.setFetchSize(1);
            statement.execute("SELECT * from AllowMultiQueriesTest;SELECT 3;");
            ResultSet rs1 = statement.getResultSet();
            assertTrue(statement.getMoreResults(Statement.KEEP_CURRENT_RESULT));
            assertTrue(rs1.next());
            assertEquals("a", rs1.getString(2));
            ResultSet rs = statement.getResultSet();
            assertTrue(rs.next());
            assertEquals(3, rs.getInt(1));
        }
    }
}

######


@Test
public void allowMultiQueriesFetchCloseTest() throws SQLException {
    try (Connection connection = setConnection("&allowMultiQueries=true")) {
        try (Statement statement = connection.createStatement()) {
            statement.setFetchSize(1);
            statement.execute("SELECT * from AllowMultiQueriesTest;SELECT * from AllowMultiQueriesTest;SELECT 3;");
            ResultSet rs1 = statement.getResultSet();
            assertTrue(statement.getMoreResults(Statement.CLOSE_CURRENT_RESULT));
            try {
                rs1.next();
                fail("Must have thrown exception, since closed");
            } catch (SQLException sqle) {
                assertTrue(sqle.getMessage().contains("Operation not permit on a closed resultSet"));
            }
            rs1 = statement.getResultSet();
            assertTrue(statement.getMoreResults(Statement.KEEP_CURRENT_RESULT));
            assertTrue(rs1.next());
            assertEquals("a", rs1.getString(2));
            ResultSet rs = statement.getResultSet();
            assertTrue(rs.next());
            assertEquals(3, rs.getInt(1));
        }
    }
}

######


@Test
public void allowMultiQueriesFetchInsertSelectTest() throws SQLException {
    try (Connection connection = setConnection("&allowMultiQueries=true")) {
        try (Statement statement = connection.createStatement()) {
            statement.setFetchSize(1);
            statement.execute("INSERT INTO AllowMultiQueriesTest2(test) VALUES ('a'), ('b');SELECT * from AllowMultiQueriesTest;SELECT 3;");
        }
    }
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    String ddl = "create table " + TABELA + " (id integer primary key, " + "nome text unique not null, telefone text, endereco text, " + "site text, nota real, caminhoFoto text);";
    db.execSQL(ddl);
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    String sql = "drop table if exists Aluno";
    db.execSQL(sql);
    onCreate(db);
}

######


public void insere(Aluno aluno) {
    ContentValues values = new ContentValues();
    values.put("nome", aluno.getNome());
    values.put("telefone", aluno.getTelefone());
    values.put("endereco", aluno.getEndereco());
    values.put("site", aluno.getSite());
    values.put("nota", aluno.getNota());
    values.put("caminhoFoto", aluno.getCaminhoFoto());
    getWritableDatabase().insert(TABELA, null, values);
}

######


public List<Aluno> getLista() {
    List<Aluno> alunos = new ArrayList<Aluno>();
    Cursor c = getReadableDatabase().rawQuery("select * from " + TABELA + ";", null);
    while (c.moveToNext()) {
        Aluno aluno = new Aluno();
        aluno.setId(c.getLong(c.getColumnIndex("id")));
        aluno.setNome(c.getString(c.getColumnIndex("nome")));
        aluno.setEndereco(c.getString(c.getColumnIndex("endereco")));
        aluno.setTelefone(c.getString(c.getColumnIndex("telefone")));
        aluno.setSite(c.getString(c.getColumnIndex("site")));
        aluno.setNota(c.getDouble(c.getColumnIndex("nota")));
        aluno.setCaminhoFoto(c.getString(c.getColumnIndex("caminhoFoto")));
        alunos.add(aluno);
    }
    c.close();
    return alunos;
}

######


public void deletar(Aluno aluno) {
    String[] args = { aluno.getId().toString() };
    getWritableDatabase().delete(TABELA, "id=?", args);
}

######


public void alterar(Aluno aluno) {
    ContentValues values = new ContentValues();
    values.put("nome", aluno.getNome());
    values.put("telefone", aluno.getTelefone());
    values.put("endereco", aluno.getEndereco());
    values.put("site", aluno.getSite());
    values.put("nota", aluno.getNota());
    values.put("caminhoFoto", aluno.getCaminhoFoto());
    String[] args = { aluno.getId().toString() };
    getWritableDatabase().update(TABELA, values, "id=?", args);
}

######


public boolean isAluno(String telefone) {
    String[] param = { telefone };
    Cursor rawQuery = getReadableDatabase().rawQuery("select telefone from " + TABELA + " where telefone= ? ", param);
    int total = rawQuery.getCount();
    rawQuery.close();
    return total > 0;
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public Map<String, String> getMetaData() {
    PreparedStatement statement = null;
    ResultSet resultSet = null;
    Map<String, String> metaInfo = new HashMap<String, String>();
    try (Connection connection = getConnection()) {
        statement = connection.prepareStatement("SELECT * from meta_info");
        resultSet = statement.executeQuery();
        while (resultSet.next()) {
            String pKey = resultSet.getString(2);
            String pValue = resultSet.getString(3);
            metaInfo.put(pKey, pValue);
        }
        statement.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return metaInfo;
}

######


@Override
public List<AggregateCountXYBean> getAllProcedureLines() {
    PreparedStatement statement = null;
    ResultSet resultSet = null;
    List<AggregateCountXYBean> results = new ArrayList<AggregateCountXYBean>();
    try (Connection connection = getConnection()) {
        statement = connection.prepareStatement("SELECT * FROM analytics_lines_procedures");
        resultSet = statement.executeQuery();
        while (resultSet.next()) {
            results.add(new AggregateCountXYBean(resultSet.getInt(1), resultSet.getString(4), "procedure", resultSet.getString(3), resultSet.getString(2), "nb of lines", null));
        }
        statement.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return results;
}

######


@Override
public List<AggregateCountXYBean> getAllProcedurePhenotypeCalls() {
    PreparedStatement statement = null;
    ResultSet resultSet = null;
    List<AggregateCountXYBean> results = new ArrayList<AggregateCountXYBean>();
    try (Connection connection = getConnection()) {
        statement = connection.prepareStatement("SELECT * FROM analytics_significant_calls_procedures");
        resultSet = statement.executeQuery();
        while (resultSet.next()) {
            results.add(new AggregateCountXYBean(resultSet.getInt(1), resultSet.getString(4), "procedure", resultSet.getString(3), resultSet.getString(2), "nb of calls", null));
        }
        statement.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return results;
}

######


@Override
public Map<String, List<String>> getAllStatisticalMethods() {
    PreparedStatement statement = null;
    ResultSet resultSet = null;
    Map<String, List<String>> results = new HashMap<String, List<String>>();
    try (Connection connection = getConnection()) {
        statement = connection.prepareStatement("SELECT DISTINCT datatype, statistical_method FROM analytics_pvalue_distribution;");
        resultSet = statement.executeQuery();
        while (resultSet.next()) {
            String datatype = resultSet.getString(1);
            String method = resultSet.getString(2);
            List<String> methods = null;
            if (!results.containsKey(datatype)) {
                methods = new ArrayList<String>();
                results.put(datatype, methods);
            } else {
                methods = results.get(datatype);
            }
            methods.add(method);
        }
        statement.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return results;
}

######


@Override
public List<AggregateCountXYBean> getPValueDistribution(String dataType, String statisticalMethod) {
    PreparedStatement statement = null;
    ResultSet resultSet = null;
    List<AggregateCountXYBean> results = new ArrayList<AggregateCountXYBean>();
    try (Connection connection = getConnection()) {
        statement = connection.prepareStatement("select pvalue_count, pvalue_bin from analytics_pvalue_distribution where datatype = ? and statistical_method = ? order by pvalue_bin asc;");
        statement.setString(1, dataType);
        statement.setString(2, statisticalMethod);
        resultSet = statement.executeQuery();
        while (resultSet.next()) {
            results.add(new AggregateCountXYBean(resultSet.getInt(1), resultSet.getString(2), "p-value", null, statisticalMethod, statisticalMethod, null));
        }
        statement.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return results;
}

######


@Override
public List<AggregateCountXYBean> getHistoricalData(String propertyKey) {
    PreparedStatement statement = null;
    ResultSet resultSet = null;
    List<AggregateCountXYBean> results = new ArrayList<AggregateCountXYBean>();
    try (Connection connection = getConnection()) {
        statement = connection.prepareStatement("SELECT property_value, property_key, data_release_version FROM meta_history WHERE property_key = ? ORDER BY data_release_version ASC");
        statement.setString(1, propertyKey);
        resultSet = statement.executeQuery();
        while (resultSet.next()) {
            results.add(new AggregateCountXYBean(resultSet.getInt(1), resultSet.getString(2), resultSet.getString(2), null, resultSet.getString(3), resultSet.getString(3), null));
        }
        statement.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return results;
}

######


@Override
public List<String> getReleases(String excludeRelease) {
    PreparedStatement statement = null;
    ResultSet resultSet = null;
    List<String> results = new ArrayList<String>();
    try (Connection connection = getConnection()) {
        if (excludeRelease != null) {
            statement = connection.prepareStatement("SELECT DISTINCT data_release_version FROM meta_history WHERE data_release_version <> ? ORDER BY data_release_version ASC");
            statement.setString(1, excludeRelease);
        } else {
            statement = connection.prepareStatement("SELECT DISTINCT data_release_version FROM meta_history ORDER BY data_release_version ASC");
        }
        resultSet = statement.executeQuery();
        while (resultSet.next()) {
            results.add(resultSet.getString(1));
        }
        statement.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return results;
}

######


public String getCurrentRelease() {
    String query = "SELECT property_value as release_version FROM meta_info WHERE property_key='data_release_version'";
    String releaseVersion = "";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        ResultSet rs = statement.executeQuery();
        if (rs.next()) {
            releaseVersion = rs.getString("release_version");
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return releaseVersion;
}

######


public boolean isAutoCommitSupported() {
    return true;
}

######


public boolean isAutoCommit() throws SQLException {
    try {
        boolean inTransaction = db.inTransaction();
        logger.trace("{}: in transaction is {}", this, inTransaction);
        return !inTransaction;
    } catch (android.database.SQLException e) {
        throw SqlExceptionUtil.create("problems getting auto-commit from database", e);
    }
}

######


public void setAutoCommit(boolean autoCommit) {
    if (autoCommit) {
        if (db.inTransaction()) {
            db.setTransactionSuccessful();
            db.endTransaction();
        }
    } else {
        if (!db.inTransaction()) {
            db.beginTransaction();
        }
    }
}

######


public Savepoint setSavePoint(String name) throws SQLException {
    try {
        db.beginTransaction();
        logger.trace("{}: save-point set with name {}", this, name);
        return new OurSavePoint(name);
    } catch (android.database.SQLException e) {
        throw SqlExceptionUtil.create("problems beginning transaction " + name, e);
    }
}

######


public boolean isReadWrite() {
    return readWrite;
}

######


public void commit(Savepoint savepoint) throws SQLException {
    try {
        db.setTransactionSuccessful();
        db.endTransaction();
        if (savepoint == null) {
            logger.trace("{}: transaction is successfuly ended", this);
        } else {
            logger.trace("{}: transaction {} is successfuly ended", this, savepoint.getSavepointName());
        }
    } catch (android.database.SQLException e) {
        if (savepoint == null) {
            throw SqlExceptionUtil.create("problems commiting transaction", e);
        } else {
            throw SqlExceptionUtil.create("problems commiting transaction " + savepoint.getSavepointName(), e);
        }
    }
}

######


public void rollback(Savepoint savepoint) throws SQLException {
    try {
        db.endTransaction();
        if (savepoint == null) {
            logger.trace("{}: transaction is ended, unsuccessfuly", this);
        } else {
            logger.trace("{}: transaction {} is ended, unsuccessfuly", this, savepoint.getSavepointName());
        }
    } catch (android.database.SQLException e) {
        if (savepoint == null) {
            throw SqlExceptionUtil.create("problems rolling back transaction", e);
        } else {
            throw SqlExceptionUtil.create("problems rolling back transaction " + savepoint.getSavepointName(), e);
        }
    }
}

######


public int executeStatement(String statementStr, int resultFlags) throws SQLException {
    return AndroidCompiledStatement.execSql(db, statementStr, statementStr, NO_STRING_ARGS);
}

######


public CompiledStatement compileStatement(String statement, StatementType type, FieldType[] argFieldTypes, int resultFlags) {
    CompiledStatement stmt = new AndroidCompiledStatement(statement, db, type, cancelQueriesEnabled);
    logger.trace("{}: compiled statement got {}: {}", this, stmt, statement);
    return stmt;
}

######


public int insert(String statement, Object[] args, FieldType[] argFieldTypes, GeneratedKeyHolder keyHolder) throws SQLException {
    SQLiteStatement stmt = null;
    try {
        stmt = db.compileStatement(statement);
        bindArgs(stmt, args, argFieldTypes);
        long rowId = stmt.executeInsert();
        if (keyHolder != null) {
            keyHolder.addKey(rowId);
        }
        int result = 1;
        logger.trace("{}: insert statement is compiled and executed, changed {}: {}", this, result, statement);
        return result;
    } catch (android.database.SQLException e) {
        throw SqlExceptionUtil.create("inserting to database failed: " + statement, e);
    } finally {
        if (stmt != null) {
            stmt.close();
        }
    }
}

######


public int update(String statement, Object[] args, FieldType[] argFieldTypes) throws SQLException {
    return update(statement, args, argFieldTypes, "updated");
}

######


public int delete(String statement, Object[] args, FieldType[] argFieldTypes) throws SQLException {
    return update(statement, args, argFieldTypes, "deleted");
}

######


public <T> Object queryForOne(String statement, Object[] args, FieldType[] argFieldTypes, GenericRowMapper<T> rowMapper, ObjectCache objectCache) throws SQLException {
    Cursor cursor = null;
    try {
        cursor = db.rawQuery(statement, toStrings(args));
        AndroidDatabaseResults results = new AndroidDatabaseResults(cursor, objectCache);
        logger.trace("{}: queried for one result: {}", this, statement);
        if (!results.first()) {
            return null;
        } else {
            T first = rowMapper.mapRow(results);
            if (results.next()) {
                return MORE_THAN_ONE;
            } else {
                return first;
            }
        }
    } catch (android.database.SQLException e) {
        throw SqlExceptionUtil.create("queryForOne from database failed: " + statement, e);
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
}

######


public long queryForLong(String statement) throws SQLException {
    SQLiteStatement stmt = null;
    try {
        stmt = db.compileStatement(statement);
        long result = stmt.simpleQueryForLong();
        logger.trace("{}: query for long simple query returned {}: {}", this, result, statement);
        return result;
    } catch (android.database.SQLException e) {
        throw SqlExceptionUtil.create("queryForLong from database failed: " + statement, e);
    } finally {
        if (stmt != null) {
            stmt.close();
        }
    }
}

######


public long queryForLong(String statement, Object[] args, FieldType[] argFieldTypes) throws SQLException {
    Cursor cursor = null;
    try {
        cursor = db.rawQuery(statement, toStrings(args));
        AndroidDatabaseResults results = new AndroidDatabaseResults(cursor, null);
        long result;
        if (results.first()) {
            result = results.getLong(0);
        } else {
            result = 0L;
        }
        logger.trace("{}: query for long raw query returned {}: {}", this, result, statement);
        return result;
    } catch (android.database.SQLException e) {
        throw SqlExceptionUtil.create("queryForLong from database failed: " + statement, e);
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
}

######


public void close() throws SQLException {
    try {
        db.close();
        logger.trace("{}: db {} closed", this, db);
    } catch (android.database.SQLException e) {
        throw SqlExceptionUtil.create("problems closing the database connection", e);
    }
}

######


public void closeQuietly() {
    try {
        close();
    } catch (SQLException e) {
    }
}

######


public boolean isClosed() throws SQLException {
    try {
        boolean isOpen = db.isOpen();
        logger.trace("{}: db {} isOpen returned {}", this, db, isOpen);
        return !isOpen;
    } catch (android.database.SQLException e) {
        throw SqlExceptionUtil.create("problems detecting if the database is closed", e);
    }
}

######


public boolean isTableExists(String tableName) {
    Cursor cursor = db.rawQuery("SELECT DISTINCT tbl_name FROM sqlite_master WHERE tbl_name = '" + tableName + "'", null);
    try {
        boolean result;
        if (cursor.getCount() > 0) {
            result = true;
        } else {
            result = false;
        }
        logger.trace("{}: isTableExists '{}' returned {}", this, tableName, result);
        return result;
    } finally {
        cursor.close();
    }
}

######


private int update(String statement, Object[] args, FieldType[] argFieldTypes, String label) throws SQLException {
    SQLiteStatement stmt = null;
    try {
        stmt = db.compileStatement(statement);
        bindArgs(stmt, args, argFieldTypes);
        stmt.execute();
    } catch (android.database.SQLException e) {
        throw SqlExceptionUtil.create("updating database failed: " + statement, e);
    } finally {
        if (stmt != null) {
            stmt.close();
            stmt = null;
        }
    }
    int result;
    try {
        stmt = db.compileStatement("SELECT CHANGES()");
        result = (int) stmt.simpleQueryForLong();
    } catch (android.database.SQLException e) {
        result = 1;
    } finally {
        if (stmt != null) {
            stmt.close();
        }
    }
    logger.trace("{} statement is compiled and executed, changed {}: {}", label, result, statement);
    return result;
}

######


private void bindArgs(SQLiteStatement stmt, Object[] args, FieldType[] argFieldTypes) throws SQLException {
    if (args == null) {
        return;
    }
    for (int i = 0; i < args.length; i++) {
        Object arg = args[i];
        if (arg == null) {
            stmt.bindNull(i + 1);
        } else {
            SqlType sqlType = argFieldTypes[i].getSqlType();
            switch(sqlType) {
                case STRING:
                case LONG_STRING:
                case CHAR:
                    stmt.bindString(i + 1, arg.toString());
                    break;
                case BOOLEAN:
                case BYTE:
                case SHORT:
                case INTEGER:
                case LONG:
                    stmt.bindLong(i + 1, ((Number) arg).longValue());
                    break;
                case FLOAT:
                case DOUBLE:
                    stmt.bindDouble(i + 1, ((Number) arg).doubleValue());
                    break;
                case BYTE_ARRAY:
                case SERIALIZABLE:
                    stmt.bindBlob(i + 1, (byte[]) arg);
                    break;
                case DATE:
                case BLOB:
                case BIG_DECIMAL:
                    throw new SQLException("Invalid Android type: " + sqlType);
                case UNKNOWN:
                default:
                    throw new SQLException("Unknown sql argument type: " + sqlType);
            }
        }
    }
}

######


private String[] toStrings(Object[] args) {
    if (args == null || args.length == 0) {
        return null;
    }
    String[] strings = new String[args.length];
    for (int i = 0; i < args.length; i++) {
        Object arg = args[i];
        if (arg == null) {
            strings[i] = null;
        } else {
            strings[i] = arg.toString();
        }
    }
    return strings;
}

######


@Override
public String toString() {
    return getClass().getSimpleName() + "@" + Integer.toHexString(super.hashCode());
}

######


public int getSavepointId() {
    return 0;
}

######


public String getSavepointName() {
    return name;
}

######


@Insert("insert into table2 (name) values(#{name})")
@SelectKey(statement = "call identity()", keyProperty = "nameId", before = false, resultType = int.class)
int insertTable2(Name name);

######


@Insert("insert into table2 (name) values(#{name})")
@Options(useGeneratedKeys = true, keyProperty = "nameId,generatedName", keyColumn = "ID,NAME_FRED")
int insertTable2WithGeneratedKey(Name name);

######


int insertTable2WithGeneratedKeyXml(Name name);

######


@Insert("insert into table2 (name) values(#{name})")
@SelectKey(statement = "select id, name_fred from table2 where id = identity()", keyProperty = "nameId,generatedName", keyColumn = "ID,NAME_FRED", before = false, resultType = Map.class)
int insertTable2WithSelectKeyWithKeyMap(Name name);

######


int insertTable2WithSelectKeyWithKeyMapXml(Name name);

######


@Insert("insert into table2 (name) values(#{name})")
@SelectKey(statement = "select id as nameId, name_fred as generatedName from table2 where id = identity()", keyProperty = "nameId,generatedName", before = false, resultType = Name.class)
int insertTable2WithSelectKeyWithKeyObject(Name name);

######


int insertTable2WithSelectKeyWithKeyObjectXml(Name name);

######


@Insert("insert into table3 (id, name) values(#{nameId}, #{name})")
@SelectKey(statement = "call next value for TestSequence", keyProperty = "nameId", before = true, resultType = int.class)
int insertTable3(Name name);

######


@InsertProvider(type = SqlProvider.class, method = "insertTable3_2")
@SelectKey(statement = "call next value for TestSequence", keyProperty = "nameId", before = true, resultType = int.class)
int insertTable3_2(Name name);

######


@Update("update table2 set name = #{name} where id = #{nameId}")
@Options(useGeneratedKeys = true, keyProperty = "generatedName")
int updateTable2WithGeneratedKey(Name name);

######


int updateTable2WithGeneratedKeyXml(Name name);

######


@Update("update table2 set name = #{name} where id = #{nameId}")
@SelectKey(statement = "select name_fred from table2 where id = #{nameId}", keyProperty = "generatedName", keyColumn = "NAME_FRED", before = false, resultType = String.class)
int updateTable2WithSelectKeyWithKeyMap(Name name);

######


int updateTable2WithSelectKeyWithKeyMapXml(Name name);

######


@Update("update table2 set name = #{name} where id = #{nameId}")
@SelectKey(statement = "select name_fred as generatedName from table2 where id = #{nameId}", keyProperty = "generatedName", before = false, resultType = Name.class)
int updateTable2WithSelectKeyWithKeyObject(Name name);

######


int updateTable2WithSelectKeyWithKeyObjectXml(Name name);

######


@Select("select * from ${table} where id = #{id}")
User getUser(Integer id);

######


public List<Application> findByEmp(Employee emp) {
    return find("select a from Application as a where " + "a.attend.employee=?0", emp);
}

######


@Override
public List<Application> search(Object object) throws ExceededMaxResultsException {
    Criteria criteria = this.getSessionFactory().getCurrentSession().createCriteria(Application.class);
    Application application = (Application) object;
    criteria.setResultTransformer(CriteriaSpecification.DISTINCT_ROOT_ENTITY).createAlias("participantID", "participant").createAlias("participant.client", "client").createAlias("benefitPeriodID", "benefitPeriod");
    criteria.add(Restrictions.eq("client.active", Client.ACTIVE));
    boolean isCriteriaEmpty = true;
    if (application.getApplicationNumber() != null) {
        criteria.add(Restrictions.eq("applicationNumber", application.getApplicationNumber()));
        if (application.getParticipantID() != null && application.getParticipantID().getClient() != null && application.getParticipantID().getClient().getClientId() != null && application.getParticipantID().getClient().getClientId() != 0) {
            criteria.add(Restrictions.eq("participant.client.clientId", application.getParticipantID().getClient().getClientId()));
        }
        isCriteriaEmpty = false;
    } else {
        if (application.getParticipantID() != null) {
            if (application.getParticipantID().getUser() != null) {
                criteria.createAlias("participant.user", "user");
                if (application.getParticipantID().getUser().getFirstName() != null && !(application.getParticipantID().getUser().getFirstName().isEmpty())) {
                    criteria.add(Restrictions.like("user.firstName", application.getParticipantID().getUser().getFirstName()));
                    isCriteriaEmpty = false;
                }
                if (application.getParticipantID().getUser().getLastName() != null && !(application.getParticipantID().getUser().getLastName().isEmpty())) {
                    criteria.add(Restrictions.like("user.lastName", application.getParticipantID().getUser().getLastName()));
                    isCriteriaEmpty = false;
                }
            }
            if (application.getParticipantID().getSsn() != null && !application.getParticipantID().getSsn().trim().isEmpty()) {
                criteria.add(Restrictions.like("participant.ssn", application.getParticipantID().getSsn()));
                isCriteriaEmpty = false;
            }
            if (application.getParticipantID().getEmployeeId() != null && !application.getParticipantID().getEmployeeId().isEmpty()) {
                criteria.add(Restrictions.like("participant.employeeId", application.getParticipantID().getEmployeeId()));
                isCriteriaEmpty = false;
            }
            if (application.getParticipantID().getClient() != null && application.getParticipantID().getClient().getClientId() != 0) {
                criteria.add(Restrictions.eq("participant.client.clientId", application.getParticipantID().getClient().getClientId()));
                isCriteriaEmpty = false;
            }
        }
        if (application.isAppealsOnly()) {
            criteria.createAlias("appealCollection", "appeal");
            isCriteriaEmpty = false;
        }
        if (application.isNonCompliantApplications()) {
            Object[] objects = { ApplicationConstants.APPLICATION_STATUS_REPAYMENT_REQUIRED, ApplicationConstants.APPLICATION_STATUS_SENT_COLLECTIONS };
            criteria.add(Restrictions.in("applicationStatusID.applicationStatusID", objects));
            isCriteriaEmpty = false;
        } else if (application.getApplicationStatusID() != null && application.getApplicationStatusID().getApplicationStatusID() != 0) {
            criteria.add(Restrictions.eq("applicationStatusID.applicationStatusID", application.getApplicationStatusID().getApplicationStatusID()));
            isCriteriaEmpty = false;
        }
        if (application.getEducationalProvider() != null && StringUtils.isNotBlank(application.getEducationalProvider().getProviderName())) {
            criteria.createAlias("educationalProvider", "educationalProvider");
            criteria.add(Restrictions.like("educationalProvider.providerName", application.getEducationalProvider().getProviderName()));
            isCriteriaEmpty = false;
        }
        if (application.getBenefitPeriodID() != null && application.getBenefitPeriodID().getBenefitPeriodID() != 0) {
            criteria.add(Restrictions.eq("benefitPeriodID.benefitPeriodID", application.getBenefitPeriodID().getBenefitPeriodID()));
            isCriteriaEmpty = false;
        }
        if (application.getBenefitPeriodID() != null && application.getBenefitPeriodID().getProgramID() != null && application.getBenefitPeriodID().getProgramID().getProgramID() != 0) {
            criteria.add(Restrictions.eq("benefitPeriod.programID.programID", application.getBenefitPeriodID().getProgramID().getProgramID()));
        }
    }
    if (isCriteriaEmpty) {
        return new ArrayList<Application>();
    } else {
        Session session = this.getSessionFactory().getCurrentSession();
        int count = ((Number) criteria.setProjection(Projections.rowCount()).uniqueResult()).intValue();
        checkMaxResultsExceeded(count);
        if (count > 0) {
            criteria.setProjection(null);
            return criteria.list();
        }
        return new ArrayList<Application>();
    }
}

######


@Override
public List<Application> findRelatedBookApplications(Long applicationId, Long[] excludedStatuses) throws ExceededMaxResultsException {
    if (applicationId == null) {
        return null;
    }
    Criteria criteria = this.getSessionFactory().getCurrentSession().createCriteria(Application.class);
    criteria.add(Restrictions.eq("relatedAppId", applicationId));
    List<Application> results = criteria.list();
    return results;
}

######


@Override
public PaginationResult<ThinApp> findSelfAndSuperviseeApplciations(Long supervisorParticipantId, int index, int recordsPerPage, String teamMemberType, String sortingProperty, String benefitPeriods) {
    String mainQueryString = buildApplicationHistoryQuery(teamMemberType);
    List<String> benefitPeriodNames = new ArrayList<>(Arrays.asList(CommonUtil.convertStringToArrayString(benefitPeriods)));
    if (!benefitPeriods.contains("-1")) {
        mainQueryString += "AND app.benefitPeriodID.benefitPeriodName in (:benefitPeriodNames) ";
    }
    Query countQuery = setQueryParameters("select count(*) " + mainQueryString, supervisorParticipantId, benefitPeriodNames);
    mainQueryString += "order by app." + sortingProperty;
    Query query = setQueryParameters(mainQueryString, supervisorParticipantId, benefitPeriodNames);
    Long totalRecordsCount = (Long) countQuery.getSingleResult();
    List<ThinApp> thinAppActivityForMyTeamList = query.setFirstResult((index - 1) * recordsPerPage).setMaxResults(recordsPerPage).getResultList();
    return new PaginationResult<>(thinAppActivityForMyTeamList, totalRecordsCount);
}

######


@Override
public List<String> getBenefitPeriodFilterOptions(Long participantId, String teamMemberType, Long defaultBenefitPeriodId) {
    String queryString = buildApplicationHistoryQuery(teamMemberType);
    Query query = setQueryParameters("SELECT DISTINCT app.benefitPeriodID.benefitPeriodName " + queryString, participantId, null);
    List<String> benefitPeriodNames = query.getResultList();
    if (defaultBenefitPeriodId != null && (benefitPeriodNames == null || benefitPeriodNames.isEmpty())) {
        queryString = "SELECT bp.benefitPeriodName ";
        queryString += " FROM " + BenefitPeriod.class.getName() + " bp";
        queryString += " WHERE bp.benefitPeriodID = :defaultBenefitPeriodId";
        query = this.getSession().createQuery(queryString);
        query.setParameter("defaultBenefitPeriodId", defaultBenefitPeriodId);
        benefitPeriodNames = query.getResultList();
    }
    return benefitPeriodNames;
}

######


@Override
public App findAppById(Long applicationId) {
    return this.getSession().get(App.class, applicationId);
}

######


@Override
public ThinApp findThinAppById(Long applicationId) {
    return this.getSession().get(ThinApp.class, applicationId);
}

######


private String buildApplicationHistoryQuery(String teamMemberType) {
    String mainQueryString = "";
    mainQueryString += "FROM ThinApp app where app.applicationTypeID.applicationTypeID != :applicationTypeId ";
    mainQueryString += "AND app.applicationStatusID != :voidStatusAppId ";
    if (teamMemberType.equals(AppTeamFilterConstants.TEAM_MEMBER_ME.getValue())) {
        mainQueryString += "AND (app.participantID = :supervisorParticipantId) ";
    } else if (teamMemberType.equals(AppTeamFilterConstants.TEAM_MEMBER_TEAM.getValue())) {
        mainQueryString += "AND app.applicationStatusID in (:appStatusIds) AND (app.participantID in (select sup.participantID FROM ParticipantSupervisor sup WHERE sup.supervisor = :supervisorParticipantId)) ";
    } else if (teamMemberType.equals(AppTeamFilterConstants.TEAM_MEMBER_COMPANY.getValue())) {
        mainQueryString += "AND app.applicationStatusID in (:appStatusIds) AND (app.participantID.client = (select part.client FROM Participant part WHERE part.participantId = :supervisorParticipantId)) ";
    } else {
        mainQueryString += "AND app.applicationStatusID in (:appStatusIds) AND app.participantID.participantId = " + Long.valueOf(teamMemberType) + " ";
    }
    return mainQueryString;
}

######


private Query setQueryParameters(String queryString, Long participantId, List<String> benefitPeriodNames) {
    List<Long> arrAppStatusIds = new ArrayList<>(Arrays.asList(110L, 120L, 125L, 135L, 400L, 450L, 500L, 510L, 530L, 545L, 540L, 900L, 930L));
    Session session = this.getSessionFactory().getCurrentSession();
    Query<ThinApp> query = session.createQuery(queryString);
    query.setParameter("applicationTypeId", 500L);
    query.setParameter("voidStatusAppId", 920L);
    if (query.getParameters().stream().anyMatch((p -> p.getName().equals("appStatusIds")))) {
        query.setParameter("appStatusIds", arrAppStatusIds);
    }
    if (query.getParameters().stream().anyMatch((p -> p.getName().equals("supervisorParticipantId")))) {
        query.setParameter("supervisorParticipantId", participantId);
    }
    if (query.getParameters().stream().anyMatch((p -> p.getName().equals("benefitPeriodNames")))) {
        query.setParameter("benefitPeriodNames", benefitPeriodNames);
    }
    return query;
}

######


@Override
public PaginationResult<ThinAppActivityForMyTeam> findActionRequiredApplicationsBySupervisorId(final Participant supervisorParticipant, int index, int recordsPerPage) throws Exception {
    Criteria criteria = this.getSessionFactory().getCurrentSession().createCriteria(ThinAppActivityForMyTeam.class).add(Restrictions.eq("supervisor", supervisorParticipant)).add(Restrictions.eq("approvalTypeID.approvalTypeID", 1)).createCriteria("applicationID", "app").createCriteria("applicationStatusID").add(Restrictions.eq("applicationStatusID", 125L));
    long totalRecordsCount = 0L;
    if (recordsPerPage != -1) {
        criteria.setProjection(Projections.rowCount());
        totalRecordsCount = (Long) criteria.uniqueResult();
        criteria.setProjection(null);
        criteria.setResultTransformer(CriteriaSpecification.DISTINCT_ROOT_ENTITY).addOrder(Order.desc("app.dateModified"));
        criteria.setFirstResult((index - 1) * recordsPerPage);
        criteria.setMaxResults(recordsPerPage);
    }
    List<ThinAppActivityForMyTeam> results = criteria.list();
    return new PaginationResult<ThinAppActivityForMyTeam>(results, totalRecordsCount);
}

######


@Override
public PaginationResult<ThinApp> getActionNeededTaskList(Participant participant, int index, int recordsPerPage) {
    String mainQueryString = "";
    mainQueryString += "FROM ThinApp app where app.applicationID in (";
    mainQueryString += "select app2.applicationID from ThinApp app2 where app2.participantID = :participant and app2.applicationStatusID in (:appStatusIds) ) ";
    mainQueryString += "OR app.applicationID in (";
    mainQueryString += "select app3.applicationID from ThinApp app3, ApplicationComment ac ";
    mainQueryString += "where ac.applicationID = app3.applicationID and ac.reviewed = 0 and app3.participantID = :participant and ac.createdBy != :user and ac.viewableToParticipant = 1 )";
    if (participant.getUser().getUserType().getId() == UserTypeConstants.SUPERVISOR) {
        mainQueryString += "OR app.applicationID in (";
        mainQueryString += "select app4.applicationID from ThinApp app4, ApprovalHistory ah ";
        mainQueryString += "where ah.applicationID = app4.applicationID and ah.supervisor = :participant and ah.approvalTypeID = 1 and app4.applicationStatusID = 125 )";
    }
    Query<ThinApp> query = setActionNeededParameters(mainQueryString, participant);
    Query<Long> countQuery = setActionNeededParameters("select COUNT(*) " + mainQueryString, participant);
    Long totalRecordsCount = countQuery.getSingleResult();
    List<ThinApp> thinAppList = query.setFirstResult((index - 1) * recordsPerPage).setMaxResults(recordsPerPage).getResultList();
    return new PaginationResult<>(thinAppList, totalRecordsCount);
}

######


private Query setActionNeededParameters(String queryString, Participant participant) {
    List<Long> arrAppStatusIds = new ArrayList<>(Arrays.asList(90L, 110L, 120L, 125L, 400L, 450L, 530L, 540L, 545L));
    Session session = this.getSession();
    Query<ThinApp> query = session.createQuery(queryString);
    query.setParameter("appStatusIds", arrAppStatusIds);
    query.setParameter("participant", participant);
    query.setParameter("user", participant.getUser());
    return query;
}

######


@Override
public Long getNumberOfUnreadComments(Application application) {
    Session session = null;
    Long totalUnreadMessages = 0L;
    session = this.getSessionFactory().getCurrentSession();
    Criteria criteria = session.createCriteria(ApplicationComment.class, "applicationComment");
    criteria.add(Restrictions.eq("applicationComment.applicationID", application.getApplicationID()));
    criteria.add(Restrictions.eq("applicationComment.reviewed", false));
    criteria.add(Restrictions.ne("applicationComment.createdBy.userId", application.getParticipantID().getUser().getUserId()));
    criteria.add(Restrictions.eq("applicationComment.viewableToParticipant", true));
    criteria.setProjection(Projections.rowCount());
    totalUnreadMessages = (Long) criteria.uniqueResult();
    return totalUnreadMessages;
}

######


@Override
public ApplicationCourseCompliancy callGetApplicationCourseCompliancyProc(final long applicationCoursesID) {
    Session session = this.getSessionFactory().getCurrentSession();
    Query q = session.getNamedQuery("callGetApplicationCourseCompliancy");
    q.setLong("applicationCoursesId", applicationCoursesID);
    return (ApplicationCourseCompliancy) q.list().get(0);
}

######


@Override
public List<ApplicationNumber> callGetNextApplicationNumberProc() throws Exception {
    Connection connection = this.getConnection();
    CallableStatement callableStatement = connection.prepareCall("{call getNextApplicationNumber(?)}");
    callableStatement.registerOutParameter(1, java.sql.Types.INTEGER);
    callableStatement.execute();
    int newAppNbr = callableStatement.getInt(1);
    ApplicationNumber appNbr = new ApplicationNumber();
    appNbr.setApplicationNumber(new Long(newAppNbr));
    ArrayList<ApplicationNumber> rtnList = new ArrayList<ApplicationNumber>();
    rtnList.add(appNbr);
    return rtnList;
}

######


@Override
public List<PercentagePayOut> callFindPercentagePayoutForAppCourse(final Long applicationCoursesID) {
    Session session = this.getSessionFactory().getCurrentSession();
    Query q = session.getNamedQuery("findPercentagePayoutForAppCourse");
    q.setLong("applicationCoursesID", applicationCoursesID);
    List<PercentagePayOut> result = q.list();
    return result;
}

######


@Override
public Boolean deleteAppNumber(Application application, String requester) {
    Session session = this.getSessionFactory().getCurrentSession();
    Query q = session.getNamedQuery("deleteAppNumber");
    q.setLong("clientID", application.getBenefitPeriodID().getProgramID().getClientID().getClientId());
    q.setLong("appnumber", application.getApplicationNumber());
    q.setString("Requestor", requester);
    int update = q.executeUpdate();
    return Boolean.TRUE;
}

######


public List<AppointmentModel> getAllAppointmentsByInspectionPlace(InspectionPlaceModel inspectionPlaceModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM AppointmentModel e WHERE " + "e.inspectionPlace = :inspectionPlace AND " + "e.appointmentDate > :date ORDER BY e.appointmentDate");
    query.setParameter("inspectionPlace", inspectionPlaceModel);
    query.setParameter("date", new Date());
    return query.getResultList();
}

######


public List<AppointmentModel> getAllCompletableAppointments() {
    Calendar date = Calendar.getInstance();
    long t = date.getTimeInMillis();
    Query query = getEntitymanager().createQuery("SELECT e FROM AppointmentModel e WHERE e.appointmentDate < :date");
    query.setParameter("date", new Date(t - (ProjectConstants.APPOINTMENT_COMPLETION_TIME * ProjectConstants.ONE_MINUTE_IN_MILLIS)));
    return query.getResultList();
}

######


public List<AppointmentModel> getAllSuspendedAppointments() {
    Query query = getEntitymanager().createQuery("SELECT e FROM AppointmentModel e WHERE e.appointmentStatus = :APPOINTMENT_STATUS AND e.expirationTimeForSuspend < :date");
    query.setParameter("APPOINTMENT_STATUS", AppointmentStatusEnum.SUSPENDED);
    query.setParameter("date", new Date());
    return query.getResultList();
}

######


@Override
public void addAppointment(Appointment appointment) {
    try {
        dao.save(appointment);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


@Override
public int CountAppByDIdAndDate(int doctorId, Date date) {
    String hql = "select count(*) from Appointment where doctorId=? and seeTime=?";
    List<Object> idObject = new ArrayList<Object>();
    idObject.add(doctorId);
    idObject.add(date);
    return dao.count(hql, idObject).intValue();
}

######


@Override
public List<AppointmentDto> findByDocId(int doctorId) {
    String hql = "from Appointment where doctorId=?";
    List<Object> idObject = new ArrayList<Object>();
    idObject.add(doctorId);
    List<Appointment> appointments = new ArrayList<Appointment>();
    List<AppointmentDto> appointmentDtoList = new ArrayList<AppointmentDto>();
    appointments = dao.find(hql, idObject);
    for (int i = 0; i < appointments.size(); i++) {
        User user = userDao.get(User.class, appointments.get(i).getPatientId());
        User doctor = userDao.get(User.class, doctorId);
        AppointmentDto dto = new AppointmentDto();
        dto.setId(appointments.get(i).getId());
        dto.setPatientId(appointments.get(i).getPatientId());
        dto.setPatientName(user.getName());
        dto.setDoctorId(doctorId);
        dto.setDoctorName(doctor.getName());
        dto.setSeeTime(appointments.get(i).getSeeTime());
        dto.setDateTime(appointments.get(i).getDateTime());
        dto.setDiagnose(appointments.get(i).getDiagnose());
        dto.setDisease(appointments.get(i).getDisease());
        dto.setdNumber(appointments.get(i).getdNumber());
        dto.setDoctorSay(appointments.get(i).getDoctorSay());
        appointmentDtoList.add(dto);
    }
    return appointmentDtoList;
}

######


@Override
public List<Appointment> findAppByDId(int doctorId, Date date) {
    String hql = "from Appointment where doctorId=? and seeTime=? ORDER BY dNumber DESC";
    List<Object> idObject = new ArrayList<Object>();
    idObject.add(doctorId);
    idObject.add(date);
    return dao.find(hql, idObject);
}

######


@Override
public void updateAppointment(Appointment appointment) {
    dao.update(appointment);
}

######


@Override
public void updateDiagnose(int id, String diagnose) {
    String hql = "update Appointment set diagnose=? where id=?";
    List<Object> idObject = new ArrayList<Object>();
    idObject.add(diagnose);
    idObject.add(id);
    dao.executeHql(hql, idObject);
}

######


@Override
public void updateDoctorSay(int id, String doctorSay) {
    String hql = "update Appointment set doctorSay=? where id=?";
    List<Object> idObject = new ArrayList<Object>();
    idObject.add(doctorSay);
    idObject.add(id);
    dao.executeHql(hql, idObject);
}

######


@Override
public List<Appointment> findAllAppointment() {
    return dao.find("from Appointment");
}

######


@Override
public List<Appointment> findAppointmentById(int id) {
    String hql = "from Appointment appointment where appointment.id=?";
    List<Object> idObject = new ArrayList<Object>();
    idObject.add(id);
    return dao.find(hql, idObject);
}

######


@Override
public List<AppointmentDto> findByPatId(int id) {
    String hql = "from Appointment where patientId=?";
    List<Object> idObject = new ArrayList<Object>();
    idObject.add(id);
    List<Appointment> appointments = new ArrayList<Appointment>();
    List<AppointmentDto> appointmentDtos = new ArrayList<AppointmentDto>();
    appointments = dao.find(hql, idObject);
    for (int i = 0; i < appointments.size(); i++) {
        User doctor = userDao.get(User.class, appointments.get(i).getDoctorId());
        AppointmentDto dto = new AppointmentDto();
        dto.setId(appointments.get(i).getId());
        dto.setPatientId(appointments.get(i).getPatientId());
        dto.setDoctorId(appointments.get(i).getDoctorId());
        dto.setDoctorName(doctor.getName());
        dto.setSeeTime(appointments.get(i).getSeeTime());
        dto.setDateTime(appointments.get(i).getDateTime());
        dto.setDiagnose(appointments.get(i).getDiagnose());
        dto.setDisease(appointments.get(i).getDisease());
        dto.setdNumber(appointments.get(i).getdNumber());
        dto.setDoctorSay(appointments.get(i).getDoctorSay());
        List<Object> idObjectd = new ArrayList<Object>();
        idObjectd.add(appointments.get(i).getDoctorId());
        List<Doctor> doctorList = new ArrayList<Doctor>();
        doctorList = doctorDao.find("from Doctor where doctorId=?", idObjectd);
        if (doctorList != null && doctorList.size() > 0) {
            dto.setdLikenum(doctorList.get(0).getLikenum());
        }
        appointmentDtos.add(dto);
    }
    return appointmentDtos;
}

######


@Override
public void deleteAppointment(List<Appointment> findAppointment) {
    List<Appointment> list = findAppointment;
    if (list != null && list.size() > 0) {
        for (int i = 0; i < list.size(); i++) {
            dao.delete(list.get(i));
        }
    }
}

######


public void store(@Header(StandardArguments.NAME) String name, @Header(StandardArguments.TIMESTAMP) Long timestamp, @Body String body) {
    String nameLowerCase = name.toLowerCase();
    name = nameLowerCase.replace(" ", "_");
    if (!tableExists.contains(name)) {
        sqlPreparedStatements.put(name, "INSERT INTO " + name + " (timestamp, local_timestamp, body) values (?, ?, ?);");
        int numberOfTables = template.queryForInt(sqlTableCount[0] + name.toUpperCase() + sqlTableCount[1] + name.toLowerCase() + sqlTableCount[2]);
        if (numberOfTables == 0) {
            String createTableStatement = "CREATE TABLE " + name + " (timestamp BIGINT, " + "local_timestamp BIGINT, body varchar(1500), " + "PRIMARY KEY (timestamp));\n";
            template.execute(createTableStatement);
        }
        tableExists.add(name);
    }
    template.update(sqlPreparedStatements.get(name), new Object[] { timestamp, System.currentTimeMillis(), body });
}

######


@Select("SELECT * FROM Author WHERE Author.AuthorID=#{id}")
@Results(value = { @Result(column = "AuthorID", property = "authorid"), @Result(column = "Name", property = "name"), @Result(column = "Age", property = "age"), @Result(column = "Country", property = "country") })
Author getUser(@Param("id") String id);

######


@Select("select id, username, password, email, bio, favourite_section from author where id = #{id}")
void selectAuthor(int id, ResultHandler handler1, ResultHandler handler2);

######


@Select("select id, username, password, email, bio, favourite_section from author where id = #{id}")
void selectAuthor(int id, RowBounds bounds1, RowBounds bounds2);

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType("text/html");
    int empid = Integer.parseInt(request.getParameter("empid"));
    try {
        HttpSession session = request.getSession();
        calculateAuto(session, request, response);
    } catch (Exception e) {
        e.printStackTrace();
        if (empid == 11) {
            RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
            ReqDis.forward(request, response);
        } else {
            RequestDispatcher ReqDis = request.getRequestDispatcher("error.jsp");
            ReqDis.forward(request, response);
        }
    }
}

######


private void calculateAuto(HttpSession session, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException, SQLException {
    PrintWriter out = response.getWriter();
    DecimalFormat df = new DecimalFormat("#.##");
    float distance = (Float) session.getAttribute("distance");
    int empid = (Integer) session.getAttribute("empid");
    String truckType = request.getParameter("Capacity");
    float backhaul = 100;
    String start = org.apache.commons.lang3.StringUtils.capitalize((String) session.getAttribute("start"));
    String end = org.apache.commons.lang3.StringUtils.capitalize((String) session.getAttribute("end"));
    String backstart = org.apache.commons.lang3.StringUtils.capitalize((String) session.getAttribute("backstart"));
    session.setAttribute("start", start);
    session.setAttribute("backstart", backstart);
    session.setAttribute("end", end);
    session.setAttribute("distance", distance);
    float intrest1 = 0, costOfTyre = 0, costOfTruck = 0, loan = 0, noOfYears = 0, residualValue = 0, noOfTyre = 0, costOfTyreUsed = 0, tyreLife = 0, tyreLifeUsed = 0, mileage = 0, noTrips = 0;
    float mileageWithLoad = 0, diesel = 0, roi = 0;
    int cap = 0;
    Connection con = Connect.getconnection();
    PreparedStatement ps = con.prepareStatement("select * from truckparam where typeofgood=?");
    ps.setString(1, truckType);
    ResultSet rs = ps.executeQuery();
    while (rs.next()) {
        costOfTruck = rs.getFloat("costoftruck");
        loan = rs.getFloat("loanpercentage");
        intrest1 = rs.getFloat("rateofintrest");
        roi = rs.getFloat("flatroi");
        costOfTyre = rs.getFloat("tyrecost");
        noOfYears = rs.getFloat("yearsemi");
        residualValue = rs.getFloat("residualvalueoftruck");
        noOfTyre = rs.getFloat("tyres");
        costOfTyreUsed = rs.getFloat("reusedtyrecost");
        tyreLife = rs.getFloat("tyrelife");
        tyreLifeUsed = rs.getFloat("reusedtyrelife");
        mileage = rs.getFloat("dieselmileage");
        mileageWithLoad = rs.getFloat("diesealmileagewithload");
        diesel = rs.getFloat("dieselcost");
        cap = rs.getInt("capacity");
    }
    PreparedStatement ps0 = con.prepareStatement("select `NoofTrip` from `slabtable` WHERE `Min Distance` <= ? AND `Max Distance` >?");
    ps0.setInt(1, (int) distance);
    ps0.setInt(2, (int) distance);
    ResultSet rs0 = ps0.executeQuery();
    while (rs0.next()) {
        noTrips = rs0.getFloat("NoofTrip");
    }
    float cost = calculateTyreCostPerKM(noOfTyre, costOfTyre, costOfTyreUsed, tyreLife, tyreLifeUsed);
    float loanamount = calculateLoanAmount(loan, costOfTruck);
    float paid = calculatePaid(costOfTruck, loanamount);
    float residualValueTruck = calulateResidualValueOfTruck(residualValue, costOfTruck);
    float depreciation = calculateDepreciation(costOfTruck, residualValueTruck, noOfYears);
    float interestcost = calculateInterestCostPerMonth(roi, loanamount);
    float netMileage = calculateNetMilage(mileageWithLoad, backhaul, mileage);
    float roundtrip = calculateRoundTrip(distance);
    float distanceTravled = calculateKmRunPerMonthAvg(roundtrip, noTrips);
    PreparedStatement ps1 = con.prepareStatement("UPDATE truckparam SET loanamount=" + loanamount + ",amountpaid=" + paid + ",kmrunpermonthaverage=" + distanceTravled + ",tyrecostperkm=" + cost + ",roundTrip=" + roundtrip + "WHERE typeofgood=?");
    ps1.setString(1, truckType);
    ps1.executeUpdate();
    float Salary = 0, batta = 0, maintenance = 0, Admin = 0, tarpaulin = 0;
    float expense = 0, totaltoll = 0, insurancepercent = 0, permit = 0, tax = 0;
    float maintenancePerKm = 0, loading = 0;
    float pro = 0;
    PreparedStatement ps2 = con.prepareStatement("select * from routeparam where typeofgood=?");
    ps2.setString(1, truckType);
    ResultSet rs1 = ps2.executeQuery();
    while (rs1.next()) {
        expense = rs1.getFloat("routeexpenses");
        totaltoll = rs1.getFloat("toll");
        insurancepercent = rs1.getFloat("insuranceaspercentageofvechiclecost");
        permit = rs1.getFloat("roadpermityear");
        tax = rs1.getFloat("roadtaxyear");
        Salary = rs1.getFloat("driver/cleaner salary");
        batta = rs1.getFloat("driver/cleaner bhatta");
        maintenance = rs1.getFloat("maintenancepermonth");
        Admin = rs1.getFloat("admin costs");
        maintenancePerKm = rs1.getFloat("maintenancecostperkm");
        tarpaulin = rs1.getFloat("tarpaulin");
        loading = rs1.getFloat("loadingcharges");
        pro = rs1.getInt("profitmargin");
    }
    float toll = calculateTollPerKm(totaltoll, distance);
    float unloading = calculateUnloadingCharges(cap);
    float unloadingloading = unloading + loading;
    float dieselCost = calculateDieselCostPerKm(diesel, netMileage);
    float variableCost = calculateVaribleCostperKm(dieselCost, toll, cost, maintenancePerKm, expense);
    float variable = calculateVaribleCostperMonth(variableCost, distanceTravled, unloadingloading);
    float insuranceMonth = calculateInsurancePerMonth(costOfTruck, insurancepercent);
    float roadPermit = calculateRoadPermitPerMonth(permit);
    float roadTax = calculateRoadTaxPerMonth(tax);
    float fixedcostperMonth = calculatefixedCostPerMonth(roadTax, roadPermit, insuranceMonth, Salary, batta, maintenance, Admin, tarpaulin, depreciation, interestcost);
    float monthlyoperating = calculateMonthlyOperatingCost(fixedcostperMonth, variable);
    float profit = calculateProfitMargin(fixedcostperMonth, pro);
    double perKmCost = calculatePerKmCost(profit, monthlyoperating, distanceTravled);
    float monthlyTon = calculateMonthlyTons(cap, backhaul, noTrips);
    float fixedPTPK = calculateFixedPTPK(fixedcostperMonth, roundtrip, cap, noTrips, backhaul);
    float variablePTPK = calculateVariablePTPK(variable, roundtrip, cap, noTrips, backhaul);
    float profitPTPK = calculateProfitPTPK(profit, roundtrip, cap, noTrips, backhaul);
    float totalPTPK = calculateTotalPTPK(profitPTPK, variablePTPK, fixedPTPK);
    float freightPerTon = calculateFreightPerTon(totalPTPK, distance);
    float emi = 0;
    float cashInflow = 0;
    float cashFlowPerMonth = 0;
    float irr = 0;
    float workingCapital = 0;
    session.setAttribute("fixedptpk", fixedPTPK);
    session.setAttribute("variableptpk", variablePTPK);
    session.setAttribute("profitptpk", profitPTPK);
    session.setAttribute("ptpk", totalPTPK);
    session.setAttribute("freightPerTon", freightPerTon);
    PreparedStatement ps3 = con.prepareStatement("UPDATE routeparam SET backhaul='" + backhaul + "',distance='" + distance + "',unloadingchages='" + unloading + "',loadingunloadingcharges='" + unloadingloading + "',variblecostperkm='" + variableCost + "',variblecostpermonth='" + variable + "',insurancepermonth='" + insuranceMonth + "',workingcapitalinterestcost='" + workingCapital + "',roadpermitmonth='" + roadPermit + "',roadtaxmonth='" + roadTax + "',monthlyoperatingcost='" + monthlyoperating + "',perkmcost='" + perKmCost + "',monthlytons='" + monthlyTon + "',fixedptpk='" + fixedPTPK + "',variableptpk='" + variablePTPK + "', profitptpk='" + profitPTPK + "', totalptpk='" + totalPTPK + "', freightperton='" + freightPerTon + "' WHERE typeofgood=?");
    PreparedStatement ps31 = con.prepareStatement("UPDATE routeparam SET origin=? ,destination=? WHERE typeofgood=?");
    ps3.setString(1, truckType);
    ps3.executeUpdate();
    ps31.setString(1, start);
    ps31.setString(2, end);
    ps31.setString(3, truckType);
    ps31.executeUpdate();
    float costs = cap * distance * totalPTPK;
    session.setAttribute("cost", costs);
    session.setAttribute("profitkm", df.format(profit / distanceTravled));
    session.setAttribute("variablekm", variableCost);
    session.setAttribute("fixedkm", df.format((fixedcostperMonth + profit) / distanceTravled));
    session.setAttribute("variableton", df.format(variable / monthlyTon));
    session.setAttribute("profitton", df.format(profit / monthlyTon));
    session.setAttribute("fixedton", df.format((fixedcostperMonth + profit) / monthlyTon));
    session.setAttribute("dep", df.format(depreciation));
    session.setAttribute("intres", df.format(interestcost));
    session.setAttribute("salr", df.format(Salary));
    session.setAttribute("insu", df.format(insuranceMonth));
    session.setAttribute("rota", df.format(roadTax));
    session.setAttribute("dies", df.format(dieselCost));
    session.setAttribute("tole", df.format(totaltoll));
    session.setAttribute("tyres", df.format(cost));
    session.setAttribute("routes", df.format(expense));
    session.setAttribute("maint", df.format(maintenancePerKm));
    if (empid == 11) {
        RequestDispatcher ReqDis = request.getRequestDispatcher("AdminResultAdvanced.jsp");
        ReqDis.forward(request, response);
    } else {
        RequestDispatcher ReqDis = request.getRequestDispatcher("ResultAdvanced.jsp");
        ReqDis.forward(request, response);
    }
}

######


private float calculateProfitMargin(float fixedcostperMonth, float pro) {
    return (fixedcostperMonth * pro) / 100;
}

######


private float calculateProfit(float monthlyoperating) {
    return (float) ((0.0752688172043011) * monthlyoperating);
}

######


private float calculateKmRunPerMonthAvg(float roundtrip, float noTrips) {
    return (roundtrip * noTrips);
}

######


private float calculateVaribleCostperMonth(float variableCost, float distanceTravled, float unloadingloading) {
    return ((variableCost * distanceTravled) + unloadingloading);
}

######


private float calculateTotalPTPK(float profitPTPK, float variablePTPK, float fixedPTPK) {
    return (profitPTPK + variablePTPK + fixedPTPK);
}

######


private float calculateProfitPTPK(float profit, float roundtrip, int cap, float noTrips, float backhaul) {
    return (profit / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateVariablePTPK(float variable, float roundtrip, int cap, float noTrips, float backhaul) {
    return (variable / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateFixedPTPK(float fixedcostperMonth, float roundtrip, int cap, float noTrips, float backhaul) {
    return (fixedcostperMonth / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateFreightPerTon(float totalPTPK, float distance) {
    return (totalPTPK * distance);
}

######


private float calculateRoundTrip(float distance) {
    return (distance * 2);
}

######


private float calculateTotalCostPerTon(float totalPTPK, float distance, int cap) {
    return (totalPTPK * distance * cap);
}

######


private float calculateMonthlyTons(int cap, float backhaul, float noTrips) {
    return (noTrips * cap * (1 + (backhaul / 100)));
}

######


private float calculatePerKmCost(float profitMargin, float monthlyoperating, float distanceTravled) {
    return ((profitMargin + monthlyoperating) / distanceTravled);
}

######


private float calculateMonthlyOperatingCost(float fixedcostperMonth, float variable) {
    return (fixedcostperMonth + variable);
}

######


private float calculatefixedCostPerMonth(float roadTax, float roadPermit, float insuranceMonth, float salary, float batta, float maintenance, float admin, float tarpaulin, float depreciation, float interestcost) {
    return (admin + batta + insuranceMonth + maintenance + roadPermit + roadTax + salary + tarpaulin + depreciation + interestcost);
}

######


private float calculateRoadTaxPerMonth(float tax) {
    return (tax / 12);
}

######


private float calculateRoadPermitPerMonth(float permit) {
    return (permit / 12);
}

######


private float calculateInsurancePerMonth(float costOfTruck, float insurancepercent) {
    return ((costOfTruck * insurancepercent) / 1200);
}

######


private float calculateVaribleCostperKm(float dieselCost, float toll, float cost, float maintenancePerKm, float route) {
    return (dieselCost + toll + cost + maintenancePerKm + route);
}

######


private float calculateRouteExpence(float expense, float distance) {
    return (expense / distance);
}

######


private float calculateUnloadingCharges(int cap) {
    return (45 * cap);
}

######


private float calculateDieselCostPerKm(float diesel, float netMileage) {
    return (diesel / netMileage);
}

######


private float calculateNetMilage(float mileageWithLoad, float backhaul, float mileage) {
    return (((mileageWithLoad * 100 + (mileageWithLoad * backhaul)) + (mileage) * (100 - backhaul)) / 200);
}

######


private float calculateTollPerKm(float totaltoll, float distance) {
    return (totaltoll / distance);
}

######


private float calulateResidualValueOfTruck(float residualValue, float costOfTruck) {
    return (costOfTruck * residualValue / 100);
}

######


private float calculateInterestCostPerMonth(float roi, float loanamount) {
    return ((roi * loanamount) / 1200);
}

######


private float calculateDepreciation(float costOfTruck, float residualValue, float noOfYears) {
    return (((costOfTruck - residualValue) / noOfYears) / 12);
}

######


private float calculatePaid(float costOfTruck, float loanamount) {
    return (costOfTruck - loanamount);
}

######


private float calculateLoanAmount(float loan, float costOfTruck) {
    return ((costOfTruck * loan) / 100);
}

######


private float calculateTyreCostPerKM(float noOfTyre, float costOfTyre, float costOfTyreUsed, float tyreLife, float tyreLifeUsed) {
    return (noOfTyre * (costOfTyre + costOfTyreUsed) / (tyreLife + tyreLifeUsed));
}

######


@Select("SELECT * FROM subject WHERE id = #{id}")
PrimitiveSubject getSubject(final int id);

######


@Select("SELECT * FROM subject")
List<PrimitiveSubject> getSubjects();

######


@Select("SELECT * FROM subject")
List<WrapperSubject> getWrapperSubjects();

######


@Select("SELECT * FROM subject")
List<AnnotatedSubject> getAnnotatedSubjects();

######


@Select("SELECT * FROM subject")
List<BadSubject> getBadSubjects();

######


@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL("CREATE TABLE " + PROFILES_TABLE_NAME + " (" + Profiles._ID + " INTEGER PRIMARY KEY," + Profiles.FULL_NAME + " TEXT," + Profiles.EMAIL_ADDRESS + " TEXT," + Profiles.COMPANY_NAME + " TEXT," + Profiles.ADDRESS_LINE_1 + " TEXT," + Profiles.ADDRESS_LINE_2 + " TEXT," + Profiles.CITY + " TEXT," + Profiles.STATE + " TEXT," + Profiles.ZIP_CODE + " TEXT," + Profiles.COUNTRY + " TEXT," + Profiles.PHONE_NUMBER + " TEXT" + " );");
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    Log.w(LOGTAG, "Upgrading database from version " + oldVersion + " to " + newVersion + ", which will destroy all old data");
    db.execSQL("DROP TABLE IF EXISTS " + PROFILES_TABLE_NAME);
    onCreate(db);
}

######


public static AutoFillProfileDatabase getInstance(Context context) {
    if (sInstance == null) {
        sInstance = new AutoFillProfileDatabase(context);
    }
    return sInstance;
}

######


private SQLiteDatabase getDatabase(boolean writable) {
    return writable ? mOpenHelper.getWritableDatabase() : mOpenHelper.getReadableDatabase();
}

######


public Cursor getProfile(int id) {
    final String[] cols = { Profiles.FULL_NAME, Profiles.EMAIL_ADDRESS, Profiles.COMPANY_NAME, Profiles.ADDRESS_LINE_1, Profiles.ADDRESS_LINE_2, Profiles.CITY, Profiles.STATE, Profiles.ZIP_CODE, Profiles.COUNTRY, Profiles.PHONE_NUMBER };
    final String[] selectArgs = { Integer.toString(id) };
    return getDatabase(false).query(PROFILES_TABLE_NAME, cols, Profiles._ID + "=?", selectArgs, null, null, null, "1");
}

######


public void dropProfile(int id) {
    final String sql = "DELETE FROM " + PROFILES_TABLE_NAME + " WHERE " + Profiles._ID + " = ?;";
    final Object[] params = { id };
    getDatabase(true).execSQL(sql, params);
}

######


public void close() {
    mOpenHelper.close();
}

######


@Override
public Autore doRetriveById(Object... id) {
    String nomeAutore = (String) id[0];
    String cognomeAutore = (String) id[1];
    try (Connection con = DriverManagerConnectionPool.getConnection()) {
        PreparedStatement prst = con.prepareStatement(doRetriveByNomeCognomeQuery);
        prst.setString(1, nomeAutore);
        prst.setString(2, cognomeAutore);
        System.out.println("Entro??");
        try (ResultSet rs = prst.executeQuery()) {
            con.commit();
            Autore a = null;
            if (rs.next()) {
                a = new Autore();
                a.setNome(nomeAutore);
                a.setCognome(cognomeAutore);
                a.setCodFiscale(rs.getString("CodiceFiscale"));
            }
            rs.close();
            return a;
        } catch (SQLException e) {
            con.rollback();
            return null;
        } finally {
            DriverManagerConnectionPool.releaseConnection(con);
            prst.close();
        }
    } catch (SQLException e) {
        return null;
    }
}

######


@Override
public List<Autore> doRetriveAll() {
    List<Autore> autori = new ArrayList<>();
    try (Connection con = DriverManagerConnectionPool.getConnection()) {
        PreparedStatement prst = con.prepareStatement(doRetriveAllQuery);
        try (ResultSet rs = prst.executeQuery()) {
            con.commit();
            while (rs.next()) {
                Autore a = new Autore();
                a.setCodFiscale(rs.getString("CodiceFiscale"));
                a.setNome(rs.getString("Nome"));
                a.setCognome(rs.getString("Cognome"));
                a.setDataDiNascita(rs.getString("DataNascita"));
                a.setCittaResidenza(rs.getString("CittaResidenza"));
                autori.add(a);
            }
            rs.close();
        } catch (SQLException e) {
            con.rollback();
        } finally {
            DriverManagerConnectionPool.releaseConnection(con);
            prst.close();
            return autori;
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return autori;
}

######


public List<Autore> doRetriveByLibro(String isbn) {
    List<Autore> autori = new ArrayList<>();
    try (Connection con = DriverManagerConnectionPool.getConnection()) {
        PreparedStatement prst = con.prepareStatement(doRetriveByLibroQuery);
        String daPassare = isbn;
        prst.setString(1, daPassare);
        try (ResultSet rs = prst.executeQuery()) {
            con.commit();
            while (rs.next()) {
                Autore a = new Autore();
                a.setNome(rs.getString("Nome"));
                a.setCognome(rs.getString("Cognome"));
                a.setCodFiscale(rs.getString("CodiceFiscale"));
                autori.add(a);
            }
            rs.close();
        } catch (SQLException e) {
            e.printStackTrace();
            con.rollback();
        } finally {
            DriverManagerConnectionPool.releaseConnection(con);
            prst.close();
            return autori;
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return autori;
}

######


@Override
public int doInsert(Autore autore) {
    return 0;
}

######


@Override
public int doUpdate(Autore autore) {
    return 0;
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    System.out.println("Creando DB");
    db.execSQL(sqlCreateHorario);
    db.execSQL(sqlCreateModulos);
    for (String consulta : sqlOmplirHorario) {
        db.execSQL(consulta);
    }
    db.execSQL(sqlOmplirModulos);
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int i, int i1) {
    System.out.println("Actualizando DB");
    String sqlRemoveHorario = "DROP TABLE horario";
    db.execSQL(sqlRemoveHorario);
    String sqlRemoveModulos = "DROP TABLE modulos";
    db.execSQL(sqlRemoveModulos);
    db.execSQL(sqlCreateHorario);
    db.execSQL(sqlCreateModulos);
    for (String consulta : sqlOmplirHorario) {
        db.execSQL(consulta);
    }
    db.execSQL(sqlOmplirModulos);
}

######


public Assignatura getAssignatura(int grup, SQLiteDatabase bbdd) {
    Assignatura res = null;
    SimpleDateFormat formatter = new SimpleDateFormat("HH:mm:ss");
    Calendar c = Calendar.getInstance();
    Date horaActual = null;
    try {
        horaActual = formatter.parse((c.get(Calendar.HOUR_OF_DAY) + ":" + c.get(Calendar.MINUTE) + ":" + c.get(Calendar.SECOND)));
    } catch (ParseException e) {
        e.printStackTrace();
    }
    String sql = "SELECT codAsignatura, horaInicio,horaFin FROM horario " + "WHERE (grup=" + grup + " OR grup=" + GRUP_A + ") AND diaSetmana=" + c.get(Calendar.DAY_OF_WEEK) + " AND '" + formatter.format(horaActual) + "' BETWEEN horaInicio AND horaFin";
    Cursor curs = bbdd.rawQuery(sql, null);
    System.out.println(sql);
    if (curs.getCount() != 0) {
        curs.moveToFirst();
        String sql2 = "SELECT nomAssignatura,nomProfe FROM modulos WHERE codAsignatura=" + curs.getInt(0);
        Cursor d = bbdd.rawQuery(sql2, null);
        d.moveToFirst();
        Date horaInici = null;
        Date horaFi = null;
        try {
            horaInici = formatter.parse(curs.getString(1));
            horaFi = formatter.parse(curs.getString(2));
        } catch (ParseException e) {
            e.printStackTrace();
        }
        res = new Assignatura(d.getString(0), d.getString(1), horaInici, horaFi, horaActual);
        d.close();
    }
    curs.close();
    return res;
}

######


@Override
@UnitOfWork
public List<T> findAll() {
    EntityManager entityManager = entityManagerProvider.get();
    return entityManager.createQuery("select t from " + modelName + " as t").getResultList();
}

######


@Override
@UnitOfWork
public List<T> findByProperty(String property, Object value) throws PersistenceException {
    EntityManager entityManager = entityManagerProvider.get();
    Query query = entityManager.createQuery("select t from " + modelName + " as t where t." + property + " = :value").setParameter("value", value);
    return query.getResultList();
}

######


@Override
@Transactional
public T create(T model) throws PersistenceException {
    if (model == null) {
        throw new PersistenceException("Model should not be null");
    }
    EntityManager entityManager = entityManagerProvider.get();
    entityManager.persist(model);
    return model;
}

######


@Override
@Transactional
public T update(T model) throws PersistenceException {
    if (model == null) {
        throw new PersistenceException("Model should not be null");
    }
    if (model.getId() == null) {
        throw new PersistenceException("Model has not been persisted");
    }
    EntityManager entityManager = entityManagerProvider.get();
    T updatedModel = entityManager.merge(model);
    entityManager.flush();
    return updatedModel;
}

######


@Override
@Transactional
public boolean destroy(T model) throws PersistenceException {
    if (model == null) {
        throw new PersistenceException("Model should not be null");
    }
    EntityManager entityManager = entityManagerProvider.get();
    T entity = (T) entityManager.find(entityType, new Long(model.getId()));
    entityManager.remove(entity);
    entityManager.flush();
    return true;
}

######


@SelectProvider(type = StatementProvider.class, method = "provideSelect")
S select(S param);

######


@SelectProvider(type = StatementProvider.class, method = "provideSelect")
List<S> selectList(S param);

######


@SelectProvider(type = StatementProvider.class, method = "provideSelect")
@MapKey("id")
Map<T, S> selectMap(S param);

######


@InsertProvider(type = StatementProvider.class, method = "provideInsert")
@Options(useGeneratedKeys = true, keyProperty = "id")
int insert(List<S> param);

######


@UpdateProvider(type = StatementProvider.class, method = "provideUpdate")
int update(S param);

######


public String provideSelect(Object param) {
    StringBuilder sql = new StringBuilder("select * from ");
    if (param == null || param instanceof Person) {
        sql.append(" person ");
        if (param != null && ((Person) param).getId() != null) {
            sql.append(" where id = #{id}");
        }
    } else if (param instanceof Country) {
        sql.append(" country ");
        if (((Country) param).getId() != null) {
            sql.append(" where id = #{id}");
        }
    }
    sql.append(" order by id");
    return sql.toString();
}

######


public String provideInsert(Map<String, Object> map) {
    List<?> params = (List<?>) map.get("list");
    StringBuilder sql = null;
    for (int i = 0; i < params.size(); i++) {
        Object param = params.get(i);
        if (sql == null) {
            sql = new StringBuilder("insert into ");
            sql.append(param instanceof Country ? " country " : " person");
            sql.append(" (id, name) values ");
        } else {
            sql.append(",");
        }
        sql.append(" (#{list[" + i + "].id}, #{list[" + i + "].name})");
    }
    return sql == null ? "" : sql.toString();
}

######


public String provideUpdate(Object param) {
    StringBuilder sql = new StringBuilder("update ");
    if (param instanceof Person) {
        sql.append(" person set name = #{name} where id = #{id}");
    } else if (param instanceof Country) {
        sql.append(" country set name = #{name} where id = #{id}");
    }
    return sql.toString();
}

######


@Test
public void testWriteOnMaster() throws SQLException {
    try (Connection connection = getNewConnection(false)) {
        Statement stmt = connection.createStatement();
        stmt.execute("drop table  if exists auroraMultiNode" + jobId);
        stmt.execute("create table auroraMultiNode" + jobId + " (id int not null primary key auto_increment, test VARCHAR(10))");
        stmt.execute("drop table  if exists auroraMultiNode" + jobId);
    }
}

######


@Test
public void relaunchWithoutError() throws Throwable {
    try (Connection connection = getNewConnection("&connectTimeout=1000&socketTimeout=1000", true)) {
        Statement st = connection.createStatement();
        int masterServerId = getServerId(connection);
        long startTime = System.currentTimeMillis();
        stopProxy(masterServerId, 4000);
        try {
            st.execute("SELECT 1");
            if (System.currentTimeMillis() - startTime < 4 * 1000) {
                fail("Auto-reconnection must have been done after 4000ms but was " + (System.currentTimeMillis() - startTime));
            }
        } catch (SQLException e) {
            fail("must not have thrown error");
        }
    }
}

######


@Test
public void relaunchWithErrorWhenInTransaction() throws Throwable {
    try (Connection connection = getNewConnection("&connectTimeout=1000&socketTimeout=1000", true)) {
        Statement st = connection.createStatement();
        st.execute("drop table if exists baseReplicationTransaction" + jobId);
        st.execute("create table baseReplicationTransaction" + jobId + " (id int not null primary key auto_increment, test VARCHAR(10))");
        connection.setAutoCommit(false);
        st.execute("INSERT INTO baseReplicationTransaction" + jobId + "(test) VALUES ('test')");
        int masterServerId = getServerId(connection);
        st.execute("SELECT 1");
        long startTime = System.currentTimeMillis();
        stopProxy(masterServerId, 2000);
        try {
            st.execute("SELECT 1");
            fail("must have thrown error since in transaction that is lost");
        } catch (SQLException e) {
            assertEquals("error type not normal after " + (System.currentTimeMillis() - startTime) + "ms", "25S03", e.getSQLState());
        }
        st.execute("drop table if exists baseReplicationTransaction" + jobId);
    }
}

######


@Test
public void failoverRelaunchedWhenSelect() throws Throwable {
    try (Connection connection = getNewConnection("&connectTimeout=1000&socketTimeout=1000&retriesAllDown=6", true)) {
        Statement st = connection.createStatement();
        final int masterServerId = getServerId(connection);
        st.execute("drop table if exists selectFailover" + jobId);
        st.execute("create table selectFailover" + jobId + " (id int not null primary key , amount int not null) " + "ENGINE = InnoDB");
        stopProxy(masterServerId, 2);
        try {
            st.execute("SELECT * from selectFailover" + jobId);
        } catch (SQLException e) {
            e.printStackTrace();
            fail("must not have thrown error");
        }
        stopProxy(masterServerId, 2);
        try {
            st.execute("INSERT INTO selectFailover" + jobId + " VALUES (1,2)");
            fail("not have thrown error !");
        } catch (SQLException e) {
            restartProxy(masterServerId);
            assertEquals("error type not normal", "25S03", e.getSQLState());
        }
    }
}

######


@Test
public void failoverRelaunchedWhenInTransaction() throws Throwable {
    try (Connection connection = getNewConnection("&connectTimeout=1000&socketTimeout=1000&retriesAllDown=6", true)) {
        Statement st = connection.createStatement();
        final int masterServerId = getServerId(connection);
        st.execute("drop table if exists selectFailoverTrans" + jobId);
        st.execute("create table selectFailoverTrans" + jobId + " (id int not null primary key , amount int not null) " + "ENGINE = InnoDB");
        connection.setAutoCommit(false);
        st.execute("INSERT INTO selectFailoverTrans" + jobId + " VALUES (0,0)");
        stopProxy(masterServerId, 2);
        try {
            st.execute("SELECT * from selectFailoverTrans" + jobId);
            fail("not have thrown error !");
        } catch (SQLException e) {
            assertEquals("error type not normal", "25S03", e.getSQLState());
        }
        stopProxy(masterServerId, 2);
        try {
            st.execute("INSERT INTO selectFailoverTrans" + jobId + " VALUES (1,2)");
            fail("not have thrown error !");
        } catch (SQLException e) {
            restartProxy(masterServerId);
            st.execute("drop table if exists selectFailoverTrans" + jobId);
            assertEquals("error type not normal", "25S03", e.getSQLState());
        }
    }
}

######


@Test
public void pingReconnectAfterRestart() throws Throwable {
    try (Connection connection = getNewConnection("&connectTimeout=1000&socketTimeout=1000&retriesAllDown=6", true)) {
        Statement st = connection.createStatement();
        int masterServerId = getServerId(connection);
        stopProxy(masterServerId);
        try {
            st.execute("SELECT 1");
        } catch (SQLException e) {
        }
        restartProxy(masterServerId);
        long restartTime = System.nanoTime();
        boolean loop = true;
        while (loop) {
            if (!connection.isClosed()) {
                loop = false;
            }
            connection.createStatement();
            long duration = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - restartTime);
            if (duration > 20 * 1000) {
                fail("Auto-reconnection not done after " + duration);
            }
            Thread.sleep(250);
        }
    }
}

######


protected void starting(Description description) {
    System.out.println("start test : " + description.getClassName() + "." + description.getMethodName());
}

######


protected void succeeded(Description description) {
    System.out.println("finished test success : " + description.getClassName() + "." + description.getMethodName());
}

######


protected void failed(Throwable throwable, Description description) {
    System.out.println("finished test failed : " + description.getClassName() + "." + description.getMethodName());
}

######


@BeforeClass
public static void beforeClass() throws SQLException {
    initialUrl = System.getProperty("dbFailoverUrl");
    initialGaleraUrl = System.getProperty("defaultGaleraUrl");
    initialReplicationUrl = System.getProperty("defaultReplicationUrl");
    initialLoadbalanceUrl = System.getProperty("defaultLoadbalanceUrl");
    initialAuroraUrl = System.getProperty("defaultAuroraUrl");
    jobId = System.getProperty("jobId", "_0");
    if (initialUrl != null) {
        proxyUrl = createProxies(initialUrl, HaMode.NONE);
    }
    if (initialReplicationUrl != null) {
        proxyReplicationUrl = createProxies(initialReplicationUrl, HaMode.REPLICATION);
    }
    if (initialLoadbalanceUrl != null) {
        proxyLoadbalanceUrl = createProxies(initialLoadbalanceUrl, HaMode.LOADBALANCE);
    }
    if (initialGaleraUrl != null) {
        proxyGaleraUrl = createProxies(initialGaleraUrl, HaMode.FAILOVER);
    }
    if (initialGaleraUrl != null) {
        proxySequentialUrl = createProxies(initialGaleraUrl, HaMode.SEQUENTIAL);
    }
    if (initialAuroraUrl != null) {
        proxyAuroraUrl = createProxies(initialAuroraUrl, HaMode.AURORA);
    }
}

######


public static boolean requireMinimumVersion(Connection connection, int major, int minor) throws SQLException {
    DatabaseMetaData md = connection.getMetaData();
    int dbMajor = md.getDatabaseMajorVersion();
    int dbMinor = md.getDatabaseMinorVersion();
    return (dbMajor > major || (dbMajor == major && dbMinor >= minor));
}

######


private static String createProxies(String tmpUrl, HaMode proxyType) throws SQLException {
    UrlParser tmpUrlParser;
    if (proxyType == HaMode.AURORA) {
        tmpUrlParser = retrieveEndpointsForProxies(tmpUrl);
    } else {
        tmpUrlParser = UrlParser.parse(tmpUrl);
    }
    TcpProxy[] tcpProxies = new TcpProxy[tmpUrlParser.getHostAddresses().size()];
    username = tmpUrlParser.getUsername();
    hostname = tmpUrlParser.getHostAddresses().get(0).host;
    StringBuilder sockethosts = new StringBuilder();
    HostAddress hostAddress;
    for (int i = 0; i < tmpUrlParser.getHostAddresses().size(); i++) {
        try {
            hostAddress = tmpUrlParser.getHostAddresses().get(i);
            tcpProxies[i] = new TcpProxy(hostAddress.host, hostAddress.port);
            sockethosts.append(",address=(host=localhost)(port=").append(tcpProxies[i].getLocalPort()).append(")").append((hostAddress.type != null) ? "(type=" + hostAddress.type + ")" : "");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    proxySet.put(proxyType, tcpProxies);
    if (tmpUrlParser.getHaMode().equals(HaMode.NONE)) {
        return "jdbc:mariadb://" + sockethosts.substring(1) + "/" + tmpUrl.split("/")[3];
    } else {
        return "jdbc:mariadb:" + tmpUrlParser.getHaMode().toString().toLowerCase() + "://" + sockethosts.substring(1) + "/" + tmpUrl.split("/")[3];
    }
}

######


private static UrlParser retrieveEndpointsForProxies(String tmpUrl) throws SQLException {
    try {
        Connection connection = DriverManager.getConnection(tmpUrl);
        connection.setReadOnly(true);
        try {
            Protocol protocol = (new BaseMultiHostTest().getProtocolFromConnection(connection));
            return protocol.getUrlParser();
        } catch (Throwable throwable) {
            connection.close();
            return UrlParser.parse(tmpUrl);
        }
    } catch (SQLException se) {
        return UrlParser.parse(tmpUrl);
    }
}

######


@AfterClass
public static void afterClass() {
    for (TcpProxy[] tcpProxies : proxySet.values()) {
        for (TcpProxy tcpProxy : tcpProxies) {
            try {
                tcpProxy.stop();
            } catch (Exception e) {
            }
        }
    }
}

######


@After
public void afterBaseTest() {
    assureProxy();
    assureBlackList();
}

######


protected Connection getNewConnection() throws SQLException {
    return getNewConnection(null, false);
}

######


protected Connection getNewConnection(boolean proxy) throws SQLException {
    return getNewConnection(null, proxy);
}

######


protected Connection getNewConnection(String additionnalConnectionData, boolean proxy) throws SQLException {
    return getNewConnection(additionnalConnectionData, proxy, false);
}

######


protected Connection getNewConnection(String additionnalConnectionData, boolean proxy, boolean forceNewProxy) throws SQLException {
    if (proxy) {
        String tmpProxyUrl = proxyUrl;
        if (forceNewProxy) {
            tmpProxyUrl = createProxies(defaultUrl, currentType);
        }
        tmpProxyUrl += (additionnalConnectionData == null) ? "" : additionnalConnectionData;
        return DriverManager.getConnection(tmpProxyUrl);
    } else {
        if (additionnalConnectionData == null) {
            return DriverManager.getConnection(defaultUrl);
        } else {
            return DriverManager.getConnection(defaultUrl + additionnalConnectionData);
        }
    }
}

######


public void stopProxy(int hostNumber, long millissecond) {
    proxySet.get(currentType)[hostNumber - 1].restart(millissecond);
}

######


public void stopProxy(int hostNumber) {
    proxySet.get(currentType)[hostNumber - 1].stop();
}

######


public void stopProxyButParameter(int hostNumber) {
    TcpProxy[] proxies = proxySet.get(currentType);
    for (int i = 0; i < proxies.length; i++) {
        if (i != hostNumber - 1) {
            proxies[i].stop();
        }
    }
}

######


public void restartProxy(int hostNumber) {
    if (hostNumber != -1) {
        proxySet.get(currentType)[hostNumber - 1].restart();
    }
}

######


public void assureProxy() {
    for (TcpProxy[] tcpProxies : proxySet.values()) {
        for (TcpProxy tcpProxy : tcpProxies) {
            tcpProxy.assureProxyOk();
        }
    }
}

######


public void assureBlackList() {
    AbstractMastersListener.clearBlacklist();
}

######


@Test
public void failoverSlaveToMasterPrepareStatement() throws Throwable {
    try (Connection connection = getNewConnection("&retriesAllDown=6&connectTimeout=1000&socketTimeout=1000" + "&useBatchMultiSend=false&useServerPrepStmts", true)) {
        Statement stmt = connection.createStatement();
        stmt.execute("drop table  if exists replicationFailoverBinary" + jobId);
        stmt.execute("create table replicationFailoverBinary" + jobId + " (id int not null primary key auto_increment, test VARCHAR(10))");
        stmt.execute("insert into replicationFailoverBinary" + jobId + "(test) values ('Harriba !')");
        final int masterServerId = getServerId(connection);
        connection.setReadOnly(true);
        Thread.sleep(200);
        connection.prepareStatement("SELECT ?");
        PreparedStatement preparedStatement = connection.prepareStatement("SELECT test from replicationFailoverBinary" + jobId + " where id = ?");
        final long currentPrepareId = getPrepareResult((ServerSidePreparedStatement) preparedStatement).getStatementId();
        int slaveServerId = getServerId(connection);
        assertFalse(masterServerId == slaveServerId);
        stopProxy(slaveServerId, 2000);
        preparedStatement.setInt(1, 1);
        ResultSet rs = preparedStatement.executeQuery();
        assertTrue(rs.next());
        assertEquals("Harriba !", rs.getString(1));
        assertNotEquals(currentPrepareId, getPrepareResult((ServerSidePreparedStatement) preparedStatement).getStatementId());
        int currentServerId = getServerId(connection);
        assertTrue(masterServerId == currentServerId);
        assertFalse(connection.isReadOnly());
        Thread.sleep(2000);
        boolean hasReturnOnSlave = false;
        for (int i = 0; i < 10; i++) {
            Thread.sleep(1000);
            preparedStatement.setInt(1, 1);
            rs = preparedStatement.executeQuery();
            assertTrue(rs.next());
            assertEquals("Harriba !", rs.getString(1));
            currentServerId = getServerId(connection);
            if (currentServerId != masterServerId) {
                hasReturnOnSlave = true;
                assertTrue(connection.isReadOnly());
                break;
            }
        }
        assertTrue("Prepare statement has not return on Slave", hasReturnOnSlave);
    }
}

######


@Test()
public void failoverSlaveAndMasterRewrite() throws Throwable {
    try (Connection connection = getNewConnection("&rewriteBatchedStatements=true&retriesAllDown=6&connectTimeout=2000&socketTimeout=2000", true)) {
        int masterServerId = getServerId(connection);
        connection.setReadOnly(true);
        int firstSlaveId = getServerId(connection);
        stopProxy(masterServerId);
        stopProxy(firstSlaveId, 4000);
        try {
            Statement stmt = connection.createStatement();
            stmt.addBatch("DO 1");
            stmt.addBatch("DO 2");
            int[] resultData = stmt.executeBatch();
            int secondSlaveId = getServerId(connection);
            assertEquals("the 2 batch queries must have been executed when failover", 2, resultData.length);
            assertTrue(secondSlaveId != firstSlaveId && secondSlaveId != masterServerId);
        } catch (SQLException e) {
            e.printStackTrace();
            fail();
        }
    }
}

######


@Test
public void failoverSlaveToMaster() throws Throwable {
    try (Connection connection = getNewConnection("&retriesAllDown=6&connectTimeout=1000&socketTimeout=1000", true)) {
        int masterServerId = getServerId(connection);
        connection.setReadOnly(true);
        int slaveServerId = getServerId(connection);
        assertFalse(masterServerId == slaveServerId);
        stopProxy(slaveServerId);
        connection.createStatement().execute("SELECT 1");
        int currentServerId = getServerId(connection);
        assertTrue(masterServerId == currentServerId);
        assertFalse(connection.isReadOnly());
    }
}

######


@Test
public void failoverDuringSlaveSetReadOnly() throws Throwable {
    try (Connection connection = getNewConnection("&socketTimeout=3000", true)) {
        connection.setReadOnly(true);
        int slaveServerId = getServerId(connection);
        stopProxy(slaveServerId, 2000);
        connection.setReadOnly(false);
        int masterServerId = getServerId(connection);
        assertFalse(slaveServerId == masterServerId);
        assertFalse(connection.isReadOnly());
    }
    Thread.sleep(2500);
}

######


@Test()
public void failoverSlaveAndMasterWithoutAutoConnect() throws Throwable {
    try (Connection connection = getNewConnection("&retriesAllDown=20&connectTimeout=2000&socketTimeout=2000", true)) {
        int masterServerId = getServerId(connection);
        connection.setReadOnly(true);
        int firstSlaveId = getServerId(connection);
        stopProxy(masterServerId);
        stopProxy(firstSlaveId);
        try {
            connection.createStatement().executeQuery("SELECT CONNECTION_ID()");
        } catch (SQLException e) {
            e.printStackTrace();
            fail();
        }
    }
}

######


@Test
public void reconnectSlaveAndMasterWithAutoConnect() throws Throwable {
    try (Connection connection = getNewConnection("&retriesAllDown=6&connectTimeout=2000&socketTimeout=2000", true)) {
        int masterServerId = getServerId(connection);
        connection.setReadOnly(true);
        int firstSlaveId = getServerId(connection);
        stopProxy(masterServerId);
        stopProxy(firstSlaveId);
        connection.createStatement().execute("SELECT 1");
        int currentSlaveId = getServerId(connection);
        assertTrue(currentSlaveId != firstSlaveId);
        assertTrue(currentSlaveId != masterServerId);
    }
}

######


@Test
public void failoverMasterWithAutoConnect() throws Throwable {
    try (Connection connection = getNewConnection("&retriesAllDown=6&connectTimeout=1000&socketTimeout=1000", true)) {
        int masterServerId = getServerId(connection);
        stopProxy(masterServerId, 250);
        int currentServerId = getServerId(connection);
        assertTrue(currentServerId == masterServerId);
        assertFalse(connection.isReadOnly());
    }
    Thread.sleep(500);
}

######


@Test
public void writeToSlaveAfterFailover() throws Throwable {
    try (Connection connection = getNewConnection("&retriesAllDown=6&connectTimeout=1000&socketTimeout=1000", true)) {
        Assume.assumeTrue(!hasSuperPrivilege(connection, "writeToSlaveAfterFailover"));
        Statement st = connection.createStatement();
        st.execute("drop table  if exists writeToSlave" + jobId);
        st.execute("create table writeToSlave" + jobId + " (id int not null primary key , amount int not null) ENGINE = InnoDB");
        st.execute("insert into writeToSlave" + jobId + " (id, amount) VALUE (1 , 100)");
        int masterServerId = getServerId(connection);
        stopProxy(masterServerId);
        try {
            st.execute("insert into writeToSlave" + jobId + " (id, amount) VALUE (2 , 100)");
            fail();
        } catch (SQLException e) {
            restartProxy(masterServerId);
            st = connection.createStatement();
            st.execute("drop table if exists writeToSlave" + jobId);
        }
    }
}

######


@Test
public void randomConnection() throws Throwable {
    Map<HostAddress, MutableInt> connectionMap = new HashMap<>();
    int masterId = -1;
    for (int i = 0; i < 20; i++) {
        try (Connection connection = getNewConnection(false)) {
            int serverId = getServerId(connection);
            if (i > 0) {
                assertTrue(masterId == serverId);
            }
            masterId = serverId;
            connection.setReadOnly(true);
            HostAddress replicaHost = getServerHostAddress(connection);
            MutableInt count = connectionMap.get(replicaHost);
            if (count == null) {
                connectionMap.put(replicaHost, new MutableInt());
            } else {
                count.increment();
            }
        }
    }
    assertTrue(connectionMap.size() >= 2);
    for (HostAddress key : connectionMap.keySet()) {
        Integer connectionCount = connectionMap.get(key).get();
        assertTrue(connectionCount > 1);
    }
}

######


@Test
public void closeWhenInReconnectionLoop() throws Throwable {
    try (Connection connection = getNewConnection("&connectTimeout=1000&socketTimeout=1000", true)) {
        int masterId = getServerId(connection);
        connection.setReadOnly(true);
        stopProxyButParameter(masterId);
        Statement stmt = connection.createStatement();
        stmt.execute("SELECT 1");
        Thread.sleep(200);
    }
}

######


@Test
public void failoverSlaveToMasterFail() throws Throwable {
    try (Connection connection = getNewConnection("&connectTimeout=1000&socketTimeout=1000&retriesAllDown=6", true)) {
        int masterServerId = getServerId(connection);
        connection.setReadOnly(true);
        int slaveServerId = getServerId(connection);
        assertTrue(slaveServerId != masterServerId);
        connection.setCatalog("mysql");
        stopProxy(masterServerId);
        try {
            connection.setReadOnly(false);
            fail();
        } catch (SQLException e) {
        }
        restartProxy(masterServerId);
    }
}

######


@Test
public void failoverDuringMasterSetReadOnly() throws Throwable {
    try (Connection connection = getNewConnection("&retriesAllDown=6", true)) {
        int masterServerId;
        masterServerId = getServerId(connection);
        stopProxy(masterServerId);
        connection.setReadOnly(true);
        int slaveServerId = getServerId(connection);
        assertFalse(slaveServerId == masterServerId);
        assertTrue(connection.isReadOnly());
        restartProxy(masterServerId);
    }
}

######


@Test
public void multipleValid() throws Throwable {
    try (Connection connection = getNewConnection("&retriesAllDown=6&connectTimeout=1000&socketTimeout=1000", true)) {
        assertTrue(connection.isValid(2));
    }
}

######


public void increment() {
    ++value;
}

######


public int get() {
    return value;
}

######


protected void starting(Description description) {
    if (testSingleHost) {
        System.out.println("start test : " + description.getClassName() + "." + description.getMethodName());
        ttime = System.nanoTime();
    }
}

######


protected void finished(Description description) {
    if (testSingleHost) {
        Random random = new Random();
        int randInt = random.nextInt();
        try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT " + randInt)) {
            ResultSet rs = preparedStatement.executeQuery();
            assertTrue(rs.next());
            assertEquals(randInt, rs.getInt(1));
        } catch (Exception e) {
            e.printStackTrace();
            fail("Prepare after test fail for " + description.getClassName() + "." + description.getMethodName());
        }
    }
}

######


protected void succeeded(Description description) {
    if (testSingleHost) {
        System.out.println("finished test success : " + description.getClassName() + "." + description.getMethodName() + " after " + numberFormat.format(((double) System.nanoTime() - ttime) / 1000000) + " ms");
    }
}

######


protected void failed(Throwable throwable, Description description) {
    if (testSingleHost) {
        System.out.println("finished test failed : " + description.getClassName() + "." + description.getMethodName() + " after " + numberFormat.format(((double) System.nanoTime() - ttime) / 1000000) + " ms");
    }
}

######


@BeforeClass()
public static void beforeClassBaseTest() throws SQLException {
    String url = System.getProperty("dbUrl", mDefUrl);
    runLongTest = Boolean.parseBoolean(System.getProperty("runLongTest", "false"));
    testSingleHost = Boolean.parseBoolean(System.getProperty("testSingleHost", "true"));
    if (testSingleHost) {
        urlParser = UrlParser.parse(url + "&pool=true&maxPoolSize=2&minPoolSize=1");
        if (urlParser.getHostAddresses().size() > 0) {
            hostname = urlParser.getHostAddresses().get(0).host;
            port = urlParser.getHostAddresses().get(0).port;
        } else {
            hostname = null;
            port = 3306;
        }
        database = urlParser.getDatabase();
        username = urlParser.getUsername();
        password = urlParser.getPassword();
        int separator = url.indexOf("//");
        String urlSecondPart = url.substring(separator + 2);
        int dbIndex = urlSecondPart.indexOf("/");
        int paramIndex = urlSecondPart.indexOf("?");
        String additionalParameters;
        if ((dbIndex < paramIndex && dbIndex < 0) || (dbIndex > paramIndex && paramIndex > -1)) {
            additionalParameters = urlSecondPart.substring(paramIndex);
        } else if ((dbIndex < paramIndex && dbIndex > -1) || (dbIndex > paramIndex && paramIndex < 0)) {
            additionalParameters = urlSecondPart.substring(dbIndex);
        } else {
            additionalParameters = null;
        }
        if (additionalParameters != null) {
            String regex = "(\\/[^\\?]*)(\\?.+)*|(\\?[^\\/]*)(\\/.+)*";
            Pattern pattern = Pattern.compile(regex);
            Matcher matcher = pattern.matcher(additionalParameters);
            if (matcher.find()) {
                String options1 = (matcher.group(2) != null) ? matcher.group(2).substring(1) : "";
                String options2 = (matcher.group(3) != null) ? matcher.group(3).substring(1) : "";
                parameters = (options1.isEmpty()) ? options2 : options1;
            }
        } else {
            parameters = null;
        }
        setUri();
        urlParser.auroraPipelineQuirks();
        try {
            sharedConnection = MariaDbConnection.newConnection(urlParser, null);
        } catch (SQLException sqle) {
            System.out.println("Connection from pool fail :" + sqle.getMessage());
            sharedConnection = DriverManager.getConnection(url);
        }
        String dbVersion = sharedConnection.getMetaData().getDatabaseProductVersion();
        doPrecisionTest = isMariadbServer() || !dbVersion.startsWith("5.5");
    }
}

######


private static void setUri() {
    connU = "jdbc:mariadb://" + ((hostname == null) ? "localhost" : hostname) + ":" + port + "/" + ((database == null) ? "" : database);
    connUri = connU + "?user=" + username + (password != null && !"".equals(password) ? "&password=" + password : "") + (parameters != null ? "&" + parameters : "");
    connDnsUri = "jdbc:mariadb://mariadb.example.com:" + port + "/" + database + "?user=" + username + (password != null && !"".equals(password) ? "&password=" + password : "") + (parameters != null ? "&" + parameters : "");
}

######


@AfterClass
public static void afterClassBaseTest() throws SQLException {
    if (testSingleHost && sharedConnection != null && !sharedConnection.isClosed()) {
        if (!tempViewList.isEmpty()) {
            Statement stmt = sharedConnection.createStatement();
            for (String viewName : tempViewList) {
                try {
                    stmt.execute("DROP VIEW IF EXISTS " + viewName);
                } catch (SQLException e) {
                }
            }
        }
        if (!tempTableList.isEmpty()) {
            Statement stmt = sharedConnection.createStatement();
            for (String tableName : tempTableList) {
                try {
                    stmt.execute("DROP TABLE IF EXISTS " + tableName);
                } catch (SQLException e) {
                }
            }
        }
        if (!tempProcedureList.isEmpty()) {
            Statement stmt = sharedConnection.createStatement();
            for (String procedureName : tempProcedureList) {
                try {
                    stmt.execute("DROP procedure IF EXISTS " + procedureName);
                } catch (SQLException e) {
                }
            }
        }
        if (!tempFunctionList.isEmpty()) {
            Statement stmt = sharedConnection.createStatement();
            for (String functionName : tempFunctionList) {
                try {
                    stmt.execute("DROP FUNCTION IF EXISTS " + functionName);
                } catch (SQLException e) {
                }
            }
        }
        try {
            sharedConnection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    Iterator<Thread> it = Thread.getAllStackTraces().keySet().iterator();
    Thread thread;
    while (it.hasNext()) {
        thread = it.next();
        if (thread.getName().contains("MariaDb-bulk-")) {
            assertEquals(State.WAITING, thread.getState());
        }
    }
}

######


static void logInfo(String message) {
    System.out.println(message);
}

######


public static void createTable(String tableName, String tableColumns) throws SQLException {
    createTable(tableName, tableColumns, null);
}

######


public static void createTable(String tableName, String tableColumns, String engine) throws SQLException {
    if (testSingleHost) {
        Statement stmt = sharedConnection.createStatement();
        stmt.execute("drop table if exists " + tableName);
        stmt.execute("create table " + tableName + " (" + tableColumns + ") " + ((engine != null) ? engine : ""));
        if (!tempFunctionList.contains(tableName)) {
            tempTableList.add(tableName);
        }
    }
}

######


public static void createView(String viewName, String tableColumns) throws SQLException {
    if (testSingleHost) {
        Statement stmt = sharedConnection.createStatement();
        stmt.execute("drop view if exists " + viewName);
        stmt.execute("create view " + viewName + " AS (" + tableColumns + ") ");
        tempViewList.add(viewName);
    }
}

######


public static void createProcedure(String name, String body) throws SQLException {
    if (testSingleHost) {
        Statement stmt = sharedConnection.createStatement();
        stmt.execute("drop procedure IF EXISTS " + name);
        stmt.execute("create  procedure " + name + body);
        tempProcedureList.add(name);
    }
}

######


public static void createFunction(String name, String body) throws SQLException {
    if (testSingleHost) {
        Statement stmt = sharedConnection.createStatement();
        stmt.execute("drop function IF EXISTS " + name);
        stmt.execute("create function " + name + body);
        tempFunctionList.add(name);
    }
}

######


static boolean isMariadbServer() throws SQLException {
    if (testSingleHost) {
        DatabaseMetaData md = sharedConnection.getMetaData();
        return md.getDatabaseProductVersion().contains("MariaDB");
    }
    return false;
}

######


public static int getCurrentConnections() {
    try {
        Statement stmt = sharedConnection.createStatement();
        ResultSet rs = stmt.executeQuery("show status where `variable_name` = 'Threads_connected'");
        assertTrue(rs.next());
        return rs.getInt(2);
    } catch (SQLException e) {
        return -1;
    }
}

######


public boolean anonymousUser() throws SQLException {
    if (testSingleHost) {
        Statement stmt = sharedConnection.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM mysql.user u where u.Host='localhost' and u.User=''");
        return rs.next();
    }
    return false;
}

######


public Connection createProxyConnection(Properties info) throws SQLException {
    UrlParser tmpUrlParser = UrlParser.parse(connUri);
    username = tmpUrlParser.getUsername();
    hostname = tmpUrlParser.getHostAddresses().get(0).host;
    String sockethosts = "";
    HostAddress hostAddress;
    try {
        hostAddress = tmpUrlParser.getHostAddresses().get(0);
        proxy = new TcpProxy(hostAddress.host, hostAddress.port);
        sockethosts += "address=(host=localhost)(port=" + proxy.getLocalPort() + ")" + ((hostAddress.type != null) ? "(type=" + hostAddress.type + ")" : "");
    } catch (IOException e) {
        e.printStackTrace();
    }
    return openConnection("jdbc:mariadb://" + sockethosts + "/" + connUri.split("/")[3], info);
}

######


public void stopProxy(long millissecond) {
    proxy.restart(millissecond);
}

######


public void stopProxy() {
    proxy.stop();
}

######


public void delayProxy(int millissecond) {
    proxy.setDelay(millissecond);
}

######


public void removeDelayProxy() {
    proxy.removeDelay();
}

######


public void restartProxy() {
    proxy.restart();
}

######


public void closeProxy() {
    try {
        proxy.stop();
        proxy = null;
    } catch (Exception e) {
    }
}

######


@Before
public void init() {
    Assume.assumeTrue(testSingleHost);
}

######


public void assureBlackList(Connection connection) {
    AbstractMastersListener.clearBlacklist();
}

######


protected Protocol getProtocolFromConnection(Connection conn) throws Throwable {
    Method getProtocol = MariaDbConnection.class.getDeclaredMethod("getProtocol");
    getProtocol.setAccessible(true);
    Object obj = getProtocol.invoke(conn);
    return (Protocol) obj;
}

######


protected void setHostname(String hostname) throws SQLException {
    BaseTest.hostname = hostname;
    setUri();
    setConnection();
}

######


protected void setPort(int port) throws SQLException {
    BaseTest.port = port;
    setUri();
    setConnection();
}

######


protected void setDatabase(String database) throws SQLException {
    BaseTest.database = database;
    BaseTest.setUri();
    setConnection();
}

######


protected void setUsername(String username) throws SQLException {
    BaseTest.username = username;
    setUri();
    setConnection();
}

######


protected void setPassword(String password) throws SQLException {
    BaseTest.password = password;
    setUri();
    setConnection();
}

######


protected Connection setBlankConnection(String parameters) throws SQLException {
    return openConnection(connU + "?user=" + username + (password != null && !"".equals(password) ? "&password=" + password : "") + parameters, null);
}

######


protected Connection setConnection() throws SQLException {
    return openConnection(connUri, null);
}

######


protected Connection setConnection(Map<String, String> props) throws SQLException {
    Properties info = new Properties();
    for (String key : props.keySet()) {
        info.setProperty(key, props.get(key));
    }
    return openConnection(connU, info);
}

######


protected Connection setConnection(Properties info) throws SQLException {
    return openConnection(connUri, info);
}

######


protected Connection setConnection(String parameters) throws SQLException {
    return openConnection(connUri + parameters, null);
}

######


protected Connection setConnection(String additionalParameters, String database) throws SQLException {
    StringBuilder sb = new StringBuilder();
    sb.append("jdbc:mariadb://");
    if (hostname == null) {
        sb.append("localhost");
    } else {
        sb.append(hostname);
    }
    sb.append(":").append(port).append("/");
    if (database != null) {
        sb.append(database);
    }
    sb.append("?user=").append(username);
    if (password != null && !password.isEmpty()) {
        sb.append("&password=").append(password);
    }
    if (parameters != null && !parameters.isEmpty()) {
        sb.append("&").append(parameters);
    }
    sb.append(additionalParameters);
    return openConnection(sb.toString(), null);
}

######


protected Connection setDnsConnection(String parameters) throws SQLException {
    String connU = "jdbc:mariadb://mariadb.example.com:" + port + "/" + ((database == null) ? "" : database);
    String connUri = connU + "?user=" + username + (password != null && !"".equals(password) ? "&password=" + password : "") + (parameters != null ? "&" + parameters : "");
    return openConnection(connUri + parameters, null);
}

######


public Connection openConnection(String uri, Properties info) throws SQLException {
    if (info == null) {
        return DriverManager.getConnection(uri);
    } else {
        return DriverManager.getConnection(uri, info);
    }
}

######


protected Connection openNewConnection(String url) throws SQLException {
    return DriverManager.getConnection(url);
}

######


protected Connection openNewConnection(String url, Properties info) throws SQLException {
    return DriverManager.getConnection(url, info);
}

######


protected boolean isGalera() {
    try {
        Statement st = sharedConnection.createStatement();
        ResultSet rs = st.executeQuery("show status like 'wsrep_cluster_size'");
        if (rs.next()) {
            return rs.getInt(2) > 0;
        }
    } catch (SQLException sqle) {
    }
    return false;
}

######


public boolean checkMaxAllowedPacketMore8m(String testName) throws SQLException {
    Statement st = sharedConnection.createStatement();
    ResultSet rs = st.executeQuery("select @@max_allowed_packet");
    assertTrue(rs.next());
    long maxAllowedPacket = rs.getLong(1);
    if (maxAllowedPacket < 8 * 1024 * 1024L) {
        System.out.println("test '" + testName + "' skipped  due to server variable max_allowed_packet < 8M");
        return false;
    }
    return true;
}

######


public boolean checkMaxAllowedPacketMore20m(String testName) throws SQLException {
    return checkMaxAllowedPacketMore20m(testName, true);
}

######


public boolean checkMaxAllowedPacketMore20m(String testName, boolean displayMessage) throws SQLException {
    Statement st = sharedConnection.createStatement();
    ResultSet rs = st.executeQuery("select @@max_allowed_packet");
    assertTrue(rs.next());
    long maxAllowedPacket = rs.getLong(1);
    if (maxAllowedPacket < 20 * 1024 * 1024L) {
        if (displayMessage) {
            System.out.println("test '" + testName + "' skipped  due to server variable max_allowed_packet < 20M");
        }
        return false;
    }
    return true;
}

######


public boolean checkMaxAllowedPacketMore40m(String testName) throws SQLException {
    return checkMaxAllowedPacketMore40m(testName, true);
}

######


public boolean checkMaxAllowedPacketMore40m(String testName, boolean displayMsg) throws SQLException {
    Statement st = sharedConnection.createStatement();
    ResultSet rs = st.executeQuery("select @@max_allowed_packet");
    assertTrue(rs.next());
    long maxAllowedPacket = rs.getLong(1);
    if (maxAllowedPacket < 40 * 1024 * 1024L) {
        if (displayMsg) {
            System.out.println("test '" + testName + "' skipped  due to server variable max_allowed_packet < 40M");
        }
        return false;
    }
    return true;
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType("text/html");
    int empid = Integer.parseInt(request.getParameter("empid"));
    try {
        HttpSession session = request.getSession();
        calculateBasic(session, request, response);
    } catch (Exception e) {
        e.printStackTrace();
        if (empid == 11) {
            RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
            ReqDis.forward(request, response);
        } else {
            RequestDispatcher ReqDis = request.getRequestDispatcher("error.jsp");
            ReqDis.forward(request, response);
        }
    }
}

######


private void calculateBasic(HttpSession session, HttpServletRequest request, HttpServletResponse response) throws SQLException, ServletException, IOException {
    PrintWriter out = response.getWriter();
    DecimalFormat df = new DecimalFormat("#.##");
    float distance = Float.parseFloat(request.getParameter("distance"));
    int empid = Integer.parseInt(request.getParameter("empid"));
    String truckType = request.getParameter("Capacity");
    String param = request.getParameter("param");
    float backhaul = Float.parseFloat(request.getParameter("back"));
    String start = org.apache.commons.lang3.StringUtils.capitalize(request.getParameter("start"));
    String end = org.apache.commons.lang3.StringUtils.capitalize(request.getParameter("end"));
    session.setAttribute("start", start);
    session.setAttribute("end", end);
    session.setAttribute("distance", distance);
    session.setAttribute("cap", truckType);
    session.setAttribute("param", param);
    session.setAttribute("back", backhaul);
    float intrest1 = 0, costOfTyre = 0, costOfTruck = 0, loan = 0, noOfYears = 0, residualValue = 0, noOfTyre = 0, costOfTyreUsed = 0, tyreLife = 0, tyreLifeUsed = 0, mileage = 0, noTrips = 0;
    float mileageWithLoad = 0, diesel = 0, roi = 0;
    int cap = 0;
    Connection con = Connect.getconnection();
    PreparedStatement ps = con.prepareStatement("select * from truckparam where typeofgood=?");
    ps.setString(1, truckType);
    ResultSet rs = ps.executeQuery();
    while (rs.next()) {
        costOfTruck = rs.getFloat("costoftruck");
        loan = rs.getFloat("loanpercentage");
        intrest1 = rs.getFloat("rateofintrest");
        roi = rs.getFloat("flatroi");
        costOfTyre = rs.getFloat("tyrecost");
        noOfYears = rs.getFloat("yearsemi");
        residualValue = rs.getFloat("residualvalueoftruck");
        noOfTyre = rs.getFloat("tyres");
        costOfTyreUsed = rs.getFloat("reusedtyrecost");
        tyreLife = rs.getFloat("tyrelife");
        tyreLifeUsed = rs.getFloat("reusedtyrelife");
        mileage = rs.getFloat("dieselmileage");
        mileageWithLoad = rs.getFloat("diesealmileagewithload");
        diesel = rs.getFloat("dieselcost");
        cap = rs.getInt("capacity");
    }
    PreparedStatement ps0 = con.prepareStatement("select `NoofTrip` from `slabtable` WHERE `Min Distance` <= ? AND `Max Distance` >?");
    ps0.setInt(1, (int) distance);
    ps0.setInt(2, (int) distance);
    ResultSet rs0 = ps0.executeQuery();
    while (rs0.next()) {
        noTrips = rs0.getFloat("NoofTrip");
    }
    float cost = calculateTyreCostPerKM(noOfTyre, costOfTyre, costOfTyreUsed, tyreLife, tyreLifeUsed);
    float loanamount = calculateLoanAmount(loan, costOfTruck);
    float paid = calculatePaid(costOfTruck, loanamount);
    float residualValueTruck = calulateResidualValueOfTruck(residualValue, costOfTruck);
    float depreciation = calculateDepreciation(costOfTruck, residualValueTruck, noOfYears);
    float interestcost = calculateInterestCostPerMonth(roi, loanamount);
    float netMileage = calculateNetMilage(mileageWithLoad, backhaul, mileage);
    float roundtrip = calculateRoundTrip(distance);
    float distanceTravled = calculateKmRunPerMonthAvg(roundtrip, noTrips);
    PreparedStatement ps1 = con.prepareStatement("UPDATE truckparam SET loanamount=" + loanamount + ",amountpaid=" + paid + ",kmrunpermonthaverage=" + distanceTravled + ",tyrecostperkm=" + cost + ",roundTrip=" + roundtrip + "WHERE typeofgood=?");
    ps1.setString(1, truckType);
    ps1.executeUpdate();
    float Salary = 0, batta = 0, maintenance = 0, Admin = 0, tarpaulin = 0;
    float expense = 0, totaltoll = 0, insurancepercent = 0, permit = 0, tax = 0;
    float maintenancePerKm = 0, loading = 0;
    float pro = 0;
    PreparedStatement ps2 = con.prepareStatement("select * from routeparam where typeofgood=?");
    ps2.setString(1, truckType);
    ResultSet rs1 = ps2.executeQuery();
    while (rs1.next()) {
        expense = rs1.getFloat("routeexpenses");
        totaltoll = rs1.getFloat("toll");
        insurancepercent = rs1.getFloat("insuranceaspercentageofvechiclecost");
        permit = rs1.getFloat("roadpermityear");
        tax = rs1.getFloat("roadtaxyear");
        Salary = rs1.getFloat("driver/cleaner salary");
        batta = rs1.getFloat("driver/cleaner bhatta");
        maintenance = rs1.getFloat("maintenancepermonth");
        Admin = rs1.getFloat("admin costs");
        maintenancePerKm = rs1.getFloat("maintenancecostperkm");
        tarpaulin = rs1.getFloat("tarpaulin");
        loading = rs1.getFloat("loadingcharges");
        pro = rs1.getInt("profitmargin");
    }
    float toll = calculateTollPerKm(totaltoll, distance);
    float unloading = calculateUnloadingCharges(cap);
    float unloadingloading = unloading + loading;
    float dieselCost = calculateDieselCostPerKm(diesel, netMileage);
    float variableCost = calculateVaribleCostperKm(dieselCost, toll, cost, maintenancePerKm, expense);
    float variable = calculateVaribleCostperMonth(variableCost, distanceTravled, unloadingloading);
    float insuranceMonth = calculateInsurancePerMonth(costOfTruck, insurancepercent);
    float roadPermit = calculateRoadPermitPerMonth(permit);
    float roadTax = calculateRoadTaxPerMonth(tax);
    float fixedcostperMonth = calculatefixedCostPerMonth(roadTax, roadPermit, insuranceMonth, Salary, batta, maintenance, Admin, tarpaulin, depreciation, interestcost);
    float monthlyoperating = calculateMonthlyOperatingCost(fixedcostperMonth, variable);
    float profit = calculateProfitMargin(fixedcostperMonth, pro);
    double perKmCost = calculatePerKmCost(profit, monthlyoperating, distanceTravled);
    float monthlyTon = calculateMonthlyTons(cap, backhaul, noTrips);
    float fixedPTPK = calculateFixedPTPK(fixedcostperMonth, roundtrip, cap, noTrips, backhaul);
    float variablePTPK = calculateVariablePTPK(variable, roundtrip, cap, noTrips, backhaul);
    float profitPTPK = calculateProfitPTPK(profit, roundtrip, cap, noTrips, backhaul);
    float totalPTPK = calculateTotalPTPK(profitPTPK, variablePTPK, fixedPTPK);
    float freightPerTon = calculateFreightPerTon(totalPTPK, distance);
    float emi = 0;
    float cashInflow = 0;
    float cashFlowPerMonth = 0;
    float irr = 0;
    float workingCapital = 0;
    session.setAttribute("fixedptpk", fixedPTPK);
    session.setAttribute("variableptpk", variablePTPK);
    session.setAttribute("profitptpk", profitPTPK);
    session.setAttribute("ptpk", totalPTPK);
    session.setAttribute("freightPerTon", freightPerTon);
    PreparedStatement ps3 = con.prepareStatement("UPDATE routeparam SET backhaul='" + backhaul + "',distance='" + distance + "',unloadingchages='" + unloading + "',loadingunloadingcharges='" + unloadingloading + "',variblecostperkm='" + variableCost + "',variblecostpermonth='" + variable + "',insurancepermonth='" + insuranceMonth + "',workingcapitalinterestcost='" + workingCapital + "',roadpermitmonth='" + roadPermit + "',roadtaxmonth='" + roadTax + "',monthlyoperatingcost='" + monthlyoperating + "',perkmcost='" + perKmCost + "',monthlytons='" + monthlyTon + "',fixedptpk='" + fixedPTPK + "',variableptpk='" + variablePTPK + "', profitptpk='" + profitPTPK + "', totalptpk='" + totalPTPK + "', freightperton='" + freightPerTon + "' WHERE typeofgood=?");
    PreparedStatement ps31 = con.prepareStatement("UPDATE routeparam SET origin=? ,destination=? WHERE typeofgood=?");
    ps3.setString(1, truckType);
    ps3.executeUpdate();
    ps31.setString(1, start);
    ps31.setString(2, end);
    ps31.setString(3, truckType);
    ps31.executeUpdate();
    float costs = cap * distance * totalPTPK;
    session.setAttribute("cost", costs);
    session.setAttribute("profitkm", df.format(profit / distanceTravled));
    session.setAttribute("variablekm", variableCost);
    session.setAttribute("fixedkm", df.format((fixedcostperMonth + profit) / distanceTravled));
    session.setAttribute("variableton", df.format(variable / monthlyTon));
    session.setAttribute("profitton", df.format(profit / monthlyTon));
    session.setAttribute("fixedton", df.format((fixedcostperMonth + profit) / monthlyTon));
    session.setAttribute("dep", df.format(depreciation));
    session.setAttribute("intres", df.format(interestcost));
    session.setAttribute("salr", df.format(Salary));
    session.setAttribute("insu", df.format(insuranceMonth));
    session.setAttribute("rota", df.format(roadTax));
    session.setAttribute("dies", df.format(dieselCost));
    session.setAttribute("tole", df.format(totaltoll));
    session.setAttribute("tyres", df.format(cost));
    session.setAttribute("routes", df.format(expense));
    session.setAttribute("maint", df.format(maintenancePerKm));
    if (empid == 11) {
        RequestDispatcher ReqDis = request.getRequestDispatcher("AdminResultBasic.jsp");
        ReqDis.forward(request, response);
    } else {
        RequestDispatcher ReqDis = request.getRequestDispatcher("ResultBasic.jsp");
        ReqDis.forward(request, response);
    }
}

######


private float calculateProfitMargin(float fixedcostperMonth, float pro) {
    return (fixedcostperMonth * pro) / 100;
}

######


private float calculateProfit(float monthlyoperating) {
    return (float) ((0.0752688172043011) * monthlyoperating);
}

######


private float calculateKmRunPerMonthAvg(float roundtrip, float noTrips) {
    return (roundtrip * noTrips);
}

######


private float calculateVaribleCostperMonth(float variableCost, float distanceTravled, float unloadingloading) {
    return ((variableCost * distanceTravled) + unloadingloading);
}

######


private float calculateTotalPTPK(float profitPTPK, float variablePTPK, float fixedPTPK) {
    return (profitPTPK + variablePTPK + fixedPTPK);
}

######


private float calculateProfitPTPK(float profit, float roundtrip, int cap, float noTrips, float backhaul) {
    return (profit / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateVariablePTPK(float variable, float roundtrip, int cap, float noTrips, float backhaul) {
    return (variable / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateFixedPTPK(float fixedcostperMonth, float roundtrip, int cap, float noTrips, float backhaul) {
    return (fixedcostperMonth / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateFreightPerTon(float totalPTPK, float distance) {
    return (totalPTPK * distance);
}

######


private float calculateRoundTrip(float distance) {
    return (distance * 2);
}

######


private float calculateTotalCostPerTon(float totalPTPK, float distance, int cap) {
    return (totalPTPK * distance * cap);
}

######


private float calculateMonthlyTons(int cap, float backhaul, float noTrips) {
    return (noTrips * cap * (1 + (backhaul / 100)));
}

######


private float calculatePerKmCost(float profitMargin, float monthlyoperating, float distanceTravled) {
    return ((profitMargin + monthlyoperating) / distanceTravled);
}

######


private float calculateMonthlyOperatingCost(float fixedcostperMonth, float variable) {
    return (fixedcostperMonth + variable);
}

######


private float calculatefixedCostPerMonth(float roadTax, float roadPermit, float insuranceMonth, float salary, float batta, float maintenance, float admin, float tarpaulin, float depreciation, float interestcost) {
    return (admin + batta + insuranceMonth + maintenance + roadPermit + roadTax + salary + tarpaulin + depreciation + interestcost);
}

######


private float calculateRoadTaxPerMonth(float tax) {
    return (tax / 12);
}

######


private float calculateRoadPermitPerMonth(float permit) {
    return (permit / 12);
}

######


private float calculateInsurancePerMonth(float costOfTruck, float insurancepercent) {
    return ((costOfTruck * insurancepercent) / 1200);
}

######


private float calculateVaribleCostperKm(float dieselCost, float toll, float cost, float maintenancePerKm, float route) {
    return (dieselCost + toll + cost + maintenancePerKm + route);
}

######


private float calculateRouteExpence(float expense, float distance) {
    return (expense / distance);
}

######


private float calculateUnloadingCharges(int cap) {
    return (45 * cap);
}

######


private float calculateDieselCostPerKm(float diesel, float netMileage) {
    return (diesel / netMileage);
}

######


private float calculateNetMilage(float mileageWithLoad, float backhaul, float mileage) {
    return (((mileageWithLoad * 100 + (mileageWithLoad * backhaul)) + (mileage) * (100 - backhaul)) / 200);
}

######


private float calculateTollPerKm(float totaltoll, float distance) {
    return (totaltoll / distance);
}

######


private float calulateResidualValueOfTruck(float residualValue, float costOfTruck) {
    return (costOfTruck * residualValue / 100);
}

######


private float calculateInterestCostPerMonth(float roi, float loanamount) {
    return ((roi * loanamount) / 1200);
}

######


private float calculateDepreciation(float costOfTruck, float residualValue, float noOfYears) {
    return (((costOfTruck - residualValue) / noOfYears) / 12);
}

######


private float calculatePaid(float costOfTruck, float loanamount) {
    return (costOfTruck - loanamount);
}

######


private float calculateLoanAmount(float loan, float costOfTruck) {
    return ((costOfTruck * loan) / 100);
}

######


private float calculateTyreCostPerKM(float noOfTyre, float costOfTyre, float costOfTyreUsed, float tyreLife, float tyreLifeUsed) {
    return (noOfTyre * (costOfTyre + costOfTyreUsed) / (tyreLife + tyreLifeUsed));
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("test_batch", "id int not null primary key auto_increment, test varchar(10)");
    createTable("test_batch2", "id int not null primary key auto_increment, test varchar(10)");
    createTable("test_batch3", "id int not null primary key auto_increment, test varchar(10)");
    createTable("batchUpdateException", "i int,PRIMARY KEY (i)");
    createTable("batchPrepareUpdateException", "i int,PRIMARY KEY (i)");
    createTable("rewritetest", "id int not null primary key, a varchar(10), b int", "engine=innodb");
    createTable("rewritetest2", "id int not null primary key, a varchar(10), b int", "engine=innodb");
    createTable("bug501452", "id int not null primary key, value varchar(20)");
}

######


@Test
public void batchTest() throws SQLException {
    Assume.assumeFalse(sharedIsRewrite());
    PreparedStatement ps = sharedConnection.prepareStatement("insert into test_batch values (null, ?)", Statement.RETURN_GENERATED_KEYS);
    ps.setString(1, "aaa");
    ps.addBatch();
    ps.setString(1, "bbb");
    ps.addBatch();
    ps.setString(1, "ccc");
    ps.addBatch();
    int[] batchResult = ps.executeBatch();
    ResultSet rs1 = ps.getGeneratedKeys();
    int[] autoInc = setAutoInc();
    for (int count = 1; count <= 3; count++) {
        assertTrue(rs1.next());
        assertTrue(String.valueOf(autoInc[0] * count + autoInc[1]).equalsIgnoreCase(rs1.getString(1)));
    }
    for (int unitInsertNumber : batchResult) {
        assertEquals(1, unitInsertNumber);
    }
    ps.setString(1, "aaa");
    ps.addBatch();
    ps.setString(1, "bbb");
    ps.addBatch();
    ps.setString(1, "ccc");
    ps.addBatch();
    batchResult = ps.executeBatch();
    for (int unitInsertNumber : batchResult) {
        assertEquals(1, unitInsertNumber);
    }
    final ResultSet rs = sharedConnection.createStatement().executeQuery("select * from test_batch");
    ps.executeQuery("SELECT 1");
    try {
        rs1 = ps.getGeneratedKeys();
        fail();
    } catch (SQLException sqle) {
        assertEquals("Cannot return generated keys : query was not set with Statement.RETURN_GENERATED_KEYS", sqle.getMessage());
    }
    assertFalse(rs1.next());
    assertEquals(true, rs.next());
    assertEquals("aaa", rs.getString(2));
    assertEquals(true, rs.next());
    assertEquals("bbb", rs.getString(2));
    assertEquals(true, rs.next());
    assertEquals("ccc", rs.getString(2));
}

######


@Test
public void batchTestStmtUsingPipeline() throws SQLException {
    batchTestStmt(sharedConnection);
}

######


@Test
public void batchTestStmtWithoutPipeline() throws SQLException {
    try (Connection connection = setConnection("&useBatchMultiSend=false")) {
        batchTestStmt(connection);
    }
}

######


private void batchTestStmt(Connection connection) throws SQLException {
    Statement stmt = connection.createStatement();
    stmt.execute("truncate test_batch2");
    stmt.addBatch("insert into test_batch2 values (null, 'hej1')");
    stmt.addBatch("insert into test_batch2 values (null, 'hej2')");
    stmt.addBatch("insert into test_batch2 values (null, 'hej3')");
    stmt.addBatch("insert into test_batch2 values (null, 'hej4')");
    int[] inserts = stmt.executeBatch();
    assertEquals(4, inserts.length);
    assertEquals(1, inserts[0]);
    assertEquals(1, inserts[1]);
    assertEquals(1, inserts[2]);
    assertEquals(1, inserts[3]);
    int[] autoInc = setAutoInc();
    ResultSet rs = stmt.executeQuery("select * from test_batch2");
    for (int i = 1; i <= 4; i++) {
        assertEquals(true, rs.next());
        assertEquals(autoInc[1] + i * autoInc[0], rs.getInt(1));
        assertEquals("hej" + i, rs.getString(2));
    }
    assertEquals(false, rs.next());
}

######


@Test
public void batchUpdateException() throws Exception {
    Statement st = sharedConnection.createStatement();
    st.addBatch("insert into batchUpdateException values(1)");
    st.addBatch("insert into batchUpdateException values(2)");
    st.addBatch("insert into batchUpdateException values(1)");
    st.addBatch("insert into batchUpdateException values(3)");
    try {
        st.executeBatch();
        fail("exception should be throw above");
    } catch (BatchUpdateException bue) {
        int[] updateCounts = bue.getUpdateCounts();
        assertEquals(4, updateCounts.length);
        if (sharedIsRewrite()) {
            assertEquals(1, updateCounts[0]);
            assertEquals(1, updateCounts[1]);
            assertEquals(Statement.EXECUTE_FAILED, updateCounts[2]);
            assertEquals(Statement.EXECUTE_FAILED, updateCounts[3]);
        } else {
            assertEquals(1, updateCounts[0]);
            assertEquals(1, updateCounts[1]);
            assertEquals(Statement.EXECUTE_FAILED, updateCounts[2]);
            assertEquals(1, updateCounts[3]);
        }
        assertTrue(bue.getCause() instanceof SQLIntegrityConstraintViolationException);
    }
}

######


@Test
public void batchPrepareUpdateException() throws Exception {
    PreparedStatement st = sharedConnection.prepareStatement("insert into batchPrepareUpdateException values(?)");
    st.setInt(1, 1);
    st.addBatch();
    st.setInt(1, 2);
    st.addBatch();
    st.setInt(1, 1);
    st.addBatch();
    st.setInt(1, 3);
    st.addBatch();
    try {
        st.executeBatch();
        fail("exception should be throw above");
    } catch (BatchUpdateException bue) {
        int[] updateCounts = bue.getUpdateCounts();
        assertEquals(4, updateCounts.length);
        if (sharedIsRewrite() || (sharedOptions().useBulkStmts && isMariadbServer() && minVersion(10, 2))) {
            assertEquals(Statement.EXECUTE_FAILED, updateCounts[0]);
            assertEquals(Statement.EXECUTE_FAILED, updateCounts[1]);
            assertEquals(Statement.EXECUTE_FAILED, updateCounts[2]);
            assertEquals(Statement.EXECUTE_FAILED, updateCounts[3]);
        } else {
            assertEquals(1, updateCounts[0]);
            assertEquals(1, updateCounts[1]);
            assertEquals(Statement.EXECUTE_FAILED, updateCounts[2]);
            assertEquals(1, updateCounts[3]);
        }
        assertTrue(bue.getCause() instanceof SQLIntegrityConstraintViolationException);
    }
}

######


@Test
public void testBatchLoop() throws SQLException {
    PreparedStatement ps = sharedConnection.prepareStatement("insert into rewritetest values (?,?,?)");
    for (int i = 0; i < 10; i++) {
        ps.setInt(1, i);
        ps.setString(2, "bbb" + i);
        ps.setInt(3, 30 + i);
        ps.addBatch();
    }
    ps.executeBatch();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from rewritetest");
    int counter = 0;
    while (rs.next()) {
        assertEquals(counter++, rs.getInt("id"));
    }
    assertEquals(10, counter);
}

######


@Test
public void testBatchLoopWithDupKey() throws SQLException {
    PreparedStatement ps = sharedConnection.prepareStatement("insert into rewritetest2 values (?,?,?) on duplicate key update a=values(a)");
    for (int i = 0; i < 2; i++) {
        ps.setInt(1, 0);
        ps.setString(2, "bbb" + i);
        ps.setInt(3, 30 + i);
        ps.addBatch();
    }
    ps.executeBatch();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from rewritetest2");
    int counter = 0;
    while (rs.next()) {
        assertEquals(counter++, rs.getInt("id"));
    }
    assertEquals(1, counter);
}

######


@Test
public void testBug501452() throws SQLException {
    PreparedStatement ps = sharedConnection.prepareStatement("insert into bug501452 (id,value) values (?,?)");
    ps.setObject(1, 1);
    ps.setObject(2, "value for 1");
    ps.addBatch();
    ps.executeBatch();
    ps.setObject(1, 2);
    ps.setObject(2, "value for 2");
    ps.addBatch();
    ps.executeBatch();
}

######


@Test
public void testMultipleStatementBatch() throws SQLException {
    try (Connection connection = setConnection("&sessionVariables=auto_increment_increment=2&allowMultiQueries=true")) {
        Statement stmt = connection.createStatement();
        stmt.addBatch("INSERT INTO test_batch3(test) value ('a')");
        stmt.addBatch("INSERT INTO test_batch3(test) value ('b')");
        stmt.addBatch("INSERT INTO test_batch3(test) value ('a'), ('e')");
        stmt.addBatch("UPDATE test_batch3 set test='c' WHERE test = 'a'");
        stmt.addBatch("UPDATE test_batch3 set test='d' WHERE test = 'b'");
        stmt.addBatch("INSERT INTO test_batch3(test) value ('e')");
        int[] updateCount = stmt.executeBatch();
        assertEquals(6, updateCount.length);
        assertEquals(1, updateCount[0]);
        assertEquals(1, updateCount[1]);
        assertEquals(2, updateCount[2]);
        assertEquals(2, updateCount[3]);
        assertEquals(1, updateCount[4]);
        assertEquals(1, updateCount[5]);
        assertEquals(-1, stmt.getUpdateCount());
        assertFalse(stmt.getMoreResults());
        ResultSet resultSet = stmt.getGeneratedKeys();
        int[] autoInc = setAutoInc(2, -1);
        assertTrue(resultSet.next());
        assertEquals(autoInc[1] + autoInc[0], resultSet.getInt(1));
        assertTrue(resultSet.next());
        assertEquals(autoInc[1] + 2 * autoInc[0], resultSet.getInt(1));
        assertTrue(resultSet.next());
        assertEquals(autoInc[1] + 3 * autoInc[0], resultSet.getInt(1));
        assertTrue(resultSet.next());
        assertEquals(autoInc[1] + 4 * autoInc[0], resultSet.getInt(1));
        assertTrue(resultSet.next());
        assertEquals(autoInc[1] + 5 * autoInc[0], resultSet.getInt(1));
        assertFalse(resultSet.next());
    }
}

######


@Test
public void testBatchString() throws SQLException {
    Assume.assumeTrue(runLongTest && (sharedOptions().useBulkStmts || sharedIsRewrite()));
    createTable("testBatchString", "charValue VARCHAR(100) NOT NULL");
    Statement stmt = sharedConnection.createStatement();
    String[] datas = new String[1_000_000];
    String empty = "____________________________________________________________________________________________________";
    for (int i = 0; i < datas.length; i++) {
        datas[i] = (String.valueOf(i) + empty).substring(0, 100);
    }
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO testBatchString (charValue) values (?)")) {
        for (String data : datas) {
            preparedStatement.setString(1, data);
            preparedStatement.addBatch();
        }
        preparedStatement.executeBatch();
    }
    stmt.setFetchSize(100);
    ResultSet rs = stmt.executeQuery("SELECT charValue FROM testBatchString");
    int counter = 0;
    while (rs.next()) {
        assertEquals(datas[counter++], rs.getString(1));
    }
    assertEquals(datas.length, counter);
}

######


@Bean
Job personEtl(JobBuilderFactory jobBuilderFactory, StepBuilderFactory stepBuilderFactory, FlatFileItemReader<Person> reader, JdbcBatchItemWriter<Person> writer) {
    Step step = stepBuilderFactory.get("file-to-database").<Person, Person>chunk(5).reader(reader).writer(writer).build();
    return jobBuilderFactory.get("etl").start(step).build();
}

######


@Bean
@StepScope
FlatFileItemReader<Person> flatFileItemReader(@Value("#{jobParameters[file]}") File file) {
    FlatFileItemReader<Person> flatFileItemReader = new FlatFileItemReader<>();
    flatFileItemReader.setResource(new FileSystemResource(file));
    flatFileItemReader.setLineMapper(new DefaultLineMapper<Person>() {

        {
            this.setLineTokenizer(new DelimitedLineTokenizer(",") {

                {
                    this.setNames(new String[] { "first", "last", "email" });
                }
            });
            this.setFieldSetMapper(new BeanWrapperFieldSetMapper<Person>() {

                {
                    this.setTargetType(Person.class);
                }
            });
        }
    });
    return flatFileItemReader;
}

######


@Bean
JdbcBatchItemWriter<Person> jdbcBatchItemWriter(DataSource h2) {
    JdbcBatchItemWriter<Person> jdbcBatchItemWriter = new JdbcBatchItemWriter<>();
    jdbcBatchItemWriter.setDataSource(h2);
    jdbcBatchItemWriter.setSql("insert into PEOPLE(first, last, email) values ( :first, :last, :email )");
    jdbcBatchItemWriter.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>());
    return jdbcBatchItemWriter;
}

######


CommandLineRunner runner(JobLauncher launcher, Job job, @Value("${file}") File in, JdbcTemplate jdbcTemplate) {
    return args -> {
        JobExecution execution = launcher.run(job, new JobParametersBuilder().addString("file", in.getAbsolutePath()).toJobParameters());
        System.out.println("Job execution status: " + execution.getExitStatus().toString());
        jdbcTemplate.query("select * from PEOPLE", (resultSet, i) -> new Person(resultSet.getString("first"), resultSet.getString("last"), resultSet.getString("email"))).forEach(System.out::println);
        ;
    };
}

######


public static void main(String[] args) throws ClassNotFoundException, SQLException {
    Class.forName("org.postgresql.Driver");
    String sql = "insert into usergraph (id, username) values (?, ?)";
    Connection connection = null;
    connection = DriverManager.getConnection("jdbc:postgresql://localhost:5432/myDB", "postgres", "maxpayne");
    PreparedStatement ps = connection.prepareStatement(sql);
    final int batchSize = 1000;
    int count = 0;
    for (int i = 1; i <= N_NODES; i++) {
        ps.setLong(1, i);
        ps.setString(2, "" + i);
        ps.addBatch();
        if (++count % batchSize == 0) {
            ps.executeBatch();
        }
    }
    ps.executeBatch();
    sql = "INSERT INTO friendship(id, userone_id, usertwo_id) VALUES (?, ?, ?)";
    ps = connection.prepareStatement(sql);
    int random, random2;
    for (int i = 1; i <= N_RELATIONS; i++) {
        random = (int) (Math.random() * ((N_NODES) + 1)) + 1;
        random2 = (int) (Math.random() * ((N_NODES) + 1)) + 1;
        if (random <= N_NODES && random2 <= N_NODES) {
            ps.setLong(1, i);
            ps.setLong(2, random);
            ps.setLong(3, random2);
            ps.addBatch();
            if (++count % batchSize == 0) {
                ps.executeBatch();
            }
            if (i % 50000 == 0)
                System.out.println(i);
        }
    }
    ps.executeBatch();
    ps.close();
    connection.close();
}

######


@Before
public void setUp() throws Exception {
    Connection conn = null;
    try {
        Class.forName("org.hsqldb.jdbcDriver");
        conn = DriverManager.getConnection("jdbc:hsqldb:mem:batch_keys", "sa", "");
        Reader reader = Resources.getResourceAsReader("org/apache/ibatis/submitted/batch_keys/CreateDB.sql");
        ScriptRunner runner = new ScriptRunner(conn);
        runner.setLogWriter(null);
        runner.setErrorLogWriter(new PrintWriter(System.err));
        runner.runScript(reader);
        conn.commit();
        reader.close();
        reader = Resources.getResourceAsReader("org/apache/ibatis/submitted/batch_keys/Config.xml");
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
        reader.close();
    } finally {
        if (conn != null) {
            conn.close();
        }
    }
}

######


public void testJdbc3Support() throws Exception {
    Connection conn = sqlSessionFactory.getConfiguration().getEnvironment().getDataSource().getConnection();
    PreparedStatement stmt = conn.prepareStatement("insert into users2 values(null, 'Pocoyo')", Statement.RETURN_GENERATED_KEYS);
    stmt.addBatch();
    stmt.executeBatch();
    ResultSet rs = stmt.getGeneratedKeys();
    if (rs.next()) {
        ResultSetMetaData rsmd = rs.getMetaData();
        int colCount = rsmd.getColumnCount();
        do {
            for (int i = 1; i <= colCount; i++) {
                String key = rs.getString(i);
                System.out.println("key " + i + " is " + key);
            }
        } while (rs.next());
    } else {
        System.out.println("There are no generated keys.");
    }
    stmt.close();
    conn.close();
}

######


@Test
public void testInsert() throws Exception {
    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
    try {
        User user1 = new User(null, "Pocoyo");
        sqlSession.insert("insert", user1);
        User user2 = new User(null, "Valentina");
        sqlSession.insert("insert", user2);
        sqlSession.flushStatements();
        assertEquals(new Integer(50), user1.getId());
        assertEquals(new Integer(50), user2.getId());
        sqlSession.commit();
    } finally {
        sqlSession.close();
    }
    try {
        sqlSession = sqlSessionFactory.openSession();
        List<User> users = sqlSession.selectList("select");
        Assert.assertTrue(users.size() == 2);
    } finally {
        sqlSession.close();
    }
}

######


@Test
public void testInsertJdbc3() throws Exception {
    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
    try {
        User user1 = new User(null, "Pocoyo");
        sqlSession.insert("insertIdentity", user1);
        User user2 = new User(null, "Valentina");
        sqlSession.insert("insertIdentity", user2);
        sqlSession.flushStatements();
        assertEquals(Integer.valueOf(0), user1.getId());
        assertEquals(Integer.valueOf(1), user2.getId());
        sqlSession.commit();
    } finally {
        sqlSession.close();
    }
    try {
        sqlSession = sqlSessionFactory.openSession();
        List<User> users = sqlSession.selectList("selectIdentity");
        Assert.assertTrue(users.size() == 2);
    } finally {
        sqlSession.close();
    }
}

######


@Test
public void testInsertWithMapper() throws Exception {
    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
    try {
        Mapper userMapper = sqlSession.getMapper(Mapper.class);
        User user1 = new User(null, "Pocoyo");
        userMapper.insert(user1);
        User user2 = new User(null, "Valentina");
        userMapper.insert(user2);
        sqlSession.flushStatements();
        assertEquals(new Integer(50), user1.getId());
        assertEquals(new Integer(50), user2.getId());
        sqlSession.commit();
    } finally {
        sqlSession.close();
    }
    try {
        sqlSession = sqlSessionFactory.openSession();
        List<User> users = sqlSession.selectList("select");
        Assert.assertTrue(users.size() == 2);
    } finally {
        sqlSession.close();
    }
}

######


@Test
public void testInsertMapperJdbc3() throws Exception {
    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
    try {
        Mapper userMapper = sqlSession.getMapper(Mapper.class);
        User user1 = new User(null, "Pocoyo");
        userMapper.insertIdentity(user1);
        User user2 = new User(null, "Valentina");
        userMapper.insertIdentity(user2);
        sqlSession.flushStatements();
        assertEquals(Integer.valueOf(0), user1.getId());
        assertEquals(Integer.valueOf(1), user2.getId());
        sqlSession.commit();
    } finally {
        sqlSession.close();
    }
    try {
        sqlSession = sqlSessionFactory.openSession();
        List<User> users = sqlSession.selectList("selectIdentity");
        Assert.assertTrue(users.size() == 2);
    } finally {
        sqlSession.close();
    }
}

######


@Test
public void testInsertMapperNoBatchJdbc3() throws Exception {
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
        Mapper userMapper = sqlSession.getMapper(Mapper.class);
        User user1 = new User(null, "Pocoyo");
        userMapper.insertIdentity(user1);
        assertEquals(Integer.valueOf(0), user1.getId());
        sqlSession.commit();
    } finally {
        sqlSession.close();
    }
    try {
        sqlSession = sqlSessionFactory.openSession();
        List<User> users = sqlSession.selectList("selectIdentity");
        Assert.assertTrue(users.size() == 1);
    } finally {
        sqlSession.close();
    }
}

######


public static void main(String[] args) throws Exception {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
    DataSource ds = (DataSource) ctx.getBean("dataSource");
    Connection conn = ds.getConnection();
    PreparedStatement pstmt = conn.prepareStatement("insert into news_inf value(null , ? , ?)");
    pstmt.setString(1, "���Java����");
    pstmt.setString(2, "Struts 2Ȩ��ָ��");
    pstmt.executeUpdate();
    pstmt.close();
    conn.close();
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("bigblob", "id int not null primary key auto_increment, test longblob");
    createTable("bigblob2", "id int not null primary key auto_increment, test longblob, test2 longblob");
    createTable("bigblob3", "id int not null primary key auto_increment, test longblob, test2 longblob, test3 varchar(20)");
    createTable("bigblob4", "test longblob");
    createTable("bigblob5", "id int not null primary key auto_increment, test longblob, test2 text");
    createTable("bigblob6", "id int not null primary key auto_increment, test longblob");
}

######


@Test
public void sendBigQuery2() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore40m("sendBigQuery2"));
    char[] arr = new char[20000000];
    for (int i = 0; i < arr.length; i++) {
        arr[i] = (char) ('a' + (i % 10));
    }
    Statement stmt = sharedConnection.createStatement();
    String query = "INSERT INTO bigblob VALUES (null, '" + String.valueOf(arr) + "')";
    stmt.executeUpdate(query);
    ResultSet rs = stmt.executeQuery("select * from bigblob");
    assertTrue(rs.next());
    byte[] newBytes = rs.getBytes(2);
    assertEquals(arr.length, newBytes.length);
    for (int i = 0; i < arr.length; i++) {
        assertEquals(arr[i], newBytes[i]);
    }
}

######


@Test
public void sendBigPreparedQueryFe() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore20m("sendBigPreparedQueryFe"));
    byte[] arr = new byte[20000000];
    Arrays.fill(arr, (byte) 0xfe);
    try (Connection connection = setConnection("&useCompression=true")) {
        PreparedStatement ps = connection.prepareStatement("insert into bigblob6 values(null, ?)");
        ps.setBytes(1, arr);
        ps.executeUpdate();
        ps.setBytes(1, arr);
        ps.executeUpdate();
        Statement stmt = connection.createStatement();
        ResultSet rs = stmt.executeQuery("select test from bigblob6");
        rs.next();
        byte[] newBytes = rs.getBytes(1);
        assertEquals(arr.length, newBytes.length);
        for (int i = 0; i < arr.length; i++) {
            assertEquals(arr[i], newBytes[i]);
        }
    }
}

######


@Test
public void sendBigPreparedQuery() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore40m("sendBigPreparedQuery"));
    byte[] arr = new byte[20000000];
    Arrays.fill(arr, (byte) 'a');
    byte[] arr2 = new byte[20000000];
    Arrays.fill(arr2, (byte) 'b');
    PreparedStatement ps = sharedConnection.prepareStatement("insert into bigblob2 values(null, ?,?)");
    ps.setBytes(1, arr);
    ps.setBytes(2, arr2);
    ps.executeUpdate();
    Statement stmt = sharedConnection.createStatement();
    ResultSet rs = stmt.executeQuery("select * from bigblob2");
    assertTrue(rs.next());
    byte[] newBytes = rs.getBytes(2);
    byte[] newBytes2 = rs.getBytes(3);
    assertEquals(arr.length, newBytes.length);
    assertEquals(arr2.length, newBytes2.length);
    for (int i = 0; i < arr.length; i++) {
        assertEquals(arr[i], newBytes[i]);
    }
    for (int i = 0; i < arr2.length; i++) {
        assertEquals(arr2[i], newBytes2[i]);
    }
}

######


@Test
public void sendBigBlobPreparedQuery() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore40m("sendBigPreparedQuery") && sharedUsePrepare());
    long maxAllowedPacket = 0;
    Statement st = sharedConnection.createStatement();
    ResultSet rs1 = st.executeQuery("select @@max_allowed_packet");
    if (rs1.next()) {
        maxAllowedPacket = rs1.getInt(1);
        Assume.assumeTrue(maxAllowedPacket < 512 * 1024 * 1024L);
    } else {
        fail();
    }
    byte[] arr = new byte[(int) maxAllowedPacket - 1000];
    int pos = 0;
    while (pos < maxAllowedPacket - 1000) {
        arr[pos] = (byte) ((pos % 132) + 40);
        pos++;
    }
    byte[] arr2 = new byte[(int) maxAllowedPacket - 1000];
    pos = 0;
    while (pos < maxAllowedPacket - 1000) {
        arr2[pos] = (byte) (((pos + 5) % 127) + 40);
        pos++;
    }
    PreparedStatement ps = sharedConnection.prepareStatement("insert into bigblob3 values(null, ?,?,?)");
    ps.setBlob(1, new MariaDbBlob(arr));
    ps.setBlob(2, new MariaDbBlob(arr2));
    ps.setString(3, "bob");
    ps.executeUpdate();
    Statement stmt = sharedConnection.createStatement();
    ResultSet rs = stmt.executeQuery("select * from bigblob3");
    assertTrue(rs.next());
    byte[] newBytes = rs.getBytes(2);
    byte[] newBytes2 = rs.getBytes(3);
    assertEquals(arr.length, newBytes.length);
    assertEquals(arr2.length, newBytes2.length);
    for (int i = 0; i < arr.length; i++) {
        assertEquals(arr[i], newBytes[i]);
    }
    for (int i = 0; i < arr2.length; i++) {
        assertEquals(arr2[i], newBytes2[i]);
    }
    assertEquals("bob", rs.getString(4));
}

######


@Test
public void testError() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore20m("testError"));
    try (Connection connection = setConnection()) {
        int selectSize = 9;
        char[] arr = new char[16 * 1024 * 1024 - selectSize];
        Arrays.fill(arr, 'a');
        String request = "select '" + new String(arr) + "'";
        ResultSet rs = connection.createStatement().executeQuery(request);
        assertTrue(rs.next());
        assertEquals(arr.length, rs.getString(1).length());
    }
}

######


@Test
public void sendStreamComData() throws Exception {
    Assume.assumeTrue(checkMaxAllowedPacketMore40m("sendBigPreparedQuery") && sharedUsePrepare());
    File tmpFile = File.createTempFile("temp-file-name", ".tmp");
    byte[] bb = new byte[11000];
    for (int i = 0; i < 11_000; i++) {
        bb[i] = (byte) (i % 110 + 40);
    }
    try (FileOutputStream fos = new FileOutputStream(tmpFile)) {
        for (int i = 0; i < 2_000; i++) {
            fos.write(bb);
        }
    }
    try (FileInputStream fis = new FileInputStream(tmpFile)) {
        try (FileInputStream fis2 = new FileInputStream(tmpFile)) {
            try (FileInputStream fis3 = new FileInputStream(tmpFile)) {
                try (PreparedStatement ps = sharedConnection.prepareStatement("insert into bigblob4 values(?)")) {
                    ps.setCharacterStream(1, new InputStreamReader(fis, StandardCharsets.UTF_8));
                    ps.executeUpdate();
                    ps.setBlob(1, fis2);
                    ps.executeUpdate();
                    ps.setCharacterStream(1, new InputStreamReader(fis3, StandardCharsets.UTF_8), 10_000_000);
                    ps.executeUpdate();
                }
            }
        }
    }
    PreparedStatement ps = sharedConnection.prepareStatement("select * from bigblob4");
    checkResult(tmpFile, ps.executeQuery(), 10_000_000);
    Statement stmt = sharedConnection.createStatement();
    checkResult(tmpFile, stmt.executeQuery("select * from bigblob4"), 10_000_000);
}

######


private void checkResult(File tmpFile, ResultSet rs, int length) throws Exception {
    assertTrue(rs.next());
    String res = rs.getString(1);
    try (Reader initialReader = new InputStreamReader(new FileInputStream(tmpFile), StandardCharsets.UTF_8)) {
        char[] bb = new char[64 * 1024];
        int len;
        int pos = 0;
        while ((len = initialReader.read(bb)) > 0) {
            for (int i = 0; i < len; i++) {
                assertEquals(bb[i], res.charAt(pos++));
            }
        }
    }
    assertTrue(rs.next());
    byte[] results = rs.getBytes(1);
    try (FileInputStream fis2 = new FileInputStream(tmpFile)) {
        byte[] byteBuffer = new byte[64 * 1024];
        int len;
        int pos = 0;
        while ((len = fis2.read(byteBuffer)) > 0) {
            for (int i = 0; i < len; i++) {
                assertEquals(byteBuffer[i], results[pos++]);
            }
        }
    }
    assertTrue(rs.next());
    res = rs.getString(1);
    assertEquals(length, res.length());
    try (Reader initialReader = new InputStreamReader(new FileInputStream(tmpFile), StandardCharsets.UTF_8)) {
        char[] bb = new char[64 * 1024];
        int len;
        int pos = 0;
        while ((len = initialReader.read(bb)) > 0) {
            for (int i = 0; i < len; i++) {
                if (pos < length) {
                    assertEquals(bb[i], res.charAt(pos++));
                }
            }
        }
        assertEquals(length, pos);
    }
    assertFalse(rs.next());
}

######


@Test
public void maxFieldSizeTest() throws SQLException {
    byte abyte = (byte) 'a';
    byte bbyte = (byte) 'b';
    byte[] arr = new byte[200];
    Arrays.fill(arr, abyte);
    byte[] arr2 = new byte[200];
    Arrays.fill(arr2, bbyte);
    PreparedStatement ps = sharedConnection.prepareStatement("insert into bigblob5 values(null, ?,?)");
    ps.setBytes(1, arr);
    ps.setBytes(2, arr2);
    ps.executeUpdate();
    Statement stmt = sharedConnection.createStatement();
    stmt.setMaxFieldSize(2);
    ResultSet rs = stmt.executeQuery("select * from bigblob5");
    assertTrue(rs.next());
    assertEquals(2, rs.getBytes(2).length);
    assertEquals(2, rs.getString(3).length());
    assertArrayEquals(new byte[] { abyte, abyte }, rs.getBytes(2));
    assertEquals("bb", rs.getString(3));
}

######


public List<BioBizz> getData(Phase phase, Integer week) {
    Query query = em.createQuery("SELECT e FROM BioBizz e where phase=:phase and week=:week");
    query.setParameter("phase", phase);
    query.setParameter("week", week);
    return (List<BioBizz>) query.getResultList();
}

######


@Transactional(readOnly = true)
public BiologicalModel findByDbidAndAllelicCompositionAndGeneticBackgroundAndZygosity(Integer id, String allelicComposition, String geneticBackground, String zygosity) {
    return (BiologicalModel) getCurrentSession().createQuery("from BiologicalModel m where m.datasource.id=? and m.allelicComposition=? and m.geneticBackground=? and m.zygosity=?").setInteger(0, id).setString(1, allelicComposition).setString(2, geneticBackground).setString(3, zygosity).uniqueResult();
}

######


@Transactional(readOnly = false)
public void saveBiologicalSample(BiologicalSample sample) {
    getCurrentSession().saveOrUpdate(sample);
}

######


@Transactional(readOnly = false)
public void saveLiveSample(LiveSample sample) {
    getCurrentSession().saveOrUpdate(sample);
}

######


@Transactional(readOnly = false)
public int deleteAllLiveSamplesByDatasource(Datasource datasource) {
    Query query = getCurrentSession().getNamedQuery("deleteLiveSamples").setInteger("dbID", datasource.getId());
    return query.executeUpdate();
}

######


@Transactional(readOnly = false)
public int deleteAllLiveSamplesWithoutModelsByDatasource(Datasource datasource) {
    Query query = getCurrentSession().getNamedQuery("deleteLiveSamplesWithoutModels").setInteger("dbID", datasource.getId());
    return query.executeUpdate();
}

######


@Transactional(readOnly = false)
public int deleteAllBiologicalSamplesByDatasource(Datasource datasource) {
    Query query = getCurrentSession().getNamedQuery("deleteBiologicalSamples").setInteger("dbID", datasource.getId());
    return query.executeUpdate();
}

######


@Transactional(readOnly = true)
public List<BiologicalModel> getAllBiologicalModelsByDatasourceId(int databaseId) {
    return (List<BiologicalModel>) getCurrentSession().createQuery("select distinct m from BiologicalModel as m inner join m.datasource as d where d.id = ?").setInteger(0, databaseId).list();
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<BiologicalModel> getAllBiologicalModelsByAccession(String accession) {
    return getCurrentSession().createQuery("from BiologicalModel as m join m.genomicFeatures as gf where gf.id.accession = ?").setString(0, accession).list();
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<LiveSample> getAllLiveSamplesByDatasourceId(int databaseId) {
    return getCurrentSession().createQuery("from LiveSample as l inner join l.datasource as d where d.id = ?").setInteger(0, databaseId).list();
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<LiveSample> getAllLiveSamples() {
    List<LiveSample> liveSamples = new LinkedList<LiveSample>();
    List<Object> l = getCurrentSession().createQuery("SELECT live FROM LiveSample AS live").list();
    for (Object o : l) {
        liveSamples.add((LiveSample) o);
    }
    return liveSamples;
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<LiveSample> getAllLiveSampleByOrganisation(Organisation organisation) {
    List<LiveSample> liveSamples = new LinkedList<LiveSample>();
    List<Object> l = getCurrentSession().createQuery("SELECT live FROM LiveSample AS live INNER JOIN live.organisation AS o WHERE o.id = ?").setInteger(0, organisation.getId()).list();
    for (Object o : l) {
        liveSamples.add((LiveSample) o);
    }
    return liveSamples;
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<LiveSample> getAllLiveSampleByOrganisationAndDatasource(Organisation organisation, Datasource datasource) {
    List<LiveSample> liveSamples = new LinkedList<LiveSample>();
    List<Object> l = getCurrentSession().createQuery("SELECT live FROM LiveSample AS live INNER JOIN live.datasource AS d INNER JOIN live.organisation AS o WHERE d.id = ? AND o.id = ?").setInteger(0, datasource.getId()).setInteger(1, organisation.getId()).list();
    for (Object o : l) {
        liveSamples.add((LiveSample) o);
    }
    return liveSamples;
}

######


@Transactional(readOnly = true)
public LiveSample getLiveSampleBySampleIdAndOrganisationId(String sampleId, Integer organisationId) {
    return (LiveSample) getCurrentSession().createQuery("SELECT live FROM LiveSample AS live INNER JOIN live.organisation AS o WHERE live.stableId = ? AND o.id=?").setString(0, sampleId).setInteger(1, organisationId).uniqueResult();
}

######


@Transactional(readOnly = true)
public BiologicalModel getBiologicalModelById(int modelId) {
    return (BiologicalModel) getCurrentSession().createQuery("from BiologicalModel as m where m.id = ?").setInteger(0, modelId).uniqueResult();
}

######


@Transactional(readOnly = true)
public BiologicalSample getBiologicalSampleById(int sampleId) {
    return (BiologicalSample) getCurrentSession().createQuery("from BiologicalSample as s where s.id = ?").setInteger(0, sampleId).uniqueResult();
}

######


@Transactional(readOnly = false)
public void saveBiologicalModel(BiologicalModel model) {
    getCurrentSession().saveOrUpdate(model);
    getCurrentSession().flush();
}

######


@Transactional(readOnly = false)
public int deleteAllBiologicalModelsByDatasource(Datasource datasource) {
    Query query = getCurrentSession().getNamedQuery("deleteBiologicalModelGenomicFeatures").setInteger("dbID", datasource.getId());
    query.executeUpdate();
    query = getCurrentSession().getNamedQuery("deleteBiologicalModels").setInteger("dbID", datasource.getId());
    int count = query.executeUpdate();
    return count;
}

######


@Transactional(readOnly = false)
public void deleteAllBiologicalModelsAndRelatedDataByDatasourceOrganisation(Datasource ds, Organisation o) {
    Query query = getCurrentSession().getNamedQuery("deleteBiologicalModelAndRelatedData").setInteger("dbID", ds.getId()).setInteger("orgID", o.getId());
    query.executeUpdate();
    getCurrentSession().flush();
}

######


@Select("select * from BLACK_LIST")
List<BlackList> queryAll();

######


@Insert("insert into BLACK_LIST(dimension,type,value,detail) VALUES (#{dimension},#{type},#{value},#{detail})")
int add(BlackList blackList);

######


@Select("select * from BLACK_LIST where dimension=#{dimension} and value= #{value}")
BlackList query(BlackList blackList);

######


@BeforeClass
public static void setupSqlSessionFactory() throws Exception {
    DataSource dataSource = BaseDataTest.createUnpooledDataSource("org/apache/ibatis/type/jdbc.properties");
    BaseDataTest.runScript(dataSource, "org/apache/ibatis/type/BlobInputStreamTypeHandlerTest.sql");
    TransactionFactory transactionFactory = new JdbcTransactionFactory();
    Environment environment = new Environment("Production", transactionFactory, dataSource);
    Configuration configuration = new Configuration(environment);
    configuration.addMapper(Mapper.class);
    sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);
}

######


@Override
@Test
public void shouldSetParameter() throws Exception {
    InputStream in = new ByteArrayInputStream("Hello".getBytes());
    TYPE_HANDLER.setParameter(ps, 1, in, null);
    verify(ps).setBlob(1, in);
}

######


@Override
@Test
public void shouldGetResultFromResultSetByName() throws Exception {
    InputStream in = new ByteArrayInputStream("Hello".getBytes());
    when(rs.getBlob("column")).thenReturn(blob);
    when(rs.wasNull()).thenReturn(false);
    when(blob.getBinaryStream()).thenReturn(in);
    assertThat(TYPE_HANDLER.getResult(rs, "column")).isEqualTo(in);
}

######


@Override
@Test
public void shouldGetResultNullFromResultSetByName() throws Exception {
    when(rs.getBlob("column")).thenReturn(null);
    when(rs.wasNull()).thenReturn(true);
    assertThat(TYPE_HANDLER.getResult(rs, "column")).isNull();
}

######


@Override
@Test
public void shouldGetResultFromResultSetByPosition() throws Exception {
    InputStream in = new ByteArrayInputStream("Hello".getBytes());
    when(rs.getBlob(1)).thenReturn(blob);
    when(rs.wasNull()).thenReturn(false);
    when(blob.getBinaryStream()).thenReturn(in);
    assertThat(TYPE_HANDLER.getResult(rs, 1)).isEqualTo(in);
}

######


@Override
@Test
public void shouldGetResultNullFromResultSetByPosition() throws Exception {
    when(rs.getBlob(1)).thenReturn(null);
    when(rs.wasNull()).thenReturn(true);
    assertThat(TYPE_HANDLER.getResult(rs, 1)).isNull();
}

######


@Override
@Test
public void shouldGetResultFromCallableStatement() throws Exception {
    InputStream in = new ByteArrayInputStream("Hello".getBytes());
    when(cs.getBlob(1)).thenReturn(blob);
    when(cs.wasNull()).thenReturn(false);
    when(blob.getBinaryStream()).thenReturn(in);
    assertThat(TYPE_HANDLER.getResult(cs, 1)).isEqualTo(in);
}

######


@Override
@Test
public void shouldGetResultNullFromCallableStatement() throws Exception {
    when(cs.getBlob(1)).thenReturn(null);
    when(cs.wasNull()).thenReturn(true);
    assertThat(TYPE_HANDLER.getResult(cs, 1)).isNull();
}

######


@Test
public void integrationTest() throws IOException {
    SqlSession session = sqlSessionFactory.openSession();
    try {
        Mapper mapper = session.getMapper(Mapper.class);
        {
            BlobContent blobContent = new BlobContent();
            blobContent.setId(1);
            blobContent.setContent(new ByteArrayInputStream("Hello".getBytes()));
            mapper.insert(blobContent);
            session.commit();
        }
        {
            BlobContent blobContent = mapper.findOne(1);
            assertThat(new BufferedReader(new InputStreamReader(blobContent.getContent())).readLine()).isEqualTo("Hello");
        }
    } finally {
        session.close();
    }
}

######


@Select("SELECT ID, CONTENT FROM TEST_BLOB WHERE ID = #{id}")
BlobContent findOne(int id);

######


@Insert("INSERT INTO TEST_BLOB (ID, CONTENT) VALUES(#{id}, #{content})")
void insert(BlobContent blobContent);

######


public int getId() {
    return id;
}

######


public void setId(int id) {
    this.id = id;
}

######


public InputStream getContent() {
    return content;
}

######


public void setContent(InputStream content) {
    this.content = content;
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("bug716378", "id int not null primary key auto_increment, test longblob, test2 blob, test3 text");
    createTable("BlobTeststreamtest2", "id int primary key not null, st varchar(20), strm text" + ", strm2 text, strm3 text", "CHARSET utf8");
    createTable("BlobTeststreamtest3", "id int primary key not null, strm text", "CHARSET utf8");
    createTable("BlobTestclobtest", "id int not null primary key, strm text", "CHARSET utf8");
    createTable("BlobTestclobtest2", "strm text", "CHARSET utf8");
    createTable("BlobTestclobtest3", "id int not null primary key, strm text", "CHARSET utf8");
    createTable("BlobTestclobtest4", "id int not null primary key, strm text", "CHARSET utf8");
    createTable("BlobTestclobtest5", "id int not null primary key, strm text", "CHARSET utf8");
    createTable("BlobTestblobtest", "id int not null primary key, strm blob");
    createTable("BlobTestblobtest2", "id int not null primary key, strm blob");
    createTable("conj77_test", "Name VARCHAR(100) NOT NULL,Archive LONGBLOB, PRIMARY KEY (Name)", "Engine=InnoDB DEFAULT CHARSET utf8");
}

######


@Test
public void testPosition() throws SQLException {
    byte[] blobContent = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
    byte[] pattern = new byte[] { 3, 4 };
    Blob blob = new MariaDbBlob(blobContent);
    assertEquals(3, blob.position(pattern, 1));
    pattern = new byte[] { 12, 13 };
    assertEquals(-1, blob.position(pattern, 1));
    pattern = new byte[] { 11, 12 };
    assertEquals(11, blob.position(pattern, 1));
    pattern = new byte[] { 1, 2 };
    assertEquals(1, blob.position(pattern, 1));
}

######


@Test(expected = SQLException.class)
public void testBadStart() throws SQLException {
    byte[] blobContent = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
    byte[] pattern = new byte[] { 3, 4 };
    Blob blob = new MariaDbBlob(blobContent);
    blob.position(pattern, 0);
}

######


@Test(expected = SQLException.class)
public void testBadStart2() throws SQLException {
    byte[] blobContent = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
    byte[] pattern = new byte[] { 3, 4 };
    Blob blob = new MariaDbBlob(blobContent);
    blob.position(pattern, 44);
}

######


@Test
public void testBug716378() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.executeUpdate("insert into bug716378 values(null, 'a','b','c')");
    ResultSet rs = stmt.executeQuery("select * from bug716378");
    assertTrue(rs.next());
    byte[] arr = new byte[0];
    assertEquals(arr.getClass(), rs.getObject(2).getClass());
    assertEquals(arr.getClass(), rs.getObject(3).getClass());
    assertEquals(String.class, rs.getObject(4).getClass());
}

######


@Test
public void testCharacterStreamWithMultibyteCharacterAndLength() throws Throwable {
    String toInsert1 = "Øbbcdefgh\njklmn\"";
    String toInsert2 = "Øabcdefgh\njklmn\"";
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into BlobTeststreamtest2 (id, st, strm, strm2, strm3) values (?,?,?,?,?)");
    stmt.setInt(1, 2);
    stmt.setString(2, toInsert1);
    Reader reader = new StringReader(toInsert2);
    stmt.setCharacterStream(3, reader, 5);
    stmt.setCharacterStream(4, null);
    stmt.setCharacterStream(5, null, 5);
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from BlobTeststreamtest2");
    assertTrue(rs.next());
    Reader rdr = rs.getCharacterStream("strm");
    StringBuilder sb = new StringBuilder();
    int ch;
    while ((ch = rdr.read()) != -1) {
        sb.append((char) ch);
    }
    assertEquals(toInsert1, rs.getString(2));
    assertEquals(toInsert2.substring(0, 5), sb.toString());
    assertNull(rs.getString(4));
    assertNull(rs.getString(5));
}

######


@Test
public void testCharacterStreamWithMultibyteCharacter() throws Throwable {
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into BlobTeststreamtest3 (id, strm) values (?,?)");
    stmt.setInt(1, 2);
    String toInsert = "Øabcdefgh\njklmn\"";
    Reader reader = new StringReader(toInsert);
    stmt.setCharacterStream(2, reader);
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from BlobTeststreamtest3");
    assertTrue(rs.next());
    Reader rdr = rs.getCharacterStream("strm");
    StringBuilder sb = new StringBuilder();
    int ch;
    while ((ch = rdr.read()) != -1) {
        sb.append((char) ch);
    }
    assertEquals(toInsert, sb.toString());
}

######


@Test
public void testReaderWithLength() throws SQLException, IOException {
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into BlobTestclobtest5 (id, strm) values (?,?)");
    byte[] arr = new byte[32000];
    Arrays.fill(arr, (byte) 'b');
    stmt.setInt(1, 1);
    String clob = new String(arr);
    stmt.setCharacterStream(2, new StringReader(clob), 20000);
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from BlobTestclobtest5");
    assertTrue(rs.next());
    Reader readStuff = rs.getCharacterStream("strm");
    char[] chars = new char[50000];
    readStuff.read(chars);
    byte[] arrResult = new byte[20000];
    Arrays.fill(arrResult, (byte) 'b');
    for (int i = 0; i < chars.length; i++) {
        if (i < 20000) {
            assertEquals(arrResult[i], chars[i]);
        } else {
            assertEquals(chars[i], '\u0000');
        }
    }
}

######


@Test
public void testBlobWithLength() throws SQLException, IOException {
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into BlobTestblobtest2 (id, strm) values (?,?)");
    byte[] arr = new byte[32000];
    Random rand = new Random();
    rand.nextBytes(arr);
    InputStream stream = new ByteArrayInputStream(arr);
    stmt.setInt(1, 1);
    stmt.setBlob(2, stream, 20000);
    stmt.execute();
    int remainRead = 0;
    while (stream.read() >= 0) {
        remainRead++;
    }
    assertEquals(12000, remainRead);
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from BlobTestblobtest2");
    assertTrue(rs.next());
    InputStream readStuff = rs.getBlob("strm").getBinaryStream();
    int pos = 0;
    int ch;
    while ((ch = readStuff.read()) != -1) {
        assertEquals(arr[pos++] & 0xff, ch);
    }
    assertEquals(20000, pos);
}

######


@Test
public void testClobWithLengthAndMultibyteCharacter() throws SQLException, IOException {
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into BlobTestclobtest (id, strm) values (?,?)");
    String clob = "Øclob";
    stmt.setInt(1, 1);
    stmt.setClob(2, new StringReader(clob));
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from BlobTestclobtest");
    if (rs.next()) {
        Reader readStuff = rs.getClob("strm").getCharacterStream();
        char[] chars = new char[5];
        readStuff.read(chars);
        assertEquals(new String(chars), clob);
    } else {
        fail();
    }
}

######


@Test
public void testClob3() throws Exception {
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into BlobTestclobtest2 (strm) values (?)");
    Clob clob = sharedConnection.createClob();
    Writer writer = clob.setCharacterStream(1);
    writer.write("Øhello", 0, 6);
    writer.flush();
    stmt.setClob(1, clob);
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from BlobTestclobtest2");
    assertTrue(rs.next());
    assertTrue(rs.getObject(1) instanceof String);
    String result = rs.getString(1);
    assertEquals("Øhello", result);
}

######


@Test
public void testBlob() throws SQLException, IOException {
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into BlobTestblobtest (id, strm) values (?,?)");
    byte[] theBlob = { 1, 2, 3, 4, 5, 6 };
    InputStream stream = new ByteArrayInputStream(theBlob);
    stmt.setInt(1, 1);
    stmt.setBlob(2, stream);
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from BlobTestblobtest");
    assertTrue(rs.next());
    InputStream readStuff = rs.getBlob("strm").getBinaryStream();
    int ch;
    int pos = 0;
    while ((ch = readStuff.read()) != -1) {
        assertEquals(theBlob[pos++], ch);
    }
    readStuff = rs.getBinaryStream("strm");
    pos = 0;
    while ((ch = readStuff.read()) != -1) {
        assertEquals(theBlob[pos++], ch);
    }
}

######


@Test
public void testClobWithLength() throws SQLException, IOException {
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into BlobTestclobtest3 (id, strm) values (?,?)");
    String clob = "clob";
    stmt.setInt(1, 1);
    stmt.setClob(2, new StringReader(clob));
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from BlobTestclobtest3");
    assertTrue(rs.next());
    Reader readStuff = rs.getClob("strm").getCharacterStream();
    char[] chars = new char[4];
    readStuff.read(chars);
    assertEquals(new String(chars), clob);
}

######


@Test
public void testClob2() throws SQLException, IOException {
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into BlobTestclobtest4 (id, strm) values (?,?)");
    Clob clob = sharedConnection.createClob();
    OutputStream ostream = clob.setAsciiStream(1);
    byte[] bytes = "hello".getBytes();
    ostream.write(bytes);
    stmt.setInt(1, 1);
    stmt.setClob(2, clob);
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from BlobTestclobtest4");
    assertTrue(rs.next());
    assertTrue(rs.getObject(2) instanceof String);
    assertTrue(rs.getString(2).equals("hello"));
}

######


@Test
public void blobSerialization() throws Exception {
    Blob blob = new MariaDbBlob(new byte[] { 1, 2, 3 });
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(baos);
    oos.writeObject(blob);
    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));
    MariaDbBlob blob2 = (MariaDbBlob) ois.readObject();
    byte[] blobBytes = blob2.getBytes(1, (int) blob2.length());
    assertEquals(3, blobBytes.length);
    assertEquals(1, blobBytes[0]);
    assertEquals(2, blobBytes[1]);
    assertEquals(3, blobBytes[2]);
    Clob clob = new MariaDbClob(new byte[] { 1, 2, 3 });
    baos = new ByteArrayOutputStream();
    oos = new ObjectOutputStream(baos);
    oos.writeObject(clob);
    ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));
    MariaDbClob c2 = (MariaDbClob) ois.readObject();
    blobBytes = c2.getBytes(1, (int) c2.length());
    assertEquals(3, blobBytes.length);
    assertEquals(1, blobBytes[0]);
    assertEquals(2, blobBytes[1]);
    assertEquals(3, blobBytes[2]);
}

######


@Test
public void conj73() throws Exception {
    Clob clob = new MariaDbClob(new byte[] { (byte) 0x10, (byte) 0xD0, (byte) 0xA0, (byte) 0xe0, (byte) 0xa1, (byte) 0x8e });
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(baos);
    oos.writeObject(clob);
    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));
    MariaDbClob c2 = (MariaDbClob) ois.readObject();
    assertEquals(3, c2.length());
}

######


@Test
public void conj77() throws Exception {
    byte[][] values = new byte[3][];
    values[0] = "".getBytes();
    values[1] = "hello".getBytes();
    values[2] = null;
    try (Statement sta1 = sharedConnection.createStatement()) {
        try (PreparedStatement pre = sharedConnection.prepareStatement("INSERT INTO conj77_test (Name,Archive) VALUES (?,?)")) {
            pre.setString(1, "1-Empty String");
            pre.setBytes(2, values[0]);
            pre.addBatch();
            pre.setString(1, "2-Data Hello");
            pre.setBytes(2, values[1]);
            pre.addBatch();
            pre.setString(1, "3-Empty Data null");
            pre.setBytes(2, values[2]);
            pre.addBatch();
            pre.executeBatch();
        }
    }
    try (Statement sta2 = sharedConnection.createStatement()) {
        try (ResultSet set = sta2.executeQuery("Select name,archive as text FROM conj77_test")) {
            int pos = 0;
            while (set.next()) {
                final Blob blob = set.getBlob("text");
                if (blob != null) {
                    try (ByteArrayOutputStream bout = new ByteArrayOutputStream((int) blob.length())) {
                        try (InputStream bin = blob.getBinaryStream()) {
                            final byte[] buffer = new byte[1024 * 4];
                            for (int read = bin.read(buffer); read != -1; read = bin.read(buffer)) {
                                bout.write(buffer, 0, read);
                            }
                        }
                        assertArrayEquals(bout.toByteArray(), values[pos++]);
                    }
                } else {
                    assertNull(values[pos++]);
                }
            }
            assertEquals(pos, 3);
        }
    }
}

######


@Test
public void sendEmptyBlobPreparedQuery() throws SQLException {
    createTable("emptyBlob", "test longblob, test2 text, test3 text");
    try (Connection conn = setConnection()) {
        PreparedStatement ps = conn.prepareStatement("insert into emptyBlob values(?,?,?)");
        ps.setBlob(1, new MariaDbBlob(new byte[0]));
        ps.setString(2, "a 'a ");
        ps.setNull(3, Types.VARCHAR);
        ps.executeUpdate();
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery("select * from emptyBlob");
        assertTrue(rs.next());
        assertEquals(0, rs.getBytes(1).length);
        assertEquals("a 'a ", rs.getString(2));
        assertNull(rs.getBytes(3));
    }
}

######


@Test
public void blobSerializationWithOffset() throws Exception {
    Blob blob = new MariaDbBlob(new byte[] { 1, 2, 3, 4, 5 }, 1, 2);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(baos);
    oos.writeObject(blob);
    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));
    MariaDbBlob blob2 = (MariaDbBlob) ois.readObject();
    byte[] blobBytes = blob2.getBytes(1, (int) blob2.length());
    assertEquals(2, blobBytes.length);
    assertEquals(2, blobBytes[0]);
    assertEquals(3, blobBytes[1]);
    Clob clob = new MariaDbClob(new byte[] { 1, 2, 3, 4, 5 }, 1, 2);
    baos = new ByteArrayOutputStream();
    oos = new ObjectOutputStream(baos);
    oos.writeObject(clob);
    ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));
    MariaDbClob c2 = (MariaDbClob) ois.readObject();
    blobBytes = c2.getBytes(1, (int) c2.length());
    assertEquals(2, blobBytes.length);
    assertEquals(2, blobBytes[0]);
    assertEquals(3, blobBytes[1]);
}

######


@Test
public void blobDeserializationFilter() throws Exception {
    blobDeserializationFilterInternal(false, 0);
    if (System.getProperty("java.version").startsWith("9.")) {
        blobDeserializationFilterInternal(true, 2000);
        try {
            blobDeserializationFilterInternal(true, 500);
            fail("must have thrown exception, since filter limit is set lower than blob size");
        } catch (InvalidClassException e) {
            assertTrue(e.getMessage().contains("REJECTED"));
        }
    }
}

######


private void blobDeserializationFilterInternal(boolean addFilter, int filterSize) throws Exception {
    Assume.assumeTrue(System.getProperty("java.version").startsWith("9."));
    byte[] bb = new byte[1000];
    for (int i = 0; i < 1000; i++) {
        bb[i] = (byte) i;
    }
    MariaDbBlob blob = new MariaDbBlob(bb, 50, 750);
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(bos);
    oos.writeObject(blob);
    oos.flush();
    oos.close();
    bos.close();
    byte[] data = bos.toByteArray();
    ByteArrayInputStream bis = new ByteArrayInputStream(data);
    ObjectInputStream ois = new ObjectInputStream(bis);
    if (addFilter) {
        ClassLoader cl = BlobTest.class.getClassLoader();
        Class<?> objectInputFilterClass = Class.forName("java.io.ObjectInputFilter");
        Object objectInputFilterImpl = Proxy.newProxyInstance(cl, new Class[] { objectInputFilterClass }, (proxy, method, args) -> {
            Class<?> filterInfoClass = Class.forName("java.io.ObjectInputFilter$FilterInfo");
            Method arrayLengthMethod = filterInfoClass.getDeclaredMethod("arrayLength");
            Long arrayLength = (Long) arrayLengthMethod.invoke(args[0]);
            Class<?> statusClass = Class.forName("java.io.ObjectInputFilter$Status");
            Field rejected = statusClass.getField("REJECTED");
            Field allowed = statusClass.getField("ALLOWED");
            if (arrayLength > filterSize) {
                return rejected.get(null);
            }
            return allowed.get(null);
        });
        Method setObjectInputFilterMethod = ObjectInputStream.class.getDeclaredMethod("setObjectInputFilter", objectInputFilterClass);
        setObjectInputFilterMethod.invoke(ois, objectInputFilterImpl);
    }
    MariaDbBlob resultBlob = (MariaDbBlob) ois.readObject();
    assertEquals(750, resultBlob.data.length);
    assertEquals(0, resultBlob.offset);
    assertEquals(750, resultBlob.length);
    byte[] blobBytes = resultBlob.getBytes(1, 1000);
    for (int i = 0; i < 750; i++) {
        assertEquals(bb[i + 50], blobBytes[i]);
    }
}

######


@Test
public void connectionBlob() throws SQLException {
    Blob blob = sharedConnection.createBlob();
    assertArrayEquals(new byte[] { 0 }, blob.getBytes(1, 1));
    blob.setBytes(5, new byte[] { 1, 2, 3, 4, 5, 6 });
    assertArrayEquals(new byte[] { 0, 0, 0, 0, 1, 2, 3, 4, 5 }, blob.getBytes(1, 9));
}

######


public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
    return inflater.inflate(R.layout.boeking_fragment, container, false);
}

######


@Override
public void onClick(View v) {
    EditText saldoInput = getView().findViewById(R.id.saldoInput);
    saldoUit = Double.valueOf(saldoInput.getText().toString());
    EditText ontvangerInput = getView().findViewById(R.id.ontvangerInput);
    String ontvanger = ontvangerInput.toString();
    dbz = new DatabaseConnector();
    sql = "SELECT Saldo FROM Rekening WHERE Rekeningnummer = '123456789'";
    dbz.execute(sql);
    try {
        zResult = dbz.get();
        String strResult = zResult.toString();
        jResult = new JSONArray(strResult);
    } catch (ExecutionException e) {
        e.printStackTrace();
    } catch (InterruptedException e) {
        e.printStackTrace();
    } catch (JSONException e) {
        e.printStackTrace();
    }
    for (int i = 0; i < jResult.length(); i++) {
        try {
            JSONObject jsonObject = (JSONObject) jResult.get(i);
            jsonSaldoZend = (String) jsonObject.get("Saldo");
            Log.i("e", jResult.toString());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    saldoZend = Double.valueOf(jsonSaldoZend);
    Double saldoZendNieuw = saldoZend - saldoUit;
    dbv = new DatabaseConnector();
    sql = "UPATE Rekening SET Saldo = '" + saldoZendNieuw + "' WHERE Rekeningnummer = '123456789'";
    dbv.execute(sql);
    dbo = new DatabaseConnector();
    sql = "SELECT Saldo FROM Rekening WHERE Rekeningnummer = '" + ontvanger + "'";
    dbo.execute(sql);
    try {
        oResult = dbo.get();
        String strOResult = oResult.toString();
        jResult = new JSONArray(strOResult);
    } catch (ExecutionException e) {
        e.printStackTrace();
    } catch (InterruptedException e) {
        e.printStackTrace();
    } catch (JSONException e) {
        e.printStackTrace();
    }
    for (int i = 0; i < jResult.length(); i++) {
        try {
            JSONObject jsonObject = (JSONObject) jResult.get(i);
            jsonSaldoOntvang = (String) jsonObject.get("Saldo");
            Log.i("e", jResult.toString());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    saldoOntvang = Double.valueOf(jsonSaldoOntvang);
    Double saldoOntvangNieuw = saldoOntvang + saldoUit;
    dbs = new DatabaseConnector();
    sql = "UPATE Rekening SET Saldo = '" + saldoOntvangNieuw + "' WHERE Rekeningnummer = '" + ontvanger + "'";
    dbs.execute(sql);
    Toast.makeText(getActivity().getApplicationContext(), "Verstuurd", Toast.LENGTH_LONG).show();
}

######


@Override
public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
    verzend = getView().findViewById(R.id.verzend);
    verzend.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            EditText saldoInput = getView().findViewById(R.id.saldoInput);
            saldoUit = Double.valueOf(saldoInput.getText().toString());
            EditText ontvangerInput = getView().findViewById(R.id.ontvangerInput);
            String ontvanger = ontvangerInput.toString();
            dbz = new DatabaseConnector();
            sql = "SELECT Saldo FROM Rekening WHERE Rekeningnummer = '123456789'";
            dbz.execute(sql);
            try {
                zResult = dbz.get();
                String strResult = zResult.toString();
                jResult = new JSONArray(strResult);
            } catch (ExecutionException e) {
                e.printStackTrace();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (JSONException e) {
                e.printStackTrace();
            }
            for (int i = 0; i < jResult.length(); i++) {
                try {
                    JSONObject jsonObject = (JSONObject) jResult.get(i);
                    jsonSaldoZend = (String) jsonObject.get("Saldo");
                    Log.i("e", jResult.toString());
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            saldoZend = Double.valueOf(jsonSaldoZend);
            Double saldoZendNieuw = saldoZend - saldoUit;
            dbv = new DatabaseConnector();
            sql = "UPATE Rekening SET Saldo = '" + saldoZendNieuw + "' WHERE Rekeningnummer = '123456789'";
            dbv.execute(sql);
            dbo = new DatabaseConnector();
            sql = "SELECT Saldo FROM Rekening WHERE Rekeningnummer = '" + ontvanger + "'";
            dbo.execute(sql);
            try {
                oResult = dbo.get();
                String strOResult = oResult.toString();
                jResult = new JSONArray(strOResult);
            } catch (ExecutionException e) {
                e.printStackTrace();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (JSONException e) {
                e.printStackTrace();
            }
            for (int i = 0; i < jResult.length(); i++) {
                try {
                    JSONObject jsonObject = (JSONObject) jResult.get(i);
                    jsonSaldoOntvang = (String) jsonObject.get("Saldo");
                    Log.i("e", jResult.toString());
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            saldoOntvang = Double.valueOf(jsonSaldoOntvang);
            Double saldoOntvangNieuw = saldoOntvang + saldoUit;
            dbs = new DatabaseConnector();
            sql = "UPATE Rekening SET Saldo = '" + saldoOntvangNieuw + "' WHERE Rekeningnummer = '" + ontvanger + "'";
            dbs.execute(sql);
            Toast.makeText(getActivity().getApplicationContext(), "Verstuurd", Toast.LENGTH_LONG).show();
        }
    });
    super.onViewCreated(view, savedInstanceState);
}

######


private Connection getConnection() throws SQLException {
    java.sql.Connection con;
    con = ConnectionFactory.getInstance().getConnection();
    return con;
}

######


public String addBook() throws ClassNotFoundException, SQLException {
    connection = getConnection();
    this.addBook = this.connection.prepareStatement("INSERT INTO books(title, author, price, category) VALUES(?,?,?,?)");
    this.addBook.setString(1, getTitle());
    this.addBook.setString(2, getAuthor());
    this.addBook.setString(3, getPrice());
    this.addBook.setString(4, getCategory());
    this.addBook.executeUpdate();
    return "success";
}

######


public String viewBooks() throws ClassNotFoundException, SQLException {
    connection = getConnection();
    this.viewBooks = this.connection.prepareStatement("SELECT * FROM books");
    viewBooks.executeQuery();
    return "success";
}

######


public String getTitle() {
    return author;
}

######


public void setTitle(String title) {
    this.title = title;
}

######


public String getAuthor() {
    return author;
}

######


public void setAuthor(String author) {
    this.author = author;
}

######


public String getPrice() {
    return price;
}

######


public void setPrice(String price) {
    this.price = price;
}

######


public String getCategory() {
    return category;
}

######


public void setCategory(String category) {
    this.category = category;
}

######


public void setSession(Map m) {
    this.m = m;
}

######


public static synchronized BookmarkDatabaseHelper getInstance(Context context) {
    if (sSingleton == null) {
        sSingleton = new BookmarkDatabaseHelper(context);
    }
    return sSingleton;
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    bootstrapDB(db);
}

######


private void bootstrapDB(SQLiteDatabase db) {
    Log.i(TAG, "Bootstrapping And Bible database");
    db.execSQL("CREATE TABLE " + Table.BOOKMARK + " (" + BookmarkColumn._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," + BookmarkColumn.KEY + " TEXT NOT NULL" + ");");
    db.execSQL("CREATE TABLE " + Table.BOOKMARK_LABEL + " (" + BookmarkLabelColumn.BOOKMARK_ID + " INTEGER NOT NULL," + BookmarkLabelColumn.LABEL_ID + " INTEGER NOT NULL" + ");");
    db.execSQL("CREATE TABLE " + Table.LABEL + " (" + LabelColumn._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," + LabelColumn.NAME + " TEXT NOT NULL" + ");");
    db.execSQL("CREATE TRIGGER bookmark_cleanup DELETE ON " + Table.BOOKMARK + " " + "BEGIN " + "DELETE FROM " + Table.BOOKMARK_LABEL + " WHERE " + BookmarkLabelColumn.BOOKMARK_ID + " = old._id;" + "END");
    db.execSQL("CREATE TRIGGER label_cleanup DELETE ON " + Table.LABEL + " " + "BEGIN " + "DELETE FROM " + Table.BOOKMARK_LABEL + " WHERE " + BookmarkLabelColumn.LABEL_ID + " = old._id;" + "END");
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    Log.i(TAG, "Upgrading DB from version " + oldVersion + " to " + newVersion);
    try {
    } catch (SQLiteException e) {
        Log.e(TAG, "onUpgrade: SQLiteException, recreating db. " + e);
        bootstrapDB(db);
        return;
    }
}

######


@Override
public Book add(Book book) {
    entityManager.persist(book);
    return book;
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("booleantest", "id int not null primary key auto_increment, test boolean");
    createTable("booleanvalue", "test boolean");
    createTable("booleanAllField", "t1 BIT, t2 TINYINT(1), t3 SMALLINT(1), t4 MEDIUMINT(1), t5 INT(1), t6 BIGINT(1), t7 DECIMAL(1), t8 FLOAT, " + "t9 DOUBLE, t10 CHAR(1), t11 VARCHAR(1), t12 BINARY(1), t13 BLOB(1), t14 TEXT(1)");
}

######


@Test
public void testBoolean() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("insert into booleantest values(null, true)");
    stmt.execute("insert into booleantest values(null, false)");
    ResultSet rs = stmt.executeQuery("select * from booleantest");
    if (rs.next()) {
        assertTrue(rs.getBoolean(2));
        if (rs.next()) {
            assertFalse(rs.getBoolean(2));
        } else {
            fail("must have a result !");
        }
    } else {
        fail("must have a result !");
    }
}

######


@Test
public void testBooleanString() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("insert into booleanvalue values(true)");
    stmt.execute("insert into booleanvalue values(false)");
    stmt.execute("insert into booleanvalue values(4)");
    ResultSet rs = stmt.executeQuery("select * from booleanvalue");
    if (rs.next()) {
        assertTrue(rs.getBoolean(1));
        assertEquals("1", rs.getString(1));
        if (rs.next()) {
            assertFalse(rs.getBoolean(1));
            assertEquals("0", rs.getString(1));
            if (rs.next()) {
                assertTrue(rs.getBoolean(1));
                assertEquals("4", rs.getString(1));
            } else {
                fail("must have a result !");
            }
        } else {
            fail("must have a result !");
        }
    } else {
        fail("must have a result !");
    }
}

######


@Test
public void testBooleanAllField() throws Exception {
    try (Connection connection = setConnection("&maxPerformance=true")) {
        Statement stmt = connection.createStatement();
        stmt.execute("INSERT INTO booleanAllField VALUES (null, null, null, null, null, null, null, null, null, null, null, null, null, null)");
        stmt.execute("INSERT INTO booleanAllField VALUES (0, 0, 0, 0, 0, 0, 0, 0, 0, '0', '0', '0', '0', '0')");
        stmt.execute("INSERT INTO booleanAllField VALUES (1, 1, 1, 1, 1, 1, 1, 1, 1, '1', '1', '1', '1', '1')");
        stmt.execute("INSERT INTO booleanAllField VALUES (1, 2, 2, 2, 2, 2, 2, 2, 2, '2', '2', '2', '2', '2')");
        ResultSet rs = stmt.executeQuery("SELECT * FROM booleanAllField");
        checkBooleanValue(rs, false, null);
        checkBooleanValue(rs, false, false);
        checkBooleanValue(rs, true, true);
        checkBooleanValue(rs, true, true);
        PreparedStatement preparedStatement = connection.prepareStatement("SELECT * FROM booleanAllField WHERE 1 = ?");
        preparedStatement.setInt(1, 1);
        rs = preparedStatement.executeQuery();
        checkBooleanValue(rs, false, null);
        checkBooleanValue(rs, false, false);
        checkBooleanValue(rs, true, true);
        checkBooleanValue(rs, true, true);
    }
}

######


private void checkBooleanValue(ResultSet rs, boolean expectedValue, Boolean expectedNull) throws SQLException {
    assertTrue(rs.next());
    for (int i = 1; i <= 14; i++) {
        assertEquals(expectedValue, rs.getBoolean(i));
        if (i == 1 || i == 2) {
            assertEquals(expectedNull, rs.getObject(i));
            assertEquals(expectedNull, rs.getObject(i, Boolean.class));
        }
    }
}

######


Blog selectBlogWithPostsUsingSubSelect(int id);

######


int selectRandom();

######


@Select({ "SELECT * FROM blog" })
@MapKey("id")
Map<Integer, Blog> selectBlogsAsMapById();

######


@Select({ "SELECT * FROM blog ORDER BY id" })
@MapKey("id")
Map<Integer, Blog> selectRangeBlogsAsMapById(RowBounds rowBounds);

######


@Select({ "SELECT *", "FROM blog" })
List<Blog> selectBlogs();

######


@Select({ "SELECT *", "FROM blog", "ORDER BY id" })
@ResultType(Blog.class)
void collectRangeBlogs(ResultHandler<Object> blog, RowBounds rowBounds);

######


@Select({ "SELECT *", "FROM blog", "ORDER BY id" })
Cursor<Blog> openRangeBlogs(RowBounds rowBounds);

######


List<Blog> selectBlogsFromXML();

######


@Select({ "SELECT *", "FROM blog" })
List<Map<String, Object>> selectBlogsAsMaps();

######


@SelectProvider(type = BoundBlogSql.class, method = "selectBlogsSql")
List<Blog> selectBlogsUsingProvider();

######


@Select("SELECT * FROM post ORDER BY id")
@TypeDiscriminator(column = "draft", javaType = String.class, cases = { @Case(value = "1", type = DraftPost.class) })
List<Post> selectPosts();

######


@Select("SELECT * FROM post ORDER BY id")
@Results({ @Result(id = true, property = "id", column = "id") })
@TypeDiscriminator(column = "draft", javaType = int.class, cases = { @Case(value = "1", type = DraftPost.class, results = { @Result(id = true, property = "id", column = "id") }) })
List<Post> selectPostsWithResultMap();

######


@Select("SELECT * FROM " + "blog WHERE id = #{id}")
Blog selectBlog(int id);

######


@Select("SELECT * FROM " + "blog WHERE id = #{id}")
@ConstructorArgs({ @Arg(column = "id", javaType = int.class, id = true), @Arg(column = "title", javaType = String.class), @Arg(column = "author_id", javaType = Author.class, select = "org.apache.ibatis.binding.BoundAuthorMapper.selectAuthor"), @Arg(column = "id", javaType = List.class, select = "selectPostsForBlog") })
Blog selectBlogUsingConstructor(int id);

######


Blog selectBlogUsingConstructorWithResultMap(int i);

######


Blog selectBlogUsingConstructorWithResultMapAndProperties(int i);

######


Blog selectBlogUsingConstructorWithResultMapCollection(int i);

######


Blog selectBlogByIdUsingConstructor(int id);

######


@Select("SELECT * FROM " + "blog WHERE id = #{id}")
Map<String, Object> selectBlogAsMap(Map<String, Object> params);

######


@Select("SELECT * FROM " + "post WHERE subject like #{query}")
List<Post> selectPostsLike(RowBounds bounds, String query);

######


@Select("SELECT * FROM " + "post WHERE subject like #{subjectQuery} and body like #{bodyQuery}")
List<Post> selectPostsLikeSubjectAndBody(RowBounds bounds, @Param("subjectQuery") String subjectQuery, @Param("bodyQuery") String bodyQuery);

######


@Select("SELECT * FROM " + "post WHERE id = #{id}")
List<Post> selectPostsById(int id);

######


@Select("SELECT * FROM blog " + "WHERE id = #{id} AND title = #{nonExistentParam,jdbcType=VARCHAR}")
Blog selectBlogByNonExistentParam(@Param("id") int id);

######


@Select("SELECT * FROM blog " + "WHERE id = #{id} AND title = #{params.nonExistentParam,jdbcType=VARCHAR}")
Blog selectBlogByNonExistentNestedParam(@Param("id") int id, @Param("params") Map<String, Object> params);

######


@Select("SELECT * FROM blog WHERE id = #{id}")
Blog selectBlogByNullParam(Integer id);

######


@Select("SELECT * FROM blog " + "WHERE id = #{0} AND title = #{1}")
Blog selectBlogByDefault30ParamNames(int id, String title);

######


@Select("SELECT * FROM blog " + "WHERE id = #{param1} AND title = #{param2}")
Blog selectBlogByDefault31ParamNames(int id, String title);

######


@Select("SELECT * FROM blog " + "WHERE ${column} = #{id} AND title = #{value}")
Blog selectBlogWithAParamNamedValue(@Param("column") String column, @Param("id") int id, @Param("value") String title);

######


@Select({ "SELECT *", "FROM blog" })
@Results({ @Result(property = "author", column = "author_id", one = @One(select = "org.apache.ibatis.binding.BoundAuthorMapper.selectAuthor")), @Result(property = "posts", column = "id", many = @Many(select = "selectPostsById")) })
List<Blog> selectBlogsWithAutorAndPosts();

######


@Select({ "SELECT *", "FROM blog" })
@Results({ @Result(property = "author", column = "author_id", one = @One(select = "org.apache.ibatis.binding.BoundAuthorMapper.selectAuthor", fetchType = FetchType.EAGER)), @Result(property = "posts", column = "id", many = @Many(select = "selectPostsById", fetchType = FetchType.EAGER)) })
List<Blog> selectBlogsWithAutorAndPostsEagerly();

######


public static String getClientId(ContentResolver cr) {
    String ret = "android-google";
    Cursor legacyClientIdCursor = null;
    Cursor searchClientIdCursor = null;
    try {
        searchClientIdCursor = cr.query(Uri.parse("content://com.google.settings/partner"), new String[] { "value" }, "name='search_client_id'", null, null);
        if (searchClientIdCursor != null && searchClientIdCursor.moveToNext()) {
            ret = searchClientIdCursor.getString(0);
        } else {
            legacyClientIdCursor = cr.query(Uri.parse("content://com.google.settings/partner"), new String[] { "value" }, "name='client_id'", null, null);
            if (legacyClientIdCursor != null && legacyClientIdCursor.moveToNext()) {
                ret = "ms-" + legacyClientIdCursor.getString(0);
            }
        }
    } catch (RuntimeException ex) {
    } finally {
        if (legacyClientIdCursor != null) {
            legacyClientIdCursor.close();
        }
        if (searchClientIdCursor != null) {
            searchClientIdCursor.close();
        }
    }
    return ret;
}

######


private static CharSequence replaceSystemPropertyInString(Context context, CharSequence srcString) {
    StringBuffer sb = new StringBuffer();
    int lastCharLoc = 0;
    final String client_id = getClientId(context.getContentResolver());
    for (int i = 0; i < srcString.length(); ++i) {
        char c = srcString.charAt(i);
        if (c == '{') {
            sb.append(srcString.subSequence(lastCharLoc, i));
            lastCharLoc = i;
            inner: for (int j = i; j < srcString.length(); ++j) {
                char k = srcString.charAt(j);
                if (k == '}') {
                    String propertyKeyValue = srcString.subSequence(i + 1, j).toString();
                    if (propertyKeyValue.equals("CLIENT_ID")) {
                        sb.append(client_id);
                    } else {
                        sb.append("unknown");
                    }
                    lastCharLoc = j + 1;
                    i = j;
                    break inner;
                }
            }
        }
    }
    if (srcString.length() - lastCharLoc > 0) {
        sb.append(srcString.subSequence(lastCharLoc, srcString.length()));
    }
    return sb;
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL("CREATE TABLE bookmarks (" + "_id INTEGER PRIMARY KEY," + "title TEXT," + "url TEXT NOT NULL," + "visits INTEGER," + "date LONG," + "created LONG," + "description TEXT," + "bookmark INTEGER," + "favicon BLOB DEFAULT NULL," + "thumbnail BLOB DEFAULT NULL," + "touch_icon BLOB DEFAULT NULL," + "user_entered INTEGER" + ");");
    final CharSequence[] bookmarks = mContext.getResources().getTextArray(R.array.bookmarks);
    int size = bookmarks.length;
    try {
        for (int i = 0; i < size; i = i + 2) {
            CharSequence bookmarkDestination = replaceSystemPropertyInString(mContext, bookmarks[i + 1]);
            db.execSQL("INSERT INTO bookmarks (title, url, visits, " + "date, created, bookmark)" + " VALUES('" + bookmarks[i] + "', '" + bookmarkDestination + "', 0, 0, 0, 1);");
        }
    } catch (ArrayIndexOutOfBoundsException e) {
    }
    db.execSQL("CREATE TABLE searches (" + "_id INTEGER PRIMARY KEY," + "search TEXT," + "date LONG" + ");");
}

######


static final String bookmarkOrHistoryColumn(String column) {
    return "CASE WHEN bookmarks." + column + " IS NOT NULL THEN " + "bookmarks." + column + " ELSE history." + column + " END AS " + column;
}

######


static final String bookmarkOrHistoryLiteral(String column, String bookmarkValue, String historyValue) {
    return "CASE WHEN bookmarks." + column + " IS NOT NULL THEN \"" + bookmarkValue + "\" ELSE \"" + historyValue + "\" END";
}

######


static final String qualifyColumn(String table, String column) {
    return table + "." + column + " AS " + column;
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL("CREATE TABLE " + TABLE_BOOKMARKS + "(" + Bookmarks._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," + Bookmarks.TITLE + " TEXT," + Bookmarks.URL + " TEXT," + Bookmarks.IS_FOLDER + " INTEGER NOT NULL DEFAULT 0," + Bookmarks.PARENT + " INTEGER," + Bookmarks.POSITION + " INTEGER NOT NULL," + Bookmarks.INSERT_AFTER + " INTEGER," + Bookmarks.IS_DELETED + " INTEGER NOT NULL DEFAULT 0," + Bookmarks.ACCOUNT_NAME + " TEXT," + Bookmarks.ACCOUNT_TYPE + " TEXT," + Bookmarks.SOURCE_ID + " TEXT," + Bookmarks.VERSION + " INTEGER NOT NULL DEFAULT 1," + Bookmarks.DATE_CREATED + " INTEGER," + Bookmarks.DATE_MODIFIED + " INTEGER," + Bookmarks.DIRTY + " INTEGER NOT NULL DEFAULT 0," + Bookmarks.SYNC1 + " TEXT," + Bookmarks.SYNC2 + " TEXT," + Bookmarks.SYNC3 + " TEXT," + Bookmarks.SYNC4 + " TEXT," + Bookmarks.SYNC5 + " TEXT" + ");");
    db.execSQL("CREATE TABLE " + TABLE_HISTORY + "(" + History._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," + History.TITLE + " TEXT," + History.URL + " TEXT NOT NULL," + History.DATE_CREATED + " INTEGER," + History.DATE_LAST_VISITED + " INTEGER," + History.VISITS + " INTEGER NOT NULL DEFAULT 0," + History.USER_ENTERED + " INTEGER" + ");");
    db.execSQL("CREATE TABLE " + TABLE_IMAGES + " (" + Images.URL + " TEXT UNIQUE NOT NULL," + Images.FAVICON + " BLOB," + Images.THUMBNAIL + " BLOB," + Images.TOUCH_ICON + " BLOB" + ");");
    db.execSQL("CREATE INDEX imagesUrlIndex ON " + TABLE_IMAGES + "(" + Images.URL + ")");
    db.execSQL("CREATE TABLE " + TABLE_SEARCHES + " (" + Searches._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," + Searches.SEARCH + " TEXT," + Searches.DATE + " LONG" + ");");
    db.execSQL("CREATE TABLE " + TABLE_SETTINGS + " (" + Settings.KEY + " TEXT PRIMARY KEY," + Settings.VALUE + " TEXT NOT NULL" + ");");
    createAccountsView(db);
    createThumbnails(db);
    mSyncHelper.createDatabase(db);
    if (!importFromBrowserProvider(db)) {
        createDefaultBookmarks(db);
    }
    enableSync(db);
    createOmniboxSuggestions(db);
}

######


void createOmniboxSuggestions(SQLiteDatabase db) {
    db.execSQL(SQL_CREATE_VIEW_OMNIBOX_SUGGESTIONS);
}

######


void createThumbnails(SQLiteDatabase db) {
    db.execSQL("CREATE TABLE IF NOT EXISTS " + TABLE_THUMBNAILS + " (" + Thumbnails._ID + " INTEGER PRIMARY KEY," + Thumbnails.THUMBNAIL + " BLOB NOT NULL" + ");");
}

######


void enableSync(SQLiteDatabase db) {
    ContentValues values = new ContentValues();
    values.put(Settings.KEY, Settings.KEY_SYNC_ENABLED);
    values.put(Settings.VALUE, 1);
    insertSettingsInTransaction(db, values);
    AccountManager am = (AccountManager) getContext().getSystemService(Context.ACCOUNT_SERVICE);
    if (am == null) {
        return;
    }
    Account[] accounts = am.getAccountsByType("com.google");
    if (accounts == null || accounts.length == 0) {
        return;
    }
    for (Account account : accounts) {
        if (ContentResolver.getIsSyncable(account, BrowserContract.AUTHORITY) == 0) {
            ContentResolver.setIsSyncable(account, BrowserContract.AUTHORITY, 1);
            ContentResolver.setSyncAutomatically(account, BrowserContract.AUTHORITY, true);
        }
    }
}

######


boolean importFromBrowserProvider(SQLiteDatabase db) {
    Context context = getContext();
    File oldDbFile = context.getDatabasePath(BrowserProvider.sDatabaseName);
    if (oldDbFile.exists()) {
        BrowserProvider.DatabaseHelper helper = new BrowserProvider.DatabaseHelper(context);
        SQLiteDatabase oldDb = helper.getWritableDatabase();
        Cursor c = null;
        try {
            String table = BrowserProvider.TABLE_NAMES[BrowserProvider.URI_MATCH_BOOKMARKS];
            c = oldDb.query(table, new String[] { BookmarkColumns.URL, BookmarkColumns.TITLE, BookmarkColumns.FAVICON, BookmarkColumns.TOUCH_ICON, BookmarkColumns.CREATED }, BookmarkColumns.BOOKMARK + "!=0", null, null, null, null);
            if (c != null) {
                while (c.moveToNext()) {
                    String url = c.getString(0);
                    if (TextUtils.isEmpty(url))
                        continue;
                    ContentValues values = new ContentValues();
                    values.put(Bookmarks.URL, url);
                    values.put(Bookmarks.TITLE, c.getString(1));
                    values.put(Bookmarks.DATE_CREATED, c.getInt(4));
                    values.put(Bookmarks.POSITION, 0);
                    values.put(Bookmarks.PARENT, FIXED_ID_ROOT);
                    ContentValues imageValues = new ContentValues();
                    imageValues.put(Images.URL, url);
                    imageValues.put(Images.FAVICON, c.getBlob(2));
                    imageValues.put(Images.TOUCH_ICON, c.getBlob(3));
                    db.insert(TABLE_IMAGES, Images.THUMBNAIL, imageValues);
                    db.insert(TABLE_BOOKMARKS, Bookmarks.DIRTY, values);
                }
                c.close();
            }
            c = oldDb.query(table, new String[] { BookmarkColumns.URL, BookmarkColumns.TITLE, BookmarkColumns.VISITS, BookmarkColumns.DATE, BookmarkColumns.CREATED }, BookmarkColumns.VISITS + " > 0 OR " + BookmarkColumns.BOOKMARK + " = 0", null, null, null, null);
            if (c != null) {
                while (c.moveToNext()) {
                    ContentValues values = new ContentValues();
                    String url = c.getString(0);
                    if (TextUtils.isEmpty(url))
                        continue;
                    values.put(History.URL, url);
                    values.put(History.TITLE, c.getString(1));
                    values.put(History.VISITS, c.getInt(2));
                    values.put(History.DATE_LAST_VISITED, c.getLong(3));
                    values.put(History.DATE_CREATED, c.getLong(4));
                    db.insert(TABLE_HISTORY, History.FAVICON, values);
                }
                c.close();
            }
            oldDb.delete(table, null, null);
        } finally {
            if (c != null)
                c.close();
            oldDb.close();
            helper.close();
        }
        if (!oldDbFile.delete()) {
            oldDbFile.deleteOnExit();
        }
        return true;
    }
    return false;
}

######


void createAccountsView(SQLiteDatabase db) {
    db.execSQL("CREATE VIEW IF NOT EXISTS v_accounts AS " + "SELECT NULL AS " + Accounts.ACCOUNT_NAME + ", NULL AS " + Accounts.ACCOUNT_TYPE + ", " + FIXED_ID_ROOT + " AS " + Accounts.ROOT_ID + " UNION ALL SELECT " + Accounts.ACCOUNT_NAME + ", " + Accounts.ACCOUNT_TYPE + ", " + Bookmarks._ID + " AS " + Accounts.ROOT_ID + " FROM " + TABLE_BOOKMARKS + " WHERE " + ChromeSyncColumns.SERVER_UNIQUE + " = \"" + ChromeSyncColumns.FOLDER_NAME_BOOKMARKS_BAR + "\" AND " + Bookmarks.IS_DELETED + " = 0");
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    if (oldVersion < 32) {
        createOmniboxSuggestions(db);
    }
    if (oldVersion < 31) {
        createThumbnails(db);
    }
    if (oldVersion < 30) {
        db.execSQL("DROP VIEW IF EXISTS " + VIEW_SNAPSHOTS_COMBINED);
        db.execSQL("DROP TABLE IF EXISTS " + TABLE_SNAPSHOTS);
    }
    if (oldVersion < 28) {
        enableSync(db);
    }
    if (oldVersion < 27) {
        createAccountsView(db);
    }
    if (oldVersion < 26) {
        db.execSQL("DROP VIEW IF EXISTS combined");
    }
    if (oldVersion < 25) {
        db.execSQL("DROP TABLE IF EXISTS " + TABLE_BOOKMARKS);
        db.execSQL("DROP TABLE IF EXISTS " + TABLE_HISTORY);
        db.execSQL("DROP TABLE IF EXISTS " + TABLE_SEARCHES);
        db.execSQL("DROP TABLE IF EXISTS " + TABLE_IMAGES);
        db.execSQL("DROP TABLE IF EXISTS " + TABLE_SETTINGS);
        mSyncHelper.onAccountsChanged(db, new Account[] {});
        onCreate(db);
    }
}

######


public void onOpen(SQLiteDatabase db) {
    mSyncHelper.onDatabaseOpened(db);
}

######


private void createDefaultBookmarks(SQLiteDatabase db) {
    ContentValues values = new ContentValues();
    values.put(Bookmarks._ID, FIXED_ID_ROOT);
    values.put(ChromeSyncColumns.SERVER_UNIQUE, ChromeSyncColumns.FOLDER_NAME_BOOKMARKS);
    values.put(Bookmarks.TITLE, "Bookmarks");
    values.putNull(Bookmarks.PARENT);
    values.put(Bookmarks.POSITION, 0);
    values.put(Bookmarks.IS_FOLDER, true);
    values.put(Bookmarks.DIRTY, true);
    db.insertOrThrow(TABLE_BOOKMARKS, null, values);
    addDefaultBookmarks(db, FIXED_ID_ROOT);
}

######


private void addDefaultBookmarks(SQLiteDatabase db, long parentId) {
    Resources res = getContext().getResources();
    final CharSequence[] bookmarks = res.getTextArray(R.array.bookmarks);
    int size = bookmarks.length;
    TypedArray preloads = res.obtainTypedArray(R.array.bookmark_preloads);
    try {
        String parent = Long.toString(parentId);
        String now = Long.toString(System.currentTimeMillis());
        for (int i = 0; i < size; i = i + 2) {
            CharSequence bookmarkDestination = replaceSystemPropertyInString(getContext(), bookmarks[i + 1]);
            db.execSQL("INSERT INTO bookmarks (" + Bookmarks.TITLE + ", " + Bookmarks.URL + ", " + Bookmarks.IS_FOLDER + "," + Bookmarks.PARENT + "," + Bookmarks.POSITION + "," + Bookmarks.DATE_CREATED + ") VALUES (" + "'" + bookmarks[i] + "', " + "'" + bookmarkDestination + "', " + "0," + parent + "," + Integer.toString(i) + "," + now + ");");
            int faviconId = preloads.getResourceId(i, 0);
            int thumbId = preloads.getResourceId(i + 1, 0);
            byte[] thumb = null, favicon = null;
            try {
                thumb = readRaw(res, thumbId);
            } catch (IOException e) {
            }
            try {
                favicon = readRaw(res, faviconId);
            } catch (IOException e) {
            }
            if (thumb != null || favicon != null) {
                ContentValues imageValues = new ContentValues();
                imageValues.put(Images.URL, bookmarkDestination.toString());
                if (favicon != null) {
                    imageValues.put(Images.FAVICON, favicon);
                }
                if (thumb != null) {
                    imageValues.put(Images.THUMBNAIL, thumb);
                }
                db.insert(TABLE_IMAGES, Images.FAVICON, imageValues);
            }
        }
    } catch (ArrayIndexOutOfBoundsException e) {
    } finally {
        preloads.recycle();
    }
}

######


private byte[] readRaw(Resources res, int id) throws IOException {
    if (id == 0) {
        return null;
    }
    InputStream is = res.openRawResource(id);
    try {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        byte[] buf = new byte[4096];
        int read;
        while ((read = is.read(buf)) > 0) {
            bos.write(buf, 0, read);
        }
        bos.flush();
        return bos.toByteArray();
    } finally {
        is.close();
    }
}

######


private String getClientId(ContentResolver cr) {
    String ret = "android-google";
    Cursor c = null;
    try {
        c = cr.query(Uri.parse("content://com.google.settings/partner"), new String[] { "value" }, "name='client_id'", null, null);
        if (c != null && c.moveToNext()) {
            ret = c.getString(0);
        }
    } catch (RuntimeException ex) {
    } finally {
        if (c != null) {
            c.close();
        }
    }
    return ret;
}

######


private CharSequence replaceSystemPropertyInString(Context context, CharSequence srcString) {
    StringBuffer sb = new StringBuffer();
    int lastCharLoc = 0;
    final String client_id = getClientId(context.getContentResolver());
    for (int i = 0; i < srcString.length(); ++i) {
        char c = srcString.charAt(i);
        if (c == '{') {
            sb.append(srcString.subSequence(lastCharLoc, i));
            lastCharLoc = i;
            inner: for (int j = i; j < srcString.length(); ++j) {
                char k = srcString.charAt(j);
                if (k == '}') {
                    String propertyKeyValue = srcString.subSequence(i + 1, j).toString();
                    if (propertyKeyValue.equals("CLIENT_ID")) {
                        sb.append(client_id);
                    } else {
                        sb.append("unknown");
                    }
                    lastCharLoc = j + 1;
                    i = j;
                    break inner;
                }
            }
        }
    }
    if (srcString.length() - lastCharLoc > 0) {
        sb.append(srcString.subSequence(lastCharLoc, srcString.length()));
    }
    return sb;
}

######


@Override
public SQLiteOpenHelper getDatabaseHelper(Context context) {
    synchronized (this) {
        if (mOpenHelper == null) {
            mOpenHelper = new DatabaseHelper(context);
        }
        return mOpenHelper;
    }
}

######


@Override
public boolean isCallerSyncAdapter(Uri uri) {
    return uri.getBooleanQueryParameter(BrowserContract.CALLER_IS_SYNCADAPTER, false);
}

######


@VisibleForTesting
public void setWidgetObserver(ContentObserver obs) {
    mWidgetObserver = obs;
}

######


void refreshWidgets() {
    mUpdateWidgets = true;
}

######


@Override
protected void onEndTransaction(boolean callerIsSyncAdapter) {
    super.onEndTransaction(callerIsSyncAdapter);
    if (mUpdateWidgets) {
        if (mWidgetObserver == null) {
            BookmarkThumbnailWidgetProvider.refreshWidgets(getContext());
        } else {
            mWidgetObserver.dispatchChange(false);
        }
        mUpdateWidgets = false;
    }
    mSyncToNetwork = true;
}

######


@Override
public String getType(Uri uri) {
    final int match = URI_MATCHER.match(uri);
    switch(match) {
        case LEGACY:
        case BOOKMARKS:
            return Bookmarks.CONTENT_TYPE;
        case LEGACY_ID:
        case BOOKMARKS_ID:
            return Bookmarks.CONTENT_ITEM_TYPE;
        case HISTORY:
            return History.CONTENT_TYPE;
        case HISTORY_ID:
            return History.CONTENT_ITEM_TYPE;
        case SEARCHES:
            return Searches.CONTENT_TYPE;
        case SEARCHES_ID:
            return Searches.CONTENT_ITEM_TYPE;
    }
    return null;
}

######


boolean isNullAccount(String account) {
    if (account == null)
        return true;
    account = account.trim();
    return account.length() == 0 || account.equals("null");
}

######


Object[] getSelectionWithAccounts(Uri uri, String selection, String[] selectionArgs) {
    String accountType = uri.getQueryParameter(Bookmarks.PARAM_ACCOUNT_TYPE);
    String accountName = uri.getQueryParameter(Bookmarks.PARAM_ACCOUNT_NAME);
    boolean hasAccounts = false;
    if (accountType != null && accountName != null) {
        if (!isNullAccount(accountType) && !isNullAccount(accountName)) {
            selection = DatabaseUtils.concatenateWhere(selection, Bookmarks.ACCOUNT_TYPE + "=? AND " + Bookmarks.ACCOUNT_NAME + "=? ");
            selectionArgs = DatabaseUtils.appendSelectionArgs(selectionArgs, new String[] { accountType, accountName });
            hasAccounts = true;
        } else {
            selection = DatabaseUtils.concatenateWhere(selection, Bookmarks.ACCOUNT_NAME + " IS NULL AND " + Bookmarks.ACCOUNT_TYPE + " IS NULL");
        }
    }
    return new Object[] { selection, selectionArgs, hasAccounts };
}

######


@Override
public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
    SQLiteDatabase db = mOpenHelper.getReadableDatabase();
    final int match = URI_MATCHER.match(uri);
    SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
    String limit = uri.getQueryParameter(BrowserContract.PARAM_LIMIT);
    String groupBy = uri.getQueryParameter(PARAM_GROUP_BY);
    switch(match) {
        case ACCOUNTS:
            {
                qb.setTables(VIEW_ACCOUNTS);
                qb.setProjectionMap(ACCOUNTS_PROJECTION_MAP);
                String allowEmpty = uri.getQueryParameter(PARAM_ALLOW_EMPTY_ACCOUNTS);
                if ("false".equals(allowEmpty)) {
                    selection = DatabaseUtils.concatenateWhere(selection, SQL_WHERE_ACCOUNT_HAS_BOOKMARKS);
                }
                if (sortOrder == null) {
                    sortOrder = DEFAULT_SORT_ACCOUNTS;
                }
                break;
            }
        case BOOKMARKS_FOLDER_ID:
        case BOOKMARKS_ID:
        case BOOKMARKS:
            {
                if (!uri.getBooleanQueryParameter(Bookmarks.QUERY_PARAMETER_SHOW_DELETED, false)) {
                    selection = DatabaseUtils.concatenateWhere(Bookmarks.IS_DELETED + "=0", selection);
                }
                if (match == BOOKMARKS_ID) {
                    selection = DatabaseUtils.concatenateWhere(selection, TABLE_BOOKMARKS + "." + Bookmarks._ID + "=?");
                    selectionArgs = DatabaseUtils.appendSelectionArgs(selectionArgs, new String[] { Long.toString(ContentUris.parseId(uri)) });
                } else if (match == BOOKMARKS_FOLDER_ID) {
                    selection = DatabaseUtils.concatenateWhere(selection, TABLE_BOOKMARKS + "." + Bookmarks.PARENT + "=?");
                    selectionArgs = DatabaseUtils.appendSelectionArgs(selectionArgs, new String[] { Long.toString(ContentUris.parseId(uri)) });
                }
                Object[] withAccount = getSelectionWithAccounts(uri, selection, selectionArgs);
                selection = (String) withAccount[0];
                selectionArgs = (String[]) withAccount[1];
                boolean hasAccounts = (Boolean) withAccount[2];
                if (TextUtils.isEmpty(sortOrder)) {
                    if (hasAccounts) {
                        sortOrder = DEFAULT_BOOKMARKS_SORT_ORDER_SYNC;
                    } else {
                        sortOrder = DEFAULT_BOOKMARKS_SORT_ORDER;
                    }
                }
                qb.setProjectionMap(BOOKMARKS_PROJECTION_MAP);
                qb.setTables(TABLE_BOOKMARKS_JOIN_IMAGES);
                break;
            }
        case BOOKMARKS_FOLDER:
            {
                boolean useAccount = false;
                String accountType = uri.getQueryParameter(Bookmarks.PARAM_ACCOUNT_TYPE);
                String accountName = uri.getQueryParameter(Bookmarks.PARAM_ACCOUNT_NAME);
                if (!isNullAccount(accountType) && !isNullAccount(accountName)) {
                    useAccount = true;
                }
                qb.setTables(TABLE_BOOKMARKS_JOIN_IMAGES);
                String[] args;
                String query;
                if (TextUtils.isEmpty(sortOrder)) {
                    if (useAccount) {
                        sortOrder = DEFAULT_BOOKMARKS_SORT_ORDER_SYNC;
                    } else {
                        sortOrder = DEFAULT_BOOKMARKS_SORT_ORDER;
                    }
                }
                if (!useAccount) {
                    qb.setProjectionMap(BOOKMARKS_PROJECTION_MAP);
                    String where = Bookmarks.PARENT + "=? AND " + Bookmarks.IS_DELETED + "=0";
                    where = DatabaseUtils.concatenateWhere(where, selection);
                    args = new String[] { Long.toString(FIXED_ID_ROOT) };
                    if (selectionArgs != null) {
                        args = DatabaseUtils.appendSelectionArgs(args, selectionArgs);
                    }
                    query = qb.buildQuery(projection, where, null, null, sortOrder, null);
                } else {
                    qb.setProjectionMap(BOOKMARKS_PROJECTION_MAP);
                    String where = Bookmarks.ACCOUNT_TYPE + "=? AND " + Bookmarks.ACCOUNT_NAME + "=? " + "AND parent = " + "(SELECT _id FROM " + TABLE_BOOKMARKS + " WHERE " + ChromeSyncColumns.SERVER_UNIQUE + "=" + "'" + ChromeSyncColumns.FOLDER_NAME_BOOKMARKS_BAR + "' " + "AND account_type = ? AND account_name = ?) " + "AND " + Bookmarks.IS_DELETED + "=0";
                    where = DatabaseUtils.concatenateWhere(where, selection);
                    String bookmarksBarQuery = qb.buildQuery(projection, where, null, null, null, null);
                    args = new String[] { accountType, accountName, accountType, accountName };
                    if (selectionArgs != null) {
                        args = DatabaseUtils.appendSelectionArgs(args, selectionArgs);
                    }
                    where = Bookmarks.ACCOUNT_TYPE + "=? AND " + Bookmarks.ACCOUNT_NAME + "=?" + " AND " + ChromeSyncColumns.SERVER_UNIQUE + "=?";
                    where = DatabaseUtils.concatenateWhere(where, selection);
                    qb.setProjectionMap(OTHER_BOOKMARKS_PROJECTION_MAP);
                    String otherBookmarksQuery = qb.buildQuery(projection, where, null, null, null, null);
                    query = qb.buildUnionQuery(new String[] { bookmarksBarQuery, otherBookmarksQuery }, sortOrder, limit);
                    args = DatabaseUtils.appendSelectionArgs(args, new String[] { accountType, accountName, ChromeSyncColumns.FOLDER_NAME_OTHER_BOOKMARKS });
                    if (selectionArgs != null) {
                        args = DatabaseUtils.appendSelectionArgs(args, selectionArgs);
                    }
                }
                Cursor cursor = db.rawQuery(query, args);
                if (cursor != null) {
                    cursor.setNotificationUri(getContext().getContentResolver(), BrowserContract.AUTHORITY_URI);
                }
                return cursor;
            }
        case BOOKMARKS_DEFAULT_FOLDER_ID:
            {
                String accountName = uri.getQueryParameter(Bookmarks.PARAM_ACCOUNT_NAME);
                String accountType = uri.getQueryParameter(Bookmarks.PARAM_ACCOUNT_TYPE);
                long id = queryDefaultFolderId(accountName, accountType);
                MatrixCursor c = new MatrixCursor(new String[] { Bookmarks._ID });
                c.newRow().add(id);
                return c;
            }
        case BOOKMARKS_SUGGESTIONS:
            {
                return doSuggestQuery(selection, selectionArgs, limit);
            }
        case HISTORY_ID:
            {
                selection = DatabaseUtils.concatenateWhere(selection, TABLE_HISTORY + "._id=?");
                selectionArgs = DatabaseUtils.appendSelectionArgs(selectionArgs, new String[] { Long.toString(ContentUris.parseId(uri)) });
            }
        case HISTORY:
            {
                filterSearchClient(selectionArgs);
                if (sortOrder == null) {
                    sortOrder = DEFAULT_SORT_HISTORY;
                }
                qb.setProjectionMap(HISTORY_PROJECTION_MAP);
                qb.setTables(TABLE_HISTORY_JOIN_IMAGES);
                break;
            }
        case SEARCHES_ID:
            {
                selection = DatabaseUtils.concatenateWhere(selection, TABLE_SEARCHES + "._id=?");
                selectionArgs = DatabaseUtils.appendSelectionArgs(selectionArgs, new String[] { Long.toString(ContentUris.parseId(uri)) });
            }
        case SEARCHES:
            {
                qb.setTables(TABLE_SEARCHES);
                qb.setProjectionMap(SEARCHES_PROJECTION_MAP);
                break;
            }
        case SYNCSTATE:
            {
                return mSyncHelper.query(db, projection, selection, selectionArgs, sortOrder);
            }
        case SYNCSTATE_ID:
            {
                selection = appendAccountToSelection(uri, selection);
                String selectionWithId = (SyncStateContract.Columns._ID + "=" + ContentUris.parseId(uri) + " ") + (selection == null ? "" : " AND (" + selection + ")");
                return mSyncHelper.query(db, projection, selectionWithId, selectionArgs, sortOrder);
            }
        case IMAGES:
            {
                qb.setTables(TABLE_IMAGES);
                qb.setProjectionMap(IMAGES_PROJECTION_MAP);
                break;
            }
        case LEGACY_ID:
        case COMBINED_ID:
            {
                selection = DatabaseUtils.concatenateWhere(selection, Combined._ID + " = CAST(? AS INTEGER)");
                selectionArgs = DatabaseUtils.appendSelectionArgs(selectionArgs, new String[] { Long.toString(ContentUris.parseId(uri)) });
            }
        case LEGACY:
        case COMBINED:
            {
                if ((match == LEGACY || match == LEGACY_ID) && projection == null) {
                    projection = Browser.HISTORY_PROJECTION;
                }
                String[] args = createCombinedQuery(uri, projection, qb);
                if (selectionArgs == null) {
                    selectionArgs = args;
                } else {
                    selectionArgs = DatabaseUtils.appendSelectionArgs(args, selectionArgs);
                }
                break;
            }
        case SETTINGS:
            {
                qb.setTables(TABLE_SETTINGS);
                qb.setProjectionMap(SETTINGS_PROJECTION_MAP);
                break;
            }
        case THUMBNAILS_ID:
            {
                selection = DatabaseUtils.concatenateWhere(selection, Thumbnails._ID + " = ?");
                selectionArgs = DatabaseUtils.appendSelectionArgs(selectionArgs, new String[] { Long.toString(ContentUris.parseId(uri)) });
            }
        case THUMBNAILS:
            {
                qb.setTables(TABLE_THUMBNAILS);
                break;
            }
        case OMNIBOX_SUGGESTIONS:
            {
                qb.setTables(VIEW_OMNIBOX_SUGGESTIONS);
                break;
            }
        default:
            {
                throw new UnsupportedOperationException("Unknown URL " + uri.toString());
            }
    }
    Cursor cursor = qb.query(db, projection, selection, selectionArgs, groupBy, null, sortOrder, limit);
    cursor.setNotificationUri(getContext().getContentResolver(), BrowserContract.AUTHORITY_URI);
    return cursor;
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("BufferTest", "test longText");
}

######


@Test
public void send8mTextData() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore8m("send8mTextData"));
    sendSqlData(false, array8m);
    sendSqlData(true, array8m);
}

######


@Test
public void send20mTextData() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore20m("send20mTextData"));
    sendSqlData(false, array20m);
    sendSqlData(true, array20m);
}

######


@Test
public void send40mTextData() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore40m("send40mTextData"));
    sendSqlData(false, array40m);
    sendSqlData(true, array40m);
}

######


@Test
public void send8mByteBufferData() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore8m("send8mByteBufferData"));
    sendByteBufferData(false, array8m);
    sendByteBufferData(true, array8m);
}

######


@Test
public void send20mByteBufferData() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore20m("send20mByteBufferData"));
    sendByteBufferData(false, array20m);
    sendByteBufferData(true, array20m);
}

######


@Test
public void send40mByteBufferData() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore40m("send40mByteBufferData"));
    sendByteBufferData(false, array40m);
    sendByteBufferData(true, array40m);
}

######


@Test
public void send20mSqlNotCompressDataException() {
    try {
        Assume.assumeTrue(!checkMaxAllowedPacketMore20m("send20mSqlNotCompressDataException", false));
        sendSqlData(false, array20m);
        fail("must have thrown exception");
    } catch (SQLException sqlexception) {
        assertTrue("not the expected exception. was " + sqlexception.getMessage(), sqlexception.getMessage().contains("is >= to max_allowed_packet"));
    }
}

######


@Test
public void send20mSqlCompressDataException() {
    try {
        Assume.assumeTrue(!checkMaxAllowedPacketMore20m("send20mSqlCompressDataException", false));
        sendSqlData(true, array20m);
        fail("must have thrown exception");
    } catch (SQLException sqlexception) {
        assertTrue("not the expected exception. was " + sqlexception.getMessage(), sqlexception.getMessage().contains("is >= to max_allowed_packet"));
    }
}

######


@Test
public void send40mSqlNotCompressDataException() {
    try {
        Assume.assumeTrue(!checkMaxAllowedPacketMore40m("send40mSqlNotCompressDataException", false));
        sendSqlData(false, array40m);
        fail("must have thrown exception");
    } catch (SQLException sqlexception) {
        assertTrue("not the expected exception. was " + sqlexception.getMessage(), sqlexception.getMessage().contains("is >= to max_allowed_packet"));
    }
}

######


@Test
public void send40mSqlCompressDataException() {
    try {
        Assume.assumeTrue(!checkMaxAllowedPacketMore40m("send40mSqlCompressDataException", false));
        sendSqlData(true, array40m);
        fail("must have thrown exception");
    } catch (SQLException sqlexception) {
        assertTrue("not the expected exception. was " + sqlexception.getMessage(), sqlexception.getMessage().contains("is >= to max_allowed_packet"));
    }
}

######


@Test
public void send20mByteBufferNotCompressDataException() {
    try {
        Assume.assumeTrue(!checkMaxAllowedPacketMore20m("send20mByteBufferNotCompressDataException", false));
        sendByteBufferData(false, array20m);
        fail("must have thrown exception");
    } catch (SQLException sqlexception) {
        assertTrue("not the expected exception. was " + sqlexception.getCause().getCause().getMessage(), sqlexception.getCause().getMessage().contains("is >= to max_allowed_packet"));
    }
}

######


@Test
public void send20mByteBufferCompressDataException() {
    try {
        Assume.assumeTrue(!checkMaxAllowedPacketMore20m("send20mByteBufferCompressDataException", false));
        sendByteBufferData(true, array20m);
        fail("must have thrown exception");
    } catch (SQLException sqlexception) {
        assertTrue("not the expected exception. was " + sqlexception.getCause().getCause().getMessage(), sqlexception.getCause().getMessage().contains("is >= to max_allowed_packet"));
    }
}

######


@Test
public void send40mByteBufferNotCompressDataException() {
    try {
        Assume.assumeTrue(!checkMaxAllowedPacketMore40m("send40mByteBufferNotCompressDataException", false));
        sendByteBufferData(false, array40m);
        fail("must have thrown exception");
    } catch (SQLException sqlexception) {
        assertTrue("not the expected exception. was " + sqlexception.getCause().getCause().getMessage(), sqlexception.getCause().getMessage().contains("is >= to max_allowed_packet"));
    }
}

######


@Test
public void send40mByteBufferCompressDataException() {
    try {
        Assume.assumeTrue(!checkMaxAllowedPacketMore40m("send40mByteBufferCompressDataException", false));
        sendByteBufferData(true, array40m);
        fail("must have thrown exception");
    } catch (SQLException sqlexception) {
        assertTrue("not the expected exception. was " + sqlexception.getCause().getCause().getMessage(), sqlexception.getCause().getMessage().contains("is >= to max_allowed_packet"));
    }
}

######


private void sendByteBufferData(boolean compression, char[] arr) throws SQLException {
    try (Connection connection = setConnection("&useCompression=" + compression)) {
        Statement stmt = connection.createStatement();
        stmt.execute("TRUNCATE BufferTest");
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO BufferTest VALUES (?)");
        preparedStatement.setString(1, new String(arr));
        preparedStatement.execute();
        checkResult(arr);
    }
}

######


private void sendSqlData(boolean compression, char[] arr) throws SQLException {
    try (Connection connection = setConnection("&useCompression=" + compression)) {
        Statement stmt = connection.createStatement();
        stmt.execute("TRUNCATE BufferTest");
        stmt.execute("INSERT INTO BufferTest VALUES ('" + new String(arr) + "')");
        checkResult(arr);
    }
}

######


private void checkResult(char[] arr) throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    ResultSet rs = stmt.executeQuery("SELECT * FROM BufferTest");
    if (rs.next()) {
        String resString = rs.getString(1);
        char[] cc = resString.toCharArray();
        assertEquals("error in data : length not equal", cc.length, arr.length);
        assertEquals(String.valueOf(cc), resString);
    } else {
        fail("Error, must have result");
    }
}

######


@Select("select c.id,c.openid,c.product_id,p.product_name,p.product_icon as product_img,c.product_num,c.state from car c,product_info p \n" + "where c.state = 0 and c.openid = #{openId} and p.product_id=c.product_id and c.state=0")
List<BuyerCar> getBuyerCarByOpenid(String openId);

######


@Insert("insert into car (openid,product_id,product_num,state) " + "values(#{openid,jdbcType=VARCHAR},#{productId,jdbcType=VARCHAR}" + ",#{productNum,jdbcType=VARCHAR},#{state,jdbcType=INTEGER})")
int addBuyerCar(BuyerCar buyerCar);

######


@Update("update car set state=1 where openid= #{openId} and state = 0")
int updateCarState(String openId);

######


@Before
public void setUp() throws Exception {
    Reader reader = Resources.getResourceAsReader("org/apache/ibatis/submitted/cache/mybatis-config.xml");
    sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
    reader.close();
    SqlSession session = sqlSessionFactory.openSession();
    Connection conn = session.getConnection();
    reader = Resources.getResourceAsReader("org/apache/ibatis/submitted/cache/CreateDB.sql");
    ScriptRunner runner = new ScriptRunner(conn);
    runner.setLogWriter(null);
    runner.runScript(reader);
    conn.close();
    reader.close();
    session.close();
}

######


@Test
public void testplan1() {
    SqlSession sqlSession1 = sqlSessionFactory.openSession(false);
    try {
        PersonMapper pm = sqlSession1.getMapper(PersonMapper.class);
        Assert.assertEquals(2, pm.findAll().size());
    } finally {
        sqlSession1.close();
    }
    SqlSession sqlSession2 = sqlSessionFactory.openSession(false);
    try {
        PersonMapper pm = sqlSession2.getMapper(PersonMapper.class);
        pm.delete(1);
        Assert.assertEquals(1, pm.findAll().size());
    } finally {
        sqlSession2.commit();
        sqlSession2.close();
    }
}

######


@Test
public void testplan2() {
    SqlSession sqlSession1 = sqlSessionFactory.openSession(false);
    try {
        PersonMapper pm = sqlSession1.getMapper(PersonMapper.class);
        Assert.assertEquals(2, pm.findAll().size());
    } finally {
        sqlSession1.close();
    }
    SqlSession sqlSession2 = sqlSessionFactory.openSession(false);
    try {
        PersonMapper pm = sqlSession2.getMapper(PersonMapper.class);
        pm.delete(1);
    } finally {
        sqlSession2.rollback();
        sqlSession2.close();
    }
    SqlSession sqlSession3 = sqlSessionFactory.openSession(false);
    try {
        PersonMapper pm = sqlSession3.getMapper(PersonMapper.class);
        Assert.assertEquals(2, pm.findAll().size());
    } finally {
        sqlSession3.close();
    }
}

######


@Test
public void testplan3() {
    SqlSession sqlSession1 = sqlSessionFactory.openSession(true);
    try {
        PersonMapper pm = sqlSession1.getMapper(PersonMapper.class);
        Assert.assertEquals(2, pm.findAll().size());
    } finally {
        sqlSession1.close();
    }
    SqlSession sqlSession2 = sqlSessionFactory.openSession(true);
    try {
        PersonMapper pm = sqlSession2.getMapper(PersonMapper.class);
        pm.delete(1);
    } finally {
        sqlSession2.close();
    }
    SqlSession sqlSession3 = sqlSessionFactory.openSession(true);
    try {
        PersonMapper pm = sqlSession3.getMapper(PersonMapper.class);
        Assert.assertEquals(1, pm.findAll().size());
    } finally {
        sqlSession3.close();
    }
}

######


@Test
public void shouldInsertWithOptionsFlushesCache() {
    SqlSession sqlSession1 = sqlSessionFactory.openSession(true);
    try {
        PersonMapper pm = sqlSession1.getMapper(PersonMapper.class);
        Assert.assertEquals(2, pm.findAll().size());
    } finally {
        sqlSession1.close();
    }
    SqlSession sqlSession2 = sqlSessionFactory.openSession(true);
    try {
        PersonMapper pm = sqlSession2.getMapper(PersonMapper.class);
        Person p = new Person(3, "hello", "world");
        pm.createWithOptions(p);
    } finally {
        sqlSession2.close();
    }
    SqlSession sqlSession3 = sqlSessionFactory.openSession(true);
    try {
        PersonMapper pm = sqlSession3.getMapper(PersonMapper.class);
        Assert.assertEquals(3, pm.findAll().size());
    } finally {
        sqlSession3.close();
    }
}

######


@Test
public void shouldApplyFlushCacheOptions() {
    SqlSession sqlSession1 = sqlSessionFactory.openSession(true);
    try {
        PersonMapper pm = sqlSession1.getMapper(PersonMapper.class);
        Assert.assertEquals(2, pm.findAll().size());
    } finally {
        sqlSession1.close();
    }
    SqlSession sqlSession2 = sqlSessionFactory.openSession(true);
    try {
        PersonMapper pm = sqlSession2.getMapper(PersonMapper.class);
        Person p = new Person(3, "hello", "world");
        pm.createWithoutFlushCache(p);
    } finally {
        sqlSession2.close();
    }
    SqlSession sqlSession3 = sqlSessionFactory.openSession(true);
    try {
        PersonMapper pm = sqlSession3.getMapper(PersonMapper.class);
        Assert.assertEquals(2, pm.findAll().size());
    } finally {
        sqlSession3.close();
    }
    SqlSession sqlSession4 = sqlSessionFactory.openSession(true);
    try {
        PersonMapper pm = sqlSession4.getMapper(PersonMapper.class);
        Assert.assertEquals(3, pm.findWithFlushCache().size());
    } finally {
        sqlSession4.close();
    }
}

######


@Test
public void shouldApplyCacheNamespaceRef() {
    {
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        try {
            PersonMapper pm = sqlSession.getMapper(PersonMapper.class);
            Assert.assertEquals(2, pm.findAll().size());
            Person p = new Person(3, "hello", "world");
            pm.createWithoutFlushCache(p);
        } finally {
            sqlSession.close();
        }
    }
    {
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        try {
            PersonMapper pm = sqlSession.getMapper(PersonMapper.class);
            Assert.assertEquals(2, pm.findAll().size());
        } finally {
            sqlSession.close();
        }
    }
    {
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        try {
            ImportantPersonMapper pm = sqlSession.getMapper(ImportantPersonMapper.class);
            Assert.assertEquals(3, pm.findWithFlushCache().size());
        } finally {
            sqlSession.close();
        }
    }
    {
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        try {
            PersonMapper pm = sqlSession.getMapper(PersonMapper.class);
            Assert.assertEquals(3, pm.findAll().size());
            Person p = new Person(4, "foo", "bar");
            pm.createWithoutFlushCache(p);
        } finally {
            sqlSession.close();
        }
    }
    {
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        try {
            SpecialPersonMapper pm = sqlSession.getMapper(SpecialPersonMapper.class);
            Assert.assertEquals(4, pm.findWithFlushCache().size());
        } finally {
            sqlSession.close();
        }
    }
    {
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        try {
            PersonMapper pm = sqlSession.getMapper(PersonMapper.class);
            Assert.assertEquals(4, pm.findAll().size());
        } finally {
            sqlSession.close();
        }
    }
}

######


@Test
public void shouldApplyCustomCacheProperties() {
    CustomCache customCache = unwrap(sqlSessionFactory.getConfiguration().getCache(CustomCacheMapper.class.getName()));
    Assert.assertEquals("bar", customCache.getStringValue());
    Assert.assertEquals(1, customCache.getIntegerValue().intValue());
    Assert.assertEquals(2, customCache.getIntValue());
    Assert.assertEquals(3, customCache.getLongWrapperValue().longValue());
    Assert.assertEquals(4, customCache.getLongValue());
    Assert.assertEquals(5, customCache.getShortWrapperValue().shortValue());
    Assert.assertEquals(6, customCache.getShortValue());
    Assert.assertEquals((float) 7.1, customCache.getFloatWrapperValue(), 0);
    Assert.assertEquals((float) 8.1, customCache.getFloatValue(), 0);
    Assert.assertEquals(9.01, customCache.getDoubleWrapperValue(), 0);
    Assert.assertEquals(10.01, customCache.getDoubleValue(), 0);
    Assert.assertEquals((byte) 11, customCache.getByteWrapperValue().byteValue());
    Assert.assertEquals((byte) 12, customCache.getByteValue());
    Assert.assertEquals(true, customCache.getBooleanWrapperValue());
    Assert.assertEquals(true, customCache.isBooleanValue());
}

######


@Test
public void shouldErrorUnsupportedProperties() {
    when(sqlSessionFactory.getConfiguration()).addMapper(CustomCacheUnsupportedPropertyMapper.class);
    then(caughtException()).isInstanceOf(CacheException.class).hasMessage("Unsupported property type for cache: 'date' of type class java.util.Date");
}

######


@Test
public void shouldErrorInvalidCacheNamespaceRefAttributesSpecifyBoth() {
    when(sqlSessionFactory.getConfiguration().getMapperRegistry()).addMapper(InvalidCacheNamespaceRefBothMapper.class);
    then(caughtException()).isInstanceOf(BuilderException.class).hasMessage("Cannot use both value() and name() attribute in the @CacheNamespaceRef");
}

######


@Test
public void shouldErrorInvalidCacheNamespaceRefAttributesIsEmpty() {
    when(sqlSessionFactory.getConfiguration().getMapperRegistry()).addMapper(InvalidCacheNamespaceRefEmptyMapper.class);
    then(caughtException()).isInstanceOf(BuilderException.class).hasMessage("Should be specified either value() or name() attribute in the @CacheNamespaceRef");
}

######


private CustomCache unwrap(Cache cache) {
    Field field;
    try {
        field = cache.getClass().getDeclaredField("delegate");
    } catch (NoSuchFieldException e) {
        throw new IllegalStateException(e);
    }
    try {
        field.setAccessible(true);
        return (CustomCache) field.get(cache);
    } catch (IllegalAccessException e) {
        throw new IllegalStateException(e);
    } finally {
        field.setAccessible(false);
    }
}

######


public static void main(String[] args) {
    try {
        secondLevelCacheDemo();
        updateData();
    } finally {
        sf.close();
    }
}

######


private static void firstLevelCacheDemo() {
    Session s = sf.openSession();
    Student s1 = s.get(Student.class, 1);
    Student s2 = s.get(Student.class, 1);
    System.out.println(s1);
    System.out.println(s2);
    s.close();
}

######


public static void updateData() {
    Session s = sf.openSession();
    Query<Student> query = s.createQuery("update st set name= 'ritu343' where id = 1 ");
    Transaction t = s.beginTransaction();
    query.executeUpdate();
    t.commit();
    s.close();
}

######


private static void secondLevelCacheDemo() {
    Session s = sf.openSession();
    Student s1 = s.get(Student.class, 1);
    System.out.println(s1);
    s.close();
    s = sf.openSession();
    Student s2 = s.get(Student.class, 1);
    System.out.println(s2);
    s.close();
}

######


public static void insertRecords() {
    Student st1 = new Student("payal");
    Student st2 = new Student("ritu");
    Phone p1 = new Phone(76_372l, Type.LANDLINE, st1);
    Phone p2 = new Phone(7_38_47_476l, Type.MOBILE, st2);
    Session s = sf.openSession();
    s.beginTransaction();
    s.persist(p1);
    s.persist(p2);
    s.getTransaction().commit();
    s.close();
}

######


@Override
public ComplexParam buildXml() {
    param.addParameter("callClass", callClass);
    parsePriority();
    if (customer != null) {
        param.addParameter("customerId", customer);
        param.addParameter("customerName", customerName);
        param.addParameter("costCenter", costCenter);
    }
    if (probCode != null) {
        param.addParameter("probCode", probCode);
    }
    if (site != null) {
        param.addParameter("site", site);
    }
    if (condition != null) {
        param.addParameter("condition", condition.toString());
    }
    if (logDate != null) {
        param.addParameter("logDate", logDate);
    }
    if (groupId != null) {
        param.addParameter("groupId", groupId);
        if (analystId != null) {
            param.addParameter("analystId", analystId);
        }
    }
    param.addParameter("timeSpent", Integer.toString(timeSpent));
    param.addParameter("updateMessage", (description != null) ? description : (summary != null) ? summary : "");
    param.addParameter("updateCode", updateCode);
    param.addParameter("updateSource", updateSource);
    if (fileAttachment != null) {
        try {
            EmbeddedFileAttachment embeddedFileAttachment = new EmbeddedFileAttachment(fileAttachment);
            param.addComplexParameter(embeddedFileAttachment.buildXml());
        } catch (ParserConfigurationException e) {
            e.printStackTrace();
        }
    }
    if (summary != null) {
        addAdditionalCallValue("opencall", "itsm_title", summary);
    }
    if (organisation != null) {
        addAdditionalCallValue("opencall", "fk_company_id", organisation);
    }
    if (status != null) {
        addAdditionalCallValue("opencall", "status", Integer.toString(status.value));
    }
    try {
        param.addComplexParameter(parseAdditionalCallValues());
    } catch (ParserConfigurationException e) {
        e.printStackTrace();
    }
    return param;
}

######


public void readMetadataFromDbIfRequired() throws SQLException {
    if (valid) {
        return;
    }
    readMetadata();
    valid = true;
}

######


private int mapMariaDbTypeToJdbc(String str) {
    switch(str.toUpperCase(Locale.ROOT)) {
        case "BIT":
            return Types.BIT;
        case "TINYINT":
            return Types.TINYINT;
        case "SMALLINT":
            return Types.SMALLINT;
        case "MEDIUMINT":
            return Types.INTEGER;
        case "INT":
            return Types.INTEGER;
        case "INTEGER":
            return Types.INTEGER;
        case "LONG":
            return Types.INTEGER;
        case "BIGINT":
            return Types.BIGINT;
        case "INT24":
            return Types.INTEGER;
        case "REAL":
            return Types.DOUBLE;
        case "FLOAT":
            return Types.FLOAT;
        case "DECIMAL":
            return Types.DECIMAL;
        case "NUMERIC":
            return Types.NUMERIC;
        case "DOUBLE":
            return Types.DOUBLE;
        case "CHAR":
            return Types.CHAR;
        case "VARCHAR":
            return Types.VARCHAR;
        case "DATE":
            return Types.DATE;
        case "TIME":
            return Types.TIME;
        case "YEAR":
            return Types.SMALLINT;
        case "TIMESTAMP":
            return Types.TIMESTAMP;
        case "DATETIME":
            return Types.TIMESTAMP;
        case "TINYBLOB":
            return Types.BINARY;
        case "BLOB":
            return Types.LONGVARBINARY;
        case "MEDIUMBLOB":
            return Types.LONGVARBINARY;
        case "LONGBLOB":
            return Types.LONGVARBINARY;
        case "TINYTEXT":
            return Types.VARCHAR;
        case "TEXT":
            return Types.LONGVARCHAR;
        case "MEDIUMTEXT":
            return Types.LONGVARCHAR;
        case "LONGTEXT":
            return Types.LONGVARCHAR;
        case "ENUM":
            return Types.VARCHAR;
        case "SET":
            return Types.VARCHAR;
        case "GEOMETRY":
            return Types.LONGVARBINARY;
        case "VARBINARY":
            return Types.VARBINARY;
        default:
            return Types.OTHER;
    }
}

######


private String[] queryMetaInfos(boolean isFunction) throws SQLException {
    String paramList;
    String functionReturn;
    try (PreparedStatement preparedStatement = con.prepareStatement("select param_list, returns, db, type from mysql.proc where name=? and db=" + (database != null ? "?" : "DATABASE()"))) {
        preparedStatement.setString(1, name);
        if (database != null) {
            preparedStatement.setString(2, database);
        }
        try (ResultSet rs = preparedStatement.executeQuery()) {
            if (!rs.next()) {
                throw new SQLException((isFunction ? "function" : "procedure") + " `" + name + "` does not exist");
            }
            paramList = rs.getString(1);
            functionReturn = rs.getString(2);
            database = rs.getString(3);
            this.isFunction = "FUNCTION".equals(rs.getString(4));
            return new String[] { paramList, functionReturn };
        }
    } catch (SQLSyntaxErrorException sqlSyntaxErrorException) {
        throw new SQLException("Access to metaData informations not granted for current user. Consider grant select access to mysql.proc " + " or avoid using parameter by name", sqlSyntaxErrorException);
    }
}

######


private void parseFunctionReturnParam(String functionReturn) throws SQLException {
    if (functionReturn == null || functionReturn.length() == 0) {
        throw new SQLException(name + "is not a function returning value");
    }
    Matcher matcher = RETURN_PATTERN.matcher(functionReturn);
    if (!matcher.matches()) {
        throw new SQLException("can not parse return value definition :" + functionReturn);
    }
    CallParameter callParameter = params.get(0);
    callParameter.setOutput(true);
    callParameter.setSigned(matcher.group(1) == null);
    callParameter.setTypeName(matcher.group(2).trim());
    callParameter.setSqlType(mapMariaDbTypeToJdbc(callParameter.getTypeName()));
    String scale = matcher.group(3);
    if (scale != null) {
        scale = scale.replace("(", "").replace(")", "").replace(" ", "");
        callParameter.setScale(Integer.valueOf(scale));
    }
}

######


private void parseParamList(boolean isFunction, String paramList) throws SQLException {
    params = new ArrayList<>();
    if (isFunction) {
        params.add(new CallParameter());
    }
    Matcher matcher2 = PARAMETER_PATTERN.matcher(paramList);
    while (matcher2.find()) {
        CallParameter callParameter = new CallParameter();
        String direction = matcher2.group(1);
        if (direction != null) {
            direction = direction.trim();
        }
        callParameter.setName(matcher2.group(2).trim());
        callParameter.setSigned(matcher2.group(3) == null);
        callParameter.setTypeName(matcher2.group(4).trim().toUpperCase(Locale.ROOT));
        if (direction == null || direction.equalsIgnoreCase("IN")) {
            callParameter.setInput(true);
        } else if (direction.equalsIgnoreCase("OUT")) {
            callParameter.setOutput(true);
        } else if (direction.equalsIgnoreCase("INOUT")) {
            callParameter.setInput(true);
            callParameter.setOutput(true);
        } else {
            throw new SQLException("unknown parameter direction " + direction + "for " + callParameter.getName());
        }
        callParameter.setSqlType(mapMariaDbTypeToJdbc(callParameter.getTypeName()));
        String scale = matcher2.group(5);
        if (scale != null) {
            scale = scale.trim().replace("(", "").replace(")", "").replace(" ", "");
            if (scale.contains(",")) {
                scale = scale.substring(0, scale.indexOf(","));
            }
            callParameter.setScale(Integer.valueOf(scale));
        }
        params.add(callParameter);
    }
}

######


private void readMetadata() throws SQLException {
    if (valid) {
        return;
    }
    String[] metaInfos = queryMetaInfos(isFunction);
    String paramList = metaInfos[0];
    String functionReturn = metaInfos[1];
    parseParamList(isFunction, paramList);
    if (isFunction) {
        parseFunctionReturnParam(functionReturn);
    }
}

######


public int getParameterCount() {
    return params.size();
}

######


private CallParameter getParam(int index) throws SQLException {
    if (index < 1 || index > params.size()) {
        throw new SQLException("invalid parameter index " + index);
    }
    readMetadataFromDbIfRequired();
    return params.get(index - 1);
}

######


public int isNullable(int param) throws SQLException {
    return getParam(param).getCanBeNull();
}

######


public boolean isSigned(int param) throws SQLException {
    return getParam(param).isSigned();
}

######


public int getPrecision(int param) throws SQLException {
    return getParam(param).getPrecision();
}

######


public int getScale(int param) throws SQLException {
    return getParam(param).getScale();
}

######


public int getParameterType(int param) throws SQLException {
    return getParam(param).getSqlType();
}

######


public String getParameterTypeName(int param) throws SQLException {
    return getParam(param).getTypeName();
}

######


public String getParameterClassName(int param) throws SQLException {
    return getParam(param).getClassName();
}

######


public int getParameterMode(int param) throws SQLException {
    CallParameter callParameter = getParam(param);
    if (callParameter.isInput() && callParameter.isOutput()) {
        return parameterModeInOut;
    }
    if (callParameter.isInput()) {
        return parameterModeIn;
    }
    if (callParameter.isOutput()) {
        return parameterModeOut;
    }
    return parameterModeUnknown;
}

######


public String getName(int param) throws SQLException {
    return getParam(param).getName();
}

######


public <T> T unwrap(Class<T> iface) {
    return null;
}

######


public boolean isWrapperFor(Class<?> iface) {
    return false;
}

######


public abstract CallOutNames findByIdAndOrgi(String id, String orgi);

######


public abstract List<CallOutNames> findByNameAndOrgi(String name, String orgi);

######


public abstract Page<CallOutNames> findByActidAndOrgi(String actid, String orgi, Pageable page);

######


public abstract List<CallOutNames> findByActidAndOrgi(String actid, String orgi);

######


public abstract List<CallOutNames> findByDataidAndOrgi(String dataid, String orgi);

######


public abstract List<CallOutNames> findByDataidAndCreaterAndOrgi(String dataid, String creater, String orgi);

######


public abstract Page<CallOutNames> findAll(Specification<CallOutNames> spec, Pageable pageable);

######


public abstract Page<CallOutNames> findByCreaterAndOrgi(String creater, String orgi, Pageable page);

######


public abstract Page<CallOutNames> findByOrganAndOrgi(String organ, String orgi, Pageable page);

######


public abstract Page<CallOutNames> findByOrgi(String orgi, Pageable page);

######


public abstract Page<CallOutNames> findByOwneruserAndOrgi(String owneruser, String orgi, Pageable page);

######


public abstract List<CallOutNames> findByMetanameAndDataidAndOrgi(String metaname, String dataid, String orgi);

######


public abstract Page<CallOutNames> findByOwneraiAndOrgi(String ownerai, String orgi, Pageable page);

######


@Modifying
@Transactional
@Query(value = "delete from CallOutNames where orgi = ?1 and owneruser = ?2")
public abstract void deleteByOrgiAndOwneruser(String orgi, String owneruser);

######


@Modifying
@Transactional
@Query(value = "delete from CallOutNames where orgi = ?1 and dataid = ?2")
public abstract void deleteByOrgiAndDataid(String orgi, String dataid);

######


@Modifying
@Transactional
@Query(value = "delete from CallOutNames where orgi = ?1 and batid = ?2")
public abstract void deleteByOrgiAndBatid(String orgi, String batid);

######


@Query(value = "delete from CallOutNames where orgi = ?1 and batid = ?2")
public abstract List<CallOutNames> findByOrgiAndOnweraiAndDuration(String metaname, String dataid, String orgi);

######


public List<CalloutSaleCount> findByOrgi(String orgi);

######


@Transactional
@Modifying
@Query("delete from CalloutSaleCount where orgi = ?1")
public void deleteByOrgi(String orgi);

######


public List<CalloutSaleCount> findByOrgiAndDataid(String orgi, String dataid);

######


public List<Camera> getAllCameras() {
    Query query = em.createQuery("SELECT e FROM Camera e where e.active=true");
    return (List<Camera>) query.getResultList();
}

######


public void persist(Camera camera) {
    em.merge(camera);
}

######


public Camera getCameraByName(String cameraName) {
    return em.find(Camera.class, cameraName);
}

######


public void persist(CameraFoto cameraFoto) {
    em.merge(cameraFoto);
}

######


public void remove(CameraFoto cameraFoto) {
    if (cameraFoto != null)
        em.remove(cameraFoto);
}

######


public CameraFoto getByFileName(String fileName) {
    Query q = em.createQuery("SELECT e FROM CameraFoto e where e.fileName=:fileName");
    q.setParameter("fileName", fileName);
    List<CameraFoto> cameraFotos = q.getResultList();
    if (cameraFotos != null && cameraFotos.size() > 0) {
        return cameraFotos.get(0);
    }
    return null;
}

######


@Before
public void cancelSupported() throws SQLException {
    requireMinimumVersion(5, 0);
    Assume.assumeTrue(System.getenv("MAXSCALE_VERSION") == null);
}

######


@Test
public void cancelTest() {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection tmpConnection = openNewConnection(connUri, new Properties())) {
        Statement stmt = tmpConnection.createStatement();
        ExecutorService exec = Executors.newFixedThreadPool(1);
        exec.execute(new CancelThread(stmt));
        stmt.execute("select * from information_schema.columns as c1,  information_schema.tables, information_schema.tables as t2");
        exec.shutdown();
        Assert.fail();
    } catch (SQLException e) {
    }
}

######


@Test(timeout = 20000, expected = SQLTimeoutException.class)
public void timeoutSleep() throws Exception {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection tmpConnection = openNewConnection(connUri, new Properties())) {
        Statement stmt = tmpConnection.createStatement();
        stmt.setQueryTimeout(1);
        stmt.execute("select * from information_schema.columns as c1,  information_schema.tables, information_schema.tables as t2");
    }
}

######


@Test(timeout = 20000, expected = SQLTimeoutException.class)
public void timeoutPrepareSleep() throws Exception {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection tmpConnection = openNewConnection(connUri, new Properties())) {
        try (PreparedStatement stmt = tmpConnection.prepareStatement("select * from information_schema.columns as c1,  information_schema.tables, information_schema.tables as t2")) {
            stmt.setQueryTimeout(1);
            stmt.execute();
        }
    }
}

######


@Test(timeout = 5000)
public void timeoutBatch() throws Exception {
    Assume.assumeFalse(sharedIsAurora());
    Assume.assumeTrue(!sharedOptions().allowMultiQueries && !sharedIsRewrite());
    createTable("timeoutBatch", "id int not null primary key auto_increment, aa text");
    try (Connection connection = setConnection("&maxQuerySizeToLog=92")) {
        Statement stmt = connection.createStatement();
        char[] arr = new char[1000];
        Arrays.fill(arr, 'a');
        String str = String.valueOf(arr);
        for (int i = 0; i < 20000; i++) {
            stmt.addBatch("INSERT INTO timeoutBatch (aa) VALUES ('" + str + "')");
        }
        stmt.setQueryTimeout(1);
        try {
            stmt.executeBatch();
            fail();
        } catch (BatchUpdateException b) {
            ResultSet rs2 = stmt.executeQuery("SELECT 2");
            assertTrue(rs2.next());
            assertEquals("2", rs2.getString(1));
        }
    }
}

######


@Test(timeout = 5000)
public void timeoutPrepareBatch() throws Exception {
    Assume.assumeFalse(sharedIsAurora());
    Assume.assumeTrue(!sharedOptions().allowMultiQueries && !sharedIsRewrite());
    Assume.assumeTrue(!(sharedOptions().useBulkStmts && isMariadbServer() && minVersion(10, 2)));
    createTable("timeoutBatch", "aa text");
    try (Connection tmpConnection = openNewConnection(connUri, new Properties())) {
        char[] arr = new char[1000];
        Arrays.fill(arr, 'a');
        String str = String.valueOf(arr);
        try (PreparedStatement stmt = tmpConnection.prepareStatement("INSERT INTO timeoutBatch VALUES (?)")) {
            stmt.setQueryTimeout(1);
            for (int i = 0; i < 20000; i++) {
                stmt.setString(1, str);
                stmt.addBatch();
            }
            try {
                stmt.executeBatch();
                fail();
            } catch (BatchUpdateException b) {
                ResultSet rs2 = stmt.executeQuery("SELECT 2");
                assertTrue(rs2.next());
                assertEquals("2", rs2.getString(1));
            }
        }
    }
}

######


@Test
public void noTimeoutSleep() throws Exception {
    Statement stmt = sharedConnection.createStatement();
    stmt.setQueryTimeout(1);
    stmt.execute("select sleep(0.5)");
}

######


@Test
public void cancelIdleStatement() throws Exception {
    Statement stmt = sharedConnection.createStatement();
    stmt.cancel();
    ResultSet rs = stmt.executeQuery("select 1");
    assertTrue(rs.next());
    assertEquals(rs.getInt(1), 1);
}

######


@Override
public void run() {
    try {
        Thread.sleep(100);
        stmt.cancel();
    } catch (SQLException | InterruptedException e) {
        e.printStackTrace();
    }
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


@Select({ "select name from car where doors = #{doors[1]}" })
List<Car> getCar(Car car);

######


@Select({ "select name from car where doors = #{doors1[1]}" })
List<Rv> getRv1(Rv rv);

######


@Select({ "select name from car where doors = #{doors2[1]}" })
List<Rv> getRv2(Rv rv);

######


public List<Car> findByMakeIgnoringCase(String make) {
    return this.jdbc.query("select * from car where upper(car.make) = UPPER(?) order by id", (rs, i) -> new Car(rs.getInt("id"), rs.getString("make"), rs.getString("model"), rs.getInt("year")), make);
}

######


@Transactional
public void persist(ChangeDetection changeDetection) {
    em.persist(changeDetection);
}

######


public ChangeDetection getLast(Sensor sensor) {
    Query query = em.createQuery("SELECT e FROM ChangeDetection e where e.id=(select max(f.id) from ChangeDetection f where f.sensor=:sensor)");
    query.setParameter("sensor", sensor);
    List<ChangeDetection> res = (List<ChangeDetection>) query.getResultList();
    if (res == null || res.size() == 0)
        return null;
    return res.get(0);
}

######


public List<ChangeDetection> getChangeDetectionLog(Integer number) {
    Query query = em.createQuery("SELECT e FROM ChangeDetection e order by date desc");
    query.setMaxResults(number);
    return (List<ChangeDetection>) query.getResultList();
}

######


public ChangeDetection getChangeDetectionToSend() {
    Query query = em.createQuery("SELECT e FROM ChangeDetection e where e.notificationSended is null order by id asc");
    List<ChangeDetection> results = query.getResultList();
    if (results != null && results.size() > 0) {
        return results.get(0);
    }
    return null;
}

######


@Transactional
public void updateNotification(ChangeDetection changeDetection) {
    changeDetection.setNotificationSended(true);
    em.merge(changeDetection);
}

######


@Test
public void testStatementExecuteAutoincrement() throws SQLException {
    createTable("CheckDataTest1", "id int not null primary key auto_increment, test varchar(10)");
    Statement stmt = sharedConnection.createStatement();
    int insert = stmt.executeUpdate("INSERT INTO CheckDataTest1 (test) VALUES ('test1')", Statement.RETURN_GENERATED_KEYS);
    assertEquals(1, insert);
    int[] autoInc = setAutoInc();
    ResultSet rs = stmt.getGeneratedKeys();
    assertTrue(rs.next());
    assertEquals(autoInc[0] + autoInc[1], rs.getInt(1));
    assertFalse(rs.next());
    rs = stmt.executeQuery("SELECT * FROM CheckDataTest1");
    assertTrue(rs.next());
    assertEquals(autoInc[1] + autoInc[0], rs.getInt(1));
    assertEquals("test1", rs.getString(2));
    assertFalse(rs.next());
}

######


@Test
public void testStatementBatch() throws SQLException {
    Assume.assumeFalse(isGalera());
    createTable("CheckDataTest2", "id int not null primary key auto_increment, test varchar(10)");
    Statement stmt = sharedConnection.createStatement();
    stmt.addBatch("INSERT INTO CheckDataTest2 (id, test) VALUES (2, 'test1')");
    stmt.addBatch("INSERT INTO CheckDataTest2 (test) VALUES ('test2')");
    stmt.addBatch("UPDATE CheckDataTest2 set test = CONCAT(test, 'tt')");
    stmt.addBatch("INSERT INTO CheckDataTest2 (id, test) VALUES (9, 'test3')");
    int[] res = stmt.executeBatch();
    assertEquals(4, res.length);
    assertEquals(1, res[0]);
    assertEquals(1, res[1]);
    assertEquals(2, res[2]);
    assertEquals(1, res[3]);
    final int[] autoInc = setAutoInc();
    ResultSet rs = stmt.getGeneratedKeys();
    assertTrue(rs.next());
    assertEquals(2, rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(2 + autoInc[0] + autoInc[1], rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(9, rs.getInt(1));
    assertFalse(rs.next());
    rs = stmt.executeQuery("SELECT * FROM CheckDataTest2");
    assertTrue(rs.next());
    assertEquals(2, rs.getInt(1));
    assertEquals("test1tt", rs.getString(2));
    assertTrue(rs.next());
    assertEquals(2 + autoInc[0] + autoInc[1], rs.getInt(1));
    assertEquals("test2tt", rs.getString(2));
    assertTrue(rs.next());
    assertEquals(9, rs.getInt(1));
    assertEquals("test3", rs.getString(2));
    assertFalse(rs.next());
}

######


@Test
public void testPrepareStatementExecuteAutoincrement() throws SQLException {
    createTable("CheckDataTest3", "id int not null primary key auto_increment, test varchar(10)");
    PreparedStatement stmt = sharedConnection.prepareStatement("INSERT INTO CheckDataTest3 (test) VALUES (?)", Statement.RETURN_GENERATED_KEYS);
    stmt.setString(1, "test1");
    int[] autoInc = setAutoInc();
    int insert = stmt.executeUpdate();
    assertEquals(1, insert);
    ResultSet rs = stmt.getGeneratedKeys();
    assertTrue(rs.next());
    assertEquals(autoInc[0] + autoInc[1], rs.getInt(1));
    assertFalse(rs.next());
    int[] noBatch = stmt.executeBatch();
    assertEquals(0, noBatch.length);
    stmt.addBatch();
    int[] nbBatch = stmt.executeBatch();
    assertEquals(1, nbBatch.length);
    assertEquals(1, nbBatch[0]);
    rs = stmt.getGeneratedKeys();
    assertTrue(rs.next());
    assertEquals(autoInc[1] + 2 * autoInc[0], rs.getInt(1));
    assertFalse(rs.next());
    rs = stmt.executeQuery("SELECT * FROM CheckDataTest3");
    assertTrue(rs.next());
    assertEquals(autoInc[1] + autoInc[0], rs.getInt(1));
    assertEquals("test1", rs.getString(2));
    assertTrue(rs.next());
    assertEquals(autoInc[1] + 2 * autoInc[0], rs.getInt(1));
    assertEquals("test1", rs.getString(2));
    assertFalse(rs.next());
}

######


@Test
public void testPrepareStatementBatch() throws SQLException {
    createTable("CheckDataTest4", "id int not null primary key auto_increment, test varchar(10)");
    PreparedStatement stmt = sharedConnection.prepareStatement("INSERT INTO CheckDataTest4 (test) VALUES (?)", Statement.RETURN_GENERATED_KEYS);
    stmt.setString(1, "test1");
    stmt.addBatch();
    stmt.setString(1, "test2");
    stmt.addBatch();
    stmt.addBatch();
    int[] res = stmt.executeBatch();
    assertEquals(3, res.length);
    assertEquals(1, res[0]);
    assertEquals(1, res[1]);
    assertEquals(1, res[2]);
    int[] autoInc = setAutoInc();
    ResultSet rs = stmt.getGeneratedKeys();
    assertTrue(rs.next());
    assertEquals(autoInc[1] + autoInc[0], rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(autoInc[1] + 2 * autoInc[0], rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(autoInc[1] + 3 * autoInc[0], rs.getInt(1));
    assertFalse(rs.next());
    rs = stmt.executeQuery("SELECT * FROM CheckDataTest4");
    assertTrue(rs.next());
    assertEquals(autoInc[1] + autoInc[0], rs.getInt(1));
    assertEquals("test1", rs.getString(2));
    assertTrue(rs.next());
    assertEquals(autoInc[1] + 2 * autoInc[0], rs.getInt(1));
    assertEquals("test2", rs.getString(2));
    assertTrue(rs.next());
    assertEquals(autoInc[1] + 3 * autoInc[0], rs.getInt(1));
    assertEquals("test2", rs.getString(2));
    assertFalse(rs.next());
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    submitActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    cancelActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    backActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    dateoutActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    jLabel4 = new javax.swing.JLabel();
    bookid = new javax.swing.JTextField();
    branchid = new javax.swing.JTextField();
    cardno = new javax.swing.JTextField();
    submit = new javax.swing.JButton();
    cancel = new javax.swing.JButton();
    back = new javax.swing.JButton();
    jLabel6 = new javax.swing.JLabel();
    dateout = new javax.swing.JTextField();
    jLabel7 = new javax.swing.JLabel();
    jLabel1.setFont(new java.awt.Font("Times New Roman", 1, 18));
    jLabel1.setText("CHECK-IN");
    jLabel2.setText("Book ID");
    jLabel3.setText("Branch ID");
    jLabel4.setText("Card no");
    submit.setText("SUBMIT");
    submit.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            submitActionPerformed(evt);
        }
    });
    cancel.setText("CANCEL");
    cancel.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            cancelActionPerformed(evt);
        }
    });
    back.setText("BACK");
    back.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            backActionPerformed(evt);
        }
    });
    jLabel6.setText("DateOut");
    dateout.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            dateoutActionPerformed(evt);
        }
    });
    jLabel7.setText("(YYYY-MM-DD)");
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(61, 61, 61).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup().addGap(4, 4, 4).addComponent(submit).addGap(40, 40, 40).addComponent(cancel).addGap(43, 43, 43).addComponent(back)).addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel3).addComponent(jLabel2)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(bookid, javax.swing.GroupLayout.DEFAULT_SIZE, 100, Short.MAX_VALUE).addComponent(branchid))).addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup().addGap(77, 77, 77).addComponent(jLabel1)).addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel4).addComponent(jLabel6)).addGap(24, 24, 24).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(cardno, javax.swing.GroupLayout.PREFERRED_SIZE, 102, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(dateout, javax.swing.GroupLayout.PREFERRED_SIZE, 102, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(30, 30, 30).addComponent(jLabel7))).addContainerGap(115, Short.MAX_VALUE)));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(23, 23, 23).addComponent(jLabel1).addGap(30, 30, 30).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel2).addComponent(bookid, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel3).addComponent(branchid, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(28, 28, 28).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(cardno, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel4)).addGap(31, 31, 31).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(dateout, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel7).addComponent(jLabel6)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 48, Short.MAX_VALUE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(submit).addComponent(cancel).addComponent(back)).addGap(40, 40, 40)));
    pack();
}

######


private void cancelActionPerformed(java.awt.event.ActionEvent evt) {
    bookid.setText("");
    branchid.setText("");
    cardno.setText("");
    dateout.setText("");
}

######


private void dateoutActionPerformed(java.awt.event.ActionEvent evt) {
}

######


public void close() {
    WindowEvent winclosingevent = new WindowEvent(this, WindowEvent.WINDOW_CLOSING);
    Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(winclosingevent);
}

######


private void backActionPerformed(java.awt.event.ActionEvent evt) {
    close();
    HomePage hp = new HomePage();
    hp.setVisible(true);
}

######


private void submitActionPerformed(java.awt.event.ActionEvent evt) {
    try {
        conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/librarynew?user=root&password=shravya92");
        Statement stmt = conn.createStatement();
        String cno = cardno.getText();
        String bkid = bookid.getText();
        String brid = branchid.getText();
        int b = Integer.parseInt(brid);
        String outdate = dateout.getText();
        String add = "delete from Book_Loans where book_id='" + bkid + "' AND branch_id=" + b + " AND card_no='" + cno + "' AND Date_out='" + outdate + "';";
        stmt.executeUpdate(add);
        JOptionPane.showMessageDialog(null, "Succesfull");
        cardno.setText("");
        bookid.setText("");
        branchid.setText("");
        dateout.setText("");
        conn.close();
    } catch (SQLException ex) {
        JOptionPane.showMessageDialog(null, ex);
    }
}

######


public void run() {
    new checkin().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(checkin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(checkin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(checkin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(checkin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new checkin().setVisible(true);
        }
    });
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    bookidActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    branchidActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    submitActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    cancelActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    backActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    jLabel4 = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    bookid = new javax.swing.JTextField();
    branchid = new javax.swing.JTextField();
    cardno = new javax.swing.JTextField();
    bid = new javax.swing.JTextField();
    submit = new javax.swing.JButton();
    cancel = new javax.swing.JButton();
    back = new javax.swing.JButton();
    jLabel6 = new javax.swing.JLabel();
    jLabel1.setFont(new java.awt.Font("Times New Roman", 1, 18));
    jLabel1.setText("CHECK-OUT");
    jLabel2.setText("Book ID");
    jLabel3.setText("Branch ID");
    jLabel4.setText("Card no");
    jLabel5.setText("Book Issue Date");
    bookid.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            bookidActionPerformed(evt);
        }
    });
    branchid.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            branchidActionPerformed(evt);
        }
    });
    submit.setText("SUBMIT");
    submit.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            submitActionPerformed(evt);
        }
    });
    cancel.setText("CANCEL");
    cancel.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            cancelActionPerformed(evt);
        }
    });
    back.setText("BACK");
    back.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            backActionPerformed(evt);
        }
    });
    jLabel6.setText("(YYYY-MM-DD)");
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(66, 66, 66).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel5).addGroup(layout.createSequentialGroup().addComponent(jLabel2).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(39, 39, 39).addComponent(jLabel1)).addGroup(layout.createSequentialGroup().addGap(45, 45, 45).addComponent(bookid, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE)))).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel4).addComponent(jLabel3)).addGap(35, 35, 35).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(branchid, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(layout.createSequentialGroup().addComponent(bid, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(31, 31, 31).addComponent(jLabel6)).addComponent(cardno, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE))))).addGroup(layout.createSequentialGroup().addGap(98, 98, 98).addComponent(submit).addGap(32, 32, 32).addComponent(cancel).addGap(38, 38, 38).addComponent(back))).addContainerGap(119, Short.MAX_VALUE)));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(25, 25, 25).addComponent(jLabel1).addGap(27, 27, 27).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(bookid, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel2)).addGap(31, 31, 31).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(branchid, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel3)).addGap(29, 29, 29).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(cardno, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel4)).addGap(30, 30, 30).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(bid, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel5).addComponent(jLabel6)).addGap(42, 42, 42).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(cancel).addComponent(back).addComponent(submit)).addContainerGap(30, Short.MAX_VALUE)));
    pack();
}

######


private void bookidActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void branchidActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void submitActionPerformed(java.awt.event.ActionEvent evt) {
    try {
        conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/librarynew?user=root&password=shravya92");
        Statement stmt = conn.createStatement();
        String cno = cardno.getText();
        String bkid = bookid.getText();
        String brid = branchid.getText();
        int b = Integer.parseInt(brid);
        String outdate = bid.getText();
        String output;
        int bc = 0;
        try {
            bc = Integer.parseInt(cno);
        } catch (NumberFormatException e) {
            String st = "Enter Correct Format of Number";
            JOptionPane.showMessageDialog(null, st);
        }
        String book_count = "select count(*) from Book_loans where Card_no=" + bc + ";";
        ResultSet rs;
        String n1 = null;
        rs = stmt.executeQuery(book_count);
        while (rs.next()) {
            n1 = rs.getString("count(*)");
        }
        int count = Integer.parseInt(n1);
        if (count < 3) {
            try {
                SimpleDateFormat parser = new SimpleDateFormat("yyyy-MM-dd");
                SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");
                Date date = parser.parse(outdate);
                Date duedate = addDays(date, 14);
                output = formatter.format(duedate);
                String add = "insert into Book_Loans values('" + bkid + "'," + b + ",'" + cno + "','" + outdate + "','" + output + "');";
                stmt.executeUpdate(add);
                JOptionPane.showMessageDialog(null, "Succesfull");
                cardno.setText("");
                bookid.setText("");
                branchid.setText("");
                bid.setText("");
            } catch (ParseException ex) {
                Logger.getLogger(checkout.class.getName()).log(Level.SEVERE, null, ex);
            }
        } else {
            String st = "Maximum Limit of Books Exceeded:Unable to Loan Book";
            JOptionPane.showMessageDialog(null, st);
        }
        conn.close();
    } catch (SQLException ex) {
        JOptionPane.showMessageDialog(null, ex);
    }
}

######


public static Date addDays(Date d, int days) {
    d.setTime(d.getTime() + days * 1000 * 60 * 60 * 24);
    return d;
}

######


private void cancelActionPerformed(java.awt.event.ActionEvent evt) {
    bookid.setText("");
    branchid.setText("");
    cardno.setText("");
    bid.setText("");
}

######


public void close() {
    WindowEvent winclosingevent = new WindowEvent(this, WindowEvent.WINDOW_CLOSING);
    Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(winclosingevent);
}

######


private void backActionPerformed(java.awt.event.ActionEvent evt) {
    close();
    HomePage hp = new HomePage();
    hp.setVisible(true);
}

######


public void run() {
    new checkout().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(checkout.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(checkout.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(checkout.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(checkout.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new checkout().setVisible(true);
        }
    });
}

######


public List<CityModel> getCities() {
    Query query = getEntitymanager().createQuery("SELECT e FROM CityModel e ORDER BY e.pk ASC");
    return query.getResultList();
}

######


public List<DistrictModel> getAllDistrictsByCity(CityModel cityModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM DistrictModel e WHERE e.cityModel = :cityModel ORDER BY e.pk ASC");
    query.setParameter("cityModel", cityModel);
    return query.getResultList();
}

######


public List<HospitalPoliclinicRelModel> getPoliclinicByCity(CityModel cityModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM HospitalPoliclinicRelModel e WHERE e.hospital.districtModel.cityModel = :cityModel ORDER BY e.policlinic.policlinicName");
    query.setParameter("cityModel", cityModel);
    return query.getResultList();
}

######


public List<HospitalModel> getHospitalsByCity(CityModel cityModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM HospitalModel e WHERE e.districtModel.cityModel = :cityModel ORDER BY e.hospitalName");
    query.setParameter("cityModel", cityModel);
    return query.getResultList();
}

######


@SqlUpdate("create table clients (idt integer primary key autoincrement, photo varchar(255), nom varchar(100), prenom varchar(100), entite varchar(100), site varchar(100), adresse varchar(100), codePostal varchar(5),ville varchar(100), mail varchar(100), mdp varchar(40), dateNaiss varchar(20), tel varchar(20), fax varchar(20), metier varchar(100), domaineAct varchar(100), description varchar(250), facebook varchar(100), twitter varchar(100), linkedIn varchar(100), googlePlus varchar(100), typeDePrestation varchar(100), listeProduits varchar(250), valide boolean)")
public void createClientTable();

######


@SqlUpdate("insert into clients (photo, nom, prenom, entite, site, adresse, codePostal, ville, mail, mdp, dateNaiss, tel, fax, metier, domaineAct, description, facebook, twitter, linkedIn, googlePlus, typeDePrestation, listeProduits, valide) values (:photo, :nom, :prenom, :entite, :site,  :adresse, :codePostal, :ville, :mail, :mdp, :dateNaiss, :tel, :fax, :metier, :domaineAct, :description, :facebook, :twitter, :linkedIn, :googlePlus, :typeDePrestation, :listeProduits, :valide)")
@GetGeneratedKeys
public int insert(@BindBean Client c);

######


@SqlUpdate("update clients set photo = :photo, nom = :nom, prenom = :prenom, entite = :entite, site=:site, adresse = :adresse, codePostal = :codePostal, ville = :ville, mail = :mail, mdp = :mdp, dateNaiss = :dateNaiss, tel = :tel, fax = :fax, metier = :metier, domaineAct = :domaineAct, description = :description, facebook = :facebook, twitter = :twitter, linkedIn = :linkedIn, googlePlus = :googlePlus, typeDePrestation = :typeDePrestation, listeProduits = :listeProduits where idt = :idt")
public void update(@BindBean Client c);

######


@SqlQuery("select count(*) from clients")
public int count();

######


@SqlQuery("select * from clients where idt = :idt")
@RegisterMapperFactory(BeanMapperFactory.class)
public Client findByIdt(@Bind("idt") int idt);

######


@SqlQuery("select * from clients where mail = :mail and mdp = :mdp")
@RegisterMapperFactory(BeanMapperFactory.class)
public Client logIn(@Bind("mail") String mail, @Bind("mdp") String mdp);

######


@SqlQuery("select * from clients order by ville, entite, nom")
@RegisterMapperFactory(BeanMapperFactory.class)
public List<Client> listerClients();

######


@SqlQuery("select * from clients where nom = :nom order by ville, entite, nom")
@RegisterMapperFactory(BeanMapperFactory.class)
public List<Client> searchByName(@Bind("nom") String nom);

######


@SqlUpdate("update clients set valide = :valide where idt= :idt")
public int validerClient(@Bind("idt") int idt, @Bind("valide") boolean valide);

######


@SqlUpdate("delete from clients where idt = :idt")
public int deleteClient(@Bind("idt") int idt);

######


@SqlUpdate("drop table if exists clients")
public void dropClientTable();

######


public void close();

######


@Override
public List<Client> search(String clientName, Long clientTypeID) throws ExceededMaxResultsException {
    List<Client> results = null;
    Criteria criteria = this.getSessionFactory().getCurrentSession().createCriteria(Client.class);
    criteria.createAlias("clientType", "clientType");
    if (clientName != null && clientName.isEmpty() == false) {
        criteria.add(Restrictions.like("clientName", clientName));
    }
    if (clientTypeID != 0) {
        criteria.add(Restrictions.eq("clientType.clientTypeID", clientTypeID));
    }
    criteria.add(Restrictions.eq("TAMS4", true));
    results = criteria.list();
    return results;
}

######


@Override
public List<Client> findEd5Clients() {
    Criteria criteria = this.getSessionFactory().getCurrentSession().createCriteria(Client.class).add(Restrictions.eq("edassist5Enabled", true));
    List<Client> results = criteria.list();
    return results;
}

######


@Override
public List<Client> findEd4Clients() {
    String mainQueryString = "";
    mainQueryString += "FROM Client cli where cli.active = 1 and cli.TAMS4 = 1";
    Session session = this.getSession();
    Query<Client> query = session.createQuery(mainQueryString);
    return query.getResultList();
}

######


private String buildQuery(int programIds, int bpendDates) {
    StringBuffer buffer = new StringBuffer(PS1);
    for (int i = 0; i < programIds; i++) {
        if (i == 0) {
            buffer.append(QMARK);
        } else {
            buffer.append(QCOMMA);
        }
    }
    buffer.append(PS2);
    for (int i = 0; i < bpendDates; i++) {
        if (i == 0) {
            buffer.append(QMARK);
        } else {
            buffer.append(QCOMMA);
        }
    }
    buffer.append(PS3);
    return buffer.toString();
}

######


@Override
public void execute(Connection connection) throws SQLException {
    PreparedStatement ps = null;
    try {
        ps = connection.prepareStatement(buildQuery(arrProgramIds.length, arrBpNames.length));
        int index = 1;
        for (Long programId : arrProgramIds) {
            ps.setLong(index++, programId.longValue());
        }
        for (String bpName : arrBpNames) {
            ps.setString(index++, bpName);
        }
        ResultSet rs = ps.executeQuery();
        if (rs.next()) {
            result = rs.getLong(1);
        }
        log.debug("Result :" + result);
    } catch (SQLException ex) {
        log.error(ex);
        throw ex;
    } finally {
        if (ps != null) {
            try {
                ps.close();
            } catch (Exception e) {
                log.error(e);
            }
        }
    }
}

######


public long getResult() {
    return result;
}

######


@Override
@Transactional
public List<Program> getProgramsByClient(Long clientId) {
    Session session = this.getSession();
    CriteriaBuilder builder = session.getCriteriaBuilder();
    CriteriaQuery<Program> criteria = builder.createQuery(Program.class);
    Root<Program> root = criteria.from(Program.class);
    List<Predicate> predicatesList = new ArrayList<Predicate>();
    ParameterExpression<Long> clientParam = builder.parameter(Long.class, "clientID");
    predicatesList.add(builder.equal(root.get("clientID"), clientParam));
    predicatesList.add(builder.equal(root.get("active"), "1"));
    criteria.select(root);
    criteria.where(predicatesList.toArray(new Predicate[0]));
    Query typedQuery = session.createQuery(criteria);
    typedQuery.setParameter("clientID", clientId);
    List<Program> results = typedQuery.getResultList();
    return results;
}

######


public static String getClientFieldById(int id, String field) {
    SQLiteStatement sq;
    sq = sqlSelect("SELECT " + field + " FROM " + tableName + " WHERE Id = " + id);
    try {
        if (sq.step())
            return sq.columnString(0);
        else
            return null;
    } catch (SQLiteException e) {
        return null;
    }
}

######


public static int getClientId(String email, String cnp) {
    int clientId = -1;
    SQLiteStatement sq;
    if (email == null || cnp == null)
        return clientId;
    sq = sqlSelect("SELECT id FROM " + tableName + " WHERE email = '" + email + "' AND cnp = '" + cnp + "'");
    try {
        if (sq.step())
            clientId = sq.columnInt(0);
    } catch (SQLiteException e) {
        DataBase.err(e);
    }
    return clientId;
}

######


public static String getClientCnp(String email, String cnp) {
    int clientId;
    clientId = getClientId(email, cnp);
    return getClientFieldById(clientId, ClientDataBase.cnp);
}

######


public static long insertNewClient(Client client) {
    String query;
    long id;
    query = "INSERT INTO " + tableName + " (";
    query += "id, name, surname, phone_number, email, cnp) ";
    query += "VALUES ( NULL";
    query += ", " + "\"" + client.getName() + "\"";
    query += ", " + "\"" + client.getSurname() + "\"";
    query += ", " + "\"" + client.getPhoneNumber() + "\"";
    query += ", " + "\"" + client.getEmail() + "\"";
    query += ", " + "\"" + client.getCnp() + "\"";
    query += ")";
    id = DataBase.sqlInsert(query);
    client.setId((int) id);
    return id;
}

######


public static Client getClientById(int id) {
    SQLiteStatement sq;
    Client client;
    sq = sqlSelect("SELECT name, surname, phone_number, email, cnp  FROM " + tableName + " WHERE Id = " + id);
    try {
        if (sq.step()) {
            client = new Client();
            client.setId(id);
            client.setName(sq.columnString(0));
            client.setSurname(sq.columnString(1));
            client.setPhoneNumber(sq.columnString(2));
            client.setEmail(sq.columnString(3));
            client.setCnp(sq.columnString(4));
            return client;
        }
    } catch (SQLiteException e) {
        err(e);
    }
    return null;
}

######


public static void updateClient(Client client) {
    String query;
    int id;
    if (getClientById(client.getId()) == null) {
        id = (int) insertNewClient(client);
        return;
    }
    query = "UPDATE " + tableName + " SET name = \"" + client.getName();
    query += "\", surname = \"" + client.getSurname();
    query += "\", phone_number = \"" + client.getPhoneNumber();
    query += "\", email = \"" + client.getEmail();
    query += "\", cnp = \"" + client.getCnp();
    query += "\" WHERE id = " + client.getId();
    DataBase.sqlUpdate(query);
}

######


public boolean isCliente(String cpfCliente, String senhaCliente) {
    PreparedStatement ps = null;
    ResultSet rs = null;
    boolean resultado = false;
    try {
        ps = conexao.prepareStatement("SELECT idcliente FROM cliente WHERE cpfcliente = ? AND senhacliente = ?");
        ps.setString(1, cpfCliente);
        ps.setString(2, senhaCliente);
        rs = ps.executeQuery();
        resultado = rs.first();
        rs.close();
        ps.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return resultado;
}

######


public Cliente getCliente(String cpfCliente, String senhaCliente) {
    PreparedStatement ps = null;
    ResultSet rs = null;
    Cliente resultado = null;
    try {
        ps = conexao.prepareStatement("SELECT idcliente, cpfcliente, nomecliente, senhacliente FROM cliente WHERE cpfcliente = ? AND senhacliente = ?");
        ps.setString(1, cpfCliente);
        ps.setString(2, senhaCliente);
        rs = ps.executeQuery();
        rs.first();
        resultado = new Cliente(rs.getInt("idCliente"), rs.getString("cpfCliente"), rs.getString("nomeCliente"), rs.getString("senhaCliente"));
        rs.close();
        ps.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return resultado;
}

######


private boolean checkParsing(String sql, int paramNumber, boolean rewritable, boolean allowMultiqueries, String[] partsRewrite, String[] partsMulti) throws Exception {
    ClientSidePreparedStatement statement = new ClientSidePreparedStatement((MariaDbConnection) sharedConnection, sql, ResultSet.FETCH_FORWARD, ResultSet.CONCUR_READ_ONLY, Statement.NO_GENERATED_KEYS);
    assertEquals(paramNumber, statement.getParameterCount());
    if (sharedIsRewrite()) {
        for (int i = 0; i < partsRewrite.length; i++) {
            assertEquals(partsRewrite[i], new String(statement.getPrepareResult().getQueryParts().get(i)));
        }
        assertEquals(rewritable, statement.getPrepareResult().isQueryMultiValuesRewritable());
    } else {
        for (int i = 0; i < partsMulti.length; i++) {
            assertEquals(partsMulti[i], new String(statement.getPrepareResult().getQueryParts().get(i)));
        }
        assertEquals(allowMultiqueries, statement.getPrepareResult().isQueryMultipleRewritable());
    }
    return true;
}

######


@Test
public void stringEscapeParsing() throws Exception {
    assertTrue(checkParsing("select '\\'' as a, ? as b, \"\\\"\" as c, ? as d", 2, false, true, new String[] { "select '\\'' as a, ", "", " as b, \"\\\"\" as c, ", "", " as d" }, new String[] { "select '\\'' as a, ", " as b, \"\\\"\" as c, ", " as d" }));
}

######


@Test
public void testRewritableWithConstantParameter() throws Exception {
    assertTrue(checkParsing("INSERT INTO TABLE(col1,col2,col3,col4, col5) VALUES (9, ?, 5, ?, 8) ON DUPLICATE KEY UPDATE col2=col2+10", 2, true, true, new String[] { "INSERT INTO TABLE(col1,col2,col3,col4, col5) VALUES", " (9, ", ", 5, ", ", 8)", " ON DUPLICATE KEY UPDATE col2=col2+10" }, new String[] { "INSERT INTO TABLE(col1,col2,col3,col4, col5) VALUES (9, ", ", 5, ", ", 8) ON DUPLICATE KEY UPDATE col2=col2+10" }));
}

######


@Test
public void testComment() throws Exception {
    assertTrue(checkParsing("/* insert Select INSERT INTO tt VALUES (?,?,?,?)  */" + " INSERT into " + "/* insert Select INSERT INTO tt VALUES (?,?,?,?)  */" + " tt VALUES " + "/* insert Select INSERT INTO tt VALUES (?,?,?,?)  */" + " (?) " + "/* insert Select INSERT INTO tt VALUES (?,?,?,?)  */", 1, true, true, new String[] { "/* insert Select INSERT INTO tt VALUES (?,?,?,?)  */" + " INSERT into " + "/* insert Select INSERT INTO tt VALUES (?,?,?,?)  */" + " tt VALUES", " /* insert Select INSERT INTO tt VALUES (?,?,?,?)  */ (", ")", " /* insert Select INSERT INTO tt VALUES (?,?,?,?)  */" }, new String[] { "/* insert Select INSERT INTO tt VALUES (?,?,?,?)  */" + " INSERT into " + "/* insert Select INSERT INTO tt VALUES (?,?,?,?)  */" + " tt VALUES " + "/* insert Select INSERT INTO tt VALUES (?,?,?,?)  */" + " (", ") " + "/* insert Select INSERT INTO tt VALUES (?,?,?,?)  */" }));
}

######


@Test
public void testRewritableWithConstantParameterAndParamAfterValue() throws Exception {
    assertTrue(checkParsing("INSERT INTO TABLE(col1,col2,col3,col4, col5) VALUES (9, ?, 5, ?, 8) ON DUPLICATE KEY UPDATE col2=?", 3, false, true, new String[] { "INSERT INTO TABLE(col1,col2,col3,col4, col5) VALUES", " (9, ", ", 5, ", ", 8) ON DUPLICATE KEY UPDATE col2=", "", "" }, new String[] { "INSERT INTO TABLE(col1,col2,col3,col4, col5) VALUES (9, ", ", 5, ", ", 8) ON DUPLICATE KEY UPDATE col2=", "" }));
}

######


@Test
public void testRewritableMultipleInserts() throws Exception {
    assertTrue(checkParsing("INSERT INTO TABLE(col1,col2) VALUES (?, ?), (?, ?)", 4, false, true, new String[] { "INSERT INTO TABLE(col1,col2) VALUES", " (", ", ", "), (", ", ", ")", "" }, new String[] { "INSERT INTO TABLE(col1,col2) VALUES (", ", ", "), (", ", ", ")" }));
}

######


@Test
public void testCall() throws Exception {
    assertTrue(checkParsing("CALL dsdssd(?,?)", 2, false, true, new String[] { "CALL dsdssd(", "", ",", ")", "" }, new String[] { "CALL dsdssd(", ",", ")" }));
}

######


@Test
public void testUpdate() throws Exception {
    assertTrue(checkParsing("UPDATE MultiTestt4 SET test = ? WHERE test = ?", 2, false, true, new String[] { "UPDATE MultiTestt4 SET test = ", "", " WHERE test = ", "", "" }, new String[] { "UPDATE MultiTestt4 SET test = ", " WHERE test = ", "" }));
}

######


@Test
public void testInsertSelect() throws Exception {
    assertTrue(checkParsing("insert into test_insert_select ( field1) (select  TMP.field1 from " + "(select CAST(? as binary) `field1` from dual) TMP)", 1, false, true, new String[] { "insert into test_insert_select ( field1) (select  TMP.field1 from (select CAST(", "", " as binary) `field1` from dual) TMP)", "" }, new String[] { "insert into test_insert_select ( field1) (select  TMP.field1 from (select CAST(", " as binary) `field1` from dual) TMP)" }));
}

######


@Test
public void testWithoutParameter() throws Exception {
    assertTrue(checkParsing("SELECT testFunction()", 0, false, true, new String[] { "SELECT testFunction()", "", "" }, new String[] { "SELECT testFunction()" }));
}

######


@Test
public void testWithoutParameterAndParenthesis() throws Exception {
    assertTrue(checkParsing("SELECT 1", 0, false, true, new String[] { "SELECT 1", "", "" }, new String[] { "SELECT 1" }));
}

######


@Test
public void testWithoutParameterAndValues() throws Exception {
    assertTrue(checkParsing("INSERT INTO tt VALUES (1)", 0, true, true, new String[] { "INSERT INTO tt VALUES", " (1)", "" }, new String[] { "INSERT INTO tt VALUES (1)" }));
}

######


@Test
public void testSemiColon() throws Exception {
    assertTrue(checkParsing("INSERT INTO tt (tt) VALUES (?); INSERT INTO tt (tt) VALUES ('multiple')", 1, false, true, new String[] { "INSERT INTO tt (tt) VALUES", " (", ")", "; INSERT INTO tt (tt) VALUES ('multiple')" }, new String[] { "INSERT INTO tt (tt) VALUES (", "); INSERT INTO tt (tt) VALUES ('multiple')" }));
}

######


@Test
public void testSemicolonRewritableIfAtEnd() throws Exception {
    assertTrue(checkParsing("INSERT INTO table (column1) VALUES (?); ", 1, true, false, new String[] { "INSERT INTO table (column1) VALUES", " (", ")", "; " }, new String[] { "INSERT INTO table (column1) VALUES (", "); " }));
}

######


@Test
public void testSemicolonNotRewritableIfNotAtEnd() throws Exception {
    assertTrue(checkParsing("INSERT INTO table (column1) VALUES (?); SELECT 1", 1, false, true, new String[] { "INSERT INTO table (column1) VALUES", " (", ")", "; SELECT 1" }, new String[] { "INSERT INTO table (column1) VALUES (", "); SELECT 1" }));
}

######


@Test
public void testError() throws Exception {
    assertTrue(checkParsing("INSERT INTO tt (tt) VALUES (?); INSERT INTO tt (tt) VALUES ('multiple')", 1, false, true, new String[] { "INSERT INTO tt (tt) VALUES", " (", ")", "; INSERT INTO tt (tt) VALUES ('multiple')" }, new String[] { "INSERT INTO tt (tt) VALUES (", "); INSERT INTO tt (tt) VALUES ('multiple')" }));
}

######


@Test
public void testLineComment() throws Exception {
    assertTrue(checkParsing("INSERT INTO tt (tt) VALUES (?) --fin", 1, true, false, new String[] { "INSERT INTO tt (tt) VALUES", " (", ")", " --fin" }, new String[] { "INSERT INTO tt (tt) VALUES (", ") --fin" }));
}

######


@Test
public void testLineCommentFinished() throws Exception {
    assertTrue(checkParsing("INSERT INTO tt (tt) VALUES --fin\n (?)", 1, true, true, new String[] { "INSERT INTO tt (tt) VALUES", " --fin\n (", ")", "" }, new String[] { "INSERT INTO tt (tt) VALUES --fin\n (", ")" }));
}

######


@Test
public void testSelect1() throws Exception {
    assertTrue(checkParsing("SELECT 1", 0, false, true, new String[] { "SELECT 1", "", "" }, new String[] { "SELECT 1" }));
}

######


@Test
public void rewriteBatchedError() throws Exception {
    try (Connection connection = setConnection("&rewriteBatchedStatements=true&dumpQueriesOnException")) {
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO errorTable (a, b) VALUES (?, ?, ?)");
        preparedStatement.setString(1, "1");
        preparedStatement.setString(2, "2");
        preparedStatement.setString(3, "3");
        preparedStatement.addBatch();
        try {
            preparedStatement.executeBatch();
            fail("must have thrown error since parameters are not good");
        } catch (SQLException e) {
            assertTrue(e.getCause().getCause().getMessage().contains("Query is: INSERT INTO errorTable (a, b) VALUES (?, ?, ?)"));
        }
    }
}

######


@Test
public void testLastInsertId() throws Exception {
    assertTrue(checkParsing("INSERT INTO tt (tt, tt2) VALUES (LAST_INSERT_ID(), ?)", 1, false, true, new String[] { "INSERT INTO tt (tt, tt2) VALUES", " (LAST_INSERT_ID(), ", ")", "" }, new String[] { "INSERT INTO tt (tt, tt2) VALUES (LAST_INSERT_ID(), ", ")" }));
}

######


@Test
public void testValuesForPartition() throws Exception {
    assertTrue(checkParsing("ALTER table test_partitioning PARTITION BY RANGE COLUMNS( created_at ) " + "(PARTITION test_p201605 VALUES LESS THAN ('2016-06-01'))", 0, false, true, new String[] { "ALTER table test_partitioning PARTITION BY RANGE COLUMNS( created_at ) " + "(PARTITION test_p201605 VALUES", " LESS THAN ('2016-06-01'))", "" }, new String[] { "ALTER table test_partitioning PARTITION BY RANGE COLUMNS( created_at ) " + "(PARTITION test_p201605 VALUES LESS THAN ('2016-06-01'))" }));
}

######


@Test
public void closedStatement() throws SQLException {
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT ?");
    preparedStatement.setString(1, "1");
    preparedStatement.execute();
    preparedStatement.setString(1, "1");
    preparedStatement.executeQuery();
    preparedStatement.setString(1, "1");
    preparedStatement.executeUpdate();
    preparedStatement.close();
    try {
        preparedStatement.setString(1, "1");
        preparedStatement.execute();
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("is called on closed statement"));
    }
    try {
        preparedStatement.setString(1, "1");
        preparedStatement.executeQuery();
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("is called on closed statement"));
    }
    try {
        preparedStatement.setString(1, "1");
        preparedStatement.executeUpdate();
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("is called on closed statement"));
    }
}

######


@Test
public void timeoutStatement() throws SQLException {
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT ?");
    preparedStatement.setQueryTimeout(10);
    preparedStatement.setString(1, "1");
    preparedStatement.execute();
    preparedStatement.setString(1, "1");
    preparedStatement.executeQuery();
    preparedStatement.setString(1, "1");
    preparedStatement.executeUpdate();
}

######


@Test
public void paramNumber() throws SQLException {
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT ?, ?");
    try {
        preparedStatement.setString(1, "1");
        preparedStatement.execute();
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("Parameter at position 2 is not set"));
    }
    try {
        preparedStatement.setString(1, "1");
        preparedStatement.executeQuery();
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("Parameter at position 2 is not set"));
    }
    try {
        preparedStatement.setString(1, "1");
        preparedStatement.executeUpdate();
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("Parameter at position 2 is not set"));
    }
}

######


@Test
public void batchParamNumber() throws SQLException {
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT ?, ?");
    assertEquals(0, preparedStatement.executeBatch().length);
    assertEquals(0, preparedStatement.executeLargeBatch().length);
    try {
        preparedStatement.setString(1, "1");
        preparedStatement.addBatch();
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("You need to set exactly 2 parameters on the prepared statement") || e.getMessage().contains("Parameter at position 2 is not set"));
    }
    try {
        preparedStatement.addBatch("SOME SQL");
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("Cannot do addBatch(String) on preparedStatement"));
    }
    preparedStatement.setString(1, "1");
    preparedStatement.setString(2, "2");
    preparedStatement.addBatch();
    preparedStatement.setString(2, "2");
    preparedStatement.addBatch();
    try {
        preparedStatement.clearParameters();
        preparedStatement.setString(2, "2");
        preparedStatement.addBatch();
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("You need to set exactly 2 parameters on the prepared statement") || e.getMessage().contains("Parameter at position 1 is not set"));
    }
}

######


@Test
public void setParameterError() throws SQLException {
    Assume.assumeFalse(sharedOptions().useServerPrepStmts);
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT ?, ?");
    preparedStatement.setString(1, "a");
    preparedStatement.setString(2, "a");
    try {
        preparedStatement.setString(3, "a");
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("Could not set parameter at position 3 (values was 'a')"));
    }
    try {
        preparedStatement.setString(0, "a");
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("Could not set parameter at position 0 (values was 'a')"));
    }
}

######


@Test
public void closedBatchError() throws SQLException {
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT ?, ?");
    preparedStatement.setString(1, "1");
    preparedStatement.setString(2, "1");
    preparedStatement.addBatch();
    preparedStatement.executeBatch();
    preparedStatement.close();
    try {
        preparedStatement.setString(1, "2");
        preparedStatement.setString(2, "2");
        preparedStatement.addBatch();
        preparedStatement.executeBatch();
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("Cannot do an operation on a closed statement"));
    }
}

######


@Test
public void executeLargeBatchError() throws SQLException {
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO unknownTable values (?, ?)");
    preparedStatement.setString(1, "1");
    preparedStatement.setString(2, "1");
    preparedStatement.addBatch();
    try {
        preparedStatement.executeLargeBatch();
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("doesn't exist"));
    }
}

######


@Test
public void executeBatchOneByOne() throws SQLException {
    try (Connection connection = setConnection("&rewriteBatchedStatements=false&useBulkStmts=false&useBatchMultiSend=false")) {
        Statement stmt = connection.createStatement();
        stmt.execute("CREATE TEMPORARY TABLE executeBatchOneByOne (c1 varchar(16), c2 varchar(16))");
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO executeBatchOneByOne values (?, ?)");
        preparedStatement.setString(1, "1");
        preparedStatement.setString(2, "1");
        preparedStatement.addBatch();
        preparedStatement.setQueryTimeout(10);
        assertEquals(1, preparedStatement.executeBatch().length);
    }
}

######


@Test
public void metaDataForWrongQuery() throws SQLException {
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("WRONG QUERY");
    try {
        preparedStatement.getMetaData();
        fail();
    } catch (SQLSyntaxErrorException e) {
        assertTrue(e.getMessage().contains("You have an error in your SQL syntax"));
    }
}

######


@Test
public void getMultipleMetaData() throws SQLException {
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT 1 as a");
    ResultSetMetaData meta = preparedStatement.getMetaData();
    assertEquals("a", meta.getColumnName(1));
    preparedStatement.execute();
    meta = preparedStatement.getMetaData();
    assertEquals("a", meta.getColumnName(1));
}

######


@Test
public void prepareToString() throws SQLException {
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT ? as a, ? as b");
    preparedStatement.setString(1, "a");
    preparedStatement.setNull(2, Types.VARCHAR);
    assertEquals("sql : 'SELECT ? as a, ? as b', parameters : ['a',<null>]", preparedStatement.toString());
}

######


@Test
public void selectQuery() {
    assertFalse(checkRewritable("SELECT * FROM MyTable"));
    assertFalse(checkRewritable("SELECT\n * FROM MyTable"));
    assertFalse(checkRewritable("SELECT(1)"));
    assertFalse(checkRewritable("INSERT MyTable (a) VALUES (1);SELECT(1)"));
}

######


@Test
public void insertSelectQuery() {
    assertFalse(checkRewritable("INSERT INTO MyTable (a) SELECT * FROM seq_1_to_1000"));
    assertFalse(checkRewritable("INSERT INTO MyTable (a);SELECT * FROM seq_1_to_1000"));
    assertFalse(checkRewritable("INSERT INTO MyTable (a)SELECT * FROM seq_1_to_1000"));
    assertFalse(checkRewritable("INSERT INTO MyTable (a) (SELECT * FROM seq_1_to_1000)"));
    assertFalse(checkRewritable("INSERT INTO MyTable (a) SELECT\n * FROM seq_1_to_1000"));
}

######


@Test
public void rewritableThatContainSelectQuery() {
    assertTrue(checkRewritable("INSERT INTO TABLE_SELECT "));
    assertTrue(checkRewritable("INSERT INTO TABLE_SELECT"));
    assertTrue(checkRewritable("INSERT INTO SELECT_TABLE"));
    assertTrue(checkRewritable("INSERT INTO `TABLE SELECT `"));
    assertTrue(checkRewritable("INSERT INTO TABLE /* SELECT in comment */ "));
    assertTrue(checkRewritable("INSERT INTO TABLE //SELECT"));
}

######


private boolean checkRewritable(String query) {
    return ClientPrepareResult.rewritableParts(query, true).isQueryMultiValuesRewritable();
}

######


@BeforeClass
public static void setupSqlSessionFactory() throws Exception {
    DataSource dataSource = BaseDataTest.createUnpooledDataSource("org/apache/ibatis/type/jdbc.properties");
    BaseDataTest.runScript(dataSource, "org/apache/ibatis/type/ClobReaderTypeHandlerTest.sql");
    TransactionFactory transactionFactory = new JdbcTransactionFactory();
    Environment environment = new Environment("Production", transactionFactory, dataSource);
    Configuration configuration = new Configuration(environment);
    configuration.addMapper(Mapper.class);
    sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);
}

######


@Override
@Test
public void shouldSetParameter() throws Exception {
    Reader reader = new StringReader("Hello");
    TYPE_HANDLER.setParameter(ps, 1, reader, null);
    verify(ps).setClob(1, reader);
}

######


@Override
@Test
public void shouldGetResultFromResultSetByName() throws Exception {
    Reader reader = new StringReader("Hello");
    when(rs.getClob("column")).thenReturn(clob);
    when(rs.wasNull()).thenReturn(false);
    when(clob.getCharacterStream()).thenReturn(reader);
    assertEquals(reader, TYPE_HANDLER.getResult(rs, "column"));
}

######


@Override
@Test
public void shouldGetResultNullFromResultSetByName() throws Exception {
    when(rs.getClob("column")).thenReturn(null);
    when(rs.wasNull()).thenReturn(true);
    assertNull(TYPE_HANDLER.getResult(rs, "column"));
}

######


@Override
@Test
public void shouldGetResultFromResultSetByPosition() throws Exception {
    when(rs.getClob(1)).thenReturn(clob);
    when(rs.wasNull()).thenReturn(true);
    assertNull(TYPE_HANDLER.getResult(rs, 1));
}

######


@Override
@Test
public void shouldGetResultNullFromResultSetByPosition() throws Exception {
    when(rs.getClob(1)).thenReturn(null);
    when(rs.wasNull()).thenReturn(true);
    assertNull(TYPE_HANDLER.getResult(rs, 1));
}

######


@Override
@Test
public void shouldGetResultFromCallableStatement() throws Exception {
    Reader reader = new StringReader("Hello");
    when(cs.getClob(1)).thenReturn(clob);
    when(cs.wasNull()).thenReturn(false);
    when(clob.getCharacterStream()).thenReturn(reader);
    assertEquals(reader, TYPE_HANDLER.getResult(cs, 1));
}

######


@Override
@Test
public void shouldGetResultNullFromCallableStatement() throws Exception {
    when(cs.getClob(1)).thenReturn(null);
    when(cs.wasNull()).thenReturn(true);
    assertNull(TYPE_HANDLER.getResult(cs, 1));
}

######


@Test
public void integrationTest() throws IOException {
    SqlSession session = sqlSessionFactory.openSession();
    try {
        Mapper mapper = session.getMapper(Mapper.class);
        {
            ClobContent clobContent = new ClobContent();
            clobContent.setId(1);
            clobContent.setContent(new StringReader("Hello"));
            mapper.insert(clobContent);
            session.commit();
        }
        {
            ClobContent clobContent = mapper.findOne(1);
            assertThat(new BufferedReader(clobContent.getContent()).readLine()).isEqualTo("Hello");
        }
    } finally {
        session.close();
    }
}

######


@Select("SELECT ID, CONTENT FROM TEST_CLOB WHERE ID = #{id}")
ClobContent findOne(int id);

######


@Insert("INSERT INTO TEST_CLOB (ID, CONTENT) VALUES(#{id}, #{content})")
void insert(ClobContent blobContent);

######


public int getId() {
    return id;
}

######


public void setId(int id) {
    this.id = id;
}

######


public Reader getContent() {
    return content;
}

######


public void setContent(Reader content) {
    this.content = content;
}

######


public void addKrankheit(CL_Krankheit po_krankheit) {
    if (!getIo_krankheiten().contains(po_krankheit)) {
        getIo_krankheiten().add(po_krankheit);
    }
    if (!po_krankheit.getIo_symptome().contains(this)) {
        po_krankheit.getIo_symptome().add(this);
    }
}

######


public Long getIv_id() {
    return iv_id;
}

######


public CL_Symptom getIo_Symptom() {
    return io_symptom;
}

######


public int getIv_wert() {
    return iv_wert;
}

######


public List<CL_Krankheit> getIo_krankheiten() {
    return io_krankheiten;
}

######


public void setIv_id(Long iv_id) {
    this.iv_id = iv_id;
}

######


public void setSymptom(CL_Symptom symptom) {
    this.io_symptom = symptom;
}

######


public void setIv_wert(int iv_wert) {
    this.iv_wert = iv_wert;
}

######


public void setIo_krankheiten(List<CL_Krankheit> io_krankheiten) {
    this.io_krankheiten = io_krankheiten;
}

######


@Override
public int hashCode() {
    int hash = 0;
    hash += (iv_id != null ? iv_id.hashCode() : 0);
    return hash;
}

######


@Override
public boolean equals(Object object) {
    if (!(object instanceof CL_Bewertetes_Symptom)) {
        return false;
    }
    CL_Bewertetes_Symptom other = (CL_Bewertetes_Symptom) object;
    if ((this.iv_id == null && other.iv_id != null) || (this.iv_id != null && !this.iv_id.equals(other.iv_id))) {
        return false;
    }
    return true;
}

######


@Override
public String toString() {
    return "model.CL_Bewertetes_Symptom[ id=" + iv_id + " ]";
}

######


public static boolean init(String dbName, String tableName) {
    if (Cocos2dxActivity.getContext() != null) {
        DATABASE_NAME = dbName;
        TABLE_NAME = tableName;
        mDatabaseOpenHelper = new DBOpenHelper(Cocos2dxActivity.getContext());
        mDatabase = mDatabaseOpenHelper.getWritableDatabase();
        return true;
    }
    return false;
}

######


public static void destory() {
    if (mDatabase != null) {
        mDatabase.close();
    }
}

######


public static void setItem(String key, String value) {
    try {
        String sql = "replace into " + TABLE_NAME + "(key,value)values(?,?)";
        mDatabase.execSQL(sql, new Object[] { key, value });
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public static String getItem(String key) {
    String ret = null;
    try {
        String sql = "select value from " + TABLE_NAME + " where key=?";
        Cursor c = mDatabase.rawQuery(sql, new String[] { key });
        while (c.moveToNext()) {
            if (ret != null) {
                Log.e(TAG, "The key contains more than one value.");
                break;
            }
            ret = c.getString(c.getColumnIndex("value"));
        }
        c.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return ret == null ? "" : ret;
}

######


public static void removeItem(String key) {
    try {
        String sql = "delete from " + TABLE_NAME + " where key=?";
        mDatabase.execSQL(sql, new Object[] { key });
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL("CREATE TABLE IF NOT EXISTS " + TABLE_NAME + "(key TEXT PRIMARY KEY,value TEXT);");
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    Log.w(TAG, "Upgrading database from version " + oldVersion + " to " + newVersion + ", which will destroy all old data");
}

######


@Override
public Collana doRetriveById(Object... id) {
    String isbn = (String) id[0];
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveByIsbnLibro);
        prst.setString(1, isbn);
        try {
            ResultSet rs = prst.executeQuery();
            con.commit();
            Collana collana = null;
            if (rs.next()) {
                collana = new Collana(isbn, rs.getString("NumeroOrdineCollana"));
            }
            rs.close();
            return collana;
        } catch (SQLException e) {
            con.rollback();
            return null;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
        return null;
    }
}

######


@Override
public List<Collana> doRetriveAll() {
    List<Collana> toReturn = new ArrayList<>();
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveAllQuery);
        ResultSet rs = prst.executeQuery();
        con.commit();
        while (rs.next()) {
            Collana collana = new Collana(rs.getString("NomeCollana"));
            toReturn.add(collana);
        }
        rs.close();
    } catch (SQLException ex) {
        Logger.getLogger(CollanaDAO.class.getName()).log(Level.SEVERE, null, ex);
    }
    return toReturn;
}

######


@Override
public int doInsert(Collana entity) {
    throw new UnsupportedOperationException("Not supported yet.");
}

######


@Override
public int doUpdate(Collana entity) {
    throw new UnsupportedOperationException("Not supported yet.");
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("emojiTest", "id int unsigned, field longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci");
    createTable("unicodeTestChar", "id int unsigned, field1 varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci, field2 longtext " + "CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci", "DEFAULT CHARSET=utf8mb4");
    createTable("textUtf8", "column1 text", "DEFAULT CHARSET=utf8");
    createTable("blobUtf8", "column1 blob", "DEFAULT CHARSET=utf8");
}

######


@Test
public void emoji() throws SQLException {
    try (Connection connection = setConnection()) {
        String sqlForCharset = "select @@character_set_server";
        ResultSet rs = connection.createStatement().executeQuery(sqlForCharset);
        assertTrue(rs.next());
        final String serverCharacterSet = rs.getString(1);
        sqlForCharset = "select @@character_set_client";
        rs = connection.createStatement().executeQuery(sqlForCharset);
        assertTrue(rs.next());
        String clientCharacterSet = rs.getString(1);
        if ("utf8mb4".equalsIgnoreCase(serverCharacterSet)) {
            assertEquals(serverCharacterSet, clientCharacterSet);
        } else {
            connection.createStatement().execute("SET NAMES utf8mb4");
        }
        PreparedStatement ps = connection.prepareStatement("INSERT INTO emojiTest (id, field) VALUES (1, ?)");
        byte[] emoji = new byte[] { (byte) 0xF0, (byte) 0x9F, (byte) 0x98, (byte) 0x84 };
        ps.setBytes(1, emoji);
        ps.execute();
        ps = connection.prepareStatement("SELECT field FROM emojiTest");
        rs = ps.executeQuery();
        assertTrue(rs.next());
        assertEquals("😄", rs.getString(1));
    }
}

######


@Test
public void test4BytesUtf8() throws Exception {
    String sqlForCharset = "select @@character_set_server";
    ResultSet rs = sharedConnection.createStatement().executeQuery(sqlForCharset);
    if (rs.next()) {
        String emoji = "🌟";
        boolean mustThrowError = true;
        String serverCharset = rs.getString(1);
        if ("utf8mb4".equals(serverCharset)) {
            mustThrowError = false;
        }
        PreparedStatement ps = sharedConnection.prepareStatement("INSERT INTO unicodeTestChar (id, field1, field2) VALUES (1, ?, ?)");
        ps.setString(1, emoji);
        Reader reader = new StringReader(emoji);
        ps.setCharacterStream(2, reader);
        try {
            ps.execute();
            ps = sharedConnection.prepareStatement("SELECT field1, field2 FROM unicodeTestChar");
            rs = ps.executeQuery();
            assertTrue(rs.next());
            assertEquals(4, rs.getBytes(1).length);
            assertEquals(emoji, rs.getString(1));
            assertEquals(4, rs.getBytes(2).length);
            assertEquals(emoji, rs.getString(2));
        } catch (SQLDataException exception) {
            if (!mustThrowError) {
                fail("Must not have thrown error");
            }
        } catch (SQLException exception) {
            if (isMariadbServer()) {
                fail("must have thrown a SQLDataException, not an SQLException");
            }
            if (!mustThrowError) {
                fail("Must not have thrown error");
            }
        }
    } else {
        fail();
    }
}

######


@Test
public void testText() throws SQLException {
    String str = "你好(hello in Chinese)";
    try (PreparedStatement ps = sharedConnection.prepareStatement("insert into textUtf8 values (?)")) {
        ps.setString(1, str);
        ps.executeUpdate();
    }
    try (PreparedStatement ps = sharedConnection.prepareStatement("select * from textUtf8");
        ResultSet rs = ps.executeQuery()) {
        while (rs.next()) {
            String tmp = rs.getString(1);
            assertEquals(tmp, str);
        }
    }
}

######


@Test
public void testBinary() throws SQLException {
    String str = "你好(hello in Chinese)";
    byte[] strBytes = str.getBytes(Charset.forName("UTF-8"));
    try (PreparedStatement ps = sharedConnection.prepareStatement("insert into blobUtf8 values (?)")) {
        ps.setBytes(1, strBytes);
        ps.executeUpdate();
    }
    try (PreparedStatement ps = sharedConnection.prepareStatement("select * from blobUtf8");
        ResultSet rs = ps.executeQuery()) {
        while (rs.next()) {
            byte[] tmp = rs.getBytes(1);
            for (int i = 0; i < tmp.length; i++) {
                assertEquals(strBytes[i], tmp[i]);
            }
        }
    }
}

######


@Test
public void insertAndSelectShouldBothUseLatin1Encoding() throws SQLException {
    createTable("fooLatin1", "x longtext", "DEFAULT CHARSET=latin1");
    final String latin1String = "ÄÖÜ";
    final Clob insertClob = sharedConnection.createClob();
    insertClob.setString(1, latin1String);
    final String insertSql = "INSERT INTO fooLatin1 VALUES(?)";
    PreparedStatement preparedStatement = sharedConnection.prepareStatement(insertSql);
    preparedStatement.setString(1, latin1String);
    preparedStatement.executeUpdate();
    preparedStatement.setClob(1, insertClob);
    preparedStatement.executeUpdate();
    final String selectSql = "select x from fooLatin1";
    ResultSet rs1 = preparedStatement.executeQuery(selectSql);
    assertTrue(rs1.next());
    assertEquals(latin1String, rs1.getString(1));
    assertTrue(rs1.next());
    assertEquals(latin1String, rs1.getString(1));
    Clob clob = rs1.getClob(1);
    assertEquals(latin1String, clob.getSubString(1, (int) clob.length()));
    assertFalse(rs1.next());
}

######


@Test
public void languageCasing() throws SQLException {
    Locale currentLocal = Locale.getDefault();
    createTable("languageCasing", "ID int, id2 int");
    try (Statement statement = sharedConnection.createStatement()) {
        statement.execute("INSERT INTO languageCasing values (1,2)");
        ResultSet rs = statement.executeQuery("SELECT * FROM languageCasing");
        assertTrue(rs.next());
        assertEquals(1, rs.getInt("ID"));
        assertEquals(1, rs.getInt("id"));
        assertEquals(2, rs.getInt("ID2"));
        assertEquals(2, rs.getInt("id2"));
        Locale.setDefault(new Locale("tr"));
        rs = statement.executeQuery("SELECT * FROM languageCasing");
        assertTrue(rs.next());
        assertEquals(1, rs.getInt("ID"));
        assertEquals(1, rs.getInt("id"));
        assertEquals(2, rs.getInt("ID2"));
        assertEquals(2, rs.getInt("id2"));
    } finally {
        Locale.setDefault(currentLocal);
    }
}

######


@Test
public void wrongSurrogate() throws SQLException {
    byte[] bb = "a\ud800b".getBytes(StandardCharsets.UTF_8);
    try (Connection conn = setConnection()) {
        Statement stmt = conn.createStatement();
        stmt.execute("CREATE TEMPORARY TABLE wrong_utf8_string(tt text) CHARSET utf8mb4");
        String wrongString = "a\ud800b";
        try (PreparedStatement preparedStatement = conn.prepareStatement("INSERT INTO wrong_utf8_string values (?)")) {
            preparedStatement.setString(1, wrongString);
            preparedStatement.execute();
        }
        ResultSet rs = stmt.executeQuery("SELECT * from wrong_utf8_string");
        assertTrue(rs.next());
        assertEquals("a?b", rs.getString(1));
    }
}

######


public SessionFactory getSessionFactory() {
    return sessionFactory;
}

######


public void setSessionFactory(SessionFactory sessionFactory) {
    this.sessionFactory = sessionFactory;
}

######


@Override
public int addConcer(Concer con, String id) {
    Session session = this.getSessionFactory().getCurrentSession();
    User user = (User) session.get(User.class, id);
    con.setUserByConcernedId(user);
    session.save(con);
    return 1;
}

######


@Override
public List<Concer> getConceredById(String id) {
    String sql = "from Concer con where con.userByConcernerId=?";
    Query query = this.sessionFactory.getCurrentSession().createQuery(sql);
    query.setString(0, id);
    List<Concer> list = query.list();
    return list;
}

######


@Override
public List<Concer> getConcerById(String id) {
    String sql = "from Concer con where con.userByConcernedId=?";
    Query query = this.sessionFactory.getCurrentSession().createQuery(sql);
    query.setString(0, id);
    List<Concer> list = query.list();
    return list;
}

######


@Override
public int deleteByConcerned_id(String id, String id2) {
    String sql = "delete from Concer con where con.userByConcernerId=? and userByConcernedId=?";
    Query query = this.sessionFactory.getCurrentSession().createQuery(sql);
    query.setString(0, id2);
    query.setString(1, id);
    int result = query.executeUpdate();
    return result;
}

######


public void failIfTextIsFail(String payload) {
    this.jdbcTemplate.update("insert into FOO values(?)", payload);
    if (payload.startsWith("fail")) {
        logger.info("Service failure for " + payload);
        throw new RuntimeException("Forced Exception");
    }
    logger.info("Service success for " + payload);
}

######


public boolean cadastrar(Condutor condutor) {
    boolean sucesso = false;
    String sqlInsert = "INSERT INTO tb_condutor(nome , cpf, rg , datanascimento , idCliente, numeroHabilitacao , " + "categoriahabilitacao , sexo , validade, passaporte,uf) " + "VALUES (?,?,?,?,?,?,?,?,?,?,?)";
    Connection conn = null;
    PreparedStatement stm = null;
    try {
        conn = AcessoBD.obtemConexao();
        stm = conn.prepareStatement(sqlInsert);
        stm.setString(1, condutor.getNome());
        stm.setString(2, condutor.getCpf());
        stm.setString(3, condutor.getRg());
        stm.setString(4, condutor.getDatNasc());
        stm.setInt(5, condutor.getId());
        stm.setString(6, condutor.getNumHabil());
        stm.setString(7, condutor.getCatHabil());
        stm.setString(8, condutor.getSexo());
        stm.setString(9, condutor.getValidade());
        stm.setString(10, condutor.getPassaporte());
        stm.setString(11, condutor.getUF());
        stm.execute();
        sucesso = true;
    } catch (Exception e) {
        e.printStackTrace();
        try {
            conn.rollback();
        } catch (SQLException e1) {
            sucesso = false;
            System.out.print(e1.getStackTrace());
        }
    } finally {
        if (stm != null) {
            try {
                stm.close();
            } catch (SQLException e1) {
                System.out.print(e1.getStackTrace());
            }
        }
    }
    return sucesso;
}

######


public boolean alterar(Condutor condutorAtualizado) {
    boolean sucesso = false;
    String sqlInsert = "UPDATE Condutor set  nome = ?, dataNascimento  = ?, numeroHabilitacao  = ? ," + " categoriaHabilitacao =? , sexo=? , validade=?" + " WHERE idCondutor = ?";
    Connection conn = null;
    PreparedStatement stm = null;
    try {
        conn = AcessoBD.obtemConexao();
        stm = conn.prepareStatement(sqlInsert);
        stm.setString(1, condutorAtualizado.getNome());
        stm.setString(2, condutorAtualizado.getDatNasc());
        stm.setString(3, condutorAtualizado.getNumHabil());
        stm.setString(4, condutorAtualizado.getCatHabil());
        stm.setString(5, condutorAtualizado.getSexo());
        stm.setString(6, condutorAtualizado.getValidade());
        stm.setInt(7, condutorAtualizado.getIdCondutor());
        stm.execute();
        sucesso = true;
    } catch (Exception e) {
        sucesso = false;
        e.printStackTrace();
        try {
            conn.rollback();
        } catch (SQLException e1) {
            System.out.print(e1.getStackTrace());
        }
    } finally {
        if (stm != null) {
            try {
                stm.close();
            } catch (SQLException e1) {
                System.out.print(e1.getStackTrace());
            }
        }
    }
    return sucesso;
}

######


public boolean excluir(int idCondutor) {
    boolean sucesso = false;
    String sqlDelete = "DELETE FROM Condutor WHERE idCondutor = ?";
    Connection conn = null;
    PreparedStatement stm = null;
    try {
        conn = AcessoBD.obtemConexao();
        stm = conn.prepareStatement(sqlDelete);
        stm.setInt(1, idCondutor);
        stm.execute();
        sucesso = true;
    } catch (Exception e) {
        sucesso = false;
        e.printStackTrace();
        try {
            conn.rollback();
        } catch (SQLException e1) {
            System.out.print(e1.getStackTrace());
        }
    } finally {
        if (stm != null) {
            try {
                stm.close();
            } catch (SQLException e1) {
                System.out.print(e1.getStackTrace());
            }
        }
    }
    return sucesso;
}

######


@Select("select * from CONFIG")
List<Config> queryAll();

######


@Update("update CONFIG set value=#{value} WHERE `key`=#{key}")
int update(Config config);

######


@BeforeClass()
public static void initClass() throws SQLException {
    for (int i = 0; i < 50; i++) {
        createTable("test_pool_batch" + i, "id int not null primary key auto_increment, test varchar(10)");
    }
}

######


@Test
public void testBasicPool() throws SQLException {
    final HikariDataSource ds = new HikariDataSource();
    ds.setMaximumPoolSize(20);
    ds.setDriverClassName("org.mariadb.jdbc.Driver");
    ds.setJdbcUrl(connU);
    ds.addDataSourceProperty("user", username);
    if (password != null) {
        ds.addDataSourceProperty("password", password);
    }
    ds.setAutoCommit(false);
    Assert.assertTrue(validateDataSource(ds));
    ds.close();
}

######


@Test
public void testPoolHikariCpWithConfig() throws SQLException {
    HikariConfig config = new HikariConfig();
    config.setJdbcUrl(connU);
    config.setUsername(username);
    if (password != null) {
        config.setPassword(password);
    }
    config.addDataSourceProperty("cachePrepStmts", "true");
    config.addDataSourceProperty("prepStmtCacheSize", "250");
    config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
    try (HikariDataSource ds = new HikariDataSource(config)) {
        Assert.assertTrue(validateDataSource(ds));
    }
}

######


private boolean validateDataSource(DataSource ds) throws SQLException {
    try (Connection connection = ds.getConnection()) {
        try (Statement statement = connection.createStatement()) {
            try (ResultSet rs = statement.executeQuery("SELECT 1")) {
                Assert.assertTrue(rs.next());
                Assert.assertEquals(1, rs.getInt(1));
                return true;
            }
        }
    }
}

######


public void run() {
    try (Connection connection = dataSource.getConnection()) {
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO test_pool_batch" + tableNumber + "(test) VALUES (?)");
        for (int i = 1; i < insertNumber; i++) {
            preparedStatement.setString(1, i + "");
            preparedStatement.addBatch();
        }
        preparedStatement.executeBatch();
    } catch (SQLException e) {
        Assert.fail("ERROR insert : " + e.getMessage());
    }
}

######


@Query("select c from connection c where c.user_id = ?1 ")
List<Connection> findById(Long user_id);

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("dummy", "a BLOB");
}

######


@Test
public void testAccessDeniedErrorCode() {
    try {
        DriverManager.getConnection("jdbc:mariadb://" + ((hostname != null) ? hostname : "localhost") + ":" + port + "/" + database + "?user=foo");
        fail();
    } catch (SQLException e) {
        switch(e.getErrorCode()) {
            case (1524):
                assertTrue("HY000".equals(e.getSQLState()));
                break;
            case (1045):
                assertTrue("28000".equals(e.getSQLState()));
                break;
            case (1044):
                assertTrue("42000".equals(e.getSQLState()));
                break;
            default:
                e.printStackTrace();
                break;
        }
    }
}

######


@Test
public void abortTest() throws SQLException {
    try (Connection connection = setConnection()) {
        try (Statement stmt = connection.createStatement()) {
            SQLPermission sqlPermission = new SQLPermission("callAbort");
            SecurityManager securityManager = System.getSecurityManager();
            if (securityManager != null) {
                try {
                    securityManager.checkPermission(sqlPermission);
                } catch (SecurityException se) {
                    System.out.println("test 'abortTest' skipped  due to missing policy");
                    return;
                }
            }
            Executor executor = Runnable::run;
            connection.abort(executor);
            assertTrue(connection.isClosed());
            try {
                stmt.executeQuery("SELECT 1");
                fail();
            } catch (SQLException sqle) {
            }
        }
    }
}

######


@Test
public void abortTestAlreadyClosed() throws SQLException {
    Connection connection = setConnection();
    connection.close();
    Executor executor = Runnable::run;
    connection.abort(executor);
}

######


@Test
public void abortTestNoExecutor() {
    try {
        sharedConnection.abort(null);
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("Cannot abort the connection: null executor passed"));
    }
}

######


@Test
public void networkTimeoutTest() throws SQLException {
    try (Connection connection = setConnection()) {
        int timeout = 1000;
        SQLPermission sqlPermission = new SQLPermission("setNetworkTimeout");
        SecurityManager securityManager = System.getSecurityManager();
        if (securityManager != null) {
            try {
                securityManager.checkPermission(sqlPermission);
            } catch (SecurityException se) {
                System.out.println("test 'setNetworkTimeout' skipped  due to missing policy");
                return;
            }
        }
        Executor executor = Runnable::run;
        try {
            connection.setNetworkTimeout(executor, timeout);
        } catch (SQLException sqlex) {
            sqlex.printStackTrace();
            fail(sqlex.getMessage());
        }
        connection.isValid(2);
        assertEquals(timeout, connection.getNetworkTimeout());
        try {
            int networkTimeout = connection.getNetworkTimeout();
            assertEquals(timeout, networkTimeout);
        } catch (SQLException sqlex) {
            sqlex.printStackTrace();
            fail(sqlex.getMessage());
        }
        try {
            connection.createStatement().execute("select sleep(2)");
            fail("Network timeout is " + timeout / 1000 + "sec, but slept for 2sec");
        } catch (SQLException sqlex) {
            assertTrue(connection.isClosed());
        }
    }
}

######


@Test
public void isValidShouldThrowExceptionWithNegativeTimeout() {
    try {
        sharedConnection.isValid(-1);
        fail("The above row should have thrown an SQLException");
    } catch (SQLException sqlex) {
        assertTrue(sqlex.getMessage().contains("negative"));
    }
}

######


@Test
public void checkMaxAllowedPacket() throws Throwable {
    Statement statement = sharedConnection.createStatement();
    ResultSet rs = statement.executeQuery("show variables like 'max_allowed_packet'");
    assertTrue(rs.next());
    int maxAllowedPacket = rs.getInt(2);
    StringBuilder sb = new StringBuilder();
    String rowData = "('this is a dummy row values')";
    int rowsToWrite = (maxAllowedPacket / rowData.getBytes(StandardCharsets.UTF_8).length) + 1;
    try {
        for (int row = 1; row <= rowsToWrite; row++) {
            if (row >= 2) {
                sb.append(", ");
            }
            sb.append(rowData);
        }
        statement.executeUpdate("INSERT INTO dummy VALUES " + sb.toString());
        fail("The previous statement should throw an SQLException");
    } catch (OutOfMemoryError e) {
        System.out.println("skip test 'maxAllowedPackedExceptionIsPrettyTest' - not enough memory");
        Assume.assumeNoException(e);
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("max_allowed_packet"));
    } catch (Exception e) {
        fail("The previous statement should throw an SQLException not a general Exception");
    }
    statement.execute("select count(*) from dummy");
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO dummy VALUES (?)");
    try {
        byte[] arr = new byte[maxAllowedPacket + 1000];
        Arrays.fill(arr, (byte) 'a');
        preparedStatement.setBytes(1, arr);
        preparedStatement.addBatch();
        preparedStatement.executeBatch();
        fail("The previous statement should throw an SQLException");
    } catch (OutOfMemoryError e) {
        System.out.println("skip second test 'maxAllowedPackedExceptionIsPrettyTest' - not enough memory");
        Assume.assumeNoException(e);
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("max_allowed_packet"));
    } catch (Exception e) {
        e.printStackTrace();
        fail("The previous statement should throw an SQLException not a general Exception");
    } finally {
        statement.execute("select count(*) from dummy");
    }
}

######


@Test
public void isValidTestWorkingConnection() throws SQLException {
    assertTrue(sharedConnection.isValid(0));
}

######


@Test
public void isValidClosedConnection() throws SQLException {
    try (Connection connection = setConnection()) {
        connection.close();
        boolean isValid = connection.isValid(0);
        assertFalse(isValid);
    }
}

######


@Test
public void isValidConnectionThatTimesOutByServer() throws SQLException, InterruptedException {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection connection = setConnection()) {
        try (Statement statement = connection.createStatement()) {
            statement.execute("set session wait_timeout=1");
            Thread.sleep(3000);
            boolean isValid = connection.isValid(0);
            assertFalse(isValid);
        }
    }
}

######


@Test
public void testConnectionClientInfos() throws Exception {
    assertNull(sharedConnection.getClientInfo("ApplicationName"));
    assertNull(sharedConnection.getClientInfo("ClientUser"));
    assertNull(sharedConnection.getClientInfo("ClientHostname"));
    try {
        sharedConnection.getClientInfo("otherName");
        fail("Must have throw exception since name wasn't correct");
    } catch (SQLException sqlEx) {
        assertTrue(sqlEx.getMessage().contains("name must be"));
    }
    Properties properties = sharedConnection.getClientInfo();
    assertNull(properties.get("ApplicationName"));
    assertNull(properties.get("ClientUser"));
    assertNull(properties.get("ClientHostname"));
    sharedConnection.setClientInfo("ClientHostname", "testHostName");
    assertEquals("testHostName", sharedConnection.getClientInfo("ClientHostname"));
    properties = sharedConnection.getClientInfo();
    assertNull(properties.get("ApplicationName"));
    assertNull(properties.get("ClientUser"));
    assertEquals("testHostName", properties.get("ClientHostname"));
    sharedConnection.setClientInfo("ClientUser", "bbb");
    properties = sharedConnection.getClientInfo();
    assertNull(properties.get("ApplicationName"));
    assertEquals("bbb", properties.get("ClientUser"));
    assertEquals("testHostName", properties.get("ClientHostname"));
    sharedConnection.setClientInfo("ApplicationName", "ccc");
    properties = sharedConnection.getClientInfo();
    assertEquals("ccc", properties.get("ApplicationName"));
    assertEquals("bbb", properties.get("ClientUser"));
    assertEquals("testHostName", properties.get("ClientHostname"));
    sharedConnection.setClientInfo("ClientHostname", null);
    assertNull(sharedConnection.getClientInfo("ClientHostname"));
    sharedConnection.setClientInfo("ClientHostname", "");
    assertEquals("", sharedConnection.getClientInfo("ClientHostname"));
    properties = new Properties();
    properties.setProperty("ApplicationName", "test\\Driver");
    properties.setProperty("ClientUser", "test Client User");
    properties.setProperty("NotPermitted", "blabla");
    properties.setProperty("NotPermitted2", "blabla");
    try {
        sharedConnection.setClientInfo(properties);
    } catch (SQLClientInfoException sqle) {
        assertEquals("setClientInfo errors : the following properties where not set :{NotPermitted,NotPermitted2}", sqle.getMessage());
        Map<String, ClientInfoStatus> failedProperties = sqle.getFailedProperties();
        assertTrue(failedProperties.containsKey("NotPermitted"));
        assertTrue(failedProperties.containsKey("NotPermitted2"));
        assertEquals(2, failedProperties.size());
    }
    assertEquals("test\\Driver", sharedConnection.getClientInfo("ApplicationName"));
    assertEquals("test Client User", sharedConnection.getClientInfo("ClientUser"));
    assertEquals(null, sharedConnection.getClientInfo("ClientHostname"));
    sharedConnection.setClientInfo("ClientUser", "otherValue");
    assertEquals("test\\Driver", sharedConnection.getClientInfo("ApplicationName"));
    assertEquals("otherValue", sharedConnection.getClientInfo("ClientUser"));
    assertEquals(null, sharedConnection.getClientInfo("ClientHostname"));
    try {
        sharedConnection.setClientInfo("NotPermitted", "otherValue");
        fail("Must have send an exception");
    } catch (SQLClientInfoException sqle) {
        assertEquals("setClientInfo() parameters can only be \"ApplicationName\",\"ClientUser\" or \"ClientHostname\", " + "but was : NotPermitted", sqle.getMessage());
        Map<String, ClientInfoStatus> failedProperties = sqle.getFailedProperties();
        assertTrue(failedProperties.containsKey("NotPermitted"));
        assertEquals(1, failedProperties.size());
    }
}

######


@Test
public void setClientError() throws SQLException {
    Connection connection = setConnection("");
    connection.close();
    try {
        connection.setClientInfo("ClientUser", "otherValue");
        fail();
    } catch (SQLClientInfoException e) {
        assertTrue(e.getMessage().contains("setClientInfo() is called on closed connection"));
    }
}

######


@Test
public void retrieveCatalogTest() throws SQLException {
    final String db = sharedConnection.getCatalog();
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("CREATE DATABASE gogogo");
    stmt.execute("USE gogogo");
    String db2 = sharedConnection.getCatalog();
    assertEquals("gogogo", db2);
    assertNotEquals(db, db2);
    stmt.execute("DROP DATABASE gogogo");
    String db3 = sharedConnection.getCatalog();
    assertNull(db3);
    stmt.execute("USE " + db);
}

######


@Override
public void run() {
    removeDelayProxy();
}

######


@Test(timeout = 15_000L)
public void testValidTimeout() throws Throwable {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection connection = createProxyConnection(new Properties())) {
        assertTrue(connection.isValid(1));
        Timer timer = new Timer();
        timer.schedule(new TimerTask() {

            @Override
            public void run() {
                removeDelayProxy();
            }
        }, 1000);
        delayProxy(200);
        assertTrue(connection.isValid(1));
        Thread.sleep(2000);
    } finally {
        closeProxy();
    }
}

######


@Override
public void run() {
    removeDelayProxy();
}

######


@Test(timeout = 15_000L)
public void testValidFailedTimeout() throws Throwable {
    Properties properties = new Properties();
    properties.setProperty("usePipelineAuth", "false");
    try (Connection connection = createProxyConnection(properties)) {
        assertTrue(connection.isValid(1));
        Timer timer = new Timer();
        timer.schedule(new TimerTask() {

            @Override
            public void run() {
                removeDelayProxy();
            }
        }, 2000);
        delayProxy(1500);
        long start = System.currentTimeMillis();
        assertFalse(connection.isValid(1));
        assertTrue(System.currentTimeMillis() - start < 1050);
        Thread.sleep(5000);
    } finally {
        closeProxy();
    }
}

######


@Test
public void standardClose() throws Throwable {
    Connection connection = setConnection();
    Statement stmt = connection.createStatement();
    stmt.setFetchSize(1);
    ResultSet rs = stmt.executeQuery("select * from information_schema.columns as c1");
    assertTrue(rs.next());
    connection.close();
    try {
        assertTrue(rs.next());
        fail();
    } catch (SQLException sqle) {
        assertTrue(sqle.getMessage().contains("Operation not permit on a closed resultSet"));
    }
}

######


@Test(timeout = 5_000L)
public void abortClose() throws Throwable {
    Connection connection = setConnection();
    Statement stmt = connection.createStatement();
    stmt.setFetchSize(1);
    ResultSet rs = stmt.executeQuery("select * from information_schema.columns as c1, " + "information_schema.tables, information_schema.tables as t2");
    assertTrue(rs.next());
    connection.abort(SchedulerServiceProviderHolder.getBulkScheduler());
    Thread.sleep(20);
    try {
        assertTrue(rs.next());
        fail();
    } catch (SQLException sqle) {
        assertTrue(sqle.getMessage().contains("Operation not permit on a closed resultSet"));
    }
}

######


@Override
public void run() {
    try {
        connection.abort(SchedulerServiceProviderHolder.getBulkScheduler());
    } catch (SQLException sqle) {
        fail(sqle.getMessage());
    }
}

######


@Test(timeout = 5_000L)
public void verificationAbort() throws Throwable {
    Timer timer = new Timer();
    try (Connection connection = setConnection()) {
        timer.schedule(new TimerTask() {

            @Override
            public void run() {
                try {
                    connection.abort(SchedulerServiceProviderHolder.getBulkScheduler());
                } catch (SQLException sqle) {
                    fail(sqle.getMessage());
                }
            }
        }, 10);
        Statement stmt = connection.createStatement();
        try {
            stmt.executeQuery("select * from information_schema.columns as c1,  information_schema.tables, information_schema.tables as t2");
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage().contains("Connection has explicitly been closed/aborted"));
        }
    }
}

######


public ArrayList<checkUser> getImc(String user, String pass) throws SQLException {
    this.connect = Conexao.getConnection();
    this.tmp = new ArrayList<>();
    String _id = new checkID_USER(user, pass).check();
    String Query = "select * from hist where FK_USER =" + _id;
    try (PreparedStatement stat = connect.prepareStatement(Query)) {
        ResultSet Data = stat.executeQuery(Query);
        while (Data.next()) {
            System.err.println("[" + Data.getString("_imc") + "]");
            tmp.add(new checkUser(Data.getString("_imc")));
        }
    }
    connect.close();
    return tmp;
}

######


@Bean
public Step step1(StepBuilderFactory stepBuilderFactory, ItemReader<Contact> reader, ItemWriter<Contact> writer, ItemProcessor<Contact, Contact> processor) {
    return stepBuilderFactory.get("step1").<Contact, Contact>chunk(5).reader(reader).processor(processor).writer(writer).build();
}

######


@Bean
public Job importUserJob(JobBuilderFactory jobs, Step s1) {
    return jobs.get("importUserJob").incrementer(new RunIdIncrementer()).flow(s1).end().build();
}

######


@Bean
public ItemProcessor<Contact, Contact> processor() {
    return (person) -> new Contact(person.getFirstName(), person.getLastName(), person.getEmail().toLowerCase());
}

######


@Bean
public ItemReader<Contact> reader() {
    FlatFileItemReader<Contact> reader = new FlatFileItemReader<Contact>();
    reader.setResource(new ClassPathResource("data.csv"));
    reader.setLineMapper(new DefaultLineMapper<Contact>() {

        {
            setLineTokenizer(new DelimitedLineTokenizer() {

                {
                    setNames(new String[] { "firstName", "lastName", "email" });
                }
            });
            setFieldSetMapper(new BeanWrapperFieldSetMapper<Contact>() {

                {
                    setTargetType(Contact.class);
                }
            });
        }
    });
    return reader;
}

######


@Bean
public ItemWriter<Contact> writer(DataSource dataSource) {
    JdbcBatchItemWriter<Contact> writer = new JdbcBatchItemWriter<Contact>();
    writer.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>());
    writer.setSql("INSERT INTO contact (first_name, last_name, email) values (:firstName, :lastName, :email)");
    writer.setDataSource(dataSource);
    return writer;
}

######


@Bean
public JdbcTemplate jdbcTemplate(DataSource dataSource) {
    return new JdbcTemplate(dataSource);
}

######


@Override
public void onApplicationEvent(JobExecutionEvent event) {
    System.out.println("finished " + event.getJobExecution().toString());
    this.jdbcTemplate.query("SELECT first_name, last_name, email FROM contact", (rs, i) -> new Contact(rs.getString("first_name"), rs.getString("last_name"), rs.getString("email"))).forEach(System.out::println);
}

######


public ArrayList<Conta> getContas(int idCliente) {
    ArrayList<Conta> resultado = new ArrayList<Conta>();
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        ps = conexao.prepareStatement("SELECT idconta, idcliente, numeroconta, agenciaconta, tipoconta FROM conta WHERE idcliente = ?");
        ps.setInt(1, idCliente);
        rs = ps.executeQuery();
        while (rs.next()) {
            resultado.add(new Conta(rs.getInt("idConta"), rs.getInt("idCliente"), rs.getString("numeroConta"), rs.getString("agenciaConta"), rs.getString("tipoConta")));
        }
        rs.close();
        ps.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return resultado;
}

######


public Long getId() {
    return id;
}

######


public void setId(Long id) {
    this.id = id;
}

######


public Usuario getUsuario() {
    return usuario;
}

######


public void setUsuario(Usuario usuario) {
    this.usuario = usuario;
}

######


public String getTexto() {
    return texto;
}

######


public void setTexto(String texto) {
    this.texto = texto;
}

######


@Override
public int hashCode() {
    int hash = 3;
    hash = 79 * hash + Objects.hashCode(this.id);
    hash = 79 * hash + Objects.hashCode(this.usuario);
    hash = 79 * hash + Objects.hashCode(this.texto);
    return hash;
}

######


@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final Contenido other = (Contenido) obj;
    if (!Objects.equals(this.id, other.id)) {
        return false;
    }
    if (!Objects.equals(this.usuario, other.usuario)) {
        return false;
    }
    if (!Objects.equals(this.texto, other.texto)) {
        return false;
    }
    return true;
}

######


@Override
public String toString() {
    return "Contenido[ id=" + id + " ]";
}

######


@ModuleAction(url = "dosetting")
public String dosetting(@ModuleActionParmar(name = "accumulative_amendments") Integer accumulative_amendments) throws SQLException {
    if (accumulative_amendments != null) {
        new Dao().update("delete from module_wxservice_setting where setting_key = ?; " + "insert into module_wxservice_setting (setting_key, setting_val) values (?,?)", "accumulative_amendments", "accumulative_amendments", accumulative_amendments);
    }
    return "success";
}

######


@ModuleAction(url = "setting")
public String setting(HttpServletRequest request, HttpServletResponse response) throws SQLException {
    int accumulative_amendments = 0;
    try {
        accumulative_amendments = Integer.parseInt(new Dao().queryForString("select setting_val from module_wxservice_setting where setting_key = ?", "accumulative_amendments"));
    } catch (Exception e) {
    }
    request.setAttribute("accumulative_amendments", accumulative_amendments);
    return "freemarker:/module/wxService/view/setting";
}

######


@Override
public int analysisAction(Date start, Date end) {
    try {
        return (int) dao.queryForLong("SELECT COUNT(log_row_id) AS rs_count " + "FROM module_wxservice_msg_dump " + "WHERE log_type = 'revc' " + "AND analyse_msg_msgtype = 'event' " + "AND analyse_event_type = ? " + "AND log_timestamp >= ? " + "AND log_timestamp < ?", "unsubscribe", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(start), new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(end));
    } catch (SQLException e) {
        log.warn("analysis action error", e);
        return 0;
    }
}

######


@Override
public int analysisAction(Date start, Date end) {
    try {
        return (int) dao.queryForLong("SELECT COUNT(log_row_id) AS rs_count " + "FROM module_wxservice_msg_dump " + "WHERE log_type = 'revc' " + "AND analyse_msg_msgtype = 'event' " + "AND analyse_event_type = ? " + "AND log_timestamp >= ? " + "AND log_timestamp < ?", "subscribe", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(start), new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(end));
    } catch (SQLException e) {
        log.warn("analysis action error", e);
        return 0;
    }
}

######


@ModuleAction(url = "userchangedata")
public Map<String, Object> data(HttpServletRequest request, HttpServletResponse response, @ModuleActionParmar(name = "times") String times) throws Exception {
    List<Date> list = new ArrayList<Date>();
    for (Object time : new ObjectMapper().readValue(times, List.class)) {
        list.add(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(time.toString()));
    }
    final Dao dao = new Dao();
    AnalysisHelper analysisHelper = new AnalysisHelper(list);
    Map<String, Object> data = analysisHelper.addAction(new AnalysisAction() {

        @Override
        public int analysisAction(Date start, Date end) {
            try {
                return (int) dao.queryForLong("SELECT COUNT(log_row_id) AS rs_count " + "FROM module_wxservice_msg_dump " + "WHERE log_type = 'revc' " + "AND analyse_msg_msgtype = 'event' " + "AND analyse_event_type = ? " + "AND log_timestamp >= ? " + "AND log_timestamp < ?", "subscribe", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(start), new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(end));
            } catch (SQLException e) {
                log.warn("analysis action error", e);
                return 0;
            }
        }
    }, "subscribe_count").addAction(new AnalysisAction() {

        @Override
        public int analysisAction(Date start, Date end) {
            try {
                return (int) dao.queryForLong("SELECT COUNT(log_row_id) AS rs_count " + "FROM module_wxservice_msg_dump " + "WHERE log_type = 'revc' " + "AND analyse_msg_msgtype = 'event' " + "AND analyse_event_type = ? " + "AND log_timestamp >= ? " + "AND log_timestamp < ?", "unsubscribe", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(start), new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(end));
            } catch (SQLException e) {
                log.warn("analysis action error", e);
                return 0;
            }
        }
    }, "unsubscribe_count").getResultMap();
    data.put("history_subscribe_count", (int) dao.queryForLong("SELECT COUNT(log_row_id) AS rs_count " + "FROM module_wxservice_msg_dump " + "WHERE log_type = 'revc' " + "AND analyse_msg_msgtype = 'event' " + "AND analyse_event_type = ? " + "AND log_timestamp < ?", "subscribe", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(analysisHelper.getMinDate())));
    data.put("history_unsubscribe_count", (int) dao.queryForLong("SELECT COUNT(log_row_id) AS rs_count " + "FROM module_wxservice_msg_dump " + "WHERE log_type = 'revc' " + "AND analyse_msg_msgtype = 'event' " + "AND analyse_event_type = ? " + "AND log_timestamp < ?", "unsubscribe", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(analysisHelper.getMinDate())));
    int accumulative_amendments = 0;
    try {
        accumulative_amendments = Integer.parseInt(new Dao().queryForString("select setting_val from module_wxservice_setting where setting_key = ?", "accumulative_amendments"));
    } catch (Exception e) {
    }
    data.put("accumulative_amendments", accumulative_amendments);
    return data;
}

######


@ModuleAction(url = "userchange")
public String index(HttpServletRequest request, HttpServletResponse response, @ModuleActionParmar(name = "starttime", format = "yyyy-MM-dd HH:mm:ss") Date starttime, @ModuleActionParmar(name = "endtime", format = "yyyy-MM-dd HH:mm:ss") Date endtime, @ModuleActionParmar(name = "accuracy") Integer accuracy, @ModuleActionParmar(name = "unit") String unit, @ModuleActionParmar(name = "querytype") String querytype) {
    if (starttime == null || endtime == null || starttime.after(endtime) || accuracy == null || accuracy < 0 || ((endtime.getTime() - starttime.getTime()) < accuracy * 1000)) {
        Calendar cal = Calendar.getInstance();
        endtime = cal.getTime();
        cal.add(Calendar.DAY_OF_MONTH, -7);
        starttime = cal.getTime();
        accuracy = 1;
        unit = "date";
        querytype = "subscribe";
    }
    request.setAttribute("starttime", starttime);
    request.setAttribute("endtime", endtime);
    request.setAttribute("accuracy", accuracy);
    request.setAttribute("unit", unit);
    request.setAttribute("querytype", querytype);
    return "freemarker:/module/wxService/view/userchange";
}

######


public void initialize() {
    if (Main.gradebookDB != null) {
        if (titles.get(titles.size() - 1).equals("Semesters")) {
            if (copySemesters.getPanes().size() != 0) {
                currentSemester = copySemesters.getExpandedPane();
            }
        }
        categoriesTable.setItems(data);
        name_col.setCellValueFactory((TableColumn.CellDataFeatures<Category, String> p) -> new SimpleStringProperty(p.getValue().name));
        weight_col.setCellValueFactory((TableColumn.CellDataFeatures<Category, Integer> p) -> new SimpleIntegerProperty(p.getValue().weight).asObject());
    }
}

######


@FXML
private void addCategory() {
    Category category = new Category(name_field.getText(), Integer.parseInt(weight_field.getText()));
    categories.addAll(category);
    try {
        Statement statement = Main.gradebookDB.createStatement();
        int id = getCategoryId();
        id_course = getCourseID();
        String sql_insertCategory = "INSERT INTO Course_Categories (id, id_course, name, weight) " + "VALUES (" + Integer.toString(id) + ", " + Integer.toString(id_course) + ", \"" + category.name + "\", " + Integer.toString(category.weight) + ")";
        statement.execute(sql_insertCategory);
    } catch (Exception e) {
        System.out.println(e);
    }
    name_field.setText("");
    weight_field.setText("");
}

######


@FXML
private void submitCourse() {
    Course course = new Course();
    course.add(0, prefix.getText());
    course.add(1, Integer.parseInt(number.getText()));
    course.add(2, section.getText());
    course.add(3, description.getText());
    course.add(6, Integer.parseInt(credit_hours.getText()));
    course.add(categories);
    id_semester = getSemesterID();
    id_course = getCourseID();
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql_insertCourse = "INSERT INTO Courses (id, id_semester, prefix, number, section, description, credit_hours) " + "VALUES (" + Integer.toString(id_course) + ", " + Integer.toString(id_semester) + ", \"" + course.prefix + "\", " + Integer.toString(course.number) + ", \"" + course.section + "\", \"" + course.description + "\", " + Integer.toString(course.credit_hours) + ");";
        statement.executeUpdate(sql_insertCourse);
        String addCredits = "UPDATE Semesters " + "SET credits=credits+" + course.credit_hours + " " + "WHERE id=" + id_semester + ";";
        statement.executeUpdate(addCredits);
    } catch (Exception e) {
        System.out.println(e);
    }
    try {
        goBack();
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


private int getCategoryId() {
    int id = -1;
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT id FROM Course_Categories;";
        ResultSet rs = statement.executeQuery(sql);
        if (!rs.isClosed()) {
            while (rs.next()) {
                id = rs.getInt("id") + 1;
            }
        } else {
            id = 1;
        }
    } catch (Exception e) {
        System.out.println(e);
    }
    return id;
}

######


private int getSemesterID() {
    if (titles.get(titles.size() - 1 - 1).equals("Semesters")) {
        int index = copySemesters.getPanes().indexOf(currentSemester) + 1;
        int id = -1;
        try {
            Statement statement = Main.gradebookDB.createStatement();
            String sql = "SELECT * FROM Semesters;";
            ResultSet rs = statement.executeQuery(sql);
            for (int i = 0; i < index; i++) {
                rs.next();
            }
            id = rs.getInt("id");
        } catch (Exception e) {
            System.out.println(e);
        }
        return id;
    } else {
        return semesterID;
    }
}

######


private int getCourseID() {
    int id = -1;
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT id FROM Courses;";
        ResultSet rs = statement.executeQuery(sql);
        if (!rs.isClosed()) {
            while (rs.next()) {
                id = rs.getInt("id") + 1;
            }
        } else {
            id = 1;
        }
    } catch (Exception e) {
        System.out.println(e);
    }
    return id;
}

######


@FXML
private void goToHome() throws IOException {
    Parent homeParent = FXMLLoader.load(getClass().getResource("Home.fxml"));
    Scene home = new Scene(homeParent);
    Stage window = (Stage) submitCourseBtn.getScene().getWindow();
    window.setScene(home);
    window.setTitle("Home");
    window.show();
    titles.add("Home");
}

######


@FXML
private void goToSemesters() throws IOException {
    Parent SemestersParent = FXMLLoader.load(getClass().getResource("Semesters.fxml"));
    Scene semesters = new Scene(SemestersParent);
    Stage window = (Stage) submitCourseBtn.getScene().getWindow();
    window.setScene(semesters);
    window.setTitle("Semesters");
    window.show();
    titles.add("Semesters");
}

######


@FXML
private void goToGPA() throws IOException {
    Parent gpaParent = FXMLLoader.load(getClass().getResource("GPA_Calculator.fxml"));
    Scene gpa = new Scene(gpaParent);
    Stage window = (Stage) submitCourseBtn.getScene().getWindow();
    window.setScene(gpa);
    window.setTitle("Calculate GPA");
    window.show();
    titles.add("Calculate GPA");
}

######


@FXML
private void goBack() throws IOException {
    int n = titles.size() - 1;
    titles.remove(n);
    Parent backParent = null;
    switch(titles.get(n - 1)) {
        case "Home":
            backParent = FXMLLoader.load(getClass().getResource("Home.fxml"));
            break;
        case "Add Course":
            backParent = FXMLLoader.load(getClass().getResource("Course_Add.fxml"));
            break;
        case "Calculate GPA":
            backParent = FXMLLoader.load(getClass().getResource("GPA_Calculator.fxml"));
            break;
        case "Semesters":
            backParent = FXMLLoader.load(getClass().getResource("Semesters.fxml"));
            break;
        case "View Course":
            backParent = FXMLLoader.load(getClass().getResource("Course_View.fxml"));
            break;
    }
    Scene back = new Scene(backParent);
    Stage window = (Stage) submitCourseBtn.getScene().getWindow();
    window.setScene(back);
    window.setTitle(titles.get(n - 1));
    window.show();
}

######


@Override
public Boolean call(TableView.ResizeFeatures p) {
    return true;
}

######


public void initialize() {
    back_home.visibleProperty().bind(new SimpleBooleanProperty(titles.size() > 1));
    homeTable.setColumnResizePolicy(new Callback<TableView.ResizeFeatures, Boolean>() {

        @Override
        public Boolean call(TableView.ResizeFeatures p) {
            return true;
        }
    });
    initializeCurrentIndex();
    getCurrentTable();
    setCurrentGPA();
    setCompletedGPA();
    setPotentialGPA();
}

######


private void initializeCurrentIndex() {
    int index = 0;
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT name, current_home FROM Semesters;";
        ResultSet rs = statement.executeQuery(sql);
        while (rs.next()) {
            if (rs.getBoolean("current_home")) {
                currentIndex = index;
            } else {
                index++;
            }
        }
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


@Override
public void handle(MouseEvent click) {
    if (click.isPrimaryButtonDown() && click.getClickCount() == 2) {
        clickedCourse = homeTable.getSelectionModel().getSelectedItem();
        try {
            goToViewCourse();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}

######


@Override
public void handle(final KeyEvent keyEvent) {
    final Course selectedCourse = homeTable.getSelectionModel().getSelectedItem();
    if (selectedCourse != null) {
        if (keyEvent.getCode().equals(KeyCode.DELETE)) {
            int idCourse = deleteCourse(selectedCourse);
            ArrayList<Integer> idsCategories = deleteCategory(idCourse);
            deleteGrade(idsCategories);
            homeTable.getItems().remove(selectedCourse);
        }
    }
}

######


private void getCurrentTable() {
    try {
        ObservableList<Course> data = FXCollections.observableArrayList();
        int index = getCurrentIndex();
        Statement statement = Main.gradebookDB.createStatement();
        String sql_getRecentTable = "SELECT * FROM Courses WHERE id_semester=" + Integer.toString(index) + ";";
        ResultSet rs = statement.executeQuery(sql_getRecentTable);
        while (rs.next()) {
            String letter_grade;
            double received = rs.getInt("received_points");
            double possible = rs.getInt("possible_points");
            if (received / possible >= 0.9) {
                letter_grade = "A";
            } else if (received / possible >= 0.8) {
                letter_grade = "B";
            } else if (received / possible >= 0.7) {
                letter_grade = "C";
            } else if (received / possible >= 0.6) {
                letter_grade = "D";
            } else if (received == 0 && possible == 1000) {
                letter_grade = "N/A";
            } else {
                letter_grade = "F";
            }
            semesterID = rs.getInt("id_semester");
            data.addAll(new Course(rs.getString("prefix"), rs.getInt("number"), rs.getString("section"), rs.getString("description"), letter_grade, rs.getInt("credit_hours")));
        }
        homeTable.setItems(data);
        homeTable.setOnMousePressed(new EventHandler<>() {

            @Override
            public void handle(MouseEvent click) {
                if (click.isPrimaryButtonDown() && click.getClickCount() == 2) {
                    clickedCourse = homeTable.getSelectionModel().getSelectedItem();
                    try {
                        goToViewCourse();
                    } catch (Exception e) {
                        System.out.println(e);
                    }
                }
            }
        });
        homeTable.setOnKeyPressed(new EventHandler<KeyEvent>() {

            @Override
            public void handle(final KeyEvent keyEvent) {
                final Course selectedCourse = homeTable.getSelectionModel().getSelectedItem();
                if (selectedCourse != null) {
                    if (keyEvent.getCode().equals(KeyCode.DELETE)) {
                        int idCourse = deleteCourse(selectedCourse);
                        ArrayList<Integer> idsCategories = deleteCategory(idCourse);
                        deleteGrade(idsCategories);
                        homeTable.getItems().remove(selectedCourse);
                    }
                }
            }
        });
        prefix.setCellValueFactory((TableColumn.CellDataFeatures<Course, String> p) -> new SimpleStringProperty(p.getValue().prefix));
        number.setCellValueFactory((TableColumn.CellDataFeatures<Course, Integer> p) -> new SimpleIntegerProperty(p.getValue().number).asObject());
        section.setCellValueFactory((TableColumn.CellDataFeatures<Course, String> p) -> new SimpleStringProperty(p.getValue().section));
        description.setCellValueFactory((TableColumn.CellDataFeatures<Course, String> p) -> new SimpleStringProperty(p.getValue().description));
        grade.setCellValueFactory((TableColumn.CellDataFeatures<Course, String> p) -> new SimpleStringProperty(p.getValue().letter_grade));
        ch.setCellValueFactory((TableColumn.CellDataFeatures<Course, Integer> p) -> new SimpleIntegerProperty(p.getValue().credit_hours).asObject());
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


private void setCurrentGPA() {
    try {
        double quality_points = 0, credits = 0;
        String gpa;
        Statement statement = Main.gradebookDB.createStatement();
        String get_semester = "SELECT id_semester, received_points, possible_points, credit_hours FROM Courses " + "WHERE id_semester=" + semesterID + ";";
        ResultSet currentSemester = statement.executeQuery(get_semester);
        while (currentSemester.next()) {
            double received = currentSemester.getInt("received_points");
            double possible = currentSemester.getInt("possible_points");
            int credit_hours = currentSemester.getInt("credit_hours");
            int currentID = currentSemester.getInt("id_semester");
            if (currentID == semesterID) {
                if (received != 0) {
                    credits += credit_hours;
                }
                if (received / possible >= 0.9) {
                    quality_points += 4 * credit_hours;
                } else if (received / possible >= 0.8) {
                    quality_points += 3 * credit_hours;
                } else if (received / possible >= 0.7) {
                    quality_points += 2 * credit_hours;
                } else if (received / possible >= 0.6) {
                    quality_points += credit_hours;
                }
            }
        }
        gpa = Double.toString(quality_points / credits);
        if (gpa.length() > 4) {
            if (Character.getNumericValue(gpa.charAt(4)) >= 5) {
                gpa = gpa.substring(0, 3) + Integer.toString(Character.getNumericValue(gpa.charAt(3)) + 1);
            } else {
                gpa = gpa.substring(0, 4);
            }
        }
        if (gpa.equals("NaN") || gpa.equals("0.0")) {
            current_GPA.setText("N/A");
        } else {
            current_GPA.setText(gpa);
        }
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


private void setCompletedGPA() {
    double quality_points = 0, credits = 0;
    try {
        String gpa;
        Statement statement = Main.gradebookDB.createStatement();
        String sql_completedGPA = "SELECT id, id_semester, received_points, possible_points, credit_hours FROM Courses;";
        ResultSet grades = statement.executeQuery(sql_completedGPA);
        while (grades.next()) {
            double received = grades.getInt("received_points");
            double possible = grades.getInt("possible_points");
            int credit_hours = grades.getInt("credit_hours");
            int currentID = grades.getInt("id_semester");
            if (currentID != semesterID) {
                if (received != 0) {
                    credits += credit_hours;
                }
                if (received / possible >= 0.9) {
                    quality_points += 4 * credit_hours;
                } else if (received / possible >= 0.8) {
                    quality_points += 3 * credit_hours;
                } else if (received / possible >= 0.7) {
                    quality_points += 2 * credit_hours;
                } else if (received / possible >= 0.6) {
                    quality_points += credit_hours;
                }
            }
        }
        gpa = Double.toString(quality_points / credits);
        completedGPA = gpa;
        completedCredits = Character.toString(Double.toString(credits).charAt(0));
        if (gpa.length() > 4) {
            if (Character.getNumericValue(gpa.charAt(4)) >= 5) {
                gpa = gpa.substring(0, 3) + Integer.toString(Character.getNumericValue(gpa.charAt(3)) + 1);
            } else {
                gpa = gpa.substring(0, 4);
            }
        }
        if (gpa.equals("NaN") || gpa.equals("0.0")) {
            completed_GPA.setText("N/A");
        } else {
            completed_GPA.setText(gpa);
        }
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


public void initialize() throws Exception {
    if (Main.gradebookDB != null) {
        copySemesters = semestersAccordion;
        ResultSet s = getSemesterNames(Main.gradebookDB);
        if (semestersAccordion.getPanes().get(0) == firstSemester) {
            semestersAccordion.getPanes().remove(firstSemester);
        }
        if (!s.isClosed()) {
            semestersAccordion.setVisible(true);
            emptyLabel.setVisible(false);
            while (s.next()) {
                TitledPane tp = newSemester(s.getString("name"));
                semestersAccordion.getPanes().addAll(tp);
                semestersAccordion.setExpandedPane(tp);
            }
        }
        if (currentIndex == 9999) {
            initializeCurrentIndex();
        }
        table_size = semestersAccordion.getPanes().size();
        if (currentIndex > -1 && semestersAccordion.getExpandedPane() != null) {
            semestersAccordion.setExpandedPane(semestersAccordion.getPanes().get(currentIndex));
            if (semestersAccordion.getPanes().indexOf(semestersAccordion.getExpandedPane()) == currentIndex) {
                currentSemesterToggle.selectToggle(((RadioButton) ((((AnchorPane) (semestersAccordion.getExpandedPane().getContent()))).getChildren().get(0))));
                semestersAccordion.setExpandedPane(semestersAccordion.getPanes().get(currentIndex));
            }
        }
    }
}

######


@FXML
public void addSemester() {
    TextInputDialog popup = new TextInputDialog();
    popup.setTitle("Enter Semester Name...");
    popup.setHeaderText("Enter name of the new semester below...");
    popup.setContentText("Name: ");
    popup.showAndWait();
    String popupTitle = popup.getResult();
    if (popupTitle != null && !popupTitle.equals("")) {
        try {
            if (table_size == 0) {
                semestersAccordion.setVisible(true);
                emptyLabel.setVisible(false);
            }
            insertSemester(Main.gradebookDB, popupTitle);
            TitledPane tp = newSemester(popupTitle);
            semestersAccordion.getPanes().add(tp);
            semestersAccordion.setExpandedPane(tp);
            if (table_size == 1) {
                currentSemesterToggle.selectToggle(((RadioButton) ((AnchorPane) (semestersAccordion.getExpandedPane().getContent())).getChildren().get(0)));
                setCurrentSemester();
                currentIndex--;
            }
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}

######


@FXML
public void deleteSemester() throws Exception {
    String name = semestersAccordion.getExpandedPane().getText();
    int id = getSemesterID(name);
    Statement statement = Main.gradebookDB.createStatement();
    String sql_semesters = "DELETE FROM semesters WHERE name=" + "\"" + name + "\";";
    String sql_courses = "DELETE FROM courses WHERE id_semester=" + id + ";";
    Alert warn = new Alert(Alert.AlertType.CONFIRMATION);
    warn.setTitle("Are you sure?");
    warn.setHeaderText(null);
    warn.setContentText("Are you sure you would like to delete this semester?\n" + "This will delete all grades, courses, and other information.");
    Optional<ButtonType> result = warn.showAndWait();
    if (result.get() == ButtonType.OK) {
        try {
            semestersAccordion.getPanes().remove(semestersAccordion.getExpandedPane());
            statement.execute(sql_semesters);
            statement.execute(sql_courses);
            if (currentIndex >= 0) {
                currentIndex--;
            }
            table_size--;
        } catch (Exception e) {
            System.out.println(e);
        }
    }
    if (semestersAccordion.getPanes().size() == 0) {
        semestersAccordion.setVisible(false);
        emptyLabel.setVisible(true);
    } else {
        TitledPane titledPane = semestersAccordion.getPanes().get(table_size - 1);
        RadioButton radio = (RadioButton) ((AnchorPane) titledPane.getContent()).getChildren().get(0);
        radio.setSelected(true);
        semestersAccordion.setExpandedPane(titledPane);
        setCurrentSemester();
    }
}

######


@FXML
public void setCurrentSemester() {
    String name = semestersAccordion.getExpandedPane().getText();
    currentIndex = semestersAccordion.getPanes().indexOf(semestersAccordion.getExpandedPane());
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String all_false = "UPDATE Semesters SET current_home=0;";
        String set_current = "UPDATE Semesters SET current_home=1 WHERE name=\"" + name + "\";";
        statement.executeUpdate(all_false);
        statement.executeUpdate(set_current);
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


private ResultSet getSemesterNames(Connection c) {
    Statement statement;
    ResultSet rs = null;
    try {
        statement = c.createStatement();
        String sql = "SELECT name FROM semesters ORDER BY id";
        rs = statement.executeQuery(sql);
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return rs;
}

######


private void insertSemester(Connection c, String name) {
    Statement statement;
    try {
        statement = c.createStatement();
        String sql = "INSERT INTO semesters (id, name) VALUES (" + Integer.toString(getSemesterID()) + ", " + "\"" + name + "\");";
        statement.executeUpdate(sql);
        table_size++;
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


private int getSemesterID() {
    ResultSet rs;
    int id = -1;
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT id FROM Semesters;";
        rs = statement.executeQuery(sql);
        if (!rs.isClosed()) {
            while (rs.next()) {
                id = rs.getInt("id") + 1;
            }
        } else {
            id = 1;
        }
    } catch (Exception e) {
        System.out.println(e);
    }
    return id;
}

######


private int getSemesterID(String name) {
    ResultSet rs;
    int id = -1;
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT id, name FROM Semesters;";
        rs = statement.executeQuery(sql);
        if (!rs.isClosed()) {
            while (rs.next()) {
                if (semestersAccordion.getExpandedPane().getText().equals(rs.getString("name"))) {
                    id = rs.getInt("id");
                }
            }
        } else {
            id = 1;
        }
    } catch (Exception e) {
        System.out.println(e);
    }
    return id;
}

######


@Override
public void handle(ActionEvent event) {
    try {
        setCurrentSemester();
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


@Override
public void handle(ActionEvent event) {
    try {
        deleteSemester();
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


@Override
public void handle(ActionEvent event) {
    try {
        goToAddCourse();
    } catch (IOException ioe) {
        System.out.println(ioe);
    }
}

######


@Override
public void handle(MouseEvent click) {
    if (click.isPrimaryButtonDown() && click.getClickCount() == 2) {
        clickedCourse = tv.getSelectionModel().getSelectedItem();
        try {
            goToViewCourse();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}

######


@Override
public void handle(final KeyEvent keyEvent) {
    final Course selectedCourse = tv.getSelectionModel().getSelectedItem();
    if (selectedCourse != null) {
        if (keyEvent.getCode().equals(KeyCode.DELETE)) {
            int idCourse = deleteCourse(selectedCourse);
            ArrayList<Integer> idsCategories = deleteCategory(idCourse);
            deleteGrade(idsCategories);
            tv.getItems().remove(selectedCourse);
        }
    }
}

######


private TitledPane newSemester(String title) {
    TitledPane template = new TitledPane();
    AnchorPane pane = new AnchorPane();
    RadioButton rb = new RadioButton();
    Button delete = new Button("Delete Semester");
    TableView<Course> tv = new TableView<>();
    Button add = new Button("Add Course");
    template.setId(title.trim());
    template.setText(title);
    template.setAnimated(true);
    template.setCollapsible(true);
    rb.setText("Current Semester");
    rb.setToggleGroup(currentSemesterToggle);
    rb.setOnAction(new EventHandler<ActionEvent>() {

        @Override
        public void handle(ActionEvent event) {
            try {
                setCurrentSemester();
            } catch (Exception e) {
                System.out.println(e);
            }
        }
    });
    delete.setOnAction(new EventHandler<ActionEvent>() {

        @Override
        public void handle(ActionEvent event) {
            try {
                deleteSemester();
            } catch (Exception e) {
                System.out.println(e);
            }
        }
    });
    add.setOnAction(new EventHandler<>() {

        @Override
        public void handle(ActionEvent event) {
            try {
                goToAddCourse();
            } catch (IOException ioe) {
                System.out.println(ioe);
            }
        }
    });
    try {
        final ObservableList<Course> data = getCourses(title);
        tv.setItems(data);
    } catch (Exception e) {
        System.out.println(e);
    }
    TableColumn<Course, String> prefix = new TableColumn<>("Prefix");
    prefix.setCellValueFactory((TableColumn.CellDataFeatures<Course, String> p) -> new SimpleStringProperty(p.getValue().prefix));
    TableColumn<Course, Integer> number = new TableColumn<>("Number");
    number.setCellValueFactory((TableColumn.CellDataFeatures<Course, Integer> p) -> new SimpleIntegerProperty(p.getValue().number).asObject());
    TableColumn<Course, String> section = new TableColumn<>("Section");
    section.setCellValueFactory((TableColumn.CellDataFeatures<Course, String> p) -> new SimpleStringProperty(p.getValue().section));
    TableColumn<Course, String> description = new TableColumn<>("Description");
    description.setCellValueFactory((TableColumn.CellDataFeatures<Course, String> p) -> new SimpleStringProperty(p.getValue().description));
    TableColumn<Course, String> grade = new TableColumn<>("Grade");
    grade.setCellValueFactory((TableColumn.CellDataFeatures<Course, String> p) -> new SimpleStringProperty(p.getValue().letter_grade));
    TableColumn<Course, Integer> credit_hours = new TableColumn<>("Credit Hours");
    credit_hours.setCellValueFactory((TableColumn.CellDataFeatures<Course, Integer> p) -> new SimpleIntegerProperty(p.getValue().credit_hours).asObject());
    tv.getColumns().addAll(prefix, number, section, description, grade, credit_hours);
    tv.setOnMousePressed(new EventHandler<>() {

        @Override
        public void handle(MouseEvent click) {
            if (click.isPrimaryButtonDown() && click.getClickCount() == 2) {
                clickedCourse = tv.getSelectionModel().getSelectedItem();
                try {
                    goToViewCourse();
                } catch (Exception e) {
                    System.out.println(e);
                }
            }
        }
    });
    tv.setOnKeyPressed(new EventHandler<KeyEvent>() {

        @Override
        public void handle(final KeyEvent keyEvent) {
            final Course selectedCourse = tv.getSelectionModel().getSelectedItem();
            if (selectedCourse != null) {
                if (keyEvent.getCode().equals(KeyCode.DELETE)) {
                    int idCourse = deleteCourse(selectedCourse);
                    ArrayList<Integer> idsCategories = deleteCategory(idCourse);
                    deleteGrade(idsCategories);
                    tv.getItems().remove(selectedCourse);
                }
            }
        }
    });
    tv.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
    AnchorPane.setTopAnchor(rb, 10.0);
    AnchorPane.setLeftAnchor(rb, 10.0);
    AnchorPane.setTopAnchor(delete, 5.0);
    AnchorPane.setRightAnchor(delete, 10.0);
    AnchorPane.setTopAnchor(tv, 40.0);
    AnchorPane.setLeftAnchor(tv, 10.0);
    AnchorPane.setRightAnchor(tv, 10.0);
    AnchorPane.setBottomAnchor(tv, 40.0);
    AnchorPane.setLeftAnchor(add, 40.0);
    AnchorPane.setRightAnchor(add, 40.0);
    AnchorPane.setBottomAnchor(add, 0.0);
    pane.getChildren().addAll(rb, tv, add, delete);
    template.setContent(pane);
    template.setExpanded(true);
    return template;
}

######


private int deleteCourse(Course course) {
    int id = -1;
    ResultSet rs;
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT id FROM Courses WHERE prefix=\"" + course.prefix + "\" AND number=" + course.number + ";";
        rs = statement.executeQuery(sql);
        id = rs.getInt("id");
        sql = "DELETE FROM Courses WHERE prefix=\"" + course.prefix + "\" AND number=" + course.number + ";";
        statement.executeUpdate(sql);
        sql = "SELECT received_points, possible_points, credit_hours FROM Courses " + "WHERE id_semester=" + getSemesterID() + ";";
        ResultSet newGPA = statement.executeQuery(sql);
        double received = newGPA.getInt("received_points"), possible = newGPA.getInt("possible_points"), qualityPoints = 0, credits = 0;
        int credit_hours = newGPA.getInt("credit_hours");
        while (newGPA.next()) {
            if (received != 0) {
                credits += credit_hours;
            }
            if (received / possible >= 0.9) {
                qualityPoints += 4 * credit_hours;
            } else if (received / possible >= 0.8) {
                qualityPoints += 3 * credit_hours;
            } else if (received / possible >= 0.7) {
                qualityPoints += 2 * credit_hours;
            } else if (received / possible >= 0.6) {
                qualityPoints += credit_hours;
            }
        }
        String gpa = Double.toString(qualityPoints / credits);
        if (gpa.length() > 4) {
            if (Character.getNumericValue(gpa.charAt(4)) >= 5) {
                gpa = gpa.substring(0, 3) + Integer.toString(Character.getNumericValue(gpa.charAt(3)) + 1);
            } else {
                gpa = gpa.substring(0, 4);
            }
        }
        sql = "UPDATE Semesters SET credits=credits-" + course.credit_hours + ", gpa=" + gpa + " " + "WHERE id=" + getSemesterID() + ";";
        statement.executeUpdate(sql);
    } catch (Exception e) {
        System.out.println(e);
    }
    return id;
}

######


private ArrayList<Integer> deleteCategory(int idCourse) {
    ArrayList<Integer> IDs = null;
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT id FROM Course_Categories WHERE id_course=" + idCourse + ";";
        ResultSet rs = statement.executeQuery(sql);
        IDs = new ArrayList<>();
        while (rs.next()) {
            IDs.add(rs.getInt("id"));
        }
        sql = "DELETE FROM Course_Categories WHERE id_course=" + idCourse + ";";
        statement.executeUpdate(sql);
    } catch (Exception e) {
        System.out.println(e);
    }
    return IDs;
}

######


private void deleteGrade(ArrayList<Integer> idsCategories) {
    try {
        Statement statement = Main.gradebookDB.createStatement();
        for (int i = 0; i < idsCategories.size(); i++) {
            String sql = "DELETE FROM Grades WHERE id_category=" + idsCategories.get(i) + ";";
            statement.executeUpdate(sql);
        }
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


private ObservableList<Course> getCourses(String semesterName) throws Exception {
    ObservableList<Course> courses = FXCollections.observableArrayList();
    ResultSet rs;
    int id, num;
    Statement s = Main.gradebookDB.createStatement();
    String sql_num = "SELECT * FROM Semesters;";
    ResultSet resultSet = s.executeQuery(sql_num);
    num = semestersAccordion.getPanes().size() + 1;
    for (int i = 0; i < num; i++) {
        resultSet.next();
    }
    id = resultSet.getInt("id");
    Statement statement = Main.gradebookDB.createStatement();
    String sql = "SELECT prefix, number, section, description, received_points, possible_points, credit_hours " + "FROM courses JOIN semesters ON courses.id_semester = semesters.id " + "WHERE courses.id_semester = " + Integer.toString(id) + ";";
    rs = statement.executeQuery(sql);
    double received = 0, possible = 0;
    while (rs.next()) {
        Course c = new Course();
        for (int i = 0; i < 7; i++) {
            if (i == 0 || i == 3) {
                c.add(i, rs.getString(i + 1));
            } else if (i == 2) {
                c.add(i, rs.getString(i + 1));
            } else if (i == 4) {
                received = rs.getInt(i + 1);
            } else if (i == 5) {
                possible = rs.getInt(i + 1);
            } else {
                c.add(i, rs.getInt(i + 1));
            }
        }
        if (received / possible >= 0.9) {
            c.add(4, "A");
        } else if (received / possible >= 0.8) {
            c.add(4, "B");
        } else if (received / possible >= 0.7) {
            c.add(4, "C");
        } else if (received / possible >= 0.6) {
            c.add(4, "D");
        } else if (received == 0 && possible == 1000) {
            c.add(4, "N/A");
        } else {
            c.add(4, "F");
        }
        courses.addAll(c);
    }
    return courses;
}

######


private void initializeCurrentIndex() {
    int index = 0;
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT name, current_home FROM Semesters;";
        ResultSet rs = statement.executeQuery(sql);
        while (rs.next()) {
            if (rs.getBoolean("current_home")) {
                currentIndex = index;
            } else {
                index++;
            }
        }
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


@FXML
private void goToHome() throws IOException {
    Parent homeParent = FXMLLoader.load(getClass().getResource("Home.fxml"));
    Scene home = new Scene(homeParent);
    Stage window = (Stage) semesterLabel.getScene().getWindow();
    window.setScene(home);
    window.setTitle("Home");
    window.show();
    Controller_Home.titles.add("Home");
}

######


@FXML
private void goToGPA() throws IOException {
    Parent gpaParent = FXMLLoader.load(getClass().getResource("GPA_Calculator.fxml"));
    Scene gpa = new Scene(gpaParent);
    Stage window = (Stage) semesterLabel.getScene().getWindow();
    window.setScene(gpa);
    window.setTitle("Calculate GPA");
    window.show();
    Controller_Home.titles.add("Calculate GPA");
}

######


@FXML
private void goToAddCourse() throws IOException {
    Parent addCourseParent = FXMLLoader.load(getClass().getResource("Course_Add.fxml"));
    Scene addCourse = new Scene(addCourseParent);
    Stage window = (Stage) semesterLabel.getScene().getWindow();
    window.setScene(addCourse);
    window.setTitle("Add Course");
    window.show();
    Controller_Home.titles.add("Add Course");
}

######


@FXML
private void goToViewCourse() throws IOException {
    Parent viewCourseParent = FXMLLoader.load(getClass().getResource("Course_View.fxml"));
    Scene viewCourse = new Scene(viewCourseParent);
    Stage window = (Stage) semesterLabel.getScene().getWindow();
    window.setScene(viewCourse);
    window.setTitle(clickedCourse.description);
    window.show();
    Controller_Home.titles.add("View Course");
}

######


@FXML
private void goBack() throws IOException {
    int n = Controller_Home.titles.size() - 1;
    Controller_Home.titles.remove(n);
    Parent backParent = null;
    switch(Controller_Home.titles.get(n - 1)) {
        case "Home":
            backParent = FXMLLoader.load(getClass().getResource("Home.fxml"));
            break;
        case "Add Course":
            backParent = FXMLLoader.load(getClass().getResource("Course_Add.fxml"));
            break;
        case "Calculate GPA":
            backParent = FXMLLoader.load(getClass().getResource("GPA_Calculator.fxml"));
            break;
        case "Semesters":
            backParent = FXMLLoader.load(getClass().getResource("Semesters.fxml"));
            break;
        case "View Course":
            backParent = FXMLLoader.load(getClass().getResource("Course_View.fxml"));
            break;
    }
    Scene back = new Scene(backParent);
    Stage window = (Stage) semesterLabel.getScene().getWindow();
    window.setScene(back);
    window.setTitle(Controller_Home.titles.get(n - 1));
    window.show();
}

######


public void initialize() {
    prefix.setText(clickedCourse.prefix);
    number.setText(Integer.toString(clickedCourse.number));
    section.setText(clickedCourse.section);
    description.setText(clickedCourse.description);
    credit_hours.setText(Integer.toString(clickedCourse.credit_hours));
    points_field.setText(getPoints());
    letter_grade.setText(clickedCourse.letter_grade);
    initializeAccordion();
    initializeGrades();
    int accordionSize = categoryAccordion.getPanes().size();
    categoryAccordion.visibleProperty().bind(new SimpleBooleanProperty(accordionSize > 0));
    emptyLabel.visibleProperty().bind(new SimpleBooleanProperty(accordionSize == 0));
}

######


@FXML
private void addCategory() {
    Dialog<Pair<String, Integer>> popup = categoryPopup();
    Optional<Pair<String, Integer>> result = popup.showAndWait();
    result.ifPresent(nameWeight -> {
        final String name = nameWeight.getKey();
        final Integer weight = nameWeight.getValue();
        Category category = new Category(name, weight);
        insertCategory(category);
        categoryAccordion.getPanes().addAll(newCategory(category));
        int accordionSize = categoryAccordion.getPanes().size();
        categoryAccordion.visibleProperty().bind(new SimpleBooleanProperty(accordionSize > 0));
        emptyLabel.visibleProperty().bind(new SimpleBooleanProperty(accordionSize == 0));
    });
}

######


@FXML
private void deleteCategory() {
    String name = categoryAccordion.getExpandedPane().getText();
    Alert warn = new Alert(Alert.AlertType.CONFIRMATION);
    warn.setTitle("Are you sure?");
    warn.setHeaderText(null);
    warn.setContentText("Are you sure you would like to delete this semester?\n" + "This will delete all grades, courses, and other information.");
    Optional<ButtonType> result = warn.showAndWait();
    if (result.get() == ButtonType.OK) {
        try {
            Statement statement = Main.gradebookDB.createStatement();
            String sql = "DELETE FROM Course_Categories " + "WHERE name=\"" + name + "\" AND id_course=" + getCourseID() + ";\n" + "DELETE FROM Grades " + "WHERE id_category=" + getCategoryID(name) + ";";
            statement.executeUpdate(sql);
            categoryAccordion.getPanes().remove(categoryAccordion.getExpandedPane());
        } catch (Exception e) {
            System.out.println(e);
        }
        int accordionSize = categoryAccordion.getPanes().size();
        categoryAccordion.visibleProperty().bind(new SimpleBooleanProperty(accordionSize > 0));
        emptyLabel.visibleProperty().bind(new SimpleBooleanProperty(accordionSize == 0));
    }
}

######


@FXML
private void addGrade() {
    String name = categoryAccordion.getExpandedPane().getText();
    TableView<Grade> table = (TableView<Grade>) (((AnchorPane) categoryAccordion.getExpandedPane().getContent()).getChildren().get(0));
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "INSERT INTO Grades (id, id_category, name) " + "VALUES (" + getNewGradeID() + ", " + getCategoryID(name) + ", \"" + name + "\");";
        statement.executeUpdate(sql);
        ObservableList<Grade> grades = getGrades(name);
        table.setItems(grades);
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


@FXML
private void submitChanges() {
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "UPDATE Courses " + "SET prefix=\"" + prefix.getText() + "\", " + "number=" + Integer.parseInt(number.getText()) + ", " + "section=\"" + section.getText() + "\", " + "description=\"" + description.getText() + "\", " + "credit_hours=" + Integer.parseInt(credit_hours.getText()) + " " + "WHERE id=" + Integer.toString(getCourseID()) + ";";
        statement.executeUpdate(sql);
        goBack();
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


private Dialog<Pair<String, Integer>> categoryPopup() {
    Dialog<Pair<String, Integer>> popup = new Dialog<>();
    popup.setTitle("Add Category");
    popup.setHeaderText("Enter name and weight of the new category below...");
    GridPane grid = new GridPane();
    grid.setHgap(10);
    grid.setVgap(10);
    grid.setPadding(new Insets(20, 150, 10, 10));
    TextField name_field = new TextField();
    TextField weight_field = new TextField();
    name_field.setPromptText("Tests");
    weight_field.setPromptText("100");
    grid.add(new Label("Name:"), 0, 0);
    grid.add(name_field, 1, 0);
    grid.add(new Label("Weight:"), 0, 1);
    grid.add(weight_field, 1, 1);
    popup.getDialogPane().getButtonTypes().addAll(ButtonType.OK, ButtonType.CANCEL);
    popup.getDialogPane().setContent(grid);
    Platform.runLater(() -> name_field.requestFocus());
    popup.setResultConverter(dialogButton -> {
        if (dialogButton == ButtonType.OK) {
            return new Pair<>(name_field.getText(), Integer.parseInt(weight_field.getText()));
        }
        return null;
    });
    return popup;
}

######


private void insertCategory(Category category) {
    Statement statement;
    try {
        statement = Main.gradebookDB.createStatement();
        String sql = "INSERT INTO Course_Categories (id, id_course, name, weight) " + "VALUES (" + Integer.toString(getNewCategoryID()) + ", " + Integer.toString(getCourseID()) + ", \"" + category.name + "\", " + Integer.toString(category.weight) + ");";
        statement.executeUpdate(sql);
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


private int getCourseID() {
    int id = -1;
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT id, prefix, number " + "FROM Courses " + "WHERE prefix=\"" + clickedCourse.prefix + "\" AND number=" + clickedCourse.number + ";";
        ResultSet rs = statement.executeQuery(sql);
        if (rs.next()) {
            id = rs.getInt("id");
        } else {
            id = 1;
        }
    } catch (Exception e) {
        System.out.println(e);
    }
    return id;
}

######


private int getCategoryID(String name) {
    int id = -1;
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT id, id_course, name FROM Course_Categories " + "WHERE id_course=" + getCourseID() + " AND name=\"" + name + "\";";
        ResultSet rs = statement.executeQuery(sql);
        if (rs.next()) {
            id = rs.getInt("id");
        }
    } catch (Exception e) {
        System.out.println(e);
    }
    return id;
}

######


private int getNewCategoryID() {
    ResultSet rs;
    int id = -1;
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT id FROM Course_Categories;";
        rs = statement.executeQuery(sql);
        if (!rs.isClosed()) {
            while (rs.next()) {
                id = rs.getInt("id") + 1;
            }
        } else {
            id = 1;
        }
    } catch (Exception e) {
        System.out.println(e);
    }
    return id;
}

######


private int getNewGradeID() {
    int id = -1;
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT id FROM Grades;";
        ResultSet rs = statement.executeQuery(sql);
        if (rs.isClosed()) {
            id = 1;
        }
        while (rs.next()) {
            id = rs.getInt("id") + 1;
        }
    } catch (Exception e) {
        System.out.println(e);
    }
    return id;
}

######


@Override
public void handle(ActionEvent event) {
    try {
        addGrade();
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


@Override
public void handle(ActionEvent event) {
    try {
        deleteCategory();
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


@Override
public void handle(final KeyEvent keyEvent) {
    final Grade selectedGrade = categoryTableView.getSelectionModel().getSelectedItem();
    if (selectedGrade != null) {
        if (keyEvent.getCode().equals(KeyCode.DELETE)) {
            int idCategory = getCategoryID(categoryAccordion.getExpandedPane().getText());
            deleteGrade(idCategory, selectedGrade.name);
            categoryTableView.getItems().remove(selectedGrade);
        }
    }
}

######


private TitledPane newCategory(Category category) {
    TitledPane template = new TitledPane();
    AnchorPane content = new AnchorPane();
    TableView<Grade> categoryTableView = new TableView<>();
    Button addGrade = new Button("Add Grade");
    Button deleteCategory = new Button("Delete Category");
    template.setId(category.name.trim());
    template.setText(category.name);
    template.setAnimated(true);
    template.setCollapsible(true);
    addGrade.setOnAction(new EventHandler<>() {

        @Override
        public void handle(ActionEvent event) {
            try {
                addGrade();
            } catch (Exception e) {
                System.out.println(e);
            }
        }
    });
    deleteCategory.setOnAction(new EventHandler<>() {

        @Override
        public void handle(ActionEvent event) {
            try {
                deleteCategory();
            } catch (Exception e) {
                System.out.println(e);
            }
        }
    });
    try {
        final ObservableList<Grade> data = getGrades(category.name);
        categoryTableView.setItems(data);
    } catch (Exception e) {
        System.out.println(e);
    }
    TableColumn<Grade, String> name = new TableColumn<>("Name");
    name.setCellFactory(TextFieldTableCell.forTableColumn());
    name.setCellValueFactory((TableColumn.CellDataFeatures<Grade, String> p) -> new SimpleStringProperty(p.getValue().name));
    TableColumn<Grade, String> points = new TableColumn<>("Points");
    points.setCellFactory(TextFieldTableCell.forTableColumn());
    points.setCellValueFactory((TableColumn.CellDataFeatures<Grade, String> p) -> new SimpleStringProperty(Integer.toString(p.getValue().received)));
    TableColumn<Grade, String> outOf = new TableColumn<>("Out Of");
    outOf.setCellFactory(TextFieldTableCell.forTableColumn());
    outOf.setCellValueFactory((TableColumn.CellDataFeatures<Grade, String> p) -> new SimpleStringProperty(Integer.toString(p.getValue().possible)));
    name.setOnEditCommit(t -> {
        String old_name = t.getTableView().getItems().get(t.getTablePosition().getRow()).name;
        String category_name = categoryAccordion.getExpandedPane().getText();
        try {
            Statement statement = Main.gradebookDB.createStatement();
            String sql = "UPDATE Grades " + "SET name=\"" + t.getNewValue() + "\" " + "WHERE name=\"" + old_name + "\" " + "AND id_category=" + getCategoryID(category_name) + ";";
            statement.executeUpdate(sql);
        } catch (Exception e) {
            System.out.println(e);
        }
        t.getTableView().getItems().get(t.getTablePosition().getRow()).name = t.getNewValue();
    });
    points.setOnEditCommit(t -> {
        int old_received = t.getTableView().getItems().get(t.getTablePosition().getRow()).received;
        String grade_name = t.getTableView().getItems().get(t.getTablePosition().getRow()).name;
        String category_name = categoryAccordion.getExpandedPane().getText();
        try {
            Statement statement = Main.gradebookDB.createStatement();
            String sql = "UPDATE Grades " + "SET received_points=" + t.getNewValue() + " " + "WHERE received_points=" + old_received + " AND id_category=" + getCategoryID(category_name) + " " + " AND name=\"" + grade_name + "\";";
            statement.executeUpdate(sql);
            getNewPoints();
            String getPoints = "SELECT id, received_points, possible_points FROM Courses " + "WHERE id=" + getCourseID() + ";";
            ResultSet coursePoints = statement.executeQuery(getPoints);
            if (coursePoints.next()) {
                double received = coursePoints.getInt("received_points");
                int received_int = coursePoints.getInt("received_points");
                double possible = coursePoints.getInt("possible_points");
                points_field.setText(Integer.toString(received_int));
                if (received / possible >= 0.9) {
                    letter_grade.setText("A");
                } else if (received / possible >= 0.8) {
                    letter_grade.setText("B");
                } else if (received / possible >= 0.7) {
                    letter_grade.setText("C");
                } else if (received / possible >= 0.6) {
                    letter_grade.setText("D");
                } else {
                    letter_grade.setText("F");
                }
            }
        } catch (Exception e) {
            System.out.println(e);
        }
        t.getTableView().getItems().get(t.getTablePosition().getRow()).received = Integer.parseInt(t.getNewValue());
    });
    outOf.setOnEditCommit(t -> {
        int old_possible = t.getTableView().getItems().get(t.getTablePosition().getRow()).possible;
        String category_name = categoryAccordion.getExpandedPane().getText();
        try {
            Statement statement = Main.gradebookDB.createStatement();
            String sql = "UPDATE Grades " + "SET possible_points=" + t.getNewValue() + " " + "WHERE possible_points=" + old_possible + " AND id_category=" + getCategoryID(category_name) + ";";
            statement.executeUpdate(sql);
        } catch (Exception e) {
            System.out.println(e);
        }
        t.getTableView().getItems().get(t.getTablePosition().getRow()).possible = Integer.parseInt(t.getNewValue());
    });
    categoryTableView.getColumns().addAll(name, points, outOf);
    categoryTableView.setEditable(true);
    categoryTableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
    categoryTableView.setOnKeyPressed(new EventHandler<KeyEvent>() {

        @Override
        public void handle(final KeyEvent keyEvent) {
            final Grade selectedGrade = categoryTableView.getSelectionModel().getSelectedItem();
            if (selectedGrade != null) {
                if (keyEvent.getCode().equals(KeyCode.DELETE)) {
                    int idCategory = getCategoryID(categoryAccordion.getExpandedPane().getText());
                    deleteGrade(idCategory, selectedGrade.name);
                    categoryTableView.getItems().remove(selectedGrade);
                }
            }
        }
    });
    AnchorPane.setTopAnchor(categoryTableView, 45.0);
    AnchorPane.setBottomAnchor(categoryTableView, 60.0);
    AnchorPane.setLeftAnchor(categoryTableView, 20.0);
    AnchorPane.setRightAnchor(categoryTableView, 20.0);
    AnchorPane.setBottomAnchor(addGrade, 20.0);
    AnchorPane.setLeftAnchor(addGrade, 100.0);
    AnchorPane.setRightAnchor(addGrade, 100.0);
    AnchorPane.setTopAnchor(deleteCategory, 10.0);
    AnchorPane.setRightAnchor(deleteCategory, 20.0);
    content.getChildren().addAll(categoryTableView, addGrade, deleteCategory);
    template.setContent(content);
    return template;
}

######


private void deleteGrade(int idCategory, String name) {
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "DELETE FROM Grades " + "WHERE id_category=" + idCategory + " AND name=\"" + name + "\";";
        statement.executeUpdate(sql);
        String getPoints = "SELECT received_points, possible_points FROM Courses " + "WHERE id=" + getCourseID() + ";";
        ResultSet points = statement.executeQuery(getPoints);
        double possible_points = points.getInt("possible_points");
        double received_points = points.getInt("received_points");
        points_field.setText(Integer.toString(points.getInt("received_points")));
        if (received_points / possible_points >= 0.9) {
            letter_grade.setText("A");
        } else if (received_points / possible_points >= 0.8) {
            letter_grade.setText("B");
        } else if (received_points / possible_points >= 0.7) {
            letter_grade.setText("C");
        } else if (received_points / possible_points >= 0.6) {
            letter_grade.setText("D");
        } else {
            letter_grade.setText("F");
        }
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


private ObservableList<Grade> getGrades(String categoryName) {
    ObservableList<Grade> grades = FXCollections.observableArrayList();
    ResultSet rs;
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT name, received_points, possible_points FROM Grades " + "WHERE id_category=" + getCategoryID(categoryName) + ";";
        rs = statement.executeQuery(sql);
        while (rs.next()) {
            Grade grade = new Grade(rs.getString("name"), rs.getInt("received_points"), rs.getInt("possible_points"));
            grades.addAll(grade);
        }
    } catch (Exception e) {
        System.out.println(e);
    }
    return grades;
}

######


private void getNewPoints() {
    try {
        int received_points = 0, possible_points = 0, idCategory, idCourse = getCourseID(), idSemester = -1;
        Statement statement = Main.gradebookDB.createStatement();
        String getCategoryIDs = "SELECT id, id_course FROM Course_Categories " + "WHERE id_course=" + idCourse + ";";
        ResultSet idCategoryList = statement.executeQuery(getCategoryIDs);
        while (idCategoryList.next()) {
            idCategory = idCategoryList.getInt("id");
            Statement gradeStatement = Main.gradebookDB.createStatement();
            String getGradePoints = "SELECT id_category, received_points, possible_points FROM Grades " + "WHERE id_category=" + idCategory + ";";
            ResultSet gradePoints = gradeStatement.executeQuery(getGradePoints);
            while (gradePoints.next()) {
                received_points += gradePoints.getInt("received_points");
                possible_points += gradePoints.getInt("possible_points");
            }
        }
        String setCoursePoints = "UPDATE Courses " + "SET received_points=" + received_points + ", possible_points=" + possible_points + " " + "WHERE id=" + idCourse + ";";
        statement.executeUpdate(setCoursePoints);
        double quality_points = 0, credits = 0;
        double received_double = 0, possible_double = 0;
        String gpa;
        Statement statement_SemesterID = Main.gradebookDB.createStatement();
        String getSemesterID = "SELECT id_semester FROM Courses " + "WHERE id=" + getCourseID() + ";";
        ResultSet SemesterID = statement_SemesterID.executeQuery(getSemesterID);
        if (SemesterID.next()) {
            idSemester = SemesterID.getInt("id_semester");
        }
        String getQualityCredits = "SELECT id, id_semester, received_points, possible_points, credit_hours FROM Courses " + "WHERE id_semester=" + idSemester + ";";
        ResultSet quality_credits = statement.executeQuery(getQualityCredits);
        while (quality_credits.next()) {
            received_double = quality_credits.getInt("received_points");
            possible_double = quality_credits.getInt("possible_points");
            credits += quality_credits.getInt("credit_hours");
            idSemester = quality_credits.getInt("id_semester");
            if (received_double / possible_double >= 0.9) {
                quality_points += 4 * (quality_credits.getInt("credit_hours"));
            } else if (received_double / possible_double >= 0.8) {
                quality_points += 3 * (quality_credits.getInt("credit_hours"));
            } else if (received_double / possible_double >= 0.7) {
                quality_points += 2 * (quality_credits.getInt("credit_hours"));
            } else if (received_double / possible_double >= 0.6) {
                quality_points += (quality_credits.getInt("credit_hours"));
            }
        }
        gpa = Double.toString(quality_points / credits);
        if (gpa.length() > 4) {
            if (Character.getNumericValue(gpa.charAt(4)) >= 5) {
                gpa = gpa.substring(0, 3) + Integer.toString(Character.getNumericValue(gpa.charAt(3)) + 1);
            } else {
                gpa = gpa.substring(0, 4);
            }
        }
        if (!gpa.equals("NaN")) {
            String setGPA = "UPDATE Semesters " + "SET gpa=" + gpa + " " + "WHERE id=" + idSemester + ";";
            statement.executeUpdate(setGPA);
        }
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


private void initializeAccordion() {
    TitledPane titledPane;
    categoryAccordion.getPanes().remove(firstCategory);
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT name, weight FROM Course_Categories " + "WHERE id_course=" + getCourseID() + ";";
        ResultSet rs = statement.executeQuery(sql);
        while (rs.next()) {
            Category category = new Category(rs.getString("name"), rs.getInt("weight"));
            ;
            categoryAccordion.getPanes().addAll(newCategory(category));
        }
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


private void initializeGrades() {
    for (int i = 0; i < categoryAccordion.getPanes().size(); i++) {
        String name = categoryAccordion.getPanes().get(i).getText();
        TableView<Grade> gradeTableView = (TableView<Grade>) ((AnchorPane) (categoryAccordion.getPanes().get(i).getContent())).getChildren().get(0);
        gradeTableView.setItems(getGrades(name));
        gradeTableView.refresh();
    }
}

######


private String getPoints() {
    String points = "N/A";
    try {
        Statement statement = Main.gradebookDB.createStatement();
        String sql = "SELECT id, received_points FROM Courses WHERE id=" + getCourseID() + ";";
        ResultSet rs = statement.executeQuery(sql);
        if (rs.next()) {
            points = Integer.toString(rs.getInt("received_points"));
        }
    } catch (Exception e) {
        System.out.println(e);
    }
    return points;
}

######


@FXML
private void goToHome() throws IOException {
    Parent homeParent = FXMLLoader.load(getClass().getResource("Home.fxml"));
    Scene home = new Scene(homeParent);
    Stage window = (Stage) viewLabel.getScene().getWindow();
    window.setScene(home);
    window.setTitle("Home");
    window.show();
    Controller_Home.titles.add("Home");
}

######


@FXML
private void goToSemesters() throws IOException {
    Parent SemestersParent = FXMLLoader.load(getClass().getResource("Semesters.fxml"));
    Scene semesters = new Scene(SemestersParent);
    Stage window = (Stage) viewLabel.getScene().getWindow();
    window.setScene(semesters);
    window.setTitle("Semesters");
    window.show();
    Controller_Home.titles.add("Semesters");
}

######


@FXML
private void goToGPA() throws IOException {
    Parent gpaParent = FXMLLoader.load(getClass().getResource("GPA_Calculator.fxml"));
    Scene gpa = new Scene(gpaParent);
    Stage window = (Stage) viewLabel.getScene().getWindow();
    window.setScene(gpa);
    window.setTitle("Calculate GPA");
    window.show();
    Controller_Home.titles.add("Calculate GPA");
}

######


@FXML
private void goBack() throws IOException {
    int n = Controller_Home.titles.size() - 1;
    Controller_Home.titles.remove(n);
    Parent backParent = null;
    switch(Controller_Home.titles.get(n - 1)) {
        case "Home":
            backParent = FXMLLoader.load(getClass().getResource("Home.fxml"));
            break;
        case "Add Course":
            backParent = FXMLLoader.load(getClass().getResource("Course_Add.fxml"));
            break;
        case "Calculate GPA":
            backParent = FXMLLoader.load(getClass().getResource("GPA_Calculator.fxml"));
            break;
        case "Semesters":
            backParent = FXMLLoader.load(getClass().getResource("Semesters.fxml"));
            break;
        case "View Course":
            backParent = FXMLLoader.load(getClass().getResource("Course_View.fxml"));
            break;
    }
    Scene back = new Scene(backParent);
    Stage window = (Stage) viewLabel.getScene().getWindow();
    window.setScene(back);
    window.setTitle(Controller_Home.titles.get(n - 1));
    window.show();
}

######


@Override
public Copia doRetriveById(Object... id) {
    throw new UnsupportedOperationException("Not supported yet.");
}

######


public List<Copia> doRetriveAllById(Object... id) {
    String codice = (String) id[0];
    List<Copia> copie = new ArrayList<>();
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveById);
        prst.setString(1, codice);
        try {
            ResultSet rs = prst.executeQuery();
            con.commit();
            while (rs.next()) {
                Copia copia = new Copia(rs.getString("NumeroRegistrazione"), rs.getString("NumeroScaffale"), rs.getInt("Posizione"), rs.getString("CodiceVolume"), rs.getBoolean("Disponibilità"));
                copie.add(copia);
            }
            rs.close();
        } catch (SQLException e) {
            con.rollback();
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
        return null;
    }
    return copie;
}

######


@Override
public int doInsert(Copia copia) {
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doInsertQuery, PreparedStatement.RETURN_GENERATED_KEYS);
        prst.setString(1, copia.getNumeroRegistrazione());
        prst.setString(2, copia.getNumeroScaffale());
        prst.setInt(3, copia.getPosizione());
        prst.setString(4, copia.getCodiceVolume());
        prst.setBoolean(5, copia.isDisponibilita());
        try {
            prst.execute();
            con.commit();
            ResultSet rs = prst.getGeneratedKeys();
            return 1;
        } catch (SQLException e) {
            con.rollback();
            e.printStackTrace();
            return -1;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException e) {
        return -1;
    }
}

######


@Override
public int doUpdate(Copia entity) {
    throw new UnsupportedOperationException("Not supported yet.");
}

######


@Override
public List<Copia> doRetriveAll() {
    List<Copia> copie = new ArrayList<>();
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement("select * from copia");
        try {
            ResultSet rs = prst.executeQuery();
            while (rs.next()) {
                Copia c = new Copia();
                c.setNumeroRegistrazione(rs.getString("NumeroRegistrazione"));
                c.setNumeroScaffale(rs.getString("NumeroScaffale"));
                c.setPosizione(rs.getInt("Posizione"));
                c.setCodiceVolume(rs.getString("CodiceVolume"));
                c.setDisponibilita(rs.getBoolean(5));
                copie.add(c);
            }
            rs.close();
        } catch (SQLException e) {
            con.rollback();
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
    }
    return copie;
}

######


public static void main(String[] args) {
    Cluster cluster = CouchbaseCluster.create("couchbase://localhost");
    Bucket bucket = cluster.openBucket("example", "");
    JsonObject person = JsonObject.create();
    person.put("firstname", "Aditya");
    person.put("lastname", "Samant");
    JsonArray socialMedia = JsonArray.create();
    socialMedia.add(JsonObject.create().put("title", "Twitter").put("link", "https://www.twitter.com/adityasamant"));
    socialMedia.add(JsonObject.create().put("title", "GitHub").put("link", "https://github.com/adityasamant25"));
    person.put("socialMedia", socialMedia);
    JsonDocument document = JsonDocument.create("aditya", person);
    bucket.upsert(document);
    System.out.println(bucket.get("aditya").content());
    bucket.query(N1qlQuery.parameterized("UPSERT INTO example (KEY, VALUE) VALUES ($id, {'firstname': $firstname, 'lastname': $lastname})", JsonObject.create().put("id", "isha").put("firstname", "Isha").put("lastname", "Samant")));
    N1qlQueryResult result = bucket.query(N1qlQuery.parameterized("SELECT example.* FROM example where META().id = $id", JsonObject.create().put("id", "isha"), N1qlParams.build().consistency(ScanConsistency.REQUEST_PLUS)));
    for (N1qlQueryRow row : result) {
        System.out.println(row);
    }
}

######


public Long getCount() {
    return count;
}

######


public void setCount(Long count) {
    this.count = count;
}

######


@Override
public String toString() {
    return "Course{" + "id=" + super.getId() + ", name=" + super.getName() + ", points=" + points + ", teacher=" + teacher.getName() + '}';
}

######


@Override
public boolean equals(Object obj) {
    return super.equals(obj);
}

######


@Override
public int hashCode() {
    return super.hashCode();
}

######


public int getPoints() {
    return points;
}

######


public void setPoints(int points) {
    this.points = points;
}

######


public Teacher getTeacher() {
    return teacher;
}

######


public void setTeacher(Teacher teacher) {
    this.teacher = teacher;
}

######


public List<Education> getEducations() {
    if (educations == null) {
        educations = new ArrayList<>();
    }
    return educations;
}

######


public void setEducations(List<Education> educations) {
    this.educations = educations;
}

######


public void addEducation(Education education) {
    getEducations().add(education);
}

######


public void removeEducation(Education education) {
    getEducations().remove(education);
}

######


public static boolean checkCourse(int subjectID, int teacherID) throws SQLException {
    boolean result;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_checkCourse);
            preparedStatement.setInt(1, subjectID);
            preparedStatement.setInt(2, teacherID);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                result = resultSet.getBoolean("isActive");
                if (result) {
                    return true;
                }
            }
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return false;
}

######


public static boolean checkCourseByID(int courseID) throws SQLException {
    boolean isActive;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_checkCourseByID);
            preparedStatement.setInt(1, courseID);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                isActive = resultSet.getBoolean("isActive");
                if (isActive) {
                    return isActive;
                }
            }
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return false;
}

######


public static boolean insertCourse(int subjectID, int teacherID) throws SQLException {
    boolean check;
    boolean result = false;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            check = checkCourse(subjectID, teacherID);
            if (!check) {
                PreparedStatement preparedStatement = connection.prepareStatement(sql_insertCourse);
                preparedStatement.setInt(1, subjectID);
                preparedStatement.setInt(2, teacherID);
                int row = preparedStatement.executeUpdate();
                result = row != 0;
            }
        } catch (SQLException e) {
            e.getMessage();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return result;
}

######


public static List<Course> getCourse(int subjectID, int teacherID) throws SQLException {
    List<Course> courses = new ArrayList<>();
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_getCourse);
            preparedStatement.setInt(1, subjectID);
            preparedStatement.setInt(2, teacherID);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                int coursesID = resultSet.getInt("courseID");
                String teacherSurname = resultSet.getString("teacherSurname");
                String teacherName = resultSet.getString("teacherName");
                String subjectName = resultSet.getString("subjectName");
                courses.add(new Course(coursesID, teacherID, teacherName, teacherSurname, subjectID, subjectName));
            }
        } catch (SQLException e) {
            e.getMessage();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return courses;
}

######


public static List<Course> getAllCourses() throws SQLException {
    List<Course> courses = new ArrayList<>();
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_getAllCourses);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                int coursesID = resultSet.getInt("courseID");
                int teacherID = resultSet.getInt("teacherID");
                String teacherSurname = resultSet.getString("teacherSurname");
                String teacherName = resultSet.getString("teacherName");
                int subjectID = resultSet.getInt("subjectID");
                String subjectName = resultSet.getString("subjectName");
                boolean isActive = resultSet.getBoolean("isActive");
                if (isActive) {
                    courses.add(new Course(coursesID, teacherID, teacherName, teacherSurname, subjectID, subjectName));
                }
            }
        } catch (SQLException e) {
            e.getMessage();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return courses;
}

######


public static boolean deleteCourse(int id) throws SQLException {
    boolean deleted = false;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement deleteStatement = connection.prepareStatement(sql_deleteCourse);
            deleteStatement.setInt(1, id);
            deleteStatement.executeUpdate();
            deleted = true;
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else {
        throw new SQLException();
    }
    return deleted;
}

######


protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setContentType("text/html;charset=utf-8");
    Status status = new Status();
    DBConnect dbConnect = new DBConnect();
    String URI = request.getRequestURI();
    int index = URI.lastIndexOf('/');
    String courseIDStr = URI.substring(index + 1);
    courseIDStr = URLDecoder.decode(courseIDStr, "utf-8");
    boolean nan = false;
    try {
        Integer.parseInt(courseIDStr);
    } catch (Exception e) {
        nan = true;
    }
    String querySting = "SELECT * FROM course WHERE id=?";
    PreparedStatement preparedStatement = dbConnect.prepareStatement(querySting);
    JSONObject jsonRet;
    if (nan || courseIDStr.equals("") || courseIDStr.equals("detail")) {
        status.setStatus(false);
        status.setInfo("空参数");
        jsonRet = JSONObject.fromObject(status);
        Course course = new Course();
        course.setCourseID(-1);
        course.setCourseName("");
        course.setCourseInfo("");
        course.setCoursePlan("");
        jsonRet.put("course", course);
    } else {
        try {
            int courseID = Integer.parseInt(courseIDStr);
            preparedStatement.setInt(1, courseID);
            ResultSet rs = preparedStatement.executeQuery();
            status.setStatus(true);
            status.setInfo("课程获取成功");
            jsonRet = JSONObject.fromObject(status);
            Course course = new Course();
            while (rs.next()) {
                course.setCourseID(rs.getInt("id"));
                course.setCourseName(rs.getString("name"));
                course.setCourseInfo(rs.getString("info"));
                course.setCoursePlan(rs.getString("plan"));
                course.setTeacherID(rs.getString("teacherid"));
                break;
            }
            rs.close();
            jsonRet.put("course", course);
        } catch (SQLException e) {
            status.setStatus(false);
            status.setInfo("课程获取失败");
            jsonRet = JSONObject.fromObject(status);
            Course course = new Course();
            course.setCourseID(-1);
            course.setCourseName("");
            course.setCourseInfo(e.getMessage());
            course.setCoursePlan("");
            jsonRet.put("course", course);
            e.printStackTrace();
        }
    }
    PrintWriter out = response.getWriter();
    out.print(jsonRet.toString());
}

######


protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
}

######


protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setContentType("text/html;charset=utf-8");
    DBConnect dbConnect = new DBConnect();
    String URI = request.getRequestURI();
    int index = URI.lastIndexOf('/');
    String courseIDStr = URI.substring(index + 1);
    courseIDStr = URLDecoder.decode(courseIDStr, "utf-8");
    String userToken = (request.getParameter("userToken") == null) ? "" : request.getParameter("userToken");
    String account = (request.getParameter("account") == null) ? "" : request.getParameter("account");
    JSONObject jsonRet;
    Status status = new Status();
    List<Evaluation> evas = new ArrayList<Evaluation>();
    if (!Widgets.isInteger(courseIDStr) || courseIDStr.equals("") || userToken.equals("")) {
        status.setStatus(false);
        status.setInfo("评教参数出问题");
    } else {
        try {
            String sql = "Select * From selection WHERE courseid = ?;";
            PreparedStatement pstm = dbConnect.prepareStatement(sql);
            pstm.setInt(1, Integer.parseInt(courseIDStr));
            ResultSet rs = pstm.executeQuery();
            while (rs.next()) {
                Evaluation eva = new Evaluation();
                eva.setComment(rs.getString("comment"));
                eva.setScore("" + rs.getInt("score"));
                evas.add(eva);
            }
            status.setStatus(true);
            status.setInfo("获取评教成功");
            rs.close();
        } catch (SQLException e) {
            status.setStatus(false);
            status.setInfo("获取评教失败");
        }
    }
    jsonRet = JSONObject.fromObject(status);
    jsonRet.put("evaluations", evas);
    PrintWriter out = response.getWriter();
    out.print(jsonRet.toString());
}

######


protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setContentType("text/html;charset=utf-8");
    DBConnect dbConnect = new DBConnect();
    String URI = request.getRequestURI();
    int index = URI.lastIndexOf('/');
    String courseIDStr = URI.substring(index + 1);
    courseIDStr = URLDecoder.decode(courseIDStr, "utf-8");
    String userToken = (request.getParameter("userToken") == null) ? "" : request.getParameter("userToken");
    String account = (request.getParameter("account") == null) ? "" : request.getParameter("account");
    String score = (request.getParameter("score") == null) ? "" : request.getParameter("score");
    String comment = (request.getParameter("comment") == null) ? "" : request.getParameter("comment");
    JSONObject jsonRet;
    Status status = new Status();
    if (!Widgets.isInteger(courseIDStr) || courseIDStr.equals("") || userToken.equals("") || !Widgets.isInteger(score) || comment.equals("")) {
        status.setStatus(false);
        status.setInfo("评教参数出问题");
    } else {
        try {
            String sql = "UPDATE selection SET score = ?, comment = ? WHERE courseid = ? and studentid = ?;";
            PreparedStatement pstm = dbConnect.prepareStatement(sql);
            pstm.setInt(3, Integer.parseInt(courseIDStr));
            pstm.setString(4, account);
            pstm.setInt(1, Integer.parseInt(score));
            pstm.setString(2, comment);
            pstm.executeUpdate();
            status.setStatus(true);
            status.setInfo("评教成功");
        } catch (SQLException e) {
            e.printStackTrace();
            status.setStatus(false);
            status.setInfo("评教失败");
        }
    }
    jsonRet = JSONObject.fromObject(status);
    PrintWriter out = response.getWriter();
    out.print(jsonRet.toString());
}

######


@SqlUpdate("create table CP (cp integer, ville text)")
void createCpTable();

######


@SqlQuery("select * from cp where cp = :name")
@RegisterMapperFactory(BeanMapperFactory.class)
List<Ville> findByName(@Bind("name") int name);

######


@SqlQuery("select * from cp order by cp")
@RegisterMapperFactory(BeanMapperFactory.class)
List<Ville> all();

######


@SqlUpdate("drop table if exists CP")
void dropCpTable();

######


@SqlBatch("insert into CP (cp, ville) values (:cp, :ville)")
void load(@Bind("cp") List<Integer> cp, @Bind("ville") List<String> ville);

######


public void addAdmin() {
    DaftarUser d = new DaftarUser();
    User user = new User();
    user.setUsername("admin");
    user.setRoleuser("1");
    user.setPassword("admin");
    user.setJabatan("administrator");
    user.setNama("administrator");
    List<User> l = d.getUser();
    Iterator<User> i = l.iterator();
    User u = new User();
    boolean result = false;
    if (!l.isEmpty()) {
        while (i.hasNext()) {
            u = i.next();
            if (u.getUsername().equalsIgnoreCase(user.getUsername())) {
                result = true;
            }
        }
        if (result = false) {
            d.rekamUser(user);
        }
    } else {
        d.rekamUser(user);
    }
    user = null;
}

######


public EntityManager getEntityManager() {
    return emf.createEntityManager();
}

######


public List<User> getUser() {
    List<User> users = new ArrayList<User>();
    EntityManager em = getEntityManager();
    try {
        Query q = em.createQuery("SELECT a FROM User AS a");
        users = q.getResultList();
    } finally {
        em.close();
    }
    return users;
}

######


public User findUser(Integer id) {
    EntityManager em = getEntityManager();
    try {
        return em.find(User.class, id);
    } finally {
        em.close();
    }
}

######


public boolean check(String username, String password) {
    boolean result = false;
    EntityManager em = getEntityManager();
    try {
        Query q = em.createQuery("SELECT count(a) FROM User AS a WHERE a.username=:uname AND a.password=:pass");
        q.setParameter("uname", username);
        q.setParameter("pass", password);
        int jumlahUser = ((Long) q.getSingleResult()).intValue();
        if (jumlahUser == 1) {
            result = true;
        }
    } finally {
        em.close();
    }
    return result;
}

######


public void rekamUser(User user) {
    EntityManager em = null;
    try {
        em = getEntityManager();
        em.getTransaction().begin();
        em.persist(user);
        em.getTransaction().commit();
    } finally {
        if (em != null) {
            em.close();
        }
    }
}

######


public void updateUser(User user) {
    EntityManager em = getEntityManager();
    try {
        em.getTransaction().begin();
        em.merge(user);
        em.getTransaction().commit();
    } finally {
        em.close();
    }
}

######


public void deleteUser(Integer id) throws NonexistentEntityException {
    EntityManager em = null;
    try {
        em = getEntityManager();
        em.getTransaction().begin();
        User user;
        try {
            user = em.getReference(User.class, id);
            user.getId();
        } catch (EntityNotFoundException enfe) {
            throw new NonexistentEntityException("The user with id " + id + " no longer exists.", enfe);
        }
        em.remove(user);
        em.getTransaction().commit();
    } finally {
        if (em != null) {
            em.close();
        }
    }
}

######


public User getUser(String username, String password) {
    User user = null;
    EntityManager em = getEntityManager();
    try {
        boolean hasilCheck = this.check(username, password);
        if (hasilCheck) {
            Query q = em.createQuery("SELECT a FROM User AS a WHERE a.username=:uname AND a.password=:pass");
            q.setParameter("uname", username);
            q.setParameter("pass", password);
            user = (User) q.getSingleResult();
        }
    } finally {
        em.close();
    }
    return user;
}

######


public User findUser(Long id) {
    EntityManager em = getEntityManager();
    try {
        return em.find(User.class, id);
    } finally {
        em.close();
    }
}

######


public boolean isUsernameExist(String kode) {
    DaftarUser daftarUser = new DaftarUser();
    List<User> listUser = daftarUser.getUser();
    Iterator<User> iterator = listUser.iterator();
    User tes = new User();
    while (iterator.hasNext()) {
        tes = iterator.next();
        if (kode.equalsIgnoreCase(tes.getUsername())) {
            return true;
        }
    }
    return false;
}

######


public boolean isPasswordExist(String nama) {
    DaftarUser daftarUser = new DaftarUser();
    List<User> listUser = daftarUser.getUser();
    Iterator<User> iterator = listUser.iterator();
    User tes = new User();
    while (iterator.hasNext()) {
        tes = iterator.next();
        if (nama.equalsIgnoreCase(tes.getPassword())) {
            return true;
        }
    }
    return false;
}

######


public void edit(User user) {
    EntityManager em = null;
    try {
        em = getEntityManager();
        em.getTransaction().begin();
        user = em.merge(user);
        em.getTransaction().commit();
    } finally {
        if (em != null) {
            em.close();
        }
    }
}

######


public void destroy(long iduser) throws NonexistentEntityException {
    EntityManager em = null;
    try {
        em = getEntityManager();
        em.getTransaction().begin();
        User user;
        try {
            user = em.getReference(User.class, iduser);
        } catch (EntityNotFoundException enfe) {
            throw new NonexistentEntityException("user belum dipilih.", enfe);
        }
        em.remove(user);
        em.getTransaction().commit();
    } finally {
        if (em != null) {
            em.close();
        }
    }
}

######


@Select("select a.id from cs_credit a inner join cs_audit_log2 b on a.id=b.id_credit where a.status='a' and b.from_status='y' and b.to_status='a' and b.end_time >= trunc(sysdate)")
List<Integer> getContractActiveOnlyId();

######


@Select("select a.id from cs_credit a where a.status = 'y' and (a.id_sa is null or a.id_sa not in (select account from cs_test_account where account_type='id_sa')) and (a.id_person is null or a.id_person not in (select account from cs_test_account where account_type='id_person'))")
List<Integer> getContractRegisterOnlyId();

######


@Select("select count(*) from checkoff_auto_acp a where a.create_time >= trunc(sysdate) and a.pay_status = 'a'")
Integer getCheckOffCount();

######


@Select("select count(*) from checkoff_auto_acp a where a.create_time >= trunc(sysdate) and a.pay_status='k'")
Integer getCheckOffSucceededCount();

######


@Update("UPDATE PERSON_TEST SET name=#{name} where id = #{id}")
Integer setName(@Param("id") Integer id, @Param("name") String name);

######


public String validUser(String userName1, String passWord1) {
    Connection connection = ConnectionFactory.getConnection();
    try {
        PreparedStatement ps = connection.prepareStatement("select * from usertable2 where firstname=? and passWord=?");
        System.out.println(userName1);
        ps.setString(1, userName1);
        ps.setString(2, passWord1);
        ResultSet rs = ps.executeQuery();
        while (rs.next()) {
            if (rs.getString("firstname").equals(userName1) && rs.getString("passWord").equals(passWord1)) {
                System.out.println(userName1);
                System.out.println(passWord1);
                System.out.println(rs.getString("firstname"));
                System.out.println(rs.getString("passWord"));
                return "valid";
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return "not valid";
}

######


public String getInsertData(String firstName, String password, String lastName, String email, String phoneNum) {
    Connection connection = ConnectionFactory.getConnection();
    int userId = 0;
    Statement stmt = null;
    String insertTableSQL = "INSERT INTO usertable2" + "(firstname,passWord,lastName,email,phonenumber,userid) VALUES" + "(?,?,?,?,?,seq1.nextval)";
    try {
        PreparedStatement ps = connection.prepareStatement(insertTableSQL);
        ps.setString(1, firstName);
        ps.setString(2, password);
        ps.setString(3, lastName);
        ps.setString(4, email);
        ps.setString(5, phoneNum);
        ps.executeUpdate();
        return "done";
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return "not done";
}

######


public String getCreateTable() {
    return createTable;
}

######


public long insert(Context context, ContentValues contentValues) throws Exception {
    long resultadoInsercao = 0;
    try {
        gerDB.checkOpeningDataBase(context, "write");
        resultadoInsercao = GerenciadorDB.db.insert(NomeTabela, null, contentValues);
        GerenciadorDB.db = gerDB.closeDataBase(context);
    } catch (Exception ex) {
        throw ex;
    }
    return resultadoInsercao;
}

######


public Cursor listar(Context context) throws Exception {
    Cursor retorno;
    String dump;
    try {
        gerDB.checkOpeningDataBase(context, "read");
        retorno = GerenciadorDB.db.rawQuery("select * " + "FROM " + NomeTabela + " ORDER BY _id DESC", null);
        dump = DatabaseUtils.dumpCursorToString(retorno);
        GerenciadorDB.db = gerDB.closeDataBase(context);
    } catch (Exception ex) {
        throw ex;
    }
    Log.v("Valores CursorCrud", dump);
    return retorno;
}

######


@Override
public void TampilData(m_toko a) {
}

######


@Override
public void UbahData(m_toko a) {
    PreparedStatement statement = null;
    try {
        statement = connection.prepareStatement(UbahData);
        statement.setString(1, a.getkode());
        statement.setString(2, a.getnama());
        statement.setString(3, a.getkategori());
        statement.setString(4, a.getjenis());
        statement.setString(5, a.getharga());
        statement.executeUpdate();
    } catch (SQLException ex) {
        Logger.getLogger(daoToko.class.getName()).log(Level.SEVERE, null, ex);
    }
}

######


@Override
public void SimpanData(m_toko a) {
    PreparedStatement statement = null;
    try {
        statement = connection.prepareStatement(SimpanData);
        statement.setString(1, a.getkode());
        statement.setString(2, a.getnama());
        statement.setString(3, a.getkategori());
        statement.setString(4, a.getjenis());
        statement.setString(5, a.getharga());
        statement.executeUpdate();
        ResultSet rs = statement.getGeneratedKeys();
        while (rs.next()) {
            a.setkode(rs.getString(1));
        }
    } catch (SQLException ex) {
        Logger.getLogger(daoToko.class.getName()).log(Level.SEVERE, null, ex);
    }
}

######


@Override
public void onCreate(SQLiteDatabase sqLiteDatabase) {
    sqLiteDatabase.execSQL("CREATE TABLE IF NOT EXISTS " + TABLE_SAMPLES + "(" + COL_BSSID + " STRING PRIMARY KEY, " + COL_LATITUDE + " REAL, " + COL_LONGITUDE + " REAL, " + COL_LAT1 + " REAL, " + COL_LON1 + " REAL, " + COL_LAT2 + " REAL, " + COL_LON2 + " REAL, " + COL_LAT3 + " REAL, " + COL_LON3 + " REAL, " + COL_D12 + " REAL, " + COL_D23 + " REAL, " + COL_D31 + " REAL);");
    onUpgrade(sqLiteDatabase, 1, VERSION);
}

######


@Override
public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
    if (oldVersion < 2) {
        sqLiteDatabase.execSQL("ALTER TABLE " + TABLE_SAMPLES + " ADD COLUMN " + COL_MOVED_GUARD + " INTEGER;");
        sqLiteDatabase.execSQL("UPDATE " + TABLE_SAMPLES + " SET " + COL_MOVED_GUARD + "=0;");
    }
    if (oldVersion < 3) {
        sqLiteDatabase.execSQL("ALTER TABLE " + TABLE_SAMPLES + " ADD COLUMN " + COL_RADIUS + " REAL;");
        sqLiteDatabase.execSQL("UPDATE " + TABLE_SAMPLES + " SET " + COL_RADIUS + "=-1.0;");
    }
    if (oldVersion < 4) {
        sqLiteDatabase.execSQL("ALTER TABLE " + TABLE_SAMPLES + " ADD COLUMN " + COL_SSID + " TEXT;");
    }
    if (oldVersion < 5) {
        sqLiteDatabase.execSQL("BEGIN TRANSACTION;");
        sqLiteDatabase.execSQL("ALTER TABLE " + TABLE_SAMPLES + " RENAME TO " + TABLE_SAMPLES + "_old;");
        sqLiteDatabase.execSQL("CREATE TABLE " + TABLE_SAMPLES + "(" + COL_RFID + " STRING PRIMARY KEY, " + COL_TYPE + " INTEGER, " + COL_SSID + " TEXT, " + COL_LATITUDE + " REAL, " + COL_LONGITUDE + " REAL, " + COL_RADIUS + " REAL, " + COL_MOVED_GUARD + " INTEGER, " + COL_CHANGED + " INTEGER, " + COL_LAT1 + " REAL, " + COL_LON1 + " REAL, " + COL_LAT2 + " REAL, " + COL_LON2 + " REAL, " + COL_LAT3 + " REAL, " + COL_LON3 + " REAL);");
        sqLiteDatabase.execSQL("INSERT INTO " + TABLE_SAMPLES + "(" + COL_RFID + ", " + COL_SSID + ", " + COL_LATITUDE + ", " + COL_LONGITUDE + ", " + COL_RADIUS + ", " + COL_MOVED_GUARD + ", " + COL_LAT1 + ", " + COL_LON1 + ", " + COL_LAT2 + ", " + COL_LON2 + ", " + COL_LAT3 + ", " + COL_LON3 + ") SELECT " + COL_BSSID + ", " + COL_SSID + ", " + COL_LATITUDE + ", " + COL_LONGITUDE + ", " + COL_RADIUS + ", " + COL_MOVED_GUARD + ", " + COL_LAT1 + ", " + COL_LON1 + ", " + COL_LAT2 + ", " + COL_LON2 + ", " + COL_LAT3 + ", " + COL_LON3 + " FROM " + TABLE_SAMPLES + "_old;");
        sqLiteDatabase.execSQL("DROP TABLE " + TABLE_SAMPLES + "_old;");
        sqLiteDatabase.execSQL("UPDATE " + TABLE_SAMPLES + " SET " + COL_TYPE + "=" + TYPE_WIFI + ";");
        sqLiteDatabase.execSQL("UPDATE " + TABLE_SAMPLES + " SET " + COL_CHANGED + "=" + (CHANGED_AP1 + CHANGED_AP2 + CHANGED_AP3) + ";");
        sqLiteDatabase.execSQL("COMMIT;");
    }
}

######


@Override
public void onOpen(SQLiteDatabase db) {
    super.onOpen(db);
    this.db = db;
    sqlSampleInsert = db.compileStatement("INSERT INTO " + TABLE_SAMPLES + "(" + COL_RFID + ", " + COL_TYPE + ", " + COL_SSID + ", " + COL_LATITUDE + ", " + COL_LONGITUDE + ", " + COL_RADIUS + ", " + COL_MOVED_GUARD + ", " + COL_CHANGED + ", " + COL_LAT1 + ", " + COL_LON1 + ", " + COL_LAT2 + ", " + COL_LON2 + ", " + COL_LAT3 + ", " + COL_LON3 + ") " + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);");
    sqlSampleUpdate = db.compileStatement("UPDATE " + TABLE_SAMPLES + " SET " + COL_SSID + "=?, " + COL_LATITUDE + "=?, " + COL_LONGITUDE + "=?, " + COL_RADIUS + "=?, " + COL_MOVED_GUARD + "=?, " + COL_CHANGED + "=?, " + COL_LAT1 + "=?, " + COL_LON1 + "=?, " + COL_LAT2 + "=?, " + COL_LON2 + "=?, " + COL_LAT3 + "=?, " + COL_LON3 + "=? " + "WHERE " + COL_RFID + "=?;");
    sqlAPdrop = db.compileStatement("DELETE FROM " + TABLE_SAMPLES + " WHERE " + COL_RFID + "=?;");
    sqlAPdropAll = db.compileStatement("DELETE FROM " + TABLE_SAMPLES);
}

######


public void exportComplete() {
    ensureOpened();
    db.execSQL("UPDATE " + TABLE_SAMPLES + " SET " + COL_CHANGED + "=" + CHANGED_NONE + ";");
    onAccessPointCountChanged();
}

######


public void dropAP(String rfId) {
    final String canonicalBSSID = AccessPoint.bssid(rfId);
    if (DEBUG) {
        Log.i(TAG, "Dropping " + canonicalBSSID + " from db");
    }
    sqlAPdrop.bindString(1, canonicalBSSID);
    sqlAPdrop.executeInsert();
    sqlAPdrop.clearBindings();
    onAccessPointCountChanged();
}

######


protected void dropAllAPs() {
    sqlAPdropAll.execute();
    onAccessPointCountChanged();
}

######


public int getAccessPointCount(boolean changed) {
    String whereClause = "";
    if (changed) {
        whereClause = " WHERE " + COL_CHANGED + "<> 0";
    }
    Cursor cursor = getReadableDatabase().rawQuery("SELECT COUNT(*) FROM " + TABLE_SAMPLES + whereClause + ";", null);
    try {
        if (cursor.moveToFirst()) {
            return (int) cursor.getLong(0);
        } else {
            return 0;
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
}

######


@Nullable
public SimpleLocation getLocation(String rfId) {
    final long entryTime = System.currentTimeMillis();
    final String canonicalBSSID = AccessPoint.bssid(rfId);
    Cursor c = getReadableDatabase().query(TABLE_SAMPLES, new String[] { COL_LATITUDE, COL_LONGITUDE, COL_RADIUS, COL_LAT1, COL_LON1, COL_LAT2, COL_LON2, COL_LAT3, COL_LON3 }, COL_RFID + "=? AND " + COL_MOVED_GUARD + "=0", new String[] { canonicalBSSID }, null, null, null);
    try {
        if (c != null && c.moveToFirst()) {
            Integer sampleCount = 0;
            if (c.getDouble(3) != 0.d || c.getDouble(4) != 0.d)
                sampleCount++;
            if (c.getDouble(5) != 0.d || c.getDouble(6) != 0.d)
                sampleCount++;
            if (c.getDouble(7) != 0.d || c.getDouble(8) != 0.d)
                sampleCount++;
            if (sampleCount == 3) {
                SimpleLocation result = SimpleLocation.builder().latitude(c.getDouble(0)).longitude(c.getDouble(1)).radius(Math.max(Configuration.with(context).accessPointAssumedAccuracy(), c.getFloat(2))).changed(false).build();
                if (DEBUG) {
                    Log.i(TAG, rfId + " at " + result.toString());
                }
                if (DEBUG) {
                    Log.i(TAG, "getLocation time: " + (System.currentTimeMillis() - entryTime) + "ms");
                }
                c.close();
                c = null;
                return result;
            } else {
                if (DEBUG) {
                    Log.i(TAG, "getLocation(): Insufficient samples (" + sampleCount + ")");
                    Log.i(TAG, "getLocation time: " + (System.currentTimeMillis() - entryTime) + "ms");
                }
            }
        }
        c.close();
        c = null;
        return null;
    } finally {
        if (c != null) {
            c.close();
        }
    }
}

######


@Nullable
public AccessPoint query(String rfId) {
    Cursor cursor = getReadableDatabase().query(TABLE_SAMPLES, new String[] { COL_RFID, COL_LATITUDE, COL_LONGITUDE, COL_RADIUS, COL_LAT1, COL_LON1, COL_LAT2, COL_LON2, COL_LAT3, COL_LON3, COL_MOVED_GUARD, COL_SSID, COL_TYPE, COL_CHANGED }, COL_RFID + "=?", new String[] { AccessPoint.bssid(rfId) }, null, null, null);
    try {
        if (cursor != null && cursor.moveToFirst()) {
            List<SimpleLocation> samples = new ArrayList<SimpleLocation>();
            Integer changed = cursor.getInt(13);
            addLocation(cursor, 4, ((changed & CHANGED_AP1) != 0), samples);
            addLocation(cursor, 6, ((changed & CHANGED_AP2) != 0), samples);
            addLocation(cursor, 8, ((changed & CHANGED_AP3) != 0), samples);
            if (DEBUG) {
                Log.i(TAG, "query(" + rfId + "): change=" + changed + ", samples=" + samples);
            }
            return AccessPoint.builder().ssid(cursor.getString(11)).rfId(AccessPoint.bssid(rfId)).samples(samples).moveGuard(cursor.getInt(10)).rfType(cursor.getInt(12)).build();
        } else {
            return null;
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
}

######


public void update(AccessPoint accessPoint) {
    synchronized (sqlSampleUpdate) {
        bind(sqlSampleUpdate, accessPoint, 1);
        sqlSampleUpdate.bindString(13, accessPoint.rfId());
        sqlSampleUpdate.executeInsert();
        sqlSampleUpdate.clearBindings();
    }
    onAccessPointDataChanged();
}

######


public void insert(AccessPoint accessPoint) {
    synchronized (sqlSampleInsert) {
        sqlSampleInsert.bindString(1, accessPoint.rfId());
        sqlSampleInsert.bindLong(2, accessPoint.rfType());
        bind(sqlSampleInsert, accessPoint, 3);
        sqlSampleInsert.executeInsert();
        sqlSampleInsert.clearBindings();
    }
    onAccessPointCountChanged();
}

######


private static Integer changedValue(AccessPoint accessPoint) {
    Integer result = CHANGED_NONE;
    for (Integer i = 0; i <= 2; i++) {
        if ((accessPoint.sample(i) != null) && accessPoint.sample(i).changed()) {
            result |= (1 << i);
        }
    }
    if (DEBUG) {
        Log.i(TAG, "changedValue=" + result + ", accessPoint=" + accessPoint);
    }
    return result;
}

######


private static SQLiteStatement bind(SQLiteStatement statement, AccessPoint accessPoint, int start) {
    if (!TextUtils.isEmpty(accessPoint.ssid())) {
        statement.bindString(start, accessPoint.ssid());
    }
    statement.bindString(start + 1, String.valueOf(accessPoint.estimateLocation().latitude()));
    statement.bindString(start + 2, String.valueOf(accessPoint.estimateLocation().longitude()));
    statement.bindString(start + 3, String.valueOf(accessPoint.estimateLocation().radius()));
    statement.bindString(start + 4, String.valueOf(accessPoint.moveGuard()));
    statement.bindLong(start + 5, changedValue(accessPoint));
    bind(statement, accessPoint.sample(0), start + 6);
    bind(statement, accessPoint.sample(1), start + 8);
    bind(statement, accessPoint.sample(2), start + 10);
    return statement;
}

######


private static void bind(SQLiteStatement statement, SimpleLocation location, int index) {
    statement.bindString(index, String.valueOf(location == null ? 0.f : location.latitude()));
    statement.bindString(index + 1, String.valueOf(location == null ? 0.f : location.longitude()));
}

######


private SimpleLocation parse(Cursor cursor, int index, boolean changed) {
    if (cursor.getDouble(index) != 0.d || cursor.getDouble(index + 1) != 0.d) {
        return SimpleLocation.builder().latitude(cursor.getDouble(index)).longitude(cursor.getDouble(index + 1)).radius(Configuration.with(context).accessPointAssumedAccuracy()).changed(changed).build();
    } else {
        return null;
    }
}

######


private List<SimpleLocation> addLocation(Cursor cursor, int index, boolean changed, List<SimpleLocation> list) {
    SimpleLocation location = parse(cursor, index, changed);
    if (location != null) {
        list.add(location);
    }
    return list;
}

######


protected void onAccessPointCountChanged() {
    dataChanged();
}

######


protected void onAccessPointDataChanged() {
    dataChanged();
}

######


private void dataChanged() {
    localBroadcastManager.sendBroadcast(new Intent(ACTION_DATA_CHANGED));
}

######


public void beginTransaction() {
    ensureOpened();
    db.beginTransaction();
    return;
}

######


public void commitTransaction() {
    ensureOpened();
    db.setTransactionSuccessful();
    db.endTransaction();
}

######


private void ensureOpened() {
    if (db == null) {
        throw new UnsupportedOperationException("Database is not opened");
    }
}

######


public int deleteAccount(long id) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        String[] sid = new String[] { String.valueOf(id) };
        Account a = load(Account.class, id);
        writeDeleteLog(TRANSACTION_TABLE, a.remoteKey);
        db.execSQL(UPDATE_ORPHAN_TRANSACTIONS_1, sid);
        db.execSQL(UPDATE_ORPHAN_TRANSACTIONS_2, sid);
        db.delete(TRANSACTION_ATTRIBUTE_TABLE, TransactionAttributeColumns.TRANSACTION_ID + " in (SELECT _id from " + TRANSACTION_TABLE + " where " + TransactionColumns.from_account_id + "=?)", sid);
        db.delete(TRANSACTION_TABLE, TransactionColumns.from_account_id + "=?", sid);
        int count = db.delete(ACCOUNT_TABLE, "_id=?", sid);
        db.setTransactionSuccessful();
        return count;
    } finally {
        db.endTransaction();
    }
}

######


public Transaction getTransaction(long id) {
    Transaction t = get(Transaction.class, id);
    if (t != null) {
        t.systemAttributes = getSystemAttributesForTransaction(id);
        if (t.isSplitParent()) {
            t.splits = getSplitsForTransaction(t.id);
        }
        return t;
    }
    return new Transaction();
}

######


public Cursor getBlotter(WhereFilter filter) {
    return getBlotter(V_BLOTTER, filter);
}

######


public Cursor getBlotterForAccount(WhereFilter filter) {
    WhereFilter accountFilter = enhanceFilterForAccountBlotter(filter);
    return getBlotter(V_BLOTTER_FOR_ACCOUNT_WITH_SPLITS, accountFilter);
}

######


public static WhereFilter enhanceFilterForAccountBlotter(WhereFilter filter) {
    WhereFilter accountFilter = WhereFilter.copyOf(filter);
    accountFilter.put(Criteria.raw(BlotterColumns.parent_id + "=0 OR " + BlotterColumns.is_transfer + "=-1"));
    return accountFilter;
}

######


public Cursor getBlotterForAccountWithSplits(WhereFilter filter) {
    return getBlotter(V_BLOTTER_FOR_ACCOUNT_WITH_SPLITS, filter);
}

######


private Cursor getBlotter(String view, WhereFilter filter) {
    long t0 = System.currentTimeMillis();
    try {
        String sortOrder = getBlotterSortOrder(filter);
        return db().query(view, BlotterColumns.NORMAL_PROJECTION, filter.getSelection(), filter.getSelectionArgs(), null, null, sortOrder);
    } finally {
        long t1 = System.currentTimeMillis();
        Log.i("DB", "getBlotter " + (t1 - t0) + "ms");
    }
}

######


private String getBlotterSortOrder(WhereFilter filter) {
    String sortOrder = filter.getSortOrder();
    if (sortOrder == null || sortOrder.length() == 0) {
        sortOrder = BlotterFilter.SORT_NEWER_TO_OLDER + "," + BlotterFilter.SORT_NEWER_TO_OLDER_BY_ID;
    } else {
        if (sortOrder.contains(BlotterFilter.SORT_NEWER_TO_OLDER)) {
            sortOrder += "," + BlotterFilter.SORT_NEWER_TO_OLDER_BY_ID;
        } else {
            sortOrder += "," + BlotterFilter.SORT_OLDER_TO_NEWER_BY_ID;
        }
    }
    return sortOrder;
}

######


public Cursor getAllTemplates(WhereFilter filter) {
    long t0 = System.currentTimeMillis();
    try {
        return db().query(V_ALL_TRANSACTIONS, BlotterColumns.NORMAL_PROJECTION, filter.getSelection(), filter.getSelectionArgs(), null, null, BlotterFilter.SORT_NEWER_TO_OLDER);
    } finally {
        long t1 = System.currentTimeMillis();
        Log.i("DB", "getBlotter " + (t1 - t0) + "ms");
    }
}

######


public Cursor getBlotterWithSplits(String where) {
    return db().query(V_BLOTTER_FOR_ACCOUNT_WITH_SPLITS, BlotterColumns.NORMAL_PROJECTION, where, null, null, null, BlotterColumns.datetime + " DESC");
}

######


private void updateLastUsed(Transaction t) {
    SQLiteDatabase db = db();
    if (t.isTransfer()) {
        db.execSQL(ACCOUNT_LAST_ACCOUNT_UPDATE, new Object[] { t.toAccountId, t.fromAccountId });
    }
    db.execSQL(ACCOUNT_LAST_CATEGORY_UPDATE, new Object[] { t.categoryId, t.fromAccountId });
    db.execSQL(PAYEE_LAST_CATEGORY_UPDATE, new Object[] { t.categoryId, t.payeeId });
    db.execSQL(CATEGORY_LAST_PROJECT_UPDATE, new Object[] { t.projectId, t.categoryId });
}

######


public long duplicateTransaction(long id) {
    return duplicateTransaction(id, 0, 1);
}

######


public long duplicateTransactionWithMultiplier(long id, int multiplier) {
    return duplicateTransaction(id, 0, multiplier);
}

######


public long duplicateTransactionAsTemplate(long id) {
    return duplicateTransaction(id, 1, 1);
}

######


private long duplicateTransaction(long id, int isTemplate, int multiplier) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        long now = System.currentTimeMillis();
        Transaction transaction = getTransaction(id);
        if (transaction.isSplitChild()) {
            id = transaction.parentId;
            transaction = getTransaction(id);
        }
        transaction.lastRecurrence = now;
        updateTransaction(transaction);
        transaction.id = -1;
        transaction.isTemplate = isTemplate;
        transaction.dateTime = now;
        transaction.remoteKey = null;
        if (isTemplate == 0) {
            transaction.recurrence = null;
            transaction.notificationOptions = null;
        }
        if (multiplier > 1) {
            transaction.fromAmount *= multiplier;
            transaction.toAmount *= multiplier;
        }
        long transactionId = insertTransaction(transaction);
        Map<Long, String> attributesMap = getAllAttributesForTransaction(id);
        LinkedList<TransactionAttribute> attributes = new LinkedList<TransactionAttribute>();
        for (long attributeId : attributesMap.keySet()) {
            TransactionAttribute ta = new TransactionAttribute();
            ta.attributeId = attributeId;
            ta.value = attributesMap.get(attributeId);
            attributes.add(ta);
        }
        if (attributes.size() > 0) {
            insertAttributes(transactionId, attributes);
        }
        List<Transaction> splits = getSplitsForTransaction(id);
        if (multiplier > 1) {
            for (Transaction split : splits) {
                split.fromAmount *= multiplier;
                split.remoteKey = null;
            }
        }
        transaction.id = transactionId;
        transaction.splits = splits;
        insertSplits(transaction);
        db.setTransactionSuccessful();
        return transactionId;
    } finally {
        db.endTransaction();
    }
}

######


public long insertOrUpdate(Transaction transaction) {
    return insertOrUpdate(transaction, Collections.<TransactionAttribute>emptyList());
}

######


public long insertOrUpdate(Transaction transaction, List<TransactionAttribute> attributes) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        long id = insertOrUpdateInTransaction(transaction, attributes);
        db.setTransactionSuccessful();
        return id;
    } finally {
        db.endTransaction();
    }
}

######


public long insertOrUpdateInTransaction(Transaction transaction, List<TransactionAttribute> attributes) {
    long transactionId;
    transaction.lastRecurrence = System.currentTimeMillis();
    if (transaction.id == -1) {
        transactionId = insertTransaction(transaction);
    } else {
        updateTransaction(transaction);
        transactionId = transaction.id;
        db().delete(TRANSACTION_ATTRIBUTE_TABLE, TransactionAttributeColumns.TRANSACTION_ID + "=?", new String[] { String.valueOf(transactionId) });
        deleteSplitsForParentTransaction(transactionId);
    }
    if (attributes != null) {
        insertAttributes(transactionId, attributes);
    }
    transaction.id = transactionId;
    insertSplits(transaction);
    updateAccountLastTransactionDate(transaction.fromAccountId);
    updateAccountLastTransactionDate(transaction.toAccountId);
    return transactionId;
}

######


public void insertWithoutUpdatingBalance(Transaction transaction) {
    updateAccountBalance = false;
    try {
        transaction.id = insertTransaction(transaction);
        insertSplits(transaction);
    } finally {
        updateAccountBalance = true;
    }
}

######


private void insertAttributes(long transactionId, List<TransactionAttribute> attributes) {
    for (TransactionAttribute a : attributes) {
        a.transactionId = transactionId;
        ContentValues values = a.toValues();
        db().insert(TRANSACTION_ATTRIBUTE_TABLE, null, values);
    }
}

######


private void insertAttributes(long transactionId, Map<Long, String> categoryAttributes) {
    if (categoryAttributes != null && categoryAttributes.size() > 0) {
        List<TransactionAttribute> attributes = new LinkedList<TransactionAttribute>();
        for (Map.Entry<Long, String> e : categoryAttributes.entrySet()) {
            TransactionAttribute a = new TransactionAttribute();
            a.attributeId = e.getKey();
            a.value = e.getValue();
            attributes.add(a);
        }
        insertAttributes(transactionId, attributes);
    }
}

######


private void insertSplits(Transaction parent) {
    List<Transaction> splits = parent.splits;
    if (splits != null) {
        for (Transaction split : splits) {
            split.id = -1;
            split.parentId = parent.id;
            split.dateTime = parent.dateTime;
            split.fromAccountId = parent.fromAccountId;
            split.payeeId = parent.payeeId;
            split.isTemplate = parent.isTemplate;
            split.status = parent.status;
            updateSplitOriginalAmount(parent, split);
            long splitId = insertTransaction(split);
            insertAttributes(splitId, split.categoryAttributes);
        }
    }
}

######


private void updateSplitOriginalAmount(Transaction parent, Transaction split) {
    if (parent.originalCurrencyId > 0) {
        split.originalCurrencyId = parent.originalCurrencyId;
        split.originalFromAmount = split.fromAmount;
        split.fromAmount = calculateAmountInAccountCurrency(parent, split.fromAmount);
    }
}

######


private long calculateAmountInAccountCurrency(Transaction parent, long amount) {
    double rate = getRateFromParent(parent);
    return (long) (rate * amount);
}

######


private double getRateFromParent(Transaction parent) {
    if (parent.originalFromAmount != 0) {
        return Math.abs(1.0 * parent.fromAmount / parent.originalFromAmount);
    }
    return 0;
}

######


private long insertTransaction(Transaction t) {
    t.updatedOn = System.currentTimeMillis();
    long id = db().insert(TRANSACTION_TABLE, null, t.toValues());
    if (updateAccountBalance) {
        if (!t.isTemplateLike()) {
            if (t.isSplitChild()) {
                if (t.isTransfer()) {
                    updateToAccountBalance(t, id);
                }
            } else {
                updateFromAccountBalance(t, id);
                updateToAccountBalance(t, id);
                updateLastUsed(t);
            }
        }
    }
    return id;
}

######


private void updateFromAccountBalance(Transaction t, long id) {
    updateAccountBalance(t.fromAccountId, t.fromAmount);
    insertRunningBalance(t.fromAccountId, id, t.dateTime, t.fromAmount, t.fromAmount);
}

######


private void updateToAccountBalance(Transaction t, long id) {
    updateAccountBalance(t.toAccountId, t.toAmount);
    insertRunningBalance(t.toAccountId, id, t.dateTime, t.toAmount, t.toAmount);
}

######


private void updateTransaction(Transaction t) {
    Transaction oldT = null;
    if (t.isNotTemplateLike()) {
        oldT = getTransaction(t.id);
        updateAccountBalance(oldT.fromAccountId, oldT.fromAmount, t.fromAccountId, t.fromAmount);
        updateAccountBalance(oldT.toAccountId, oldT.toAmount, t.toAccountId, t.toAmount);
        updateRunningBalance(oldT, t);
    }
    t.updatedOn = System.currentTimeMillis();
    db().update(TRANSACTION_TABLE, t.toValues(), TransactionColumns._id + "=?", new String[] { String.valueOf(t.id) });
    if (oldT != null) {
        updateAccountLastTransactionDate(oldT.fromAccountId);
        updateAccountLastTransactionDate(oldT.toAccountId);
    }
}

######


public void updateTransactionStatus(long id, TransactionStatus status) {
    Transaction t = getTransaction(id);
    t.status = status;
    updateTransaction(t);
}

######


public void deleteTransaction(long id) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        deleteTransactionNoDbTransaction(id);
        db.setTransactionSuccessful();
    } finally {
        db.endTransaction();
    }
}

######


public void deleteTransactionNoDbTransaction(long id) {
    Transaction t = getTransaction(id);
    if (t.isNotTemplateLike()) {
        revertFromAccountBalance(t);
        revertToAccountBalance(t);
        updateAccountLastTransactionDate(t.fromAccountId);
        updateAccountLastTransactionDate(t.toAccountId);
    }
    String[] sid = new String[] { String.valueOf(id) };
    SQLiteDatabase db = db();
    db.delete(TRANSACTION_ATTRIBUTE_TABLE, TransactionAttributeColumns.TRANSACTION_ID + "=?", sid);
    db.delete(TRANSACTION_TABLE, TransactionColumns._id + "=?", sid);
    writeDeleteLog(TRANSACTION_TABLE, t.remoteKey);
    deleteSplitsForParentTransaction(id);
}

######


private void deleteSplitsForParentTransaction(long parentId) {
    List<Transaction> splits = getSplitsForTransaction(parentId);
    SQLiteDatabase db = db();
    for (Transaction split : splits) {
        if (split.isTransfer()) {
            revertToAccountBalance(split);
        }
        db.delete(TRANSACTION_ATTRIBUTE_TABLE, TransactionAttributeColumns.TRANSACTION_ID + "=?", new String[] { String.valueOf(split.id) });
        writeDeleteLog(TRANSACTION_TABLE, split.remoteKey);
    }
    db.delete(TRANSACTION_TABLE, TransactionColumns.parent_id + "=?", new String[] { String.valueOf(parentId) });
}

######


private void revertFromAccountBalance(Transaction t) {
    updateAccountBalance(t.fromAccountId, -t.fromAmount);
    deleteRunningBalance(t.fromAccountId, t.id, t.fromAmount, t.dateTime);
}

######


private void revertToAccountBalance(Transaction t) {
    updateAccountBalance(t.toAccountId, -t.toAmount);
    deleteRunningBalance(t.toAccountId, t.id, t.toAmount, t.dateTime);
}

######


private void updateAccountBalance(long oldAccountId, long oldAmount, long newAccountId, long newAmount) {
    if (oldAccountId == newAccountId) {
        updateAccountBalance(newAccountId, newAmount - oldAmount);
    } else {
        updateAccountBalance(oldAccountId, -oldAmount);
        updateAccountBalance(newAccountId, newAmount);
    }
}

######


private void updateAccountBalance(long accountId, long deltaAmount) {
    if (accountId <= 0) {
        return;
    }
    db().execSQL(ACCOUNT_TOTAL_AMOUNT_UPDATE, new Object[] { deltaAmount, accountId });
}

######


private void insertRunningBalance(long accountId, long transactionId, long datetime, long amount, long deltaAmount) {
    if (accountId <= 0) {
        return;
    }
    long previousTransactionBalance = fetchAccountBalanceAtTheTime(accountId, datetime);
    SQLiteDatabase db = db();
    db.execSQL(INSERT_RUNNING_BALANCE, new Object[] { accountId, transactionId, datetime, previousTransactionBalance + amount });
    db.execSQL(UPDATE_RUNNING_BALANCE, new Object[] { deltaAmount, accountId, datetime });
}

######


private void updateRunningBalance(Transaction oldTransaction, Transaction newTransaction) {
    deleteRunningBalance(oldTransaction.fromAccountId, oldTransaction.id, oldTransaction.fromAmount, oldTransaction.dateTime);
    insertRunningBalance(newTransaction.fromAccountId, newTransaction.id, newTransaction.dateTime, newTransaction.fromAmount, newTransaction.fromAmount);
    deleteRunningBalance(oldTransaction.toAccountId, oldTransaction.id, oldTransaction.toAmount, oldTransaction.dateTime);
    insertRunningBalance(newTransaction.toAccountId, newTransaction.id, newTransaction.dateTime, newTransaction.toAmount, newTransaction.toAmount);
}

######


private void deleteRunningBalance(long accountId, long transactionId, long amount, long dateTime) {
    if (accountId <= 0) {
        return;
    }
    SQLiteDatabase db = db();
    db.execSQL(DELETE_RUNNING_BALANCE, new Object[] { accountId, transactionId });
    db.execSQL(UPDATE_RUNNING_BALANCE, new Object[] { -amount, accountId, dateTime });
}

######


private long fetchAccountBalanceAtTheTime(long accountId, long datetime) {
    return DatabaseUtils.rawFetchLongValue(this, "select balance from running_balance where account_id = ? and datetime <= ? order by datetime desc, transaction_id desc limit 1", new String[] { String.valueOf(accountId), String.valueOf(datetime) });
}

######


public void addAttributes(long categoryId, List<Attribute> attributes) {
    SQLiteDatabase db = db();
    db.delete(CATEGORY_ATTRIBUTE_TABLE, CategoryAttributeColumns.CATEGORY_ID + "=?", new String[] { String.valueOf(categoryId) });
    if (attributes != null && attributes.size() > 0) {
        ContentValues values = new ContentValues();
        values.put(CategoryAttributeColumns.CATEGORY_ID, categoryId);
        for (Attribute a : attributes) {
            values.put(CategoryAttributeColumns.ATTRIBUTE_ID, a.id);
            db.insert(CATEGORY_ATTRIBUTE_TABLE, null, values);
        }
    }
}

######


public List<Attribute> getAttributesForCategory(long categoryId) {
    LongSparseArray<Attribute> attributesMap = getAllAttributesMap();
    Cursor c = db().query(V_ATTRIBUTES, AttributeViewColumns.NORMAL_PROJECTION, AttributeViewColumns.CATEGORY_ID + "=?", new String[] { String.valueOf(categoryId) }, null, null, AttributeViewColumns.NAME);
    return collectAttributesFromCursor(attributesMap, c);
}

######


public List<Attribute> getAllAttributesForCategory(Category category) {
    LongSparseArray<Attribute> attributesMap = getAllAttributesMap();
    Cursor c = db().query(V_ATTRIBUTES, AttributeViewColumns.NORMAL_PROJECTION, AttributeViewColumns.CATEGORY_LEFT + "<= ? AND " + AttributeViewColumns.CATEGORY_RIGHT + " >= ?", new String[] { String.valueOf(category.left), String.valueOf(category.right) }, null, null, AttributeViewColumns.NAME);
    return collectAttributesFromCursor(attributesMap, c);
}

######


protected List<Attribute> collectAttributesFromCursor(LongSparseArray<Attribute> attributesMap, Cursor c) {
    try {
        ArrayList<Attribute> list = new ArrayList<Attribute>(c.getCount());
        while (c.moveToNext()) {
            long attributeId = c.getLong(AttributeViewColumns.Indicies.ID);
            Attribute a = attributesMap.get(attributeId);
            if (a != null) {
                list.add(a);
            }
        }
        return list;
    } finally {
        c.close();
    }
}

######


public Map<Long, String> getAttributesMapping() {
    Cursor c = db().query(V_ATTRIBUTES, AttributeViewColumns.NORMAL_PROJECTION, null, null, null, null, AttributeViewColumns.CATEGORY_ID + ", " + AttributeViewColumns.NAME);
    try {
        HashMap<Long, String> attributes = new HashMap<Long, String>();
        StringBuilder sb = null;
        long prevCategoryId = -1;
        while (c.moveToNext()) {
            long categoryId = c.getLong(AttributeViewColumns.Indicies.CATEGORY_ID);
            String name = c.getString(AttributeViewColumns.Indicies.NAME);
            if (prevCategoryId != categoryId) {
                if (sb == null) {
                    sb = new StringBuilder();
                    sb.append("[");
                } else {
                    attributes.put(prevCategoryId, sb.append("]").toString());
                    sb.setLength(1);
                }
                prevCategoryId = categoryId;
            }
            if (sb.length() > 1) {
                sb.append(", ");
            }
            sb.append(name);
        }
        if (sb != null) {
            attributes.put(prevCategoryId, sb.append("]").toString());
        }
        return attributes;
    } finally {
        c.close();
    }
}

######


public Map<Long, String> getAllAttributesForTransaction(long transactionId) {
    Cursor c = db().query(TRANSACTION_ATTRIBUTE_TABLE, TransactionAttributeColumns.NORMAL_PROJECTION, TransactionAttributeColumns.TRANSACTION_ID + "=? AND " + TransactionAttributeColumns.ATTRIBUTE_ID + ">=0", new String[] { String.valueOf(transactionId) }, null, null, null);
    try {
        HashMap<Long, String> attributes = new HashMap<Long, String>();
        while (c.moveToNext()) {
            long attributeId = c.getLong(TransactionAttributeColumns.Indicies.ATTRIBUTE_ID);
            String value = c.getString(TransactionAttributeColumns.Indicies.VALUE);
            attributes.put(attributeId, value);
        }
        return attributes;
    } finally {
        c.close();
    }
}

######


public EnumMap<SystemAttribute, String> getSystemAttributesForTransaction(long transactionId) {
    Cursor c = db().query(TRANSACTION_ATTRIBUTE_TABLE, TransactionAttributeColumns.NORMAL_PROJECTION, TransactionAttributeColumns.TRANSACTION_ID + "=? AND " + TransactionAttributeColumns.ATTRIBUTE_ID + "<0", new String[] { String.valueOf(transactionId) }, null, null, null);
    try {
        EnumMap<SystemAttribute, String> attributes = new EnumMap<SystemAttribute, String>(SystemAttribute.class);
        while (c.moveToNext()) {
            long attributeId = c.getLong(TransactionAttributeColumns.Indicies.ATTRIBUTE_ID);
            String value = c.getString(TransactionAttributeColumns.Indicies.VALUE);
            attributes.put(SystemAttribute.forId(attributeId), value);
        }
        return attributes;
    } finally {
        c.close();
    }
}

######


public void clearSelectedTransactions(long[] ids) {
    String sql = "UPDATE " + TRANSACTION_TABLE + " SET " + TransactionColumns.status + "='" + TransactionStatus.CL + "'," + TransactionColumns.updated_on + "='" + System.currentTimeMillis() + "' ";
    runInTransaction(sql, ids);
}

######


public void reconcileSelectedTransactions(long[] ids) {
    String sql = "UPDATE " + TRANSACTION_TABLE + " SET " + TransactionColumns.status + "='" + TransactionStatus.RC + "'," + TransactionColumns.updated_on + "='" + System.currentTimeMillis() + "' ";
    runInTransaction(sql, ids);
}

######


public void deleteSelectedTransactions(long[] ids) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        for (long id : ids) {
            deleteTransactionNoDbTransaction(id);
        }
        db.setTransactionSuccessful();
    } finally {
        db.endTransaction();
    }
}

######


private void runInTransaction(String sql, long[] ids) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        int count = ids.length;
        int bucket = 100;
        int num = 1 + count / bucket;
        for (int i = 0; i < num; i++) {
            int x = bucket * i;
            int y = Math.min(count, bucket * (i + 1));
            String script = createSql(sql, ids, x, y);
            db.execSQL(script);
        }
        db.setTransactionSuccessful();
    } finally {
        db.endTransaction();
    }
}

######


private String createSql(String updateSql, long[] ids, int x, int y) {
    StringBuilder sb = new StringBuilder(updateSql).append(" WHERE ").append(TransactionColumns.is_template).append("=0 AND ").append(TransactionColumns.parent_id).append("=0 AND ").append(TransactionColumns._id).append(" IN (");
    for (int i = x; i < y; i++) {
        if (i > x) {
            sb.append(",");
        }
        sb.append(ids[i]);
    }
    sb.append(")");
    return sb.toString();
}

######


public long[] storeMissedSchedules(List<RestoredTransaction> restored, long now) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        int count = restored.size();
        long[] restoredIds = new long[count];
        HashMap<Long, Transaction> transactions = new HashMap<Long, Transaction>();
        for (int i = 0; i < count; i++) {
            RestoredTransaction rt = restored.get(i);
            long transactionId = rt.transactionId;
            Transaction t = transactions.get(transactionId);
            if (t == null) {
                t = getTransaction(transactionId);
                transactions.put(transactionId, t);
            }
            t.id = -1;
            t.dateTime = rt.dateTime.getTime();
            t.status = TransactionStatus.RS;
            t.isTemplate = 0;
            restoredIds[i] = insertOrUpdate(t);
            t.id = transactionId;
        }
        for (Transaction t : transactions.values()) {
            db.execSQL(UPDATE_LAST_RECURRENCE, new Object[] { now, t.id });
        }
        db.setTransactionSuccessful();
        return restoredIds;
    } finally {
        db.endTransaction();
    }
}

######


public int getCustomClosingDay(long accountId, int period) {
    String where = CreditCardClosingDateColumns.ACCOUNT_ID + "=? AND " + CreditCardClosingDateColumns.PERIOD + "=?";
    Cursor c = db().query(CCARD_CLOSING_DATE_TABLE, new String[] { CreditCardClosingDateColumns.CLOSING_DAY }, where, new String[] { Long.toString(accountId), Integer.toString(period) }, null, null, null);
    int res = 0;
    try {
        if (c != null) {
            if (c.getCount() > 0) {
                c.moveToFirst();
                res = c.getInt(0);
            } else {
                res = 0;
            }
        } else {
            res = 0;
        }
    } catch (SQLiteException e) {
        res = 0;
    } finally {
        if (c != null)
            c.close();
    }
    return res;
}

######


public void setCustomClosingDay(long accountId, int period, int closingDay) {
    ContentValues values = new ContentValues();
    values.put(CreditCardClosingDateColumns.ACCOUNT_ID, Long.toString(accountId));
    values.put(CreditCardClosingDateColumns.PERIOD, Integer.toString(period));
    values.put(CreditCardClosingDateColumns.CLOSING_DAY, Integer.toString(closingDay));
    db().insert(CCARD_CLOSING_DATE_TABLE, null, values);
}

######


public void deleteCustomClosingDay(long accountId, int period) {
    String where = CreditCardClosingDateColumns.ACCOUNT_ID + "=? AND " + CreditCardClosingDateColumns.PERIOD + "=?";
    String[] args = new String[] { Long.toString(accountId), Integer.toString(period) };
    db().delete(CCARD_CLOSING_DATE_TABLE, where, args);
}

######


public void updateCustomClosingDay(long accountId, int period, int closingDay) {
    deleteCustomClosingDay(accountId, period);
    setCustomClosingDay(accountId, period, closingDay);
}

######


public void rebuildRunningBalances() {
    List<Account> accounts = getAllAccountsList();
    for (Account account : accounts) {
        rebuildRunningBalanceForAccount(account);
    }
}

######


public void rebuildRunningBalanceForAccount(Account account) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        String accountId = String.valueOf(account.getId());
        db.execSQL("delete from running_balance where account_id=?", new Object[] { accountId });
        WhereFilter filter = new WhereFilter("");
        filter.put(Criteria.eq(BlotterFilter.FROM_ACCOUNT_ID, accountId));
        filter.asc("datetime");
        filter.asc("_id");
        Cursor c = getBlotterForAccountWithSplits(filter);
        Object[] values = new Object[4];
        values[0] = accountId;
        try {
            long balance = 0;
            while (c.moveToNext()) {
                long parentId = c.getLong(BlotterColumns.parent_id.ordinal());
                int isTransfer = c.getInt(BlotterColumns.is_transfer.ordinal());
                if (parentId > 0) {
                    if (isTransfer >= 0) {
                        continue;
                    }
                }
                long fromAccountId = c.getLong(BlotterColumns.from_account_id.ordinal());
                long toAccountId = c.getLong(BlotterColumns.to_account_id.ordinal());
                if (toAccountId > 0 && toAccountId == fromAccountId) {
                    continue;
                }
                balance += c.getLong(DatabaseHelper.BlotterColumns.from_amount.ordinal());
                values[1] = c.getString(DatabaseHelper.BlotterColumns._id.ordinal());
                values[2] = c.getString(DatabaseHelper.BlotterColumns.datetime.ordinal());
                values[3] = balance;
                db.execSQL("insert into running_balance(account_id,transaction_id,datetime,balance) values (?,?,?,?)", values);
            }
        } finally {
            c.close();
        }
        updateAccountLastTransactionDate(account.id);
        db.setTransactionSuccessful();
    } finally {
        db.endTransaction();
    }
}

######


public long fetchBudgetBalance(LongSparseArray<Category> categories, LongSparseArray<Project> projects, Budget b) {
    String where = Budget.createWhere(b, categories, projects);
    Cursor c = db().query(V_BLOTTER_FOR_ACCOUNT_WITH_SPLITS, SUM_FROM_AMOUNT, where, null, null, null, null);
    try {
        if (c.moveToNext()) {
            return c.getLong(0);
        }
    } finally {
        c.close();
    }
    return 0;
}

######


public void recalculateAccountsBalances() {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        Cursor accountsCursor = db.query(ACCOUNT_TABLE, new String[] { AccountColumns.ID }, null, null, null, null, null);
        try {
            while (accountsCursor.moveToNext()) {
                long accountId = accountsCursor.getLong(0);
                recalculateAccountBalances(accountId);
            }
        } finally {
            accountsCursor.close();
        }
        db.setTransactionSuccessful();
    } finally {
        db.endTransaction();
    }
}

######


private void recalculateAccountBalances(long accountId) {
    long amount = fetchAccountBalance(accountId);
    ContentValues values = new ContentValues();
    values.put(AccountColumns.TOTAL_AMOUNT, amount);
    db().update(ACCOUNT_TABLE, values, AccountColumns.ID + "=?", new String[] { String.valueOf(accountId) });
    Log.i("DatabaseImport", "Recalculating amount for " + accountId);
}

######


private long fetchAccountBalance(long accountId) {
    Cursor c = db().query(V_BLOTTER_FOR_ACCOUNT_WITH_SPLITS, new String[] { "SUM(" + BlotterColumns.from_amount + ")" }, BlotterColumns.from_account_id + "=? and (" + BlotterColumns.parent_id + "=0 or " + BlotterColumns.is_transfer + "=-1)", new String[] { String.valueOf(accountId) }, null, null, null);
    try {
        if (c.moveToFirst()) {
            return c.getLong(0);
        }
        return 0;
    } finally {
        c.close();
    }
}

######


public void saveRate(ExchangeRate r) {
    replaceRate(r, r.date);
}

######


public void replaceRate(ExchangeRate rate, long originalDate) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        replaceRateInTransaction(rate, originalDate, db);
        db.setTransactionSuccessful();
    } finally {
        db.endTransaction();
    }
}

######


private void replaceRateInTransaction(ExchangeRate rate, long originalDate, SQLiteDatabase db) {
    deleteRateInTransaction(rate.fromCurrencyId, rate.toCurrencyId, originalDate, db);
    saveBothRatesInTransaction(rate, db);
}

######


private void saveBothRatesInTransaction(ExchangeRate r, SQLiteDatabase db) {
    r.date = DateUtils.atMidnight(r.date);
    saveRateInTransaction(db, r);
    saveRateInTransaction(db, r.flip());
}

######


private void saveRateInTransaction(SQLiteDatabase db, ExchangeRate r) {
    ContentValues values = r.toValues();
    values.remove("updated_on");
    values.put(CategoryColumns.updated_on.name(), System.currentTimeMillis());
    db.insert(EXCHANGE_RATES_TABLE, null, values);
}

######


public void saveDownloadedRates(List<ExchangeRate> downloadedRates) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        for (ExchangeRate r : downloadedRates) {
            if (r.isOk()) {
                replaceRateInTransaction(r, r.date, db);
            }
        }
        db.setTransactionSuccessful();
    } finally {
        db.endTransaction();
    }
}

######


public ExchangeRate findRate(Currency fromCurrency, Currency toCurrency, long date) {
    long day = DateUtils.atMidnight(date);
    Cursor c = db().query(EXCHANGE_RATES_TABLE, ExchangeRateColumns.NORMAL_PROJECTION, ExchangeRateColumns.NORMAL_PROJECTION_WHERE, new String[] { String.valueOf(fromCurrency.id), String.valueOf(toCurrency.id), String.valueOf(day) }, null, null, null);
    try {
        if (c.moveToFirst()) {
            return ExchangeRate.fromCursor(c);
        }
    } finally {
        c.close();
    }
    return null;
}

######


public List<ExchangeRate> findRates(Currency fromCurrency) {
    List<ExchangeRate> rates = new ArrayList<ExchangeRate>();
    Cursor c = db().query(EXCHANGE_RATES_TABLE, ExchangeRateColumns.NORMAL_PROJECTION, ExchangeRateColumns.from_currency_id + "=?", new String[] { String.valueOf(fromCurrency.id) }, null, null, ExchangeRateColumns.rate_date + " desc");
    try {
        while (c.moveToNext()) {
            rates.add(ExchangeRate.fromCursor(c));
        }
    } finally {
        c.close();
    }
    return rates;
}

######


public List<ExchangeRate> findRates(Currency fromCurrency, Currency toCurrency) {
    List<ExchangeRate> rates = new ArrayList<ExchangeRate>();
    Cursor c = db().query(EXCHANGE_RATES_TABLE, ExchangeRateColumns.NORMAL_PROJECTION, ExchangeRateColumns.from_currency_id + "=? and " + ExchangeRateColumns.to_currency_id + "=?", new String[] { String.valueOf(fromCurrency.id), String.valueOf(toCurrency.id) }, null, null, ExchangeRateColumns.rate_date + " desc");
    try {
        while (c.moveToNext()) {
            rates.add(ExchangeRate.fromCursor(c));
        }
    } finally {
        c.close();
    }
    return rates;
}

######


public ExchangeRateProvider getLatestRates() {
    LatestExchangeRates m = new LatestExchangeRates();
    Cursor c = db().query(EXCHANGE_RATES_TABLE, ExchangeRateColumns.LATEST_RATE_PROJECTION, null, null, ExchangeRateColumns.LATEST_RATE_GROUP_BY, null, null);
    fillRatesCollection(m, c);
    return m;
}

######


public ExchangeRateProvider getHistoryRates() {
    HistoryExchangeRates m = new HistoryExchangeRates();
    Cursor c = db().query(EXCHANGE_RATES_TABLE, ExchangeRateColumns.NORMAL_PROJECTION, null, null, null, null, null);
    fillRatesCollection(m, c);
    return m;
}

######


private void fillRatesCollection(ExchangeRatesCollection m, Cursor c) {
    try {
        while (c.moveToNext()) {
            ExchangeRate r = ExchangeRate.fromCursor(c);
            m.addRate(r);
        }
    } finally {
        c.close();
    }
}

######


public void deleteRate(ExchangeRate rate) {
    deleteRate(rate.fromCurrencyId, rate.toCurrencyId, rate.date);
}

######


public void deleteRate(long fromCurrencyId, long toCurrencyId, long date) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        deleteRateInTransaction(fromCurrencyId, toCurrencyId, date, db);
        db.setTransactionSuccessful();
    } finally {
        db.endTransaction();
    }
}

######


private void deleteRateInTransaction(long fromCurrencyId, long toCurrencyId, long date, SQLiteDatabase db) {
    long d = DateUtils.atMidnight(date);
    db.delete(EXCHANGE_RATES_TABLE, ExchangeRateColumns.DELETE_CLAUSE, new String[] { String.valueOf(fromCurrencyId), String.valueOf(toCurrencyId), String.valueOf(d) });
    db.delete(EXCHANGE_RATES_TABLE, ExchangeRateColumns.DELETE_CLAUSE, new String[] { String.valueOf(toCurrencyId), String.valueOf(fromCurrencyId), String.valueOf(d) });
}

######


public Total getAccountsTotalInHomeCurrency() {
    Currency homeCurrency = getHomeCurrency();
    return getAccountsTotal(homeCurrency);
}

######


public Total[] getAccountsTotal() {
    List<Account> accounts = getAllAccountsList();
    Map<Currency, Total> totalsMap = new HashMap<Currency, Total>();
    for (Account account : accounts) {
        if (account.shouldIncludeIntoTotals()) {
            Currency currency = account.currency;
            Total total = totalsMap.get(currency);
            if (total == null) {
                total = new Total(currency);
                totalsMap.put(currency, total);
            }
            total.balance += account.totalAmount;
        }
    }
    Collection<Total> values = totalsMap.values();
    return values.toArray(new Total[values.size()]);
}

######


public Total getAccountsTotal(Currency homeCurrency) {
    ExchangeRateProvider rates = getLatestRates();
    List<Account> accounts = getAllAccountsList();
    BigDecimal total = BigDecimal.ZERO;
    for (Account account : accounts) {
        if (account.shouldIncludeIntoTotals()) {
            if (account.currency.id == homeCurrency.id) {
                total = total.add(BigDecimal.valueOf(account.totalAmount));
            } else {
                ExchangeRate rate = rates.getRate(account.currency, homeCurrency);
                if (rate == ExchangeRate.NA) {
                    return new Total(homeCurrency, TotalError.lastRateError(account.currency));
                } else {
                    total = total.add(BigDecimal.valueOf(rate.rate * account.totalAmount));
                }
            }
        }
    }
    Total result = new Total(homeCurrency);
    result.balance = total.longValue();
    return result;
}

######


public boolean singleCurrencyOnly() {
    long currencyId = getSingleCurrencyId();
    return currencyId > 0;
}

######


private long getSingleCurrencyId() {
    Cursor c = db().rawQuery("select distinct " + AccountColumns.CURRENCY_ID + " from " + ACCOUNT_TABLE + " where " + AccountColumns.IS_INCLUDE_INTO_TOTALS + "=1 and " + AccountColumns.IS_ACTIVE + "=1", null);
    try {
        if (c.getCount() == 1) {
            c.moveToFirst();
            return c.getLong(0);
        }
        return -1;
    } finally {
        c.close();
    }
}

######


public void setDefaultHomeCurrency() {
    Currency homeCurrency = getHomeCurrency();
    long singleCurrencyId = getSingleCurrencyId();
    if (homeCurrency == Currency.EMPTY && singleCurrencyId > 0) {
        Currency c = get(Currency.class, singleCurrencyId);
        c.isDefault = true;
        saveOrUpdate(c);
    }
}

######


public void purgeAccountAtDate(Account account, long date) {
    long nearestTransactionId = findNearestOlderTransactionId(account, date);
    if (nearestTransactionId > 0) {
        SQLiteDatabase db = db();
        db.beginTransaction();
        try {
            Transaction newTransaction = createTransactionFromNearest(account, nearestTransactionId);
            breakSplitTransactions(account, date);
            deleteOldTransactions(account, date);
            insertWithoutUpdatingBalance(newTransaction);
            db.execSQL(INSERT_RUNNING_BALANCE, new Object[] { account.id, newTransaction.id, newTransaction.dateTime, newTransaction.fromAmount });
            db.setTransactionSuccessful();
        } finally {
            db.endTransaction();
        }
    }
}

######


private Transaction createTransactionFromNearest(Account account, long nearestTransactionId) {
    Transaction nearestTransaction = get(Transaction.class, nearestTransactionId);
    long balance = getAccountBalanceForTransaction(account, nearestTransaction);
    Transaction newTransaction = new Transaction();
    newTransaction.fromAccountId = account.id;
    newTransaction.dateTime = DateUtils.atDayEnd(nearestTransaction.dateTime);
    newTransaction.fromAmount = balance;
    Payee payee = insertPayee(context.getString(R.string.purge_account_payee));
    newTransaction.payeeId = payee != null ? payee.id : 0;
    newTransaction.status = TransactionStatus.CL;
    return newTransaction;
}

######


private void breakSplitTransactions(Account account, long date) {
    SQLiteDatabase db = db();
    long dayEnd = DateUtils.atDayEnd(date);
    db.execSQL(BREAK_SPLIT_TRANSACTIONS_1, new Object[] { account.id, dayEnd });
    db.execSQL(BREAK_SPLIT_TRANSACTIONS_2, new Object[] { account.id, dayEnd });
    db.delete(TRANSACTION_ATTRIBUTE_TABLE, TransactionAttributeColumns.TRANSACTION_ID + " in (SELECT _id from " + TRANSACTION_TABLE + " where " + TransactionColumns.datetime + "<=?)", new String[] { String.valueOf(dayEnd) });
}

######


public void deleteOldTransactions(Account account, long date) {
    SQLiteDatabase db = db();
    long dayEnd = DateUtils.atDayEnd(date);
    db.delete("transactions", "from_account_id=? and datetime<=? and is_template=0", new String[] { String.valueOf(account.id), String.valueOf(dayEnd) });
    db.delete("running_balance", "account_id=? and datetime<=?", new String[] { String.valueOf(account.id), String.valueOf(dayEnd) });
}

######


public long getAccountBalanceForTransaction(Account a, Transaction t) {
    return DatabaseUtils.rawFetchLongValue(this, "select balance from running_balance where account_id=? and transaction_id=?", new String[] { String.valueOf(a.id), String.valueOf(t.id) });
}

######


public long findNearestOlderTransactionId(Account account, long date) {
    return DatabaseUtils.rawFetchId(this, "select _id from v_blotter where from_account_id=? and datetime<=? order by datetime desc limit 1", new String[] { String.valueOf(account.id), String.valueOf(DateUtils.atDayEnd(date)) });
}

######


public long findLatestTransactionDate(long accountId) {
    return DatabaseUtils.rawFetchLongValue(this, "select datetime from running_balance where account_id=? order by datetime desc limit 1", new String[] { String.valueOf(accountId) });
}

######


private void updateAccountLastTransactionDate(long accountId) {
    if (accountId <= 0) {
        return;
    }
    long lastTransactionDate = findLatestTransactionDate(accountId);
    db().execSQL(ACCOUNT_LAST_TRANSACTION_DATE_UPDATE, new Object[] { lastTransactionDate, accountId });
}

######


public void updateAccountsLastTransactionDate() {
    List<Account> accounts = getAllAccountsList();
    for (Account account : accounts) {
        updateAccountLastTransactionDate(account.id);
    }
}

######


public long getLastRunningBalanceForAccount(Account account) {
    return DatabaseUtils.rawFetchLongValue(this, "select balance from running_balance where account_id=? order by datetime desc, transaction_id desc limit 1", new String[] { String.valueOf(account.id) });
}

######


public long writeDeleteLog(String tableName, String remoteKey) {
    if (remoteKey == null) {
        return 0;
    }
    if (remoteKey == "") {
        return 0;
    }
    ContentValues row = new ContentValues();
    row.put(deleteLogColumns.TABLE_NAME, tableName);
    row.put(deleteLogColumns.REMOTE_KEY, remoteKey);
    row.put(deleteLogColumns.DELETED_ON, System.currentTimeMillis());
    return db().insert(DELETE_LOG_TABLE, null, row);
}

######


@Override
protected String getExtension() {
    return ".backup";
}

######


@Override
protected void writeHeader(BufferedWriter bw) throws IOException, NameNotFoundException {
    PackageInfo pi = Utils.getPackageInfo(context);
    bw.write("PACKAGE:");
    bw.write(pi.packageName);
    bw.write("\n");
    bw.write("VERSION_CODE:");
    bw.write(String.valueOf(pi.versionCode));
    bw.write("\n");
    bw.write("VERSION_NAME:");
    bw.write(pi.versionName);
    bw.write("\n");
    bw.write("DATABASE_VERSION:");
    bw.write(String.valueOf(db.getVersion()));
    bw.write("\n");
    bw.write("#START\n");
}

######


public static void copy(File source, File dest) throws IOException {
    FileChannel in = null, out = null;
    try {
        in = new FileInputStream(source).getChannel();
        out = new FileOutputStream(dest).getChannel();
        long size = in.size();
        MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);
        out.write(buf);
    } finally {
        if (in != null)
            in.close();
        if (out != null)
            out.close();
    }
}

######


@Override
protected void writeBody(BufferedWriter bw) throws IOException {
    for (String tableName : BACKUP_TABLES) {
        exportTable(bw, tableName);
    }
}

######


@Override
protected void writeFooter(BufferedWriter bw) throws IOException {
    bw.write("#END");
}

######


private void exportTable(BufferedWriter bw, String tableName) throws IOException {
    String sql = "select * from " + tableName + (tableHasSystemIds(tableName) ? " WHERE _id>=0" : "");
    Cursor c = db.rawQuery(sql, null);
    try {
        String[] columnNames = c.getColumnNames();
        int cols = columnNames.length;
        while (c.moveToNext()) {
            bw.write("$ENTITY:");
            bw.write(tableName);
            bw.write("\n");
            for (int i = 0; i < cols; i++) {
                String value = c.getString(i);
                if (value != null) {
                    bw.write(columnNames[i]);
                    bw.write(":");
                    bw.write(removeNewLine(value));
                    bw.write("\n");
                }
            }
            bw.write("$$\n");
        }
    } finally {
        c.close();
    }
}

######


private static String removeNewLine(String value) {
    return value.replace('\n', ' ');
}

######


protected abstract String getDatabaseDriverClass();

######


protected abstract List<String> getCreateSchemeSQL();

######


protected abstract List<String> getCreateTablesSQL();

######


protected abstract List<String> getCreateIndexesSQL();

######


protected abstract String getDuplicateKeyErrorCode();

######


protected String getBalanceSelectSQL() {
    return SELECT_BALANCE_SQL;
}

######


protected String getTablesExistSQL() {
    return SELECT_CHECK_TABLES_EXIST_SQL;
}

######


protected List<String> getCompatibilitySQL() {
    List<String> sqlStatements = new ArrayList<String>();
    sqlStatements.add(SELECT_COMPATIBILITY_COINBASE_SQL);
    return sqlStatements;
}

######


protected String getTrasactionOutputSelectSQL() {
    return SELECT_TRANSACTION_OUTPUTS_SQL;
}

######


protected List<String> getDropTablesSQL() {
    List<String> sqlStatements = new ArrayList<String>();
    sqlStatements.add(DROP_SETTINGS_TABLE);
    sqlStatements.add(DROP_HEADERS_TABLE);
    sqlStatements.add(DROP_UNDOABLE_TABLE);
    sqlStatements.add(DROP_OPEN_OUTPUT_TABLE);
    return sqlStatements;
}

######


protected String getSelectSettingsSQL() {
    return SELECT_SETTINGS_SQL;
}

######


protected String getInsertSettingsSQL() {
    return INSERT_SETTINGS_SQL;
}

######


protected String getUpdateSettingsSLQ() {
    return UPDATE_SETTINGS_SQL;
}

######


protected String getSelectHeadersSQL() {
    return SELECT_HEADERS_SQL;
}

######


protected String getInsertHeadersSQL() {
    return INSERT_HEADERS_SQL;
}

######


protected String getUpdateHeadersSQL() {
    return UPDATE_HEADERS_SQL;
}

######


protected String getSelectUndoableBlocksSQL() {
    return SELECT_UNDOABLEBLOCKS_SQL;
}

######


protected String getInsertUndoableBlocksSQL() {
    return INSERT_UNDOABLEBLOCKS_SQL;
}

######


protected String getUpdateUndoableBlocksSQL() {
    return UPDATE_UNDOABLEBLOCKS_SQL;
}

######


protected String getDeleteUndoableBlocksSQL() {
    return DELETE_UNDOABLEBLOCKS_SQL;
}

######


protected String getSelectOpenoutputsSQL() {
    return SELECT_OPENOUTPUTS_SQL;
}

######


protected String getSelectOpenoutputsCountSQL() {
    return SELECT_OPENOUTPUTS_COUNT_SQL;
}

######


protected String getInsertOpenoutputsSQL() {
    return INSERT_OPENOUTPUTS_SQL;
}

######


protected String getDeleteOpenoutputsSQL() {
    return DELETE_OPENOUTPUTS_SQL;
}

######


protected String getSelectSettingsDumpSQL() {
    return SELECT_DUMP_SETTINGS_SQL;
}

######


protected String getSelectHeadersDumpSQL() {
    return SELECT_DUMP_HEADERS_SQL;
}

######


protected String getSelectUndoableblocksDumpSQL() {
    return SELECT_DUMP_UNDOABLEBLOCKS_SQL;
}

######


protected String getSelectopenoutputsDumpSQL() {
    return SELECT_DUMP_OPENOUTPUTS_SQL;
}

######


protected final synchronized void maybeConnect() throws BlockStoreException {
    try {
        if (conn.get() != null && !conn.get().isClosed())
            return;
        if (username == null || password == null) {
            conn.set(DriverManager.getConnection(connectionURL));
        } else {
            Properties props = new Properties();
            props.setProperty("user", this.username);
            props.setProperty("password", this.password);
            conn.set(DriverManager.getConnection(connectionURL, props));
        }
        allConnections.add(conn.get());
        Connection connection = conn.get();
        if (schemaName != null) {
            Statement s = connection.createStatement();
            for (String sql : getCreateSchemeSQL()) {
                s.execute(sql);
            }
        }
        log.info("Made a new connection to database " + connectionURL);
    } catch (SQLException ex) {
        throw new BlockStoreException(ex);
    }
}

######


@Override
public synchronized void close() {
    for (Connection conn : allConnections) {
        try {
            if (!conn.getAutoCommit()) {
                conn.rollback();
            }
            conn.close();
            if (conn == this.conn.get()) {
                this.conn.set(null);
            }
        } catch (SQLException ex) {
            throw new RuntimeException(ex);
        }
    }
    allConnections.clear();
}

######


private boolean tablesExists() throws SQLException {
    PreparedStatement ps = null;
    try {
        ps = conn.get().prepareStatement(getTablesExistSQL());
        ResultSet results = ps.executeQuery();
        results.close();
        return true;
    } catch (SQLException ex) {
        return false;
    } finally {
        if (ps != null && !ps.isClosed()) {
            ps.close();
        }
    }
}

######


private void checkCompatibility() throws SQLException, BlockStoreException {
    for (String sql : getCompatibilitySQL()) {
        PreparedStatement ps = null;
        try {
            ps = conn.get().prepareStatement(sql);
            ResultSet results = ps.executeQuery();
            results.close();
        } catch (SQLException ex) {
            throw new BlockStoreException("Database block store is not compatible with the current release.  " + "See galilelj release notes for further information: " + ex.getMessage());
        } finally {
            if (ps != null && !ps.isClosed()) {
                ps.close();
            }
        }
    }
}

######


private void createTables() throws SQLException, BlockStoreException {
    Statement s = conn.get().createStatement();
    for (String sql : getCreateTablesSQL()) {
        if (log.isDebugEnabled()) {
            log.debug("DatabaseFullPrunedBlockStore : CREATE table [SQL= {0}]", sql);
        }
        s.executeUpdate(sql);
    }
    for (String sql : getCreateIndexesSQL()) {
        if (log.isDebugEnabled()) {
            log.debug("DatabaseFullPrunedBlockStore : CREATE index [SQL= {0}]", sql);
        }
        s.executeUpdate(sql);
    }
    s.close();
    PreparedStatement ps = conn.get().prepareStatement(getInsertSettingsSQL());
    ps.setString(1, CHAIN_HEAD_SETTING);
    ps.setNull(2, Types.BINARY);
    ps.execute();
    ps.setString(1, VERIFIED_CHAIN_HEAD_SETTING);
    ps.setNull(2, Types.BINARY);
    ps.execute();
    ps.setString(1, VERSION_SETTING);
    ps.setBytes(2, "03".getBytes());
    ps.execute();
    ps.close();
    createNewStore(params);
}

######


private void createNewStore(NetworkParameters params) throws BlockStoreException {
    try {
        StoredBlock storedGenesisHeader = new StoredBlock(params.getGenesisBlock().cloneAsHeader(), params.getGenesisBlock().getWork(), 0);
        List<Transaction> genesisTransactions = Lists.newLinkedList();
        StoredUndoableBlock storedGenesis = new StoredUndoableBlock(params.getGenesisBlock().getHash(), genesisTransactions);
        put(storedGenesisHeader, storedGenesis);
        setChainHead(storedGenesisHeader);
        setVerifiedChainHead(storedGenesisHeader);
    } catch (VerificationException e) {
        throw new RuntimeException(e);
    }
}

######


private void initFromDatabase() throws SQLException, BlockStoreException {
    PreparedStatement ps = conn.get().prepareStatement(getSelectSettingsSQL());
    ResultSet rs;
    ps.setString(1, CHAIN_HEAD_SETTING);
    rs = ps.executeQuery();
    if (!rs.next()) {
        throw new BlockStoreException("corrupt database block store - no chain head pointer");
    }
    Sha256Hash hash = Sha256Hash.wrap(rs.getBytes(1));
    rs.close();
    this.chainHeadBlock = get(hash);
    this.chainHeadHash = hash;
    if (this.chainHeadBlock == null) {
        throw new BlockStoreException("corrupt database block store - head block not found");
    }
    ps.setString(1, VERIFIED_CHAIN_HEAD_SETTING);
    rs = ps.executeQuery();
    if (!rs.next()) {
        throw new BlockStoreException("corrupt database block store - no verified chain head pointer");
    }
    hash = Sha256Hash.wrap(rs.getBytes(1));
    rs.close();
    ps.close();
    this.verifiedChainHeadBlock = get(hash);
    this.verifiedChainHeadHash = hash;
    if (this.verifiedChainHeadBlock == null) {
        throw new BlockStoreException("corrupt databse block store - verified head block not found");
    }
}

######


protected void putUpdateStoredBlock(StoredBlock storedBlock, boolean wasUndoable) throws SQLException {
    try {
        PreparedStatement s = conn.get().prepareStatement(getInsertHeadersSQL());
        byte[] hashBytes = new byte[28];
        System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28);
        s.setBytes(1, hashBytes);
        s.setBytes(2, storedBlock.getChainWork().toByteArray());
        s.setInt(3, storedBlock.getHeight());
        s.setBytes(4, storedBlock.getHeader().cloneAsHeader().unsafeBitcoinSerialize());
        s.setBoolean(5, wasUndoable);
        s.executeUpdate();
        s.close();
    } catch (SQLException e) {
        if (!(e.getSQLState().equals(getDuplicateKeyErrorCode())) || !wasUndoable)
            throw e;
        PreparedStatement s = conn.get().prepareStatement(getUpdateHeadersSQL());
        s.setBoolean(1, true);
        byte[] hashBytes = new byte[28];
        System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28);
        s.setBytes(2, hashBytes);
        s.executeUpdate();
        s.close();
    }
}

######


@Override
public void put(StoredBlock storedBlock) throws BlockStoreException {
    maybeConnect();
    try {
        putUpdateStoredBlock(storedBlock, false);
    } catch (SQLException e) {
        throw new BlockStoreException(e);
    }
}

######


@Override
public void put(StoredBlock storedBlock, StoredUndoableBlock undoableBlock) throws BlockStoreException {
    maybeConnect();
    byte[] hashBytes = new byte[28];
    System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28);
    int height = storedBlock.getHeight();
    byte[] transactions = null;
    byte[] txOutChanges = null;
    try {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        if (undoableBlock.getTxOutChanges() != null) {
            undoableBlock.getTxOutChanges().serializeToStream(bos);
            txOutChanges = bos.toByteArray();
        } else {
            int numTxn = undoableBlock.getTransactions().size();
            bos.write(0xFF & numTxn);
            bos.write(0xFF & (numTxn >> 8));
            bos.write(0xFF & (numTxn >> 16));
            bos.write(0xFF & (numTxn >> 24));
            for (Transaction tx : undoableBlock.getTransactions()) tx.bitcoinSerialize(bos);
            transactions = bos.toByteArray();
        }
        bos.close();
    } catch (IOException e) {
        throw new BlockStoreException(e);
    }
    try {
        try {
            PreparedStatement s = conn.get().prepareStatement(getInsertUndoableBlocksSQL());
            s.setBytes(1, hashBytes);
            s.setInt(2, height);
            if (transactions == null) {
                s.setBytes(3, txOutChanges);
                s.setNull(4, Types.BINARY);
            } else {
                s.setNull(3, Types.BINARY);
                s.setBytes(4, transactions);
            }
            s.executeUpdate();
            s.close();
            try {
                putUpdateStoredBlock(storedBlock, true);
            } catch (SQLException e) {
                throw new BlockStoreException(e);
            }
        } catch (SQLException e) {
            if (!e.getSQLState().equals(getDuplicateKeyErrorCode()))
                throw new BlockStoreException(e);
            PreparedStatement s = conn.get().prepareStatement(getUpdateUndoableBlocksSQL());
            s.setBytes(3, hashBytes);
            if (transactions == null) {
                s.setBytes(1, txOutChanges);
                s.setNull(2, Types.BINARY);
            } else {
                s.setNull(1, Types.BINARY);
                s.setBytes(2, transactions);
            }
            s.executeUpdate();
            s.close();
        }
    } catch (SQLException ex) {
        throw new BlockStoreException(ex);
    }
}

######


public StoredBlock get(Sha256Hash hash, boolean wasUndoableOnly) throws BlockStoreException {
    if (chainHeadHash != null && chainHeadHash.equals(hash))
        return chainHeadBlock;
    if (verifiedChainHeadHash != null && verifiedChainHeadHash.equals(hash))
        return verifiedChainHeadBlock;
    maybeConnect();
    PreparedStatement s = null;
    try {
        s = conn.get().prepareStatement(getSelectHeadersSQL());
        byte[] hashBytes = new byte[28];
        System.arraycopy(hash.getBytes(), 4, hashBytes, 0, 28);
        s.setBytes(1, hashBytes);
        ResultSet results = s.executeQuery();
        if (!results.next()) {
            return null;
        }
        if (wasUndoableOnly && !results.getBoolean(4))
            return null;
        BigInteger chainWork = new BigInteger(results.getBytes(1));
        int height = results.getInt(2);
        Block b = params.getDefaultSerializer().makeBlock(results.getBytes(3));
        b.verifyHeader();
        StoredBlock stored = new StoredBlock(b, chainWork, height);
        return stored;
    } catch (SQLException ex) {
        throw new BlockStoreException(ex);
    } catch (ProtocolException e) {
        throw new BlockStoreException(e);
    } catch (VerificationException e) {
        throw new BlockStoreException(e);
    } finally {
        if (s != null) {
            try {
                s.close();
            } catch (SQLException e) {
                throw new BlockStoreException("Failed to close PreparedStatement");
            }
        }
    }
}

######


@Override
public StoredBlock get(Sha256Hash hash) throws BlockStoreException {
    return get(hash, false);
}

######


@Override
public StoredBlock getOnceUndoableStoredBlock(Sha256Hash hash) throws BlockStoreException {
    return get(hash, true);
}

######


@Override
public StoredUndoableBlock getUndoBlock(Sha256Hash hash) throws BlockStoreException {
    maybeConnect();
    PreparedStatement s = null;
    try {
        s = conn.get().prepareStatement(getSelectUndoableBlocksSQL());
        byte[] hashBytes = new byte[28];
        System.arraycopy(hash.getBytes(), 4, hashBytes, 0, 28);
        s.setBytes(1, hashBytes);
        ResultSet results = s.executeQuery();
        if (!results.next()) {
            return null;
        }
        byte[] txOutChanges = results.getBytes(1);
        byte[] transactions = results.getBytes(2);
        StoredUndoableBlock block;
        if (txOutChanges == null) {
            int offset = 0;
            int numTxn = ((transactions[offset++] & 0xFF)) | ((transactions[offset++] & 0xFF) << 8) | ((transactions[offset++] & 0xFF) << 16) | ((transactions[offset++] & 0xFF) << 24);
            List<Transaction> transactionList = new LinkedList<Transaction>();
            for (int i = 0; i < numTxn; i++) {
                Transaction tx = params.getDefaultSerializer().makeTransaction(transactions, offset);
                transactionList.add(tx);
                offset += tx.getMessageSize();
            }
            block = new StoredUndoableBlock(hash, transactionList);
        } else {
            TransactionOutputChanges outChangesObject = new TransactionOutputChanges(new ByteArrayInputStream(txOutChanges));
            block = new StoredUndoableBlock(hash, outChangesObject);
        }
        return block;
    } catch (SQLException ex) {
        throw new BlockStoreException(ex);
    } catch (NullPointerException e) {
        throw new BlockStoreException(e);
    } catch (ClassCastException e) {
        throw new BlockStoreException(e);
    } catch (ProtocolException e) {
        throw new BlockStoreException(e);
    } catch (IOException e) {
        throw new BlockStoreException(e);
    } finally {
        if (s != null) {
            try {
                s.close();
            } catch (SQLException e) {
                throw new BlockStoreException("Failed to close PreparedStatement");
            }
        }
    }
}

######


@Override
public StoredBlock getChainHead() throws BlockStoreException {
    return chainHeadBlock;
}

######


@Override
public void setChainHead(StoredBlock chainHead) throws BlockStoreException {
    Sha256Hash hash = chainHead.getHeader().getHash();
    this.chainHeadHash = hash;
    this.chainHeadBlock = chainHead;
    maybeConnect();
    try {
        PreparedStatement s = conn.get().prepareStatement(getUpdateSettingsSLQ());
        s.setString(2, CHAIN_HEAD_SETTING);
        s.setBytes(1, hash.getBytes());
        s.executeUpdate();
        s.close();
    } catch (SQLException ex) {
        throw new BlockStoreException(ex);
    }
}

######


@Override
public StoredBlock getVerifiedChainHead() throws BlockStoreException {
    return verifiedChainHeadBlock;
}

######


@Override
public void setVerifiedChainHead(StoredBlock chainHead) throws BlockStoreException {
    Sha256Hash hash = chainHead.getHeader().getHash();
    this.verifiedChainHeadHash = hash;
    this.verifiedChainHeadBlock = chainHead;
    maybeConnect();
    try {
        PreparedStatement s = conn.get().prepareStatement(getUpdateSettingsSLQ());
        s.setString(2, VERIFIED_CHAIN_HEAD_SETTING);
        s.setBytes(1, hash.getBytes());
        s.executeUpdate();
        s.close();
    } catch (SQLException ex) {
        throw new BlockStoreException(ex);
    }
    if (this.chainHeadBlock.getHeight() < chainHead.getHeight())
        setChainHead(chainHead);
    removeUndoableBlocksWhereHeightIsLessThan(chainHead.getHeight() - fullStoreDepth);
}

######


private void removeUndoableBlocksWhereHeightIsLessThan(int height) throws BlockStoreException {
    try {
        PreparedStatement s = conn.get().prepareStatement(getDeleteUndoableBlocksSQL());
        s.setInt(1, height);
        if (log.isDebugEnabled())
            log.debug("Deleting undoable undoable block with height <= " + height);
        s.executeUpdate();
        s.close();
    } catch (SQLException ex) {
        throw new BlockStoreException(ex);
    }
}

######


@Override
public UTXO getTransactionOutput(Sha256Hash hash, long index) throws BlockStoreException {
    maybeConnect();
    PreparedStatement s = null;
    try {
        s = conn.get().prepareStatement(getSelectOpenoutputsSQL());
        s.setBytes(1, hash.getBytes());
        s.setInt(2, (int) index);
        ResultSet results = s.executeQuery();
        if (!results.next()) {
            return null;
        }
        int height = results.getInt(1);
        Coin value = Coin.valueOf(results.getLong(2));
        byte[] scriptBytes = results.getBytes(3);
        boolean coinbase = results.getBoolean(4);
        String address = results.getString(5);
        UTXO txout = new UTXO(hash, index, value, height, coinbase, new Script(scriptBytes), address);
        return txout;
    } catch (SQLException ex) {
        throw new BlockStoreException(ex);
    } finally {
        if (s != null) {
            try {
                s.close();
            } catch (SQLException e) {
                throw new BlockStoreException("Failed to close PreparedStatement");
            }
        }
    }
}

######


@Override
public void addUnspentTransactionOutput(UTXO out) throws BlockStoreException {
    maybeConnect();
    PreparedStatement s = null;
    try {
        s = conn.get().prepareStatement(getInsertOpenoutputsSQL());
        s.setBytes(1, out.getHash().getBytes());
        s.setInt(2, (int) out.getIndex());
        s.setInt(3, out.getHeight());
        s.setLong(4, out.getValue().value);
        s.setBytes(5, out.getScript().getProgram());
        s.setString(6, out.getAddress());
        s.setInt(7, out.getScript().getScriptType().ordinal());
        s.setBoolean(8, out.isCoinbase());
        s.executeUpdate();
        s.close();
    } catch (SQLException e) {
        if (!(e.getSQLState().equals(getDuplicateKeyErrorCode())))
            throw new BlockStoreException(e);
    } finally {
        if (s != null) {
            try {
                s.close();
            } catch (SQLException e) {
                throw new BlockStoreException(e);
            }
        }
    }
}

######


@Override
public void removeUnspentTransactionOutput(UTXO out) throws BlockStoreException {
    maybeConnect();
    if (getTransactionOutput(out.getHash(), out.getIndex()) == null)
        throw new BlockStoreException("Tried to remove a UTXO from DatabaseFullPrunedBlockStore that it didn't have!");
    try {
        PreparedStatement s = conn.get().prepareStatement(getDeleteOpenoutputsSQL());
        s.setBytes(1, out.getHash().getBytes());
        s.setInt(2, (int) out.getIndex());
        s.executeUpdate();
        s.close();
    } catch (SQLException e) {
        throw new BlockStoreException(e);
    }
}

######


@Override
public void beginDatabaseBatchWrite() throws BlockStoreException {
    maybeConnect();
    if (log.isDebugEnabled())
        log.debug("Starting database batch write with connection: " + conn.get().toString());
    try {
        conn.get().setAutoCommit(false);
    } catch (SQLException e) {
        throw new BlockStoreException(e);
    }
}

######


@Override
public void commitDatabaseBatchWrite() throws BlockStoreException {
    maybeConnect();
    if (log.isDebugEnabled())
        log.debug("Committing database batch write with connection: " + conn.get().toString());
    try {
        conn.get().commit();
        conn.get().setAutoCommit(true);
    } catch (SQLException e) {
        throw new BlockStoreException(e);
    }
}

######


@Override
public void abortDatabaseBatchWrite() throws BlockStoreException {
    maybeConnect();
    if (log.isDebugEnabled())
        log.debug("Rollback database batch write with connection: " + conn.get().toString());
    try {
        if (!conn.get().getAutoCommit()) {
            conn.get().rollback();
            conn.get().setAutoCommit(true);
        } else {
            log.warn("Warning: Rollback attempt without transaction");
        }
    } catch (SQLException e) {
        throw new BlockStoreException(e);
    }
}

######


@Override
public boolean hasUnspentOutputs(Sha256Hash hash, int numOutputs) throws BlockStoreException {
    maybeConnect();
    PreparedStatement s = null;
    try {
        s = conn.get().prepareStatement(getSelectOpenoutputsCountSQL());
        s.setBytes(1, hash.getBytes());
        ResultSet results = s.executeQuery();
        if (!results.next()) {
            throw new BlockStoreException("Got no results from a COUNT(*) query");
        }
        int count = results.getInt(1);
        return count != 0;
    } catch (SQLException ex) {
        throw new BlockStoreException(ex);
    } finally {
        if (s != null) {
            try {
                s.close();
            } catch (SQLException e) {
                throw new BlockStoreException("Failed to close PreparedStatement");
            }
        }
    }
}

######


@Override
public NetworkParameters getParams() {
    return params;
}

######


@Override
public int getChainHeadHeight() throws UTXOProviderException {
    try {
        return getVerifiedChainHead().getHeight();
    } catch (BlockStoreException e) {
        throw new UTXOProviderException(e);
    }
}

######


public void resetStore() throws BlockStoreException {
    maybeConnect();
    try {
        deleteStore();
        createTables();
        initFromDatabase();
    } catch (SQLException ex) {
        throw new RuntimeException(ex);
    }
}

######


public void deleteStore() throws BlockStoreException {
    maybeConnect();
    try {
        Statement s = conn.get().createStatement();
        for (String sql : getDropTablesSQL()) {
            s.execute(sql);
        }
        s.close();
    } catch (SQLException ex) {
        throw new RuntimeException(ex);
    }
}

######


public BigInteger calculateBalanceForAddress(Address address) throws BlockStoreException {
    maybeConnect();
    PreparedStatement s = null;
    try {
        s = conn.get().prepareStatement(getBalanceSelectSQL());
        s.setString(1, address.toString());
        ResultSet rs = s.executeQuery();
        BigInteger balance = BigInteger.ZERO;
        if (rs.next()) {
            return BigInteger.valueOf(rs.getLong(1));
        }
        return balance;
    } catch (SQLException ex) {
        throw new BlockStoreException(ex);
    } finally {
        if (s != null) {
            try {
                s.close();
            } catch (SQLException e) {
                throw new BlockStoreException("Could not close statement");
            }
        }
    }
}

######


@Override
public List<UTXO> getOpenTransactionOutputs(List<Address> addresses) throws UTXOProviderException {
    PreparedStatement s = null;
    List<UTXO> outputs = new ArrayList<UTXO>();
    try {
        maybeConnect();
        s = conn.get().prepareStatement(getTrasactionOutputSelectSQL());
        for (Address address : addresses) {
            s.setString(1, address.toString());
            ResultSet rs = s.executeQuery();
            while (rs.next()) {
                Sha256Hash hash = Sha256Hash.wrap(rs.getBytes(1));
                Coin amount = Coin.valueOf(rs.getLong(2));
                byte[] scriptBytes = rs.getBytes(3);
                int height = rs.getInt(4);
                int index = rs.getInt(5);
                boolean coinbase = rs.getBoolean(6);
                String toAddress = rs.getString(7);
                UTXO output = new UTXO(hash, index, amount, height, coinbase, new Script(scriptBytes), toAddress);
                outputs.add(output);
            }
        }
        return outputs;
    } catch (SQLException ex) {
        throw new UTXOProviderException(ex);
    } catch (BlockStoreException bse) {
        throw new UTXOProviderException(bse);
    } finally {
        if (s != null)
            try {
                s.close();
            } catch (SQLException e) {
                throw new UTXOProviderException("Could not close statement", e);
            }
    }
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL("DROP TABLE IF EXISTS " + TABLE_CONTACTS);
    db.execSQL("DROP TABLE IF EXISTS " + TABLE_CALL_LOGS);
    String CREATE_CONTACTS_TABLE = "CREATE TABLE " + TABLE_CONTACTS + "(" + KEY_ID + " INTEGER PRIMARY KEY, " + KEY_NAME + " TEXT NOT NULL, " + KEY_PH_NO + " TEXT NOT NULL, " + KEY_IMG_STR + " TEXT, " + KEY_TYPE + " TEXT)";
    db.execSQL(CREATE_CONTACTS_TABLE);
    String CREATE_CALL_LOGS_TABLE = "CREATE TABLE " + TABLE_CALL_LOGS + "(" + KEY_ID + " INTEGER PRIMARY KEY, " + KEY_CALL_NUM + " TEXT NOT NULL, " + KEY_CALL_TYPE + " TEXT NOT NULL, " + KEY_DURATION + " TEXT NOT NULL, " + KEY_DATE_TIME + " TEXT NOT NULL)";
    db.execSQL(CREATE_CALL_LOGS_TABLE);
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    db.execSQL("DROP TABLE IF EXISTS " + TABLE_CONTACTS);
    db.execSQL("DROP TABLE IF EXISTS " + TABLE_CALL_LOGS);
    onCreate(db);
}

######


void addContact(CContacts contact) {
    if (!checkExistenceOfContact(contact.getNumber())) {
        SQLiteDatabase db = this.getWritableDatabase();
        ContentValues values = new ContentValues();
        values.put(KEY_NAME, contact.getName());
        values.put(KEY_PH_NO, contact.getNumber());
        values.put(KEY_IMG_STR, contact.getImageString());
        values.put(KEY_TYPE, contact.getType());
        db.insert(TABLE_CONTACTS, null, values);
        db.close();
    } else {
        updateContact(contact);
    }
}

######


private boolean checkExistenceOfContact(String phNumber) {
    boolean bExists = false;
    int t_count = 0;
    String query = "SELECT COUNT(*) as T_COUNT FROM " + TABLE_CONTACTS + " WHERE " + KEY_PH_NO + " = '" + phNumber + "'";
    SQLiteDatabase db = this.getWritableDatabase();
    Cursor cursor = db.rawQuery(query, null);
    if (cursor.moveToFirst()) {
        do {
            t_count = cursor.getInt(0);
        } while (cursor.moveToNext());
    }
    cursor.close();
    db.close();
    if (t_count > 0)
        bExists = true;
    return bExists;
}

######


private boolean checkExistenceOfCallLogs(CCallLogs callLog) {
    boolean bExists = false;
    int t_count = 0;
    String query = "SELECT COUNT(*) as T_COUNT FROM " + TABLE_CALL_LOGS + " WHERE " + KEY_CALL_NUM + " = '" + callLog.getNumber() + "'" + " AND " + KEY_CALL_TYPE + " = '" + callLog.getType() + "' AND " + KEY_DURATION + " = '" + String.valueOf(callLog.getDuration()) + "'" + " AND " + KEY_DATE_TIME + " = '" + String.valueOf(callLog.getDate()) + "'";
    SQLiteDatabase db = this.getWritableDatabase();
    Cursor cursor = db.rawQuery(query, null);
    if (cursor.moveToFirst()) {
        do {
            t_count = cursor.getInt(0);
        } while (cursor.moveToNext());
    }
    cursor.close();
    db.close();
    if (t_count > 0)
        bExists = true;
    return bExists;
}

######


void addCallLog(CCallLogs callLogs) {
    if (!checkExistenceOfCallLogs(callLogs)) {
        SQLiteDatabase db = this.getWritableDatabase();
        ContentValues values = new ContentValues();
        values.put(KEY_CALL_NUM, callLogs.getNumber());
        values.put(KEY_CALL_TYPE, String.valueOf(callLogs.getType()));
        values.put(KEY_DURATION, String.valueOf(callLogs.getDuration()));
        values.put(KEY_DATE_TIME, String.valueOf(callLogs.getDate()));
        db.insert(TABLE_CALL_LOGS, null, values);
        db.close();
    }
}

######


CContacts getContact(String phNumber) {
    CContacts contacts = null;
    String selectQuery = "SELECT  * FROM " + TABLE_CONTACTS + " WHERE phone_str = '" + phNumber + "'";
    SQLiteDatabase db = this.getWritableDatabase();
    Cursor cursor = db.rawQuery(selectQuery, null);
    if (cursor.moveToFirst()) {
        do {
            contacts = new CContacts();
            contacts.setName(cursor.getString(1));
            contacts.setNumber(cursor.getString(2));
            contacts.setImageString(cursor.getString(3));
            contacts.setType(cursor.getString(4));
        } while (cursor.moveToNext());
    }
    cursor.close();
    db.close();
    return contacts;
}

######


public ArrayList<CContacts> getAllContacts() {
    ArrayList<CContacts> contactList = new ArrayList<CContacts>();
    String selectQuery = "SELECT  * FROM " + TABLE_CONTACTS;
    SQLiteDatabase db = this.getWritableDatabase();
    Cursor cursor = db.rawQuery(selectQuery, null);
    if (cursor.moveToFirst()) {
        do {
            CContacts contact = new CContacts();
            contact.setName(cursor.getString(1));
            contact.setNumber(cursor.getString(2));
            contact.setImageString(cursor.getString(3));
            contact.setType(cursor.getString(4));
            contactList.add(contact);
        } while (cursor.moveToNext());
    }
    cursor.close();
    db.close();
    return contactList;
}

######


public ArrayList<CCallLogs> getAllCallLogs() {
    ArrayList<CCallLogs> callLogsList = new ArrayList<CCallLogs>();
    String selectQuery = "SELECT  * FROM " + TABLE_CALL_LOGS;
    SQLiteDatabase db = this.getWritableDatabase();
    Cursor cursor = db.rawQuery(selectQuery, null);
    if (cursor.moveToFirst()) {
        do {
            CCallLogs callLog = new CCallLogs();
            callLog.setNumber(cursor.getString(1));
            callLog.setType(Integer.parseInt(cursor.getString(2)));
            callLog.setDuration(Integer.parseInt(cursor.getString(3)));
            callLog.setDate(Long.parseLong(cursor.getString(4)));
            callLogsList.add(callLog);
        } while (cursor.moveToNext());
    }
    cursor.close();
    db.close();
    return callLogsList;
}

######


public void updateContact(CContacts contact) {
    SQLiteDatabase db = this.getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put(KEY_NAME, contact.getName());
    values.put(KEY_TYPE, contact.getType());
    values.put(KEY_IMG_STR, contact.getImageString());
    int rowsAffected = db.update(TABLE_CONTACTS, values, KEY_PH_NO + " = ?", new String[] { String.valueOf(contact.getNumber()) });
    System.out.println(rowsAffected);
    db.close();
}

######


public void deleteContact(CContacts contact) {
    SQLiteDatabase db = this.getWritableDatabase();
    int rows = db.delete(TABLE_CONTACTS, KEY_PH_NO + " = ?", new String[] { String.valueOf(contact.getNumber()) });
    db.close();
}

######


public void deleteCallLog(CCallLogs callLogs) {
    SQLiteDatabase db = this.getWritableDatabase();
    int rows = db.delete(TABLE_CALL_LOGS, KEY_CALL_NUM + " = ? AND " + KEY_CALL_TYPE + " = ? AND " + KEY_DATE_TIME + " = ? AND " + KEY_DURATION + " = ?", new String[] { callLogs.getNumber(), String.valueOf(callLogs.getType()), String.valueOf(callLogs.getDate()), String.valueOf(callLogs.getDuration()) });
    db.close();
}

######


public int getContactsCount() {
    String countQuery = "SELECT  * FROM " + TABLE_CONTACTS;
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor cursor = db.rawQuery(countQuery, null);
    int count = cursor.getCount();
    cursor.close();
    db.close();
    return count;
}

######


public int getCallLogsCount() {
    String countQuery = "SELECT  * FROM " + TABLE_CALL_LOGS;
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor cursor = db.rawQuery(countQuery, null);
    int count = cursor.getCount();
    cursor.close();
    db.close();
    return count;
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL("DROP TABLE IF EXISTS " + TABLE_CONTACTS);
    db.execSQL("DROP TABLE IF EXISTS " + TABLE_CALL_LOGS);
    String CREATE_CONTACTS_TABLE = "CREATE TABLE " + TABLE_CONTACTS + "(" + KEY_ID + " INTEGER PRIMARY KEY, " + KEY_NAME + " TEXT NOT NULL, " + KEY_PH_NO + " TEXT NOT NULL, " + KEY_IMG_STR + " TEXT, " + KEY_TYPE + " TEXT)";
    db.execSQL(CREATE_CONTACTS_TABLE);
    String CREATE_CALL_LOGS_TABLE = "CREATE TABLE " + TABLE_CALL_LOGS + "(" + KEY_ID + " INTEGER PRIMARY KEY, " + KEY_CALL_NUM + " TEXT NOT NULL, " + KEY_CALL_TYPE + " TEXT NOT NULL, " + KEY_DURATION + " TEXT NOT NULL, " + KEY_DATE_TIME + " TEXT NOT NULL)";
    db.execSQL(CREATE_CALL_LOGS_TABLE);
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    db.execSQL("DROP TABLE IF EXISTS " + TABLE_CONTACTS);
    db.execSQL("DROP TABLE IF EXISTS " + TABLE_CALL_LOGS);
    onCreate(db);
}

######


void addContact(CContacts contact) {
    if (!checkExistenceOfContact(contact.getNumber())) {
        SQLiteDatabase db = this.getWritableDatabase();
        ContentValues values = new ContentValues();
        values.put(KEY_NAME, contact.getName());
        values.put(KEY_PH_NO, contact.getNumber());
        values.put(KEY_IMG_STR, contact.getImageString());
        values.put(KEY_TYPE, contact.getType());
        db.insert(TABLE_CONTACTS, null, values);
        db.close();
    } else {
        updateContact(contact);
    }
}

######


private boolean checkExistenceOfContact(String phNumber) {
    boolean bExists = false;
    int t_count = 0;
    String query = "SELECT COUNT(*) as T_COUNT FROM " + TABLE_CONTACTS + " WHERE " + KEY_PH_NO + " = '" + phNumber + "'";
    SQLiteDatabase db = this.getWritableDatabase();
    Cursor cursor = db.rawQuery(query, null);
    if (cursor.moveToFirst()) {
        do {
            t_count = cursor.getInt(0);
        } while (cursor.moveToNext());
    }
    cursor.close();
    db.close();
    if (t_count > 0)
        bExists = true;
    return bExists;
}

######


private boolean checkExistenceOfCallLogs(CCallLogs callLog) {
    boolean bExists = false;
    int t_count = 0;
    String query = "SELECT COUNT(*) as T_COUNT FROM " + TABLE_CALL_LOGS + " WHERE " + KEY_CALL_NUM + " = '" + callLog.getNumber() + "'" + " AND " + KEY_CALL_TYPE + " = '" + callLog.getType() + "' AND " + KEY_DURATION + " = '" + String.valueOf(callLog.getDuration()) + "'" + " AND " + KEY_DATE_TIME + " = '" + String.valueOf(callLog.getDate()) + "'";
    SQLiteDatabase db = this.getWritableDatabase();
    Cursor cursor = db.rawQuery(query, null);
    if (cursor.moveToFirst()) {
        do {
            t_count = cursor.getInt(0);
        } while (cursor.moveToNext());
    }
    cursor.close();
    db.close();
    if (t_count > 0)
        bExists = true;
    return bExists;
}

######


void addCallLog(CCallLogs callLogs) {
    if (!checkExistenceOfCallLogs(callLogs)) {
        SQLiteDatabase db = this.getWritableDatabase();
        ContentValues values = new ContentValues();
        values.put(KEY_CALL_NUM, callLogs.getNumber());
        values.put(KEY_CALL_TYPE, String.valueOf(callLogs.getType()));
        values.put(KEY_DURATION, String.valueOf(callLogs.getDuration()));
        values.put(KEY_DATE_TIME, String.valueOf(callLogs.getDate()));
        db.insert(TABLE_CALL_LOGS, null, values);
        db.close();
    }
}

######


CContacts getContact(String phNumber) {
    CContacts contacts = null;
    String selectQuery = "SELECT  * FROM " + TABLE_CONTACTS + " WHERE phone_str = '" + phNumber + "'";
    SQLiteDatabase db = this.getWritableDatabase();
    Cursor cursor = db.rawQuery(selectQuery, null);
    if (cursor.moveToFirst()) {
        do {
            contacts = new CContacts();
            contacts.setName(cursor.getString(1));
            contacts.setNumber(cursor.getString(2));
            contacts.setImageString(cursor.getString(3));
            contacts.setType(cursor.getString(4));
        } while (cursor.moveToNext());
    }
    cursor.close();
    db.close();
    return contacts;
}

######


public ArrayList<CContacts> getAllContacts() {
    ArrayList<CContacts> contactList = new ArrayList<CContacts>();
    String selectQuery = "SELECT  * FROM " + TABLE_CONTACTS;
    SQLiteDatabase db = this.getWritableDatabase();
    Cursor cursor = db.rawQuery(selectQuery, null);
    if (cursor.moveToFirst()) {
        do {
            CContacts contact = new CContacts();
            contact.setName(cursor.getString(1));
            contact.setNumber(cursor.getString(2));
            contact.setImageString(cursor.getString(3));
            contact.setType(cursor.getString(4));
            contactList.add(contact);
        } while (cursor.moveToNext());
    }
    cursor.close();
    db.close();
    return contactList;
}

######


public ArrayList<CCallLogs> getAllCallLogs() {
    ArrayList<CCallLogs> callLogsList = new ArrayList<CCallLogs>();
    String selectQuery = "SELECT  * FROM " + TABLE_CALL_LOGS;
    SQLiteDatabase db = this.getWritableDatabase();
    Cursor cursor = db.rawQuery(selectQuery, null);
    if (cursor.moveToFirst()) {
        do {
            CCallLogs callLog = new CCallLogs();
            callLog.setNumber(cursor.getString(1));
            callLog.setType(Integer.parseInt(cursor.getString(2)));
            callLog.setDuration(Integer.parseInt(cursor.getString(3)));
            callLog.setDate(Long.parseLong(cursor.getString(4)));
            callLogsList.add(callLog);
        } while (cursor.moveToNext());
    }
    cursor.close();
    db.close();
    return callLogsList;
}

######


public void updateContact(CContacts contact) {
    SQLiteDatabase db = this.getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put(KEY_NAME, contact.getName());
    values.put(KEY_TYPE, contact.getType());
    values.put(KEY_IMG_STR, contact.getImageString());
    int rowsAffected = db.update(TABLE_CONTACTS, values, KEY_PH_NO + " = ?", new String[] { String.valueOf(contact.getNumber()) });
    System.out.println(rowsAffected);
    db.close();
}

######


public void deleteContact(CContacts contact) {
    SQLiteDatabase db = this.getWritableDatabase();
    int rows = db.delete(TABLE_CONTACTS, KEY_PH_NO + " = ?", new String[] { String.valueOf(contact.getNumber()) });
    db.close();
}

######


public void deleteCallLog(CCallLogs callLogs) {
    SQLiteDatabase db = this.getWritableDatabase();
    int rows = db.delete(TABLE_CALL_LOGS, KEY_CALL_NUM + " = ? AND " + KEY_CALL_TYPE + " = ? AND " + KEY_DATE_TIME + " = ? AND " + KEY_DURATION + " = ?", new String[] { callLogs.getNumber(), String.valueOf(callLogs.getType()), String.valueOf(callLogs.getDate()), String.valueOf(callLogs.getDuration()) });
    db.close();
}

######


public int getContactsCount() {
    String countQuery = "SELECT  * FROM " + TABLE_CONTACTS;
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor cursor = db.rawQuery(countQuery, null);
    int count = cursor.getCount();
    cursor.close();
    db.close();
    return count;
}

######


public int getCallLogsCount() {
    String countQuery = "SELECT  * FROM " + TABLE_CALL_LOGS;
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor cursor = db.rawQuery(countQuery, null);
    int count = cursor.getCount();
    cursor.close();
    db.close();
    return count;
}

######


public static void initDataBase() {
    if (allTablesExists() == false)
        resetDataBase();
    else {
        extractStudentData();
        extractLayersData();
    }
}

######


public static void closeDataBase() {
    updateDataBase();
}

######


public static void updateDataBase() {
    updateStudent();
    updateLayers();
}

######


public static void resetDataBase() {
    resetStudentTable();
    resetLayerTables();
}

######


public static void updateStudent() {
    int idStudent;
    Cursor resultSetUpdate;
    String updateCommand;
    resultSetUpdate = db.rawQuery("SELECT * FROM " + STUDENT_TABLE + ";", null);
    while (resultSetUpdate.moveToNext()) {
        idStudent = resultSetUpdate.getInt(0);
        updateCommand = "UPDATE " + STUDENT_TABLE + " SET";
        updateCommand += " Absente_Total = " + studentDataMatrix[idStudent][Layer.ABSENTE_TOTAL];
        updateCommand += " , Prezente_Total = " + studentDataMatrix[idStudent][Layer.PREZENTE_TOTAL];
        updateCommand += " , Absente_Curs = " + studentDataMatrix[idStudent][Layer.ABSENTE_CURS];
        updateCommand += " , Prezente_Curs = " + studentDataMatrix[idStudent][Layer.PREZENTE_CURS];
        updateCommand += " , Absente_Seminar = " + studentDataMatrix[idStudent][Layer.ABSENTE_SEMINAR];
        updateCommand += " , Prezente_Seminar = " + studentDataMatrix[idStudent][Layer.PREZENTE_SEMINAR];
        updateCommand += " , Prezente_Laborator = " + studentDataMatrix[idStudent][Layer.PREZENTE_LAB];
        updateCommand += " , Absente_Laborator = " + studentDataMatrix[idStudent][Layer.ABSENTE_LAB];
        if (studentDataMatrix[idStudent][Layer.BAIAT] == 1)
            updateCommand += Layer.BAIAT;
        else
            updateCommand += Layer.FATA;
        updateCommand += " WHERE id = " + idStudent;
        db.execSQL(updateCommand);
    }
}

######


public static void createStudentTable() {
    db.execSQL("CREATE TABLE IF NOT EXISTS " + STUDENT_TABLE + "\n" + "(\n" + "  ID INT(11) PRIMARY KEY NOT NULL,\n" + "  Nume VARCHAR(20) NOT NULL,\n" + "  Prenume VARCHAR(20) NOT NULL,\n" + "  Media FLOAT NOT NULL,\n" + "  Lucru INT(2) DEFAULT '0' NOT NULL,\n" + "  Locul INT(11) NOT NULL,\n" + "  Partener INT(11) NOT NULL,\n" + "  Absente_Total INT(11) NOT NULL,\n" + "  Prezente_Total INT(11) NOT NULL,\n" + "  Absente_Curs INT(11) NOT NULL,\n" + "  Prezente_Curs INT(11) NOT NULL,\n" + "  Absente_Seminar INT(11) NOT NULL,\n" + "  Prezente_Seminar INT(11) NOT NULL,\n" + "  Absente_Laborator INT(11) NOT NULL,\n" + "  Prezente_Laborator INT(11) NOT NULL,\n" + "  Gen INT(11) NOT NULL\n" + ");");
}

######


public static void resetStudentTable() {
    deleteTable(STUDENT_TABLE);
    createStudentTable();
    studentsCount = 22;
    insertStudentData(defaultStudentDataMatrix, defaultStudentNameData);
    extractStudentData();
}

######


public static void insertStudentData(float[][] studentData, String[][] studentName) {
    int i;
    String updateCommand;
    for (i = 0; i < studentsCount; i++) {
        updateCommand = "INSERT INTO " + STUDENT_TABLE + " VALUES (" + i;
        updateCommand += ", '" + studentName[i][0] + "'";
        updateCommand += ", '" + studentName[i][1] + "'";
        updateCommand += ", " + studentData[i][Layer.MEDIA];
        updateCommand += ", " + studentData[i][Layer.LUCRU];
        updateCommand += ", ";
        if (studentData[i][Layer.CAMIN] == 1)
            updateCommand += Layer.CAMIN;
        else if (studentData[i][Layer.ORAS] == 1)
            updateCommand += Layer.ORAS;
        else
            updateCommand += Layer.OUT_ORAS;
        updateCommand += ", " + studentData[i][Layer.PARTENER];
        updateCommand += ", " + studentData[i][Layer.ABSENTE_TOTAL];
        updateCommand += ", " + studentData[i][Layer.PREZENTE_TOTAL];
        updateCommand += ", " + studentData[i][Layer.ABSENTE_CURS];
        updateCommand += ", " + studentData[i][Layer.PREZENTE_CURS];
        updateCommand += ", " + studentData[i][Layer.ABSENTE_SEMINAR];
        updateCommand += ", " + studentData[i][Layer.PREZENTE_SEMINAR];
        updateCommand += ", " + studentData[i][Layer.PREZENTE_LAB];
        updateCommand += ", " + studentData[i][Layer.ABSENTE_LAB];
        updateCommand += ", ";
        if (studentData[i][Layer.BAIAT] == 1)
            updateCommand += Layer.BAIAT;
        else
            updateCommand += Layer.FATA;
        updateCommand += ");";
        db.execSQL(updateCommand);
    }
}

######


public static void extractStudentData() {
    int idStudent;
    Cursor resultSetExtract;
    int aux;
    resultSetExtract = db.rawQuery("SELECT * FROM " + STUDENT_TABLE + ";", null);
    studentsCount = resultSetExtract.getCount();
    studentDataMatrix = new float[studentsCount][Layer.BAIAT + 1];
    studentNameData = new String[studentsCount][2];
    while (resultSetExtract.moveToNext()) {
        idStudent = resultSetExtract.getInt(0);
        studentNameData[idStudent][0] = resultSetExtract.getString(1);
        studentNameData[idStudent][1] = resultSetExtract.getString(2);
        studentDataMatrix[idStudent][Layer.MEDIA] = resultSetExtract.getFloat(3);
        studentDataMatrix[idStudent][Layer.LUCRU] = resultSetExtract.getFloat(4);
        studentDataMatrix[idStudent][Layer.CAMIN] = 0;
        studentDataMatrix[idStudent][Layer.ORAS] = 0;
        studentDataMatrix[idStudent][Layer.OUT_ORAS] = 0;
        aux = resultSetExtract.getInt(5);
        studentDataMatrix[idStudent][aux] = 1f;
        studentDataMatrix[idStudent][Layer.PARTENER] = resultSetExtract.getFloat(6);
        studentDataMatrix[idStudent][Layer.ABSENTE_TOTAL] = resultSetExtract.getFloat(7);
        studentDataMatrix[idStudent][Layer.PREZENTE_TOTAL] = resultSetExtract.getFloat(8);
        studentDataMatrix[idStudent][Layer.ABSENTE_CURS] = resultSetExtract.getFloat(9);
        studentDataMatrix[idStudent][Layer.PREZENTE_CURS] = resultSetExtract.getFloat(10);
        studentDataMatrix[idStudent][Layer.ABSENTE_SEMINAR] = resultSetExtract.getFloat(11);
        studentDataMatrix[idStudent][Layer.PREZENTE_SEMINAR] = resultSetExtract.getFloat(12);
        studentDataMatrix[idStudent][Layer.ABSENTE_LAB] = resultSetExtract.getFloat(13);
        studentDataMatrix[idStudent][Layer.PREZENTE_LAB] = resultSetExtract.getFloat(14);
        aux = resultSetExtract.getInt(15);
        studentDataMatrix[idStudent][Layer.FATA] = 0;
        studentDataMatrix[idStudent][Layer.BAIAT] = 0;
        studentDataMatrix[idStudent][aux] = 1f;
    }
    resultSetExtract.close();
}

######


public static void deleteTable(String tableName) {
    db.execSQL("DROP TABLE IF EXISTS " + tableName);
}

######


public static boolean allTablesExists() {
    Cursor resultSetExtract;
    createStudentTable();
    resultSetExtract = db.rawQuery("SELECT * FROM " + STUDENT_TABLE + ";", null);
    if (resultSetExtract.moveToNext()) {
        resultSetExtract.close();
        return true;
    }
    createLayerTables();
    resultSetExtract = db.rawQuery("SELECT * FROM " + LAYER1_TABLE + ";", null);
    if (resultSetExtract.moveToNext()) {
        resultSetExtract.close();
        return true;
    }
    resultSetExtract = db.rawQuery("SELECT * FROM " + LAYER2_TABLE + ";", null);
    if (resultSetExtract.moveToNext()) {
        resultSetExtract.close();
        return true;
    }
    resultSetExtract.close();
    return false;
}

######


public static void createLayerTables() {
    db.execSQL("CREATE TABLE IF NOT EXISTS " + LAYER1_TABLE + "\n" + "(\n" + "    ID INT(11) PRIMARY KEY NOT NULL,\n" + "    Field1 DOUBLE,\n" + "    Field2 DOUBLE,\n" + "    Field3 DOUBLE,\n" + "    Field4 DOUBLE,\n" + "    Field5 DOUBLE,\n" + "    Field6 DOUBLE,\n" + "    Field7 DOUBLE,\n" + "    Field8 DOUBLE,\n" + "    Field9 DOUBLE,\n" + "    Field10 DOUBLE,\n" + "    Field11 DOUBLE,\n" + "    Field12 DOUBLE,\n" + "    Field13 DOUBLE,\n" + "    Field14 DOUBLE,\n" + "    Field15 DOUBLE,\n" + "    Field16 DOUBLE,\n" + "    Field17 DOUBLE,\n" + "    Field18 DOUBLE,\n" + "    Field19 DOUBLE,\n" + "    Field20 DOUBLE,\n" + "    Field21 DOUBLE,\n" + "    Field22 DOUBLE,\n" + "    Field23 DOUBLE,\n" + "    Field24 DOUBLE,\n" + "    Field25 DOUBLE,\n" + "    Field26 DOUBLE,\n" + "    Field27 DOUBLE\n" + ")");
    db.execSQL("CREATE TABLE IF NOT EXISTS " + LAYER2_TABLE + "\n" + "(\n" + "    ID INT(11) PRIMARY KEY NOT NULL,\n" + "    Field1 DOUBLE,\n" + "    Field2 DOUBLE,\n" + "    Field3 DOUBLE,\n" + "    Field4 DOUBLE,\n" + "    Field5 DOUBLE,\n" + "    Field6 DOUBLE,\n" + "    Field7 DOUBLE,\n" + "    Field8 DOUBLE,\n" + "    Field9 DOUBLE,\n" + "    Field10 DOUBLE,\n" + "    Field11 DOUBLE\n" + ")");
}

######


public static void insertLayerData(float[][] layer1, float[][] layer2) {
    int i;
    int j;
    String updateCommand;
    for (i = 0; i < neuronCount[0]; i++) {
        updateCommand = "INSERT INTO " + LAYER1_TABLE + " VALUES (" + i;
        for (j = 0; j <= T_STATUS; j++) {
            updateCommand += ", " + layer1[i][j];
        }
        updateCommand += ");";
        db.execSQL(updateCommand);
    }
    for (i = 0; i < neuronCount[1]; i++) {
        updateCommand = "INSERT INTO " + LAYER2_TABLE + " VALUES (" + i;
        for (j = 0; j <= neuronCount[0]; j++) {
            updateCommand += ", " + layer2[i][j];
        }
        updateCommand += ");";
        db.execSQL(updateCommand);
    }
}

######


public static void resetLayerTables() {
    deleteTable(LAYER1_TABLE);
    deleteTable(LAYER2_TABLE);
    createLayerTables();
    insertLayerData(defaultLayer1, defaultLayer2);
    extractLayersData();
}

######


public static void extractLayersData() {
    int idNeuron;
    Cursor resultSetExtract;
    int j;
    int aux;
    resultSetExtract = db.rawQuery("SELECT * FROM " + LAYER1_TABLE + ";", null);
    Layer1 = new float[neuronCount[0]][T_STATUS + 1];
    while (resultSetExtract.moveToNext()) {
        idNeuron = resultSetExtract.getInt(0);
        for (j = 0; j <= T_STATUS; j++) {
            Layer1[idNeuron][j] = resultSetExtract.getFloat(j + 1);
        }
    }
    resultSetExtract.close();
    resultSetExtract = db.rawQuery("SELECT * FROM " + LAYER2_TABLE + ";", null);
    Layer2 = new float[neuronCount[1]][neuronCount[0] + 1];
    while (resultSetExtract.moveToNext()) {
        idNeuron = resultSetExtract.getInt(0);
        for (j = 0; j <= neuronCount[0]; j++) {
            Layer2[idNeuron][j] = resultSetExtract.getFloat(j + 1);
        }
    }
    resultSetExtract.close();
}

######


public static void updateLayers() {
    int idNeuron;
    ;
    Cursor resultSetUpdate;
    String updateCommand;
    int j;
    resultSetUpdate = db.rawQuery("SELECT * FROM " + LAYER1_TABLE + ";", null);
    while (resultSetUpdate.moveToNext()) {
        idNeuron = resultSetUpdate.getInt(0);
        updateCommand = "UPDATE " + LAYER1_TABLE + " SET";
        updateCommand += " Field1 = " + Layer1[idNeuron][0];
        for (j = 1; j <= T_STATUS; j++) {
            updateCommand += " , Field" + (j + 1) + " = " + Layer1[idNeuron][j];
        }
        updateCommand += " WHERE id = " + idNeuron;
        db.execSQL(updateCommand);
    }
    resultSetUpdate = db.rawQuery("SELECT * FROM " + LAYER2_TABLE + ";", null);
    while (resultSetUpdate.moveToNext()) {
        idNeuron = resultSetUpdate.getInt(0);
        updateCommand = "UPDATE " + LAYER2_TABLE + " SET";
        updateCommand += " Field1 = " + Layer2[idNeuron][0];
        for (j = 0; j <= neuronCount[0]; j++) {
            updateCommand += " , Field" + (j + 1) + " = " + Layer2[idNeuron][j];
        }
        updateCommand += " WHERE id = " + idNeuron;
        db.execSQL(updateCommand);
    }
}

######


public static void initDataBase() {
    if (allTablesExists() == false)
        resetDataBase();
    else {
        extractStudentData();
        extractLayersData();
    }
}

######


public static void closeDataBase() {
    updateDataBase();
}

######


public static void updateDataBase() {
    updateStudent();
    updateLayers();
}

######


public static void resetDataBase() {
    resetStudentTable();
    resetLayerTables();
}

######


public static void updateStudent() {
    int idStudent;
    Cursor resultSetUpdate;
    String updateCommand;
    resultSetUpdate = db.rawQuery("SELECT * FROM " + STUDENT_TABLE + ";", null);
    while (resultSetUpdate.moveToNext()) {
        idStudent = resultSetUpdate.getInt(0);
        updateCommand = "UPDATE " + STUDENT_TABLE + " SET";
        updateCommand += " Absente_Total = " + studentDataMatrix[idStudent][Layer.ABSENTE_TOTAL];
        updateCommand += " , Prezente_Total = " + studentDataMatrix[idStudent][Layer.PREZENTE_TOTAL];
        updateCommand += " , Absente_Curs = " + studentDataMatrix[idStudent][Layer.ABSENTE_CURS];
        updateCommand += " , Prezente_Curs = " + studentDataMatrix[idStudent][Layer.PREZENTE_CURS];
        updateCommand += " , Absente_Seminar = " + studentDataMatrix[idStudent][Layer.ABSENTE_SEMINAR];
        updateCommand += " , Prezente_Seminar = " + studentDataMatrix[idStudent][Layer.PREZENTE_SEMINAR];
        updateCommand += " , Prezente_Laborator = " + studentDataMatrix[idStudent][Layer.PREZENTE_LAB];
        updateCommand += " , Absente_Laborator = " + studentDataMatrix[idStudent][Layer.ABSENTE_LAB];
        if (studentDataMatrix[idStudent][Layer.BAIAT] == 1)
            updateCommand += Layer.BAIAT;
        else
            updateCommand += Layer.FATA;
        updateCommand += " WHERE id = " + idStudent;
        db.execSQL(updateCommand);
    }
}

######


public static void createStudentTable() {
    db.execSQL("CREATE TABLE IF NOT EXISTS " + STUDENT_TABLE + "\n" + "(\n" + "  ID INT(11) PRIMARY KEY NOT NULL,\n" + "  Nume VARCHAR(20) NOT NULL,\n" + "  Prenume VARCHAR(20) NOT NULL,\n" + "  Media FLOAT NOT NULL,\n" + "  Lucru INT(2) DEFAULT '0' NOT NULL,\n" + "  Locul INT(11) NOT NULL,\n" + "  Partener INT(11) NOT NULL,\n" + "  Absente_Total INT(11) NOT NULL,\n" + "  Prezente_Total INT(11) NOT NULL,\n" + "  Absente_Curs INT(11) NOT NULL,\n" + "  Prezente_Curs INT(11) NOT NULL,\n" + "  Absente_Seminar INT(11) NOT NULL,\n" + "  Prezente_Seminar INT(11) NOT NULL,\n" + "  Absente_Laborator INT(11) NOT NULL,\n" + "  Prezente_Laborator INT(11) NOT NULL,\n" + "  Gen INT(11) NOT NULL\n" + ");");
}

######


public static void resetStudentTable() {
    deleteTable(STUDENT_TABLE);
    createStudentTable();
    studentsCount = 22;
    insertStudentData(defaultStudentDataMatrix, defaultStudentNameData);
    extractStudentData();
}

######


public static void insertStudentData(float[][] studentData, String[][] studentName) {
    int i;
    String updateCommand;
    for (i = 0; i < studentsCount; i++) {
        updateCommand = "INSERT INTO " + STUDENT_TABLE + " VALUES (" + i;
        updateCommand += ", '" + studentName[i][0] + "'";
        updateCommand += ", '" + studentName[i][1] + "'";
        updateCommand += ", " + studentData[i][Layer.MEDIA];
        updateCommand += ", " + studentData[i][Layer.LUCRU];
        updateCommand += ", ";
        if (studentData[i][Layer.CAMIN] == 1)
            updateCommand += Layer.CAMIN;
        else if (studentData[i][Layer.ORAS] == 1)
            updateCommand += Layer.ORAS;
        else
            updateCommand += Layer.OUT_ORAS;
        updateCommand += ", " + studentData[i][Layer.PARTENER];
        updateCommand += ", " + studentData[i][Layer.ABSENTE_TOTAL];
        updateCommand += ", " + studentData[i][Layer.PREZENTE_TOTAL];
        updateCommand += ", " + studentData[i][Layer.ABSENTE_CURS];
        updateCommand += ", " + studentData[i][Layer.PREZENTE_CURS];
        updateCommand += ", " + studentData[i][Layer.ABSENTE_SEMINAR];
        updateCommand += ", " + studentData[i][Layer.PREZENTE_SEMINAR];
        updateCommand += ", " + studentData[i][Layer.PREZENTE_LAB];
        updateCommand += ", " + studentData[i][Layer.ABSENTE_LAB];
        updateCommand += ", ";
        if (studentData[i][Layer.BAIAT] == 1)
            updateCommand += Layer.BAIAT;
        else
            updateCommand += Layer.FATA;
        updateCommand += ");";
        db.execSQL(updateCommand);
    }
}

######


public static void extractStudentData() {
    int idStudent;
    Cursor resultSetExtract;
    int aux;
    resultSetExtract = db.rawQuery("SELECT * FROM " + STUDENT_TABLE + ";", null);
    studentsCount = resultSetExtract.getCount();
    studentDataMatrix = new float[studentsCount][Layer.BAIAT + 1];
    studentNameData = new String[studentsCount][2];
    while (resultSetExtract.moveToNext()) {
        idStudent = resultSetExtract.getInt(0);
        studentNameData[idStudent][0] = resultSetExtract.getString(1);
        studentNameData[idStudent][1] = resultSetExtract.getString(2);
        studentDataMatrix[idStudent][Layer.MEDIA] = resultSetExtract.getFloat(3);
        studentDataMatrix[idStudent][Layer.LUCRU] = resultSetExtract.getFloat(4);
        studentDataMatrix[idStudent][Layer.CAMIN] = 0;
        studentDataMatrix[idStudent][Layer.ORAS] = 0;
        studentDataMatrix[idStudent][Layer.OUT_ORAS] = 0;
        aux = resultSetExtract.getInt(5);
        studentDataMatrix[idStudent][aux] = 1f;
        studentDataMatrix[idStudent][Layer.PARTENER] = resultSetExtract.getFloat(6);
        studentDataMatrix[idStudent][Layer.ABSENTE_TOTAL] = resultSetExtract.getFloat(7);
        studentDataMatrix[idStudent][Layer.PREZENTE_TOTAL] = resultSetExtract.getFloat(8);
        studentDataMatrix[idStudent][Layer.ABSENTE_CURS] = resultSetExtract.getFloat(9);
        studentDataMatrix[idStudent][Layer.PREZENTE_CURS] = resultSetExtract.getFloat(10);
        studentDataMatrix[idStudent][Layer.ABSENTE_SEMINAR] = resultSetExtract.getFloat(11);
        studentDataMatrix[idStudent][Layer.PREZENTE_SEMINAR] = resultSetExtract.getFloat(12);
        studentDataMatrix[idStudent][Layer.ABSENTE_LAB] = resultSetExtract.getFloat(13);
        studentDataMatrix[idStudent][Layer.PREZENTE_LAB] = resultSetExtract.getFloat(14);
        aux = resultSetExtract.getInt(15);
        studentDataMatrix[idStudent][Layer.FATA] = 0;
        studentDataMatrix[idStudent][Layer.BAIAT] = 0;
        studentDataMatrix[idStudent][aux] = 1f;
    }
    resultSetExtract.close();
}

######


public static void deleteTable(String tableName) {
    db.execSQL("DROP TABLE IF EXISTS " + tableName);
}

######


public static boolean allTablesExists() {
    Cursor resultSetExtract;
    createStudentTable();
    resultSetExtract = db.rawQuery("SELECT * FROM " + STUDENT_TABLE + ";", null);
    if (resultSetExtract.moveToNext()) {
        resultSetExtract.close();
        return true;
    }
    createLayerTables();
    resultSetExtract = db.rawQuery("SELECT * FROM " + LAYER1_TABLE + ";", null);
    if (resultSetExtract.moveToNext()) {
        resultSetExtract.close();
        return true;
    }
    resultSetExtract = db.rawQuery("SELECT * FROM " + LAYER2_TABLE + ";", null);
    if (resultSetExtract.moveToNext()) {
        resultSetExtract.close();
        return true;
    }
    resultSetExtract.close();
    return false;
}

######


public static void createLayerTables() {
    db.execSQL("CREATE TABLE IF NOT EXISTS " + LAYER1_TABLE + "\n" + "(\n" + "    ID INT(11) PRIMARY KEY NOT NULL,\n" + "    Field1 DOUBLE,\n" + "    Field2 DOUBLE,\n" + "    Field3 DOUBLE,\n" + "    Field4 DOUBLE,\n" + "    Field5 DOUBLE,\n" + "    Field6 DOUBLE,\n" + "    Field7 DOUBLE,\n" + "    Field8 DOUBLE,\n" + "    Field9 DOUBLE,\n" + "    Field10 DOUBLE,\n" + "    Field11 DOUBLE,\n" + "    Field12 DOUBLE,\n" + "    Field13 DOUBLE,\n" + "    Field14 DOUBLE,\n" + "    Field15 DOUBLE,\n" + "    Field16 DOUBLE,\n" + "    Field17 DOUBLE,\n" + "    Field18 DOUBLE,\n" + "    Field19 DOUBLE,\n" + "    Field20 DOUBLE,\n" + "    Field21 DOUBLE,\n" + "    Field22 DOUBLE,\n" + "    Field23 DOUBLE,\n" + "    Field24 DOUBLE,\n" + "    Field25 DOUBLE,\n" + "    Field26 DOUBLE,\n" + "    Field27 DOUBLE\n" + ")");
    db.execSQL("CREATE TABLE IF NOT EXISTS " + LAYER2_TABLE + "\n" + "(\n" + "    ID INT(11) PRIMARY KEY NOT NULL,\n" + "    Field1 DOUBLE,\n" + "    Field2 DOUBLE,\n" + "    Field3 DOUBLE,\n" + "    Field4 DOUBLE,\n" + "    Field5 DOUBLE,\n" + "    Field6 DOUBLE,\n" + "    Field7 DOUBLE,\n" + "    Field8 DOUBLE,\n" + "    Field9 DOUBLE,\n" + "    Field10 DOUBLE,\n" + "    Field11 DOUBLE\n" + ")");
}

######


public static void insertLayerData(float[][] layer1, float[][] layer2) {
    int i;
    int j;
    String updateCommand;
    for (i = 0; i < neuronCount[0]; i++) {
        updateCommand = "INSERT INTO " + LAYER1_TABLE + " VALUES (" + i;
        for (j = 0; j <= T_STATUS; j++) {
            updateCommand += ", " + layer1[i][j];
        }
        updateCommand += ");";
        db.execSQL(updateCommand);
    }
    for (i = 0; i < neuronCount[1]; i++) {
        updateCommand = "INSERT INTO " + LAYER2_TABLE + " VALUES (" + i;
        for (j = 0; j <= neuronCount[0]; j++) {
            updateCommand += ", " + layer2[i][j];
        }
        updateCommand += ");";
        db.execSQL(updateCommand);
    }
}

######


public static void resetLayerTables() {
    deleteTable(LAYER1_TABLE);
    deleteTable(LAYER2_TABLE);
    createLayerTables();
    insertLayerData(defaultLayer1, defaultLayer2);
    extractLayersData();
}

######


public static void extractLayersData() {
    int idNeuron;
    Cursor resultSetExtract;
    int j;
    int aux;
    resultSetExtract = db.rawQuery("SELECT * FROM " + LAYER1_TABLE + ";", null);
    Layer1 = new float[neuronCount[0]][T_STATUS + 1];
    while (resultSetExtract.moveToNext()) {
        idNeuron = resultSetExtract.getInt(0);
        for (j = 0; j <= T_STATUS; j++) {
            Layer1[idNeuron][j] = resultSetExtract.getFloat(j + 1);
        }
    }
    resultSetExtract.close();
    resultSetExtract = db.rawQuery("SELECT * FROM " + LAYER2_TABLE + ";", null);
    Layer2 = new float[neuronCount[1]][neuronCount[0] + 1];
    while (resultSetExtract.moveToNext()) {
        idNeuron = resultSetExtract.getInt(0);
        for (j = 0; j <= neuronCount[0]; j++) {
            Layer2[idNeuron][j] = resultSetExtract.getFloat(j + 1);
        }
    }
    resultSetExtract.close();
}

######


public static void updateLayers() {
    int idNeuron;
    ;
    Cursor resultSetUpdate;
    String updateCommand;
    int j;
    resultSetUpdate = db.rawQuery("SELECT * FROM " + LAYER1_TABLE + ";", null);
    while (resultSetUpdate.moveToNext()) {
        idNeuron = resultSetUpdate.getInt(0);
        updateCommand = "UPDATE " + LAYER1_TABLE + " SET";
        updateCommand += " Field1 = " + Layer1[idNeuron][0];
        for (j = 1; j <= T_STATUS; j++) {
            updateCommand += " , Field" + (j + 1) + " = " + Layer1[idNeuron][j];
        }
        updateCommand += " WHERE id = " + idNeuron;
        db.execSQL(updateCommand);
    }
    resultSetUpdate = db.rawQuery("SELECT * FROM " + LAYER2_TABLE + ";", null);
    while (resultSetUpdate.moveToNext()) {
        idNeuron = resultSetUpdate.getInt(0);
        updateCommand = "UPDATE " + LAYER2_TABLE + " SET";
        updateCommand += " Field1 = " + Layer2[idNeuron][0];
        for (j = 0; j <= neuronCount[0]; j++) {
            updateCommand += " , Field" + (j + 1) + " = " + Layer2[idNeuron][j];
        }
        updateCommand += " WHERE id = " + idNeuron;
        db.execSQL(updateCommand);
    }
}

######


private void initDBConnection() {
    try {
        Class.forName("com.mysql.jdbc.Driver");
    } catch (ClassNotFoundException e) {
        main_app.error("DatabaseManager.setupDBConnection() Unable to load jdbc driver. ClassNotFoundException " + e.getMessage());
    }
}

######


private Connection getConnection() {
    Connection _conn = null;
    try {
        _conn = DriverManager.getConnection("jdbc:mysql://" + db_server + "/" + db_instance_name + "?user=" + db_username + "&password=" + db_password + "");
    } catch (SQLException e) {
        main_app.error("DatabaseManager.setupDBConnection() get DB connection " + e.getMessage() + "jdbc:mysql://" + db_server + "/" + db_instance_name + "?user=" + db_username + "&password=" + db_password + "");
    }
    return _conn;
}

######


private void closeConnection(Connection conn, PreparedStatement stmt, String caller) {
    if (stmt != null) {
        try {
            stmt.close();
        } catch (SQLException e) {
        }
        stmt = null;
    }
    if (conn != null) {
        try {
            conn.close();
        } catch (SQLException e) {
        }
        conn = null;
    }
}

######


public void saveImage(String path) {
    main_app.log("DatabaseManager.saveImage() session_id=" + _session_id);
    String saveImageSql = "insert into image (session_id, path) values (?,?)";
    Connection conn = null;
    PreparedStatement preparedStatement = null;
    try {
        conn = getConnection();
        preparedStatement = conn.prepareStatement(saveImageSql);
        preparedStatement.clearParameters();
        preparedStatement.setInt(1, _session_id);
        preparedStatement.setString(2, path);
        preparedStatement.execute();
    } catch (SQLException e) {
        main_app.error("saveSessionStartReport(): execute(): " + e.toString());
    } finally {
        closeConnection(conn, preparedStatement, "saveImage");
    }
}

######


public Boolean saveSessionStart(AMFDataObj amfDataObj, String room_name) {
    main_app.log("DatabaseManager.saveSessionStart() appName=" + main_app.app_instance.getApplication().getName() + " session_id=" + _session_id + " room_name=" + room_name + " user_name=" + amfDataObj.getString("user_name"));
    if (_session_id > 0) {
        main_app.log("DatabaseManager.saveSessionStartReport() aborting because session_id has already been set");
        return true;
    }
    String sessionStartSql = "insert into session " + "(room_id, " + "room_name, " + "application_name) values (?,?,?)";
    Connection conn = null;
    PreparedStatement preparedStatement = null;
    ResultSet rs = null;
    try {
        conn = getConnection();
        preparedStatement = conn.prepareStatement(sessionStartSql, PreparedStatement.RETURN_GENERATED_KEYS);
        preparedStatement.clearParameters();
        preparedStatement.setString(1, main_app.app_instance.getName());
        preparedStatement.setString(2, room_name);
        preparedStatement.setString(3, main_app.app_instance.getApplication().getName());
        preparedStatement.execute();
        rs = preparedStatement.getGeneratedKeys();
        if (rs.next()) {
            _session_id = rs.getInt(1);
        }
        preparedStatement.close();
        preparedStatement = null;
        conn.close();
        conn = null;
    } catch (SQLException e) {
        main_app.error("saveSessionStartReport(): execute(): " + e.toString());
    } finally {
        closeConnection(conn, preparedStatement, "saveSessionStart");
    }
    return true;
}

######


public boolean saveSessionReport(AMFDataObj amfDataObj, long lastValidateTime, long pingRoundTripTime, long fileInBytesRate, long fileOutBytesRate, long messagesInBytesRate, long messagesInCountRate, long messagesLossBytesRate, long messagesLossCountRate, long messagesOutBytesRate, long messagesOutCountRate) {
    String wowza_protocol = amfDataObj.getString("wowza_protocol");
    int currentBytesPerSecond = amfDataObj.getInt("currentBytesPerSecond");
    int dataBytesPerSecond = amfDataObj.getInt("dataBytesPerSecond");
    int videoBytesPerSecond = amfDataObj.getInt("videoBytesPerSecond");
    int audioBytesPerSecond = amfDataObj.getInt("audioBytesPerSecond");
    int maxBytesPerSecond = amfDataObj.getInt("maxBytesPerSecond");
    int byteCount = amfDataObj.getInt("byteCount");
    int dataByteCount = amfDataObj.getInt("dataByteCount");
    int audioLossRate = amfDataObj.getInt("audioLossRate");
    int droppedFrames = amfDataObj.getInt("droppedFrames");
    int videoByteCount = amfDataObj.getInt("videoByteCount");
    int srtt = amfDataObj.getInt("SRTT");
    String room_id = amfDataObj.getString("room_id");
    String room_name = amfDataObj.getString("room_name");
    String user_name = amfDataObj.getString("user_name");
    String user_id = amfDataObj.getString("user_id");
    String application_name = main_app.app_instance.getApplication().getName();
    String sessionReportSql = "insert into session_report " + "(session_id, " + "room_id, " + "room_name, " + "user_name, " + "c_audioBytesPerSecond, " + "c_videoBytesPerSecond, " + "c_dataBytesPerSecond, " + "c_currentBytesPerSecond, " + "c_maxBytesPerSecond, " + "c_byteCount, " + "c_dataByteCount, " + "c_videoByteCount, " + "c_audioLossRate, " + "c_srtt, " + "c_wowzaProtocol, " + "c_droppedFrames, " + "application_name, " + "s_lastValidatedTime, " + "s_pingRtt, " + "s_fileInBytesRate, " + "s_fileOutBytesRate, " + "s_messagesInBytesRate, " + "s_messagesInCountRate, " + "s_messagesLossBytesRate, " + "s_messagesLossCountRate, " + "s_messagesOutBytesRate, " + "s_messagesOutCountRate, " + "user_id " + ") values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
    Connection conn = null;
    PreparedStatement preparedStatement = null;
    try {
        conn = getConnection();
        preparedStatement = conn.prepareStatement(sessionReportSql);
        preparedStatement.clearParameters();
        preparedStatement.setInt(1, _session_id);
        preparedStatement.setString(2, room_id);
        preparedStatement.setString(3, room_name);
        preparedStatement.setString(4, user_name);
        preparedStatement.setInt(5, audioBytesPerSecond);
        preparedStatement.setInt(6, videoBytesPerSecond);
        preparedStatement.setInt(7, dataBytesPerSecond);
        preparedStatement.setInt(8, currentBytesPerSecond);
        preparedStatement.setInt(9, maxBytesPerSecond);
        preparedStatement.setInt(10, byteCount);
        preparedStatement.setInt(11, dataByteCount);
        preparedStatement.setInt(12, videoByteCount);
        preparedStatement.setInt(13, audioLossRate);
        preparedStatement.setInt(14, srtt);
        preparedStatement.setString(15, wowza_protocol);
        preparedStatement.setInt(16, droppedFrames);
        preparedStatement.setString(17, application_name);
        preparedStatement.setTimestamp(18, new Timestamp(lastValidateTime));
        preparedStatement.setLong(19, pingRoundTripTime);
        preparedStatement.setLong(20, fileInBytesRate);
        preparedStatement.setLong(21, fileOutBytesRate);
        preparedStatement.setLong(22, messagesInBytesRate);
        preparedStatement.setLong(23, messagesInCountRate);
        preparedStatement.setLong(24, messagesLossBytesRate);
        preparedStatement.setLong(25, messagesLossCountRate);
        preparedStatement.setLong(26, messagesOutBytesRate);
        preparedStatement.setLong(27, messagesOutCountRate);
        preparedStatement.setString(28, user_id);
        preparedStatement.execute();
    } catch (SQLException e) {
        main_app.error("saveSessionReport() sqlexecuteException: " + e.toString());
    } finally {
        closeConnection(conn, preparedStatement, "saveSessionReport");
    }
    return true;
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("dbpk_test", "val varchar(20), id1 int not null, id2 int not null,primary key(id1, id2)", "engine=innodb");
    createTable("datetime_test", "dt datetime");
    createTable("`manycols`", "  `tiny` tinyint(4) DEFAULT NULL," + "  `tiny_uns` tinyint(3) unsigned DEFAULT NULL," + "  `small` smallint(6) DEFAULT NULL," + "  `small_uns` smallint(5) unsigned DEFAULT NULL," + "  `medium` mediumint(9) DEFAULT NULL," + "  `medium_uns` mediumint(8) unsigned DEFAULT NULL," + "  `int_col` int(11) DEFAULT NULL," + "  `int_col_uns` int(10) unsigned DEFAULT NULL," + "  `big` bigint(20) DEFAULT NULL," + "  `big_uns` bigint(20) unsigned DEFAULT NULL," + "  `decimal_col` decimal(10,5) DEFAULT NULL," + "  `fcol` float DEFAULT NULL," + "  `fcol_uns` float unsigned DEFAULT NULL," + "  `dcol` double DEFAULT NULL," + "  `dcol_uns` double unsigned DEFAULT NULL," + "  `date_col` date DEFAULT NULL," + "  `time_col` time DEFAULT NULL," + "  `timestamp_col` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP," + "  `year_col` year(4) DEFAULT NULL," + "  `bit_col` bit(5) DEFAULT NULL," + "  `char_col` char(5) DEFAULT NULL," + "  `varchar_col` varchar(10) DEFAULT NULL," + "  `binary_col` binary(10) DEFAULT NULL," + "  `varbinary_col` varbinary(10) DEFAULT NULL," + "  `tinyblob_col` tinyblob," + "  `blob_col` blob," + "  `mediumblob_col` mediumblob," + "  `longblob_col` longblob," + "  `tinytext_col` tinytext," + "  `text_col` text," + "  `mediumtext_col` mediumtext," + "  `longtext_col` longtext");
    createTable("ytab", "y year");
    createTable("maxcharlength", "maxcharlength char(1)", "character set utf8");
    createTable("conj72", "t tinyint(1)");
}

######


private static void checkType(String name, int actualType, String colName, int expectedType) {
    if (name.equals(colName)) {
        assertEquals(actualType, expectedType);
    }
}

######


@Before
public void checkSupported() throws SQLException {
    requireMinimumVersion(5, 1);
}

######


@Test
public void primaryKeysTest() throws SQLException {
    DatabaseMetaData dbmd = sharedConnection.getMetaData();
    ResultSet rs = dbmd.getPrimaryKeys("testj", null, "dbpk_test");
    int counter = 0;
    while (rs.next()) {
        counter++;
        assertEquals("testj", rs.getString("table_cat"));
        assertEquals(null, rs.getString("table_schem"));
        assertEquals("dbpk_test", rs.getString("table_name"));
        assertEquals("id" + counter, rs.getString("column_name"));
        assertEquals("id" + counter, rs.getString("column_name"));
        assertEquals("PRIMARY", rs.getString("PK_NAME"));
    }
    assertEquals(2, counter);
}

######


@Test
public void primaryKeyTest2() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("drop table if exists t2");
    stmt.execute("drop table if exists t1");
    stmt.execute("CREATE TABLE t1 ( id1 integer, constraint pk primary key(id1))");
    stmt.execute("CREATE TABLE t2 (id2a integer, id2b integer, constraint pk primary key(id2a, id2b), " + "constraint fk1 foreign key(id2a) references t1(id1),  constraint fk2 foreign key(id2b) " + "references t1(id1))");
    DatabaseMetaData dbmd = sharedConnection.getMetaData();
    ResultSet rs = dbmd.getPrimaryKeys("testj", null, "t2");
    int counter = 0;
    while (rs.next()) {
        counter++;
        assertEquals("testj", rs.getString("table_cat"));
        assertEquals(null, rs.getString("table_schem"));
        assertEquals("t2", rs.getString("table_name"));
        assertEquals(counter, rs.getShort("key_seq"));
    }
    assertEquals(2, counter);
    stmt.execute("drop table if exists t2");
    stmt.execute("drop table if exists t1");
}

######


@Test
public void datetimeTest() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    ResultSet rs = stmt.executeQuery("select * from datetime_test");
    assertEquals(93, rs.getMetaData().getColumnType(1));
}

######


@Test
public void functionColumns() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    DatabaseMetaData md = sharedConnection.getMetaData();
    if (md.getDatabaseMajorVersion() < 5) {
        return;
    } else if (md.getDatabaseMajorVersion() == 5 && md.getDatabaseMinorVersion() < 5) {
        return;
    }
    stmt.execute("DROP FUNCTION IF EXISTS hello");
    stmt.execute("CREATE FUNCTION hello (s CHAR(20), i int) RETURNS CHAR(50) DETERMINISTIC  " + "RETURN CONCAT('Hello, ',s,'!')");
    ResultSet rs = sharedConnection.getMetaData().getFunctionColumns(null, null, "hello", null);
    assertTrue(rs.next());
    assertEquals(rs.getString("FUNCTION_CAT"), sharedConnection.getCatalog());
    assertEquals(rs.getString("FUNCTION_SCHEM"), null);
    assertEquals(rs.getString("COLUMN_NAME"), null);
    assertEquals(rs.getInt("COLUMN_TYPE"), DatabaseMetaData.functionReturn);
    assertEquals(rs.getInt("DATA_TYPE"), Types.CHAR);
    assertEquals(rs.getString("TYPE_NAME"), "char");
    assertTrue(rs.next());
    assertEquals(rs.getString("COLUMN_NAME"), "s");
    assertEquals(rs.getInt("COLUMN_TYPE"), DatabaseMetaData.functionColumnIn);
    assertEquals(rs.getInt("DATA_TYPE"), Types.CHAR);
    assertEquals(rs.getString("TYPE_NAME"), "char");
    assertTrue(rs.next());
    assertEquals(rs.getString("COLUMN_NAME"), "i");
    assertEquals(rs.getInt("COLUMN_TYPE"), DatabaseMetaData.functionColumnIn);
    assertEquals(rs.getInt("DATA_TYPE"), Types.INTEGER);
    assertEquals(rs.getString("TYPE_NAME"), "int");
    stmt.execute("DROP FUNCTION IF EXISTS hello");
}

######


@Test
public void getImportedKeys() throws Exception {
    Assume.assumeFalse(!isMariadbServer() && minVersion(8, 0, 0));
    Statement st = sharedConnection.createStatement();
    st.execute("DROP TABLE IF EXISTS product_order");
    st.execute("DROP TABLE IF EXISTS t1.product ");
    st.execute("DROP TABLE IF EXISTS `cus``tomer`");
    st.execute("DROP DATABASE IF EXISTS test1");
    st.execute("CREATE DATABASE IF NOT EXISTS t1");
    st.execute("CREATE TABLE t1.product ( category INT NOT NULL, id INT NOT NULL, price DECIMAL," + " PRIMARY KEY(category, id) )   ENGINE=INNODB");
    st.execute("CREATE TABLE `cus``tomer` (id INT NOT NULL, PRIMARY KEY (id))   ENGINE=INNODB");
    st.execute("CREATE TABLE product_order (\n" + "    no INT NOT NULL AUTO_INCREMENT,\n" + "    product_category INT NOT NULL,\n" + "    product_id INT NOT NULL,\n" + "    customer_id INT NOT NULL,\n" + "    PRIMARY KEY(no),\n" + "    INDEX (product_category, product_id),\n" + "    INDEX (customer_id),\n" + "    FOREIGN KEY (product_category, product_id)\n" + "      REFERENCES t1.product(category, id)\n" + "      ON UPDATE CASCADE ON DELETE RESTRICT,\n" + "    FOREIGN KEY (customer_id)\n" + "      REFERENCES `cus``tomer`(id)\n" + ")   ENGINE=INNODB;");
    ResultSet rs1 = ((MariaDbDatabaseMetaData) sharedConnection.getMetaData()).getImportedKeysUsingShowCreateTable("testj", "product_order");
    ResultSet rs2 = ((MariaDbDatabaseMetaData) sharedConnection.getMetaData()).getImportedKeysUsingInformationSchema("testj", "product_order");
    assertEquals(rs1.getMetaData().getColumnCount(), rs2.getMetaData().getColumnCount());
    while (rs1.next()) {
        assertTrue(rs2.next());
        for (int i = 1; i <= rs1.getMetaData().getColumnCount(); i++) {
            Object s1 = rs1.getObject(i);
            Object s2 = rs2.getObject(i);
            if (s1 instanceof Number && s2 instanceof Number) {
                assertEquals(((Number) s1).intValue(), ((Number) s2).intValue());
            } else {
                if (s1 != null && s2 != null && !s1.equals(s2)) {
                    fail();
                }
                assertEquals(s1, s2);
            }
        }
    }
    ResultSetMetaData md1 = rs1.getMetaData();
    ResultSetMetaData md2 = rs2.getMetaData();
    for (int i = 1; i <= md1.getColumnCount(); i++) {
        assertEquals(md1.getColumnLabel(i), md2.getColumnLabel(i));
    }
    st.execute("DROP TABLE IF EXISTS product_order");
    st.execute("DROP TABLE IF EXISTS t1.product ");
    st.execute("DROP TABLE IF EXISTS `cus``tomer`");
    st.execute("DROP DATABASE IF EXISTS test1");
}

######


@Test
public void exportedKeysTest() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("drop table if exists fore_key0");
    stmt.execute("drop table if exists fore_key1");
    stmt.execute("drop table if exists prim_key");
    stmt.execute("create table prim_key (id int not null primary key, " + "val varchar(20)) engine=innodb");
    stmt.execute("create table fore_key0 (id int not null primary key, " + "id_ref0 int, foreign key (id_ref0) references prim_key(id)) engine=innodb");
    stmt.execute("create table fore_key1 (id int not null primary key, " + "id_ref1 int, foreign key (id_ref1) references prim_key(id) on update cascade) engine=innodb");
    DatabaseMetaData dbmd = sharedConnection.getMetaData();
    ResultSet rs = dbmd.getExportedKeys("testj", null, "prim_key");
    int counter = 0;
    while (rs.next()) {
        assertEquals("id", rs.getString("pkcolumn_name"));
        assertEquals("fore_key" + counter, rs.getString("fktable_name"));
        assertEquals("id_ref" + counter, rs.getString("fkcolumn_name"));
        counter++;
    }
    assertEquals(2, counter);
    stmt.execute("drop table if exists fore_key0");
    stmt.execute("drop table if exists fore_key1");
    stmt.execute("drop table if exists prim_key");
}

######


@Test
public void importedKeysTest() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("drop table if exists fore_key0");
    stmt.execute("drop table if exists fore_key1");
    stmt.execute("drop table if exists prim_key");
    stmt.execute("create table prim_key (id int not null primary key, " + "val varchar(20)) engine=innodb");
    stmt.execute("create table fore_key0 (id int not null primary key, " + "id_ref0 int, foreign key (id_ref0) references prim_key(id)) engine=innodb");
    stmt.execute("create table fore_key1 (id int not null primary key, " + "id_ref1 int, foreign key (id_ref1) references prim_key(id) on update cascade) engine=innodb");
    DatabaseMetaData dbmd = sharedConnection.getMetaData();
    ResultSet rs = dbmd.getImportedKeys(sharedConnection.getCatalog(), null, "fore_key0");
    int counter = 0;
    while (rs.next()) {
        assertEquals("id", rs.getString("pkcolumn_name"));
        assertEquals("prim_key", rs.getString("pktable_name"));
        counter++;
    }
    assertEquals(1, counter);
    stmt.execute("drop table if exists fore_key0");
    stmt.execute("drop table if exists fore_key1");
    stmt.execute("drop table if exists prim_key");
}

######


@Test
public void testGetCatalogs() throws SQLException {
    DatabaseMetaData dbmd = sharedConnection.getMetaData();
    ResultSet rs = dbmd.getCatalogs();
    boolean haveMysql = false;
    boolean haveInformationSchema = false;
    while (rs.next()) {
        String cat = rs.getString(1);
        if (cat.equalsIgnoreCase("mysql")) {
            haveMysql = true;
        } else if (cat.equalsIgnoreCase("information_schema")) {
            haveInformationSchema = true;
        }
    }
    assertTrue(haveMysql);
    assertTrue(haveInformationSchema);
}

######


@Test
public void testGetTables() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("drop table if exists fore_key0");
    stmt.execute("drop table if exists fore_key1");
    stmt.execute("drop table if exists prim_key");
    stmt.execute("create table prim_key (id int not null primary key, " + "val varchar(20)) engine=innodb");
    stmt.execute("create table fore_key0 (id int not null primary key, " + "id_ref0 int, foreign key (id_ref0) references prim_key(id)) engine=innodb");
    stmt.execute("create table fore_key1 (id int not null primary key, " + "id_ref1 int, foreign key (id_ref1) references prim_key(id) on update cascade) engine=innodb");
    DatabaseMetaData dbmd = sharedConnection.getMetaData();
    ResultSet rs = dbmd.getTables(null, null, "prim_key", null);
    assertEquals(true, rs.next());
    rs = dbmd.getTables("", null, "prim_key", null);
    assertEquals(true, rs.next());
}

######


@Test
public void testGetTables2() throws SQLException {
    DatabaseMetaData dbmd = sharedConnection.getMetaData();
    ResultSet rs = dbmd.getTables("information_schema", null, "TABLE_PRIVILEGES", new String[] { "SYSTEM VIEW" });
    assertEquals(true, rs.next());
    assertEquals(false, rs.next());
    rs = dbmd.getTables(null, null, "TABLE_PRIVILEGES", new String[] { "TABLE" });
    assertEquals(false, rs.next());
}

######


@Test
public void testGetTables3() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("drop table if exists table_type_test");
    stmt.execute("create table table_type_test (id int not null primary key, " + "val varchar(20)) engine=innodb");
    DatabaseMetaData dbmd = sharedConnection.getMetaData();
    ResultSet tableSet = dbmd.getTables(null, null, "table_type_test", null);
    assertEquals(true, tableSet.next());
    String tableName = tableSet.getString("TABLE_NAME");
    assertEquals("table_type_test", tableName);
    String tableType = tableSet.getString("TABLE_TYPE");
    assertEquals("TABLE", tableType);
}

######


@Test
public void testGetColumns() throws SQLException {
    Assume.assumeTrue(isMariadbServer() || !isMariadbServer() && minVersion(5, 7));
    if (minVersion(10, 2) || !isMariadbServer()) {
        createTable("tablegetcolumns", "a INT NOT NULL primary key auto_increment, b VARCHAR(32), c INT AS (CHAR_LENGTH(b)) VIRTUAL, " + "d VARCHAR(5) AS (left(b,5)) STORED", "CHARACTER SET 'utf8mb4'");
    } else {
        createTable("tablegetcolumns", "a INT NOT NULL primary key auto_increment, b VARCHAR(32), c INT AS (CHAR_LENGTH(b)) VIRTUAL, " + "d VARCHAR(5) AS (left(b,5)) PERSISTENT", "CHARACTER SET 'utf8mb4'");
    }
    DatabaseMetaData dbmd = sharedConnection.getMetaData();
    ResultSet rs = dbmd.getColumns(null, null, "tablegetcolumns", null);
    assertTrue(rs.next());
    assertEquals("testj", rs.getString(1));
    assertEquals(null, rs.getString(2));
    assertEquals("tablegetcolumns", rs.getString(3));
    assertEquals("a", rs.getString(4));
    assertEquals(Types.INTEGER, rs.getInt(5));
    assertEquals("INT", rs.getString(6));
    assertEquals(10, rs.getInt(7));
    assertEquals(0, rs.getInt(9));
    assertEquals(10, rs.getInt(10));
    assertEquals(0, rs.getInt(11));
    assertEquals("", rs.getString(12));
    assertEquals(null, rs.getString(13));
    assertEquals(0, rs.getInt(16));
    assertEquals(1, rs.getInt(17));
    assertEquals("NO", rs.getString(18));
    assertEquals(null, rs.getString(19));
    assertEquals(null, rs.getString(20));
    assertEquals(null, rs.getString(21));
    assertEquals(0, rs.getShort(22));
    assertEquals("YES", rs.getString(23));
    assertEquals("NO", rs.getString(24));
    assertTrue(rs.next());
    assertEquals("testj", rs.getString(1));
    assertEquals(null, rs.getString(2));
    assertEquals("tablegetcolumns", rs.getString(3));
    assertEquals("b", rs.getString(4));
    assertEquals(Types.VARCHAR, rs.getInt(5));
    assertEquals("VARCHAR", rs.getString(6));
    assertEquals(32, rs.getInt(7));
    assertEquals(0, rs.getInt(9));
    assertEquals(10, rs.getInt(10));
    assertEquals(1, rs.getInt(11));
    assertEquals("", rs.getString(12));
    assertTrue("null".equalsIgnoreCase(rs.getString(13)) || rs.getString(13) == null);
    assertEquals(32 * 4, rs.getInt(16));
    assertEquals(2, rs.getInt(17));
    assertEquals("YES", rs.getString(18));
    assertEquals(null, rs.getString(19));
    assertEquals(null, rs.getString(20));
    assertEquals(null, rs.getString(21));
    assertEquals(0, rs.getShort(22));
    assertEquals("NO", rs.getString(23));
    assertEquals("NO", rs.getString(24));
    assertTrue(rs.next());
    assertEquals("testj", rs.getString(1));
    assertEquals(null, rs.getString(2));
    assertEquals("tablegetcolumns", rs.getString(3));
    assertEquals("c", rs.getString(4));
    assertEquals(Types.INTEGER, rs.getInt(5));
    assertEquals("INT", rs.getString(6));
    assertEquals(10, rs.getInt(7));
    assertEquals(0, rs.getInt(9));
    assertEquals(10, rs.getInt(10));
    assertEquals(1, rs.getInt(11));
    assertEquals("", rs.getString(12));
    assertTrue("null".equalsIgnoreCase(rs.getString(13)) || rs.getString(13) == null);
    assertEquals(0, rs.getInt(16));
    assertEquals(3, rs.getInt(17));
    assertEquals("YES", rs.getString(18));
    assertEquals(null, rs.getString(19));
    assertEquals(null, rs.getString(20));
    assertEquals(null, rs.getString(21));
    assertEquals(0, rs.getShort(22));
    assertEquals("NO", rs.getString(23));
    assertEquals("YES", rs.getString(24));
    assertTrue(rs.next());
    assertEquals("testj", rs.getString(1));
    assertEquals(null, rs.getString(2));
    assertEquals("tablegetcolumns", rs.getString(3));
    assertEquals("d", rs.getString(4));
    assertEquals(Types.VARCHAR, rs.getInt(5));
    assertEquals("VARCHAR", rs.getString(6));
    assertEquals(5, rs.getInt(7));
    assertEquals(0, rs.getInt(9));
    assertEquals(10, rs.getInt(10));
    assertEquals(1, rs.getInt(11));
    assertEquals("", rs.getString(12));
    assertTrue("null".equalsIgnoreCase(rs.getString(13)) || rs.getString(13) == null);
    assertEquals(5 * 4, rs.getInt(16));
    assertEquals(4, rs.getInt(17));
    assertEquals("YES", rs.getString(18));
    assertEquals(null, rs.getString(19));
    assertEquals(null, rs.getString(20));
    assertEquals(null, rs.getString(21));
    assertEquals(0, rs.getShort(22));
    assertEquals("NO", rs.getString(23));
    assertEquals("YES", rs.getString(24));
    assertFalse(rs.next());
}

######


private void testResultSetColumns(ResultSet rs, String spec) throws SQLException {
    ResultSetMetaData rsmd = rs.getMetaData();
    String[] tokens = spec.split(",");
    for (int i = 0; i < tokens.length; i++) {
        String[] splitTokens = tokens[i].trim().split(" ");
        String label = splitTokens[0];
        String type = splitTokens[1];
        int col = i + 1;
        assertEquals(label, rsmd.getColumnLabel(col));
        int columnType = rsmd.getColumnType(col);
        switch(type) {
            case "String":
                assertTrue("invalid type  " + columnType + " for " + rsmd.getColumnLabel(col) + ",expected String", columnType == Types.VARCHAR || columnType == Types.NULL || columnType == Types.LONGVARCHAR);
                break;
            case "decimal":
                assertTrue("invalid type  " + columnType + "( " + rsmd.getColumnTypeName(col) + " ) for " + rsmd.getColumnLabel(col) + ",expected decimal", columnType == Types.DECIMAL);
                break;
            case "int":
            case "short":
                assertTrue("invalid type  " + columnType + "( " + rsmd.getColumnTypeName(col) + " ) for " + rsmd.getColumnLabel(col) + ",expected numeric", columnType == Types.BIGINT || columnType == Types.INTEGER || columnType == Types.SMALLINT || columnType == Types.TINYINT);
                break;
            case "boolean":
                assertTrue("invalid type  " + columnType + "( " + rsmd.getColumnTypeName(col) + " ) for " + rsmd.getColumnLabel(col) + ",expected boolean", columnType == Types.BOOLEAN || columnType == Types.BIT);
                break;
            case "null":
                assertTrue("invalid type  " + columnType + " for " + rsmd.getColumnLabel(col) + ",expected null", columnType == Types.NULL);
                break;
            default:
                fail("invalid type '" + type + "'");
                break;
        }
    }
}

######


@Test
public void getAttributesBasic() throws Exception {
    testResultSetColumns(sharedConnection.getMetaData().getAttributes(null, null, null, null), "TYPE_CAT String,TYPE_SCHEM String,TYPE_NAME String," + "ATTR_NAME String,DATA_TYPE int,ATTR_TYPE_NAME String,ATTR_SIZE int,DECIMAL_DIGITS int," + "NUM_PREC_RADIX int,NULLABLE int,REMARKS String,ATTR_DEF String,SQL_DATA_TYPE int," + "SQL_DATETIME_SUB int, CHAR_OCTET_LENGTH int,ORDINAL_POSITION int,IS_NULLABLE String," + "SCOPE_CATALOG String,SCOPE_SCHEMA String," + "SCOPE_TABLE String,SOURCE_DATA_TYPE short");
}

######


public void resetOptions() {
    super.resetOptions();
    setRetrieval(NONE);
    m_tableName = "";
    m_Username = "";
    m_Password = "";
    m_count = 1;
    m_id = false;
    m_tabName = true;
    try {
        if (m_DataBaseConnection != null && m_DataBaseConnection.isConnected())
            m_DataBaseConnection.disconnectFromDatabase();
        m_DataBaseConnection = new DatabaseConnection();
    } catch (Exception ex) {
        printException(ex);
    }
}

######


public void cancel() {
    if (getWriteMode() == CANCEL) {
        try {
            m_DataBaseConnection.update("DROP TABLE " + m_tableName);
            if (m_DataBaseConnection.tableExists(m_tableName))
                System.err.println("Table cannot be dropped.");
        } catch (Exception ex) {
            printException(ex);
        }
        resetOptions();
    }
}

######


public String globalInfo() {
    return "Writes to a database (tested with MySQL, InstantDB, HSQLDB).";
}

######


public void setTableName(String tn) {
    m_tableName = tn;
}

######


public String getTableName() {
    return m_tableName;
}

######


public String tableNameTipText() {
    return "Sets the name of the table.";
}

######


public void setAutoKeyGeneration(boolean flag) {
    m_id = flag;
}

######


public boolean getAutoKeyGeneration() {
    return m_id;
}

######


public String autoKeyGenerationTipText() {
    return "If set to true, a primary key column is generated automatically (containing the row number as INTEGER). The name of the key is read from DatabaseUtils (idColumn)" + " This primary key can be used for incremental loading (requires an unique key). This primary key will not be loaded as an attribute.";
}

######


public void setRelationForTableName(boolean flag) {
    m_tabName = flag;
}

######


public boolean getRelationForTableName() {
    return m_tabName;
}

######


public String relationForTableNameTipText() {
    return "If set to true, the relation name will be used as name for the database table. Otherwise the user has to provide a table name.";
}

######


public void setUrl(String url) {
    m_DataBaseConnection.setDatabaseURL(url);
}

######


public String getUrl() {
    return m_DataBaseConnection.getDatabaseURL();
}

######


public String urlTipText() {
    return "The URL of the database";
}

######


public void setUser(String user) {
    m_Username = user;
    m_DataBaseConnection.setUsername(user);
}

######


public String getUser() {
    return m_DataBaseConnection.getUsername();
}

######


public String userTipText() {
    return "The user name for the database";
}

######


public void setPassword(String password) {
    m_Password = password;
    m_DataBaseConnection.setPassword(password);
}

######


public String getPassword() {
    return m_DataBaseConnection.getPassword();
}

######


public String passwordTipText() {
    return "The database password";
}

######


public void setDestination(String url, String userName, String password) {
    try {
        m_DataBaseConnection = new DatabaseConnection();
        m_DataBaseConnection.setDatabaseURL(url);
        m_DataBaseConnection.setUsername(userName);
        m_DataBaseConnection.setPassword(password);
    } catch (Exception ex) {
        printException(ex);
    }
}

######


public void setDestination(String url) {
    try {
        m_DataBaseConnection = new DatabaseConnection();
        m_DataBaseConnection.setDatabaseURL(url);
        m_DataBaseConnection.setUsername(m_Username);
        m_DataBaseConnection.setPassword(m_Password);
    } catch (Exception ex) {
        printException(ex);
    }
}

######


public void setDestination() {
    try {
        m_DataBaseConnection = new DatabaseConnection();
        m_DataBaseConnection.setUsername(m_Username);
        m_DataBaseConnection.setPassword(m_Password);
    } catch (Exception ex) {
        printException(ex);
    }
}

######


public Capabilities getCapabilities() {
    Capabilities result = super.getCapabilities();
    result.enable(Capability.NOMINAL_ATTRIBUTES);
    result.enable(Capability.NUMERIC_ATTRIBUTES);
    result.enable(Capability.DATE_ATTRIBUTES);
    result.enable(Capability.MISSING_VALUES);
    result.enable(Capability.NOMINAL_CLASS);
    result.enable(Capability.NUMERIC_CLASS);
    result.enable(Capability.DATE_CLASS);
    result.enable(Capability.NO_CLASS);
    result.enable(Capability.MISSING_CLASS_VALUES);
    return result;
}

######


public void connectToDatabase() {
    try {
        if (!m_DataBaseConnection.isConnected())
            m_DataBaseConnection.connectToDatabase();
    } catch (Exception ex) {
        printException(ex);
    }
}

######


private void writeStructure() throws Exception {
    StringBuffer query = new StringBuffer();
    Instances structure = getInstances();
    query.append("CREATE TABLE ");
    if (m_tabName || m_tableName.equals(""))
        m_tableName = structure.relationName();
    if (m_DataBaseConnection.getUpperCase()) {
        m_tableName = m_tableName.toUpperCase();
        m_createInt = m_createInt.toUpperCase();
        m_createDouble = m_createDouble.toUpperCase();
        m_createText = m_createText.toUpperCase();
    }
    m_tableName = m_tableName.replaceAll("[^\\w]", "_");
    query.append(m_tableName);
    if (structure.numAttributes() == 0)
        throw new Exception("Instances have no attribute.");
    query.append(" ( ");
    if (m_id) {
        if (m_DataBaseConnection.getUpperCase())
            m_idColumn = m_idColumn.toUpperCase();
        query.append(m_idColumn);
        query.append(" ");
        query.append(m_createInt);
        query.append(" PRIMARY KEY,");
    }
    for (int i = 0; i < structure.numAttributes(); i++) {
        Attribute att = structure.attribute(i);
        String attName = att.name();
        attName = attName.replaceAll("[^\\w]", "_");
        if (m_DataBaseConnection.getUpperCase())
            query.append(attName.toUpperCase());
        else
            query.append(attName);
        if (att.isDate())
            query.append(" DATE");
        else {
            if (att.isNumeric())
                query.append(" " + m_createDouble);
            else
                query.append(" " + m_createText);
        }
        if (i != structure.numAttributes() - 1)
            query.append(", ");
    }
    query.append(" )");
    m_DataBaseConnection.update(query.toString());
    m_DataBaseConnection.close();
    if (!m_DataBaseConnection.tableExists(m_tableName)) {
        throw new IOException("Table cannot be built.");
    }
}

######


private void writeInstance(Instance inst) throws Exception {
    StringBuffer insert = new StringBuffer();
    insert.append("INSERT INTO ");
    insert.append(m_tableName);
    insert.append(" VALUES ( ");
    if (m_id) {
        insert.append(m_count);
        insert.append(", ");
        m_count++;
    }
    for (int j = 0; j < inst.numAttributes(); j++) {
        if (inst.isMissing(j))
            insert.append("NULL");
        else {
            if ((inst.attribute(j)).isNumeric())
                insert.append(inst.value(j));
            else {
                String stringInsert = "'" + inst.stringValue(j) + "'";
                if (stringInsert.length() > 2)
                    stringInsert = stringInsert.replaceAll("''", "'");
                insert.append(stringInsert);
            }
        }
        if (j != inst.numAttributes() - 1)
            insert.append(", ");
    }
    insert.append(" )");
    if (m_DataBaseConnection.update(insert.toString()) < 1) {
        throw new IOException("Tuple cannot be inserted.");
    } else {
        m_DataBaseConnection.close();
    }
}

######


public void writeIncremental(Instance inst) throws IOException {
    int writeMode = getWriteMode();
    Instances structure = getInstances();
    if (m_DataBaseConnection == null)
        throw new IOException("No database has been set up.");
    if (getRetrieval() == BATCH)
        throw new IOException("Batch and incremental saving cannot be mixed.");
    setRetrieval(INCREMENTAL);
    try {
        if (!m_DataBaseConnection.isConnected())
            connectToDatabase();
        if (writeMode == WAIT) {
            if (structure == null) {
                setWriteMode(CANCEL);
                if (inst != null)
                    throw new Exception("Structure(Header Information) has to be set in advance");
            } else
                setWriteMode(STRUCTURE_READY);
            writeMode = getWriteMode();
        }
        if (writeMode == CANCEL) {
            cancel();
        }
        if (writeMode == STRUCTURE_READY) {
            setWriteMode(WRITE);
            writeStructure();
            writeMode = getWriteMode();
        }
        if (writeMode == WRITE) {
            if (structure == null)
                throw new IOException("No instances information available.");
            if (inst != null) {
                writeInstance(inst);
            } else {
                m_DataBaseConnection.disconnectFromDatabase();
                resetStructure();
                m_count = 1;
            }
        }
    } catch (Exception ex) {
        printException(ex);
    }
}

######


public void writeBatch() throws IOException {
    Instances instances = getInstances();
    if (instances == null)
        throw new IOException("No instances to save");
    if (getRetrieval() == INCREMENTAL)
        throw new IOException("Batch and incremental saving cannot be mixed.");
    if (m_DataBaseConnection == null)
        throw new IOException("No database has been set up.");
    setRetrieval(BATCH);
    try {
        if (!m_DataBaseConnection.isConnected())
            connectToDatabase();
        setWriteMode(WRITE);
        writeStructure();
        for (int i = 0; i < instances.numInstances(); i++) {
            writeInstance(instances.instance(i));
        }
        m_DataBaseConnection.disconnectFromDatabase();
        setWriteMode(WAIT);
        resetStructure();
        m_count = 1;
    } catch (Exception ex) {
        printException(ex);
    }
}

######


private void printException(Exception ex) {
    System.out.println("\n--- Exception caught ---\n");
    while (ex != null) {
        System.out.println("Message:   " + ex.getMessage());
        if (ex instanceof SQLException) {
            System.out.println("SQLState:  " + ((SQLException) ex).getSQLState());
            System.out.println("ErrorCode: " + ((SQLException) ex).getErrorCode());
            ex = ((SQLException) ex).getNextException();
        } else
            ex = null;
        System.out.println("");
    }
}

######


public String[] getOptions() {
    Vector options = new Vector();
    if ((getUrl() != null) && (getUrl().length() != 0)) {
        options.add("-url");
        options.add(getUrl());
    }
    if ((getUser() != null) && (getUser().length() != 0)) {
        options.add("-user");
        options.add(getUser());
    }
    if ((getPassword() != null) && (getPassword().length() != 0)) {
        options.add("-password");
        options.add(getPassword());
    }
    if ((m_tableName != null) && (m_tableName.length() != 0)) {
        options.add("-T");
        options.add(m_tableName);
    }
    if (m_id)
        options.add("-P");
    if ((m_inputFile != null) && (m_inputFile.length() != 0)) {
        options.add("-i");
        options.add(m_inputFile);
    }
    return (String[]) options.toArray(new String[options.size()]);
}

######


public java.util.Enumeration listOptions() {
    FastVector newVector = new FastVector();
    newVector.addElement(new Option("\tThe JDBC URL to connect to.\n" + "\t(default: from DatabaseUtils.props file)", "url", 1, "-url <JDBC URL>"));
    newVector.addElement(new Option("\tThe user to connect with to the database.\n" + "\t(default: none)", "user", 1, "-user <name>"));
    newVector.addElement(new Option("\tThe password to connect with to the database.\n" + "\t(default: none)", "password", 1, "-password <password>"));
    newVector.addElement(new Option("\tThe name of the table.\n" + "\t(default: the relation name)", "T", 1, "-T <table name>"));
    newVector.addElement(new Option("\tAdd an ID column as primary key. The name is specified\n" + "\tin the DatabaseUtils file ('idColumn'). The DatabaseLoader\n" + "\twon't load this column.", "P", 0, "-P"));
    newVector.addElement(new Option("\tInput file in arff format that should be saved in database.", "i", 1, "-i <input file name>"));
    return newVector.elements();
}

######


public void setOptions(String[] options) throws Exception {
    String tableString, inputString, tmpStr;
    resetOptions();
    tmpStr = Utils.getOption("url", options);
    if (tmpStr.length() != 0)
        setUrl(tmpStr);
    tmpStr = Utils.getOption("user", options);
    if (tmpStr.length() != 0)
        setUser(tmpStr);
    tmpStr = Utils.getOption("password", options);
    if (tmpStr.length() != 0)
        setPassword(tmpStr);
    tableString = Utils.getOption('T', options);
    inputString = Utils.getOption('i', options);
    if (tableString.length() != 0) {
        m_tableName = tableString;
        m_tabName = false;
    }
    m_id = Utils.getFlag('P', options);
    if (inputString.length() != 0) {
        try {
            m_inputFile = inputString;
            ArffLoader al = new ArffLoader();
            File inputFile = new File(inputString);
            al.setSource(inputFile);
            setInstances(al.getDataSet());
            if (tableString.length() == 0)
                m_tableName = getInstances().relationName();
        } catch (Exception ex) {
            printException(ex);
            ex.printStackTrace();
        }
    }
}

######


public String getRevision() {
    return RevisionUtils.extract("$Revision: 1.1 $");
}

######


public static void main(String[] options) {
    StringBuffer text = new StringBuffer();
    text.append("\n\nDatabaseSaver options:\n");
    try {
        DatabaseSaver asv = new DatabaseSaver();
        try {
            Enumeration enumi = asv.listOptions();
            while (enumi.hasMoreElements()) {
                Option option = (Option) enumi.nextElement();
                text.append(option.synopsis() + '\n');
                text.append(option.description() + '\n');
            }
            asv.setOptions(options);
            asv.setDestination();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        asv.writeBatch();
    } catch (Exception ex) {
        ex.printStackTrace();
        System.out.println(text);
    }
}

######


@Override
protected void onCreate(Bundle savedInstanceState) {
    TextView textView;
    super.onCreate(savedInstanceState);
    setContentView(R.layout.add);
}

######


public void createTable() {
    db = getBaseContext().openOrCreateDatabase("app.db", MODE_PRIVATE, null);
}

######


public static int getCount() {
    int count = 0;
    Cursor query = db.rawQuery("SELECT * FROM users;", null);
    if (query.moveToFirst()) {
        count = query.getInt(1);
    }
    query.close();
    return count;
}

######


public static void setData(int count) {
}

######


public static void addData() {
    db.execSQL("INSERT INTO" + TABLE_NAME + " VALUES (1, 0);");
}

######


public static String loadDatabaseDriver(String connectionUrl, String connectionDriver) throws ClassNotFoundException {
    if (StringUtils.hasText(connectionDriver)) {
        Class.forName(connectionDriver);
        log.debug("set user defined Database driver class: " + connectionDriver);
    } else {
        if (connectionUrl.contains("mysql")) {
            Class.forName("com.mysql.jdbc.Driver");
            connectionDriver = "com.mysql.jdbc.Driver";
        } else if (connectionUrl.contains("hsqldb")) {
            Class.forName("org.hsqldb.jdbcDriver");
            connectionDriver = "org.hsqldb.jdbcDriver";
        } else if (connectionUrl.contains("postgresql")) {
            Class.forName("org.postgresql.Driver");
            connectionDriver = "org.postgresql.Driver";
        } else if (connectionUrl.contains("oracle")) {
            Class.forName("oracle.jdbc.driver.OracleDriver");
            connectionDriver = "oracle.jdbc.driver.OracleDriver";
        } else if (connectionUrl.contains("jtds")) {
            Class.forName("net.sourceforge.jtds.jdbc.Driver");
            connectionDriver = "net.sourceforge.jtds.jdbc.Driver";
        } else if (connectionUrl.contains("sqlserver")) {
            Class.forName("com.microsoft.jdbc.sqlserver.SQLServerDriver");
            connectionDriver = "com.microsoft.jdbc.sqlserver.SQLServerDriver";
        }
    }
    log.info("Set database driver class as " + connectionDriver);
    return connectionDriver;
}

######


public static List<List<Object>> executeSQL(Session session, String sql, boolean selectOnly) throws DAOException {
    sql = sql.trim();
    boolean dataManipulation = checkQueryForManipulationCommands(sql, selectOnly);
    final List<List<Object>> result = new ArrayList<>();
    final String query = sql;
    final boolean sessionDataManipulation = dataManipulation;
    session.doWork(conn -> populateResultsFromSQLQuery(conn, query, sessionDataManipulation, result));
    return result;
}

######


public static List<List<Object>> executeSQL(Connection conn, String sql, boolean selectOnly) throws DAOException {
    sql = sql.trim();
    boolean dataManipulation = checkQueryForManipulationCommands(sql, selectOnly);
    List<List<Object>> result = new ArrayList<>();
    populateResultsFromSQLQuery(conn, sql, dataManipulation, result);
    return result;
}

######


private static boolean checkQueryForManipulationCommands(String sql, boolean selectOnly) {
    boolean dataManipulation = false;
    String sqlLower = sql.toLowerCase();
    if (sqlLower.startsWith("insert") || sqlLower.startsWith("update") || sqlLower.startsWith("delete") || sqlLower.startsWith("alter") || sqlLower.startsWith("drop") || sqlLower.startsWith("create") || sqlLower.startsWith("rename")) {
        dataManipulation = true;
    }
    if (selectOnly && dataManipulation) {
        throw new IllegalArgumentException("Illegal command(s) found in query string");
    }
    return dataManipulation;
}

######


private static void populateResultsFromSQLQuery(Connection conn, String sql, boolean dataManipulation, List<List<Object>> results) {
    PreparedStatement ps = null;
    try {
        ps = conn.prepareStatement(sql);
        if (dataManipulation) {
            Integer i = ps.executeUpdate();
            List<Object> row = new ArrayList<>();
            row.add(i);
            results.add(row);
        } else {
            ResultSet resultSet = ps.executeQuery();
            ResultSetMetaData rmd = resultSet.getMetaData();
            int columnCount = rmd.getColumnCount();
            while (resultSet.next()) {
                List<Object> rowObjects = new ArrayList<>();
                for (int x = 1; x <= columnCount; x++) {
                    rowObjects.add(resultSet.getObject(x));
                }
                results.add(rowObjects);
            }
        }
    } catch (Exception e) {
        log.debug("Error while running sql: " + sql, e);
        throw new DAOException("Error while running sql: " + sql + " . Message: " + e.getMessage(), e);
    } finally {
        if (ps != null) {
            try {
                ps.close();
            } catch (SQLException e) {
                log.error("Error generated while closing statement", e);
            }
        }
    }
}

######


public static <T> Set<T> getUniqueNonNullColumnValues(String columnName, String tableName, Class<T> type, Connection connection) throws Exception {
    Set<T> uniqueValues = new HashSet<>();
    final String alias = "unique_values";
    String select = "SELECT DISTINCT " + columnName + " AS " + alias + " FROM " + tableName + " WHERE " + columnName + " IS NOT NULL";
    List<List<Object>> rows = DatabaseUtil.executeSQL(connection, select, true);
    for (List<Object> row : rows) {
        uniqueValues.add((T) row.get(0));
    }
    return uniqueValues;
}

######


protected String attributeCaseFix(String columnName) {
    if (m_checkForUpperCaseNames) {
        String ucname = columnName.toUpperCase();
        if (ucname.equals(EXP_TYPE_COL.toUpperCase())) {
            return EXP_TYPE_COL;
        } else if (ucname.equals(EXP_SETUP_COL.toUpperCase())) {
            return EXP_SETUP_COL;
        } else if (ucname.equals(EXP_RESULT_COL.toUpperCase())) {
            return EXP_RESULT_COL;
        } else {
            return columnName;
        }
    } else if (m_checkForLowerCaseNames) {
        String ucname = columnName.toLowerCase();
        if (ucname.equals(EXP_TYPE_COL.toLowerCase())) {
            return EXP_TYPE_COL;
        } else if (ucname.equals(EXP_SETUP_COL.toLowerCase())) {
            return EXP_SETUP_COL;
        } else if (ucname.equals(EXP_RESULT_COL.toLowerCase())) {
            return EXP_RESULT_COL;
        } else {
            return columnName;
        }
    } else {
        return columnName;
    }
}

######


public int translateDBColumnType(String type) {
    try {
        String value = PROPERTIES.getProperty(type);
        String typeUnderscore = type.replaceAll(" ", "_");
        if (value == null)
            value = PROPERTIES.getProperty(typeUnderscore);
        return Integer.parseInt(value);
    } catch (NumberFormatException e) {
        throw new IllegalArgumentException("Unknown data type: " + type + ". " + "Add entry in " + PROPERTY_FILE + ".\n" + "If the type contains blanks, either escape them with a backslash " + "or use underscores instead of blanks.");
    }
}

######


public static String arrayToString(Object[] array) {
    String result = "";
    if (array == null) {
        result = "<null>";
    } else {
        for (int i = 0; i < array.length; i++) {
            if (array[i] == null) {
                result += " ?";
            } else {
                result += " " + array[i];
            }
        }
    }
    return result;
}

######


public static String typeName(int type) {
    switch(type) {
        case Types.BIGINT:
            return "BIGINT ";
        case Types.BINARY:
            return "BINARY";
        case Types.BIT:
            return "BIT";
        case Types.CHAR:
            return "CHAR";
        case Types.DATE:
            return "DATE";
        case Types.DECIMAL:
            return "DECIMAL";
        case Types.DOUBLE:
            return "DOUBLE";
        case Types.FLOAT:
            return "FLOAT";
        case Types.INTEGER:
            return "INTEGER";
        case Types.LONGVARBINARY:
            return "LONGVARBINARY";
        case Types.LONGVARCHAR:
            return "LONGVARCHAR";
        case Types.NULL:
            return "NULL";
        case Types.NUMERIC:
            return "NUMERIC";
        case Types.OTHER:
            return "OTHER";
        case Types.REAL:
            return "REAL";
        case Types.SMALLINT:
            return "SMALLINT";
        case Types.TIME:
            return "TIME";
        case Types.TIMESTAMP:
            return "TIMESTAMP";
        case Types.TINYINT:
            return "TINYINT";
        case Types.VARBINARY:
            return "VARBINARY";
        case Types.VARCHAR:
            return "VARCHAR";
        default:
            return "Unknown";
    }
}

######


public String databaseURLTipText() {
    return "Set the URL to the database.";
}

######


public String getDatabaseURL() {
    return m_DatabaseURL;
}

######


public void setDatabaseURL(String newDatabaseURL) {
    m_DatabaseURL = newDatabaseURL;
}

######


public String debugTipText() {
    return "Whether debug information is printed.";
}

######


public void setDebug(boolean d) {
    m_Debug = d;
}

######


public boolean getDebug() {
    return m_Debug;
}

######


public String usernameTipText() {
    return "The user to use for connecting to the database.";
}

######


public void setUsername(String username) {
    m_userName = username;
}

######


public String getUsername() {
    return m_userName;
}

######


public String passwordTipText() {
    return "The password to use for connecting to the database.";
}

######


public void setPassword(String password) {
    m_password = password;
}

######


public String getPassword() {
    return m_password;
}

######


public void connectToDatabase() throws Exception {
    if (m_Debug) {
        System.err.println("Connecting to " + m_DatabaseURL);
    }
    if (m_Connection == null) {
        if (m_userName.equals("")) {
            try {
                m_Connection = DriverManager.getConnection(m_DatabaseURL);
            } catch (java.sql.SQLException e) {
                for (int i = 0; i < DRIVERS.size(); i++) {
                    try {
                        Class.forName((String) DRIVERS.elementAt(i));
                    } catch (Exception ex) {
                    }
                }
                m_Connection = DriverManager.getConnection(m_DatabaseURL);
            }
        } else {
            try {
                m_Connection = DriverManager.getConnection(m_DatabaseURL, m_userName, m_password);
            } catch (java.sql.SQLException e) {
                for (int i = 0; i < DRIVERS.size(); i++) {
                    try {
                        Class.forName((String) DRIVERS.elementAt(i));
                    } catch (Exception ex) {
                    }
                }
                m_Connection = DriverManager.getConnection(m_DatabaseURL, m_userName, m_password);
            }
        }
    }
    m_Connection.setAutoCommit(m_setAutoCommit);
}

######


public void disconnectFromDatabase() throws Exception {
    if (m_Debug) {
        System.err.println("Disconnecting from " + m_DatabaseURL);
    }
    if (m_Connection != null) {
        m_Connection.close();
        m_Connection = null;
    }
}

######


public boolean isConnected() {
    return (m_Connection != null);
}

######


public boolean isCursorScrollSensitive() {
    boolean result;
    result = false;
    try {
        if (isConnected())
            result = m_Connection.getMetaData().supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
    } catch (Exception e) {
    }
    return result;
}

######


public boolean isCursorScrollable() {
    return (getSupportedCursorScrollType() != -1);
}

######


public int getSupportedCursorScrollType() {
    int result;
    result = -1;
    try {
        if (isConnected()) {
            if (m_Connection.getMetaData().supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY))
                result = ResultSet.TYPE_SCROLL_SENSITIVE;
            if (result == -1) {
                if (m_Connection.getMetaData().supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY))
                    result = ResultSet.TYPE_SCROLL_INSENSITIVE;
            }
        }
    } catch (Exception e) {
    }
    return result;
}

######


public boolean execute(String query) throws SQLException {
    if (!isConnected())
        throw new IllegalStateException("Not connected, please connect first!");
    if (!isCursorScrollable())
        m_PreparedStatement = m_Connection.prepareStatement(query, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    else
        m_PreparedStatement = m_Connection.prepareStatement(query, getSupportedCursorScrollType(), ResultSet.CONCUR_READ_ONLY);
    return (m_PreparedStatement.execute());
}

######


public ResultSet getResultSet() throws SQLException {
    if (m_PreparedStatement != null)
        return m_PreparedStatement.getResultSet();
    else
        return null;
}

######


public int update(String query) throws SQLException {
    if (!isConnected())
        throw new IllegalStateException("Not connected, please connect first!");
    Statement statement;
    if (!isCursorScrollable())
        statement = m_Connection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    else
        statement = m_Connection.createStatement(getSupportedCursorScrollType(), ResultSet.CONCUR_READ_ONLY);
    int result = statement.executeUpdate(query);
    statement.close();
    return result;
}

######


public ResultSet select(String query) throws SQLException {
    if (!isConnected())
        throw new IllegalStateException("Not connected, please connect first!");
    Statement statement;
    if (!isCursorScrollable())
        statement = m_Connection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    else
        statement = m_Connection.createStatement(getSupportedCursorScrollType(), ResultSet.CONCUR_READ_ONLY);
    ResultSet result = statement.executeQuery(query);
    return result;
}

######


public void close(ResultSet rs) {
    try {
        Statement statement = rs.getStatement();
        rs.close();
        statement.close();
        statement = null;
        rs = null;
    } catch (Exception e) {
    }
}

######


public void close() {
    if (m_PreparedStatement != null) {
        try {
            m_PreparedStatement.close();
            m_PreparedStatement = null;
        } catch (Exception e) {
        }
    }
}

######


public boolean tableExists(String tableName) throws Exception {
    if (!isConnected())
        throw new IllegalStateException("Not connected, please connect first!");
    if (m_Debug) {
        System.err.println("Checking if table " + tableName + " exists...");
    }
    DatabaseMetaData dbmd = m_Connection.getMetaData();
    ResultSet rs;
    if (m_checkForUpperCaseNames) {
        rs = dbmd.getTables(null, null, tableName.toUpperCase(), null);
    } else if (m_checkForLowerCaseNames) {
        rs = dbmd.getTables(null, null, tableName.toLowerCase(), null);
    } else {
        rs = dbmd.getTables(null, null, tableName, null);
    }
    boolean tableExists = rs.next();
    if (rs.next()) {
        throw new Exception("This table seems to exist more than once!");
    }
    rs.close();
    if (m_Debug) {
        if (tableExists) {
            System.err.println("... " + tableName + " exists");
        } else {
            System.err.println("... " + tableName + " does not exist");
        }
    }
    return tableExists;
}

######


public static String processKeyString(String s) {
    return s.replaceAll("\\\\", "/").replaceAll("'", "''");
}

######


protected boolean isKeyInTable(String tableName, ResultProducer rp, Object[] key) throws Exception {
    String query = "SELECT Key_Run" + " FROM " + tableName;
    String[] keyNames = rp.getKeyNames();
    if (keyNames.length != key.length) {
        throw new Exception("Key names and key values of different lengths");
    }
    boolean first = true;
    for (int i = 0; i < key.length; i++) {
        if (key[i] != null) {
            if (first) {
                query += " WHERE ";
                first = false;
            } else {
                query += " AND ";
            }
            query += "Key_" + keyNames[i] + '=';
            if (key[i] instanceof String) {
                query += "'" + processKeyString(key[i].toString()) + "'";
            } else {
                query += key[i].toString();
            }
        }
    }
    boolean retval = false;
    ResultSet rs = select(query);
    if (rs.next()) {
        retval = true;
        if (rs.next()) {
            throw new Exception("More than one result entry " + "for result key: " + query);
        }
    }
    close(rs);
    return retval;
}

######


public Object[] getResultFromTable(String tableName, ResultProducer rp, Object[] key) throws Exception {
    String query = "SELECT ";
    String[] resultNames = rp.getResultNames();
    for (int i = 0; i < resultNames.length; i++) {
        if (i != 0) {
            query += ", ";
        }
        query += resultNames[i];
    }
    query += " FROM " + tableName;
    String[] keyNames = rp.getKeyNames();
    if (keyNames.length != key.length) {
        throw new Exception("Key names and key values of different lengths");
    }
    boolean first = true;
    for (int i = 0; i < key.length; i++) {
        if (key[i] != null) {
            if (first) {
                query += " WHERE ";
                first = false;
            } else {
                query += " AND ";
            }
            query += "Key_" + keyNames[i] + '=';
            if (key[i] instanceof String) {
                query += "'" + processKeyString(key[i].toString()) + "'";
            } else {
                query += key[i].toString();
            }
        }
    }
    ResultSet rs = select(query);
    ResultSetMetaData md = rs.getMetaData();
    int numAttributes = md.getColumnCount();
    if (!rs.next()) {
        throw new Exception("No result for query: " + query);
    }
    Object[] result = new Object[numAttributes];
    for (int i = 1; i <= numAttributes; i++) {
        switch(translateDBColumnType(md.getColumnTypeName(i))) {
            case STRING:
                result[i - 1] = rs.getString(i);
                if (rs.wasNull()) {
                    result[i - 1] = null;
                }
                break;
            case FLOAT:
            case DOUBLE:
                result[i - 1] = new Double(rs.getDouble(i));
                if (rs.wasNull()) {
                    result[i - 1] = null;
                }
                break;
            default:
                throw new Exception("Unhandled SQL result type (field " + (i + 1) + "): " + DatabaseUtils.typeName(md.getColumnType(i)));
        }
    }
    if (rs.next()) {
        throw new Exception("More than one result entry " + "for result key: " + query);
    }
    close(rs);
    return result;
}

######


public void putResultInTable(String tableName, ResultProducer rp, Object[] key, Object[] result) throws Exception {
    String query = "INSERT INTO " + tableName + " VALUES ( ";
    for (int i = 0; i < key.length; i++) {
        if (i != 0) {
            query += ',';
        }
        if (key[i] != null) {
            if (key[i] instanceof String) {
                query += "'" + processKeyString(key[i].toString()) + "'";
            } else if (key[i] instanceof Double) {
                query += safeDoubleToString((Double) key[i]);
            } else {
                query += key[i].toString();
            }
        } else {
            query += "NULL";
        }
    }
    for (int i = 0; i < result.length; i++) {
        query += ',';
        if (result[i] != null) {
            if (result[i] instanceof String) {
                query += "'" + result[i].toString() + "'";
            } else if (result[i] instanceof Double) {
                query += safeDoubleToString((Double) result[i]);
            } else {
                query += result[i].toString();
            }
        } else {
            query += "NULL";
        }
    }
    query += ')';
    if (m_Debug) {
        System.err.println("Submitting result: " + query);
    }
    update(query);
    close();
}

######


private String safeDoubleToString(Double number) {
    if (number.isNaN())
        return "NULL";
    String orig = number.toString();
    int pos = orig.indexOf('E');
    if ((pos == -1) || (orig.charAt(pos + 1) == '-')) {
        return orig;
    } else {
        StringBuffer buff = new StringBuffer(orig);
        buff.insert(pos + 1, '+');
        return new String(buff);
    }
}

######


public boolean experimentIndexExists() throws Exception {
    return tableExists(EXP_INDEX_TABLE);
}

######


public void createExperimentIndex() throws Exception {
    if (m_Debug) {
        System.err.println("Creating experiment index table...");
    }
    String query;
    query = "CREATE TABLE " + EXP_INDEX_TABLE + " ( " + EXP_TYPE_COL + " " + m_stringType + "," + "  " + EXP_SETUP_COL + " " + m_stringType + "," + "  " + EXP_RESULT_COL + " " + m_intType + " )";
    update(query);
    close();
}

######


public String createExperimentIndexEntry(ResultProducer rp) throws Exception {
    if (m_Debug) {
        System.err.println("Creating experiment index entry...");
    }
    int numRows = 0;
    String query = "SELECT COUNT(*) FROM " + EXP_INDEX_TABLE;
    ResultSet rs = select(query);
    if (m_Debug) {
        System.err.println("...getting number of rows");
    }
    if (rs.next()) {
        numRows = rs.getInt(1);
    }
    close(rs);
    String expType = rp.getClass().getName();
    String expParams = rp.getCompatibilityState();
    query = "INSERT INTO " + EXP_INDEX_TABLE + " VALUES ('" + expType + "', '" + expParams + "', " + numRows + " )";
    if (update(query) > 0) {
        if (m_Debug) {
            System.err.println("...create returned resultset");
        }
    }
    close();
    if (!m_setAutoCommit) {
        m_Connection.commit();
        m_Connection.setAutoCommit(true);
    }
    String tableName = getResultsTableName(rp);
    if (tableName == null) {
        throw new Exception("Problem adding experiment index entry");
    }
    try {
        query = "DROP TABLE " + tableName;
        if (m_Debug) {
            System.err.println(query);
        }
        update(query);
    } catch (SQLException ex) {
        System.err.println(ex.getMessage());
    }
    return tableName;
}

######


public String getResultsTableName(ResultProducer rp) throws Exception {
    if (m_Debug) {
        System.err.println("Getting results table name...");
    }
    String expType = rp.getClass().getName();
    String expParams = rp.getCompatibilityState();
    String query = "SELECT " + EXP_RESULT_COL + " FROM " + EXP_INDEX_TABLE + " WHERE " + EXP_TYPE_COL + "='" + expType + "' AND " + EXP_SETUP_COL + "='" + expParams + "'";
    String tableName = null;
    ResultSet rs = select(query);
    if (rs.next()) {
        tableName = rs.getString(1);
        if (rs.next()) {
            throw new Exception("More than one index entry " + "for experiment config: " + query);
        }
    }
    close(rs);
    if (m_Debug) {
        System.err.println("...results table = " + ((tableName == null) ? "<null>" : EXP_RESULT_PREFIX + tableName));
    }
    return (tableName == null) ? tableName : EXP_RESULT_PREFIX + tableName;
}

######


public String createResultsTable(ResultProducer rp, String tableName) throws Exception {
    if (m_Debug) {
        System.err.println("Creating results table " + tableName + "...");
    }
    String query = "CREATE TABLE " + tableName + " ( ";
    String[] names = rp.getKeyNames();
    Object[] types = rp.getKeyTypes();
    if (names.length != types.length) {
        throw new Exception("key names types differ in length");
    }
    for (int i = 0; i < names.length; i++) {
        query += "Key_" + names[i] + " ";
        if (types[i] instanceof Double) {
            query += m_doubleType;
        } else if (types[i] instanceof String) {
            query += m_stringType + " ";
        } else {
            throw new Exception("Unknown/unsupported field type in key");
        }
        query += ", ";
    }
    names = rp.getResultNames();
    types = rp.getResultTypes();
    if (names.length != types.length) {
        throw new Exception("result names and types differ in length");
    }
    for (int i = 0; i < names.length; i++) {
        query += names[i] + " ";
        if (types[i] instanceof Double) {
            query += m_doubleType;
        } else if (types[i] instanceof String) {
            query += m_stringType + " ";
        } else {
            throw new Exception("Unknown/unsupported field type in key");
        }
        if (i < names.length - 1) {
            query += ", ";
        }
    }
    query += " )";
    update(query);
    if (m_Debug)
        System.err.println("table created");
    close();
    if (m_createIndex) {
        query = "CREATE UNIQUE INDEX Key_IDX ON " + tableName + " (";
        String[] keyNames = rp.getKeyNames();
        boolean first = true;
        for (int i = 0; i < keyNames.length; i++) {
            if (keyNames[i] != null) {
                if (first) {
                    first = false;
                    query += "Key_" + keyNames[i];
                } else {
                    query += ",Key_" + keyNames[i];
                }
            }
        }
        query += ")";
        update(query);
    }
    return tableName;
}

######


public String getRevision() {
    return RevisionUtils.extract("$Revision: 1.1 $");
}

######


@Override
protected Void doInBackground(Object... params) {
    final String tt = t + "doInBackground(): ";
    mHandler = (Handler) params[0];
    mFormDefinition = (FormDefinition) params[1];
    mExportOptions = (Bundle) params[2];
    int i;
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    try {
        publishProgress("Retreiving form template...");
        AttachmentInputStream ais = Collect.getInstance().getDbService().getDb().getAttachment(mFormDefinition.getId(), "xml");
        publishProgress("Parsing template...");
        mFormReader = new FormReader(ais, false);
        ais.close();
        publishProgress("Generating headers...");
        if (mExportOptions.getBoolean(DataExportActivity.KEY_OUTPUT_RECORD_METADATA, false)) {
            mExportHeaders.put("formDefinitionName", "Template Name");
            mExportHeaders.put("formDefinitionUuid", "Template ID");
        }
        mExportHeaders.put("rowId", "Row Number");
        mExportHeaders.put("recordUuid", "Record ID");
        if (mExportOptions.getBoolean(DataExportActivity.KEY_OUTPUT_RECORD_METADATA, false)) {
            mExportHeaders.put("dateCreated", "Record Date Created");
            mExportHeaders.put("createdBy", "Record Created By");
            mExportHeaders.put("dateUpdated", "Record Date Updated");
            mExportHeaders.put("updatedBy", "Record Updated By");
            mExportHeaders.put("recordStatus", "Record Status");
        }
        generateExportHeaders(mFormReader.getInstance());
        if (mErrorMsg != null)
            return null;
        publishProgress("Retrieving records...");
        List<FormInstance> unfilteredList = ((FormInstanceRepo) new FormInstanceRepo(Collect.getInstance().getDbService().getDb())).findByFormId(mFormDefinition.getId());
        for (i = 0; i < unfilteredList.size(); i++) {
            if (unfilteredList.get(i).getStatus().equals(FormInstance.Status.complete) && mExportOptions.getBoolean(DataExportActivity.KEY_EXPORT_COMPLETED, false)) {
                mExportList.add(unfilteredList.get(i));
            }
            if (unfilteredList.get(i).getStatus().equals(FormInstance.Status.draft) && mExportOptions.getBoolean(DataExportActivity.KEY_EXPORT_DRAFT, false)) {
                mExportList.add(unfilteredList.get(i));
            }
        }
        if (mExportList.size() == 0) {
            mErrorMsg = "No records found to export!";
            return null;
        }
        String prefix = "export_" + getExportTimestamp();
        String exportPath = Environment.getExternalStorageDirectory() + File.separator + prefix + File.separator;
        FileUtils.createFolder(exportPath);
        for (i = 0; i < mExportList.size(); i++) {
            int idx = i + 1;
            publishProgress("Exporting record " + idx + "/" + mExportList.size());
            FormInstance instance = mExportList.get(i);
            String instancePath = exportPath + File.separator + idx + "-" + instance.getId() + ".xml";
            if (Collect.Log.VERBOSE)
                Log.v(Collect.LOGTAG, tt + "processing " + instance.getId() + " for export");
            HashMap<String, Attachment> attachments = (HashMap<String, Attachment>) instance.getAttachments();
            if (attachments == null) {
                if (Collect.Log.WARN)
                    Log.w(Collect.LOGTAG, t + "skipping attachment download for " + instance.getId() + ": no attachments!");
                continue;
            }
            for (Entry<String, Attachment> entry : attachments.entrySet()) {
                String key = entry.getKey();
                FileOutputStream file;
                if (key.equals("xml")) {
                    file = new FileOutputStream(instancePath);
                } else {
                    if (mExportOptions.getBoolean(DataExportActivity.KEY_OUTPUT_MEDIA_FILES, false)) {
                        file = new FileOutputStream(exportPath + File.separator + idx + "-" + instance.getId() + "-" + key);
                    } else {
                        continue;
                    }
                }
                ais = Collect.getInstance().getDbService().getDb().getAttachment(instance.getId(), key);
                byte[] buffer = new byte[8192];
                int bytesRead = 0;
                while ((bytesRead = ais.read(buffer)) != -1) {
                    file.write(buffer, 0, bytesRead);
                }
                file.close();
                ais.close();
            }
            mExportData.add(new HashMap<String, Object>());
            if (mExportOptions.getBoolean(DataExportActivity.KEY_OUTPUT_RECORD_METADATA, false)) {
                mExportData.getLast().put(mExportHeaders.get("formDefinitionUuid"), getStringValue(mFormDefinition.getId()));
                mExportData.getLast().put(mExportHeaders.get("formDefinitionName"), getStringValue(mFormDefinition.getName()));
            }
            mExportData.getLast().put(mExportHeaders.get("rowId"), idx);
            mExportData.getLast().put(mExportHeaders.get("recordUuid"), instance.getId());
            if (mExportOptions.getBoolean(DataExportActivity.KEY_OUTPUT_RECORD_METADATA, false)) {
                mExportData.getLast().put(mExportHeaders.get("recordStatus"), getStringValue(instance.getStatus().toString()));
                mExportData.getLast().put(mExportHeaders.get("dateCreated"), getStringValue(instance.getDateCreated()));
                mExportData.getLast().put(mExportHeaders.get("createdBy"), getStringValue(instance.getCreatedByAlias()));
                mExportData.getLast().put(mExportHeaders.get("dateUpdated"), getStringValue(instance.getDateUpdated()));
                mExportData.getLast().put(mExportHeaders.get("updatedBy"), getStringValue(instance.getUpdatedByAlias()));
            }
            FileInputStream fis = new FileInputStream(new File(instancePath));
            XMLTag instanceXml = XMLDoc.from(fis, false);
            readData(instanceXml, "/" + instanceXml.getCurrentTagName());
            fis.close();
            if (!mExportOptions.getBoolean(DataExportActivity.KEY_OUTPUT_XFORM_FILES, false)) {
                new File(instancePath).delete();
            }
        }
        publishProgress("Writing CSV file...");
        ICsvMapWriter writer = new CsvMapWriter(new FileWriter(exportPath + prefix + ".csv"), CsvPreference.EXCEL_PREFERENCE);
        Object[] headerObjects = mExportHeaders.values().toArray();
        String[] headers = Arrays.asList(headerObjects).toArray(new String[headerObjects.length]);
        writer.writeHeader(headers);
        for (i = 0; i < mExportData.size(); i++) {
            writer.write(mExportData.get(i), headers);
        }
        writer.close();
        String exportTally = mExportData.size() + "/" + mExportList.size();
        if (mExportOptions.getBoolean(DataExportActivity.KEY_OUTPUT_ZIP, false)) {
            publishProgress("Compressing exported data...");
            String zip = Environment.getExternalStorageDirectory() + File.separator + prefix + ".zip";
            ZipArchiveOutputStream os = new ZipArchiveOutputStream(new File(zip));
            if (Collect.Log.DEBUG)
                Log.d(Collect.LOGTAG, tt + "creating zip file " + zip);
            for (File f : new File(exportPath).listFiles()) {
                if (Collect.Log.VERBOSE)
                    Log.v(Collect.LOGTAG, tt + "adding " + f.getName() + " to zip file");
                os.putArchiveEntry(os.createArchiveEntry(f, f.getName()));
                FileInputStream is = new FileInputStream(f);
                byte[] buffer = new byte[8192];
                int bytesRead = 0;
                while ((bytesRead = is.read(buffer)) != -1) {
                    os.write(buffer, 0, bytesRead);
                }
                is.close();
                os.closeArchiveEntry();
            }
            os.close();
            FileUtilsExtended.deleteFolder(exportPath);
            mCompleteMsg = exportTally + " records have been successfully exported to the external storage on this device.\n\nPlease look for a ZIP file with the following name:\n\n" + prefix;
        } else {
            mCompleteMsg = exportTally + " records have been successfully exported to the external storage on this device.\n\nPlease look for a folder with the following name:\n\n" + prefix;
        }
        if (mExportOptions.getBoolean(DataExportActivity.KEY_OUTPUT_SEND, false)) {
            mAttachmentPath = FileUtilsExtended.EXTERNAL_CACHE + File.separator + prefix + ".zip";
            org.apache.commons.io.FileUtils.copyFile(new File(Environment.getExternalStorageDirectory() + File.separator + prefix + ".zip"), new File(mAttachmentPath));
            if (mExportOptions.getBoolean(DataExportActivity.KEY_OUTPUT_EXTERNAL, false)) {
                mCompleteMsg = mCompleteMsg + "\n\nSelect \"Send\" to compose an email with the exported data attached in a ZIP file or to transfer the file via Bluetooth.";
            } else {
                new File(Environment.getExternalStorageDirectory() + File.separator + prefix + ".zip").delete();
                mCompleteMsg = exportTally + " records have been successfully exported.\n\nSelect \"Send\" to compose an email with the exported data attached in a ZIP file or to transfer the file via Bluetooth.";
            }
        }
    } catch (Exception e) {
        if (Collect.Log.ERROR)
            Log.e(Collect.LOGTAG, t + "problem exporting data: " + e.toString());
        e.printStackTrace();
        mErrorMsg = "An error occured while exporting your data. Please contact our support team at support@groupcomplete.com with this error message:\n\n" + e.toString();
    }
    return null;
}

######


@Override
protected void onProgressUpdate(String... values) {
    Message update = Message.obtain();
    update.what = PROGRESS;
    Bundle data = new Bundle();
    data.putString(DataExportActivity.KEY_PROGRESS_MSG, values[0]);
    update.setData(data);
    mHandler.sendMessage(update);
}

######


@Override
protected void onPostExecute(Void nothing) {
    synchronized (this) {
        if (mStateListener != null) {
            Message done = Message.obtain();
            done.what = COMPLETE;
            mHandler.sendMessage(done);
            if (mErrorMsg == null) {
                Bundle b = new Bundle();
                b.putString(DataExportListener.KEY_MESSAGE, mCompleteMsg);
                b.putString(DataExportListener.KEY_EMAIL_ATTACHMENT, mAttachmentPath);
                mStateListener.exportComplete(b);
            } else {
                mStateListener.exportError(mErrorMsg);
            }
        }
    }
}

######


public void setDataExportListener(DataExportListener sl) {
    synchronized (this) {
        mStateListener = sl;
    }
}

######


public void setHandler(Handler h) {
    mHandler = h;
}

######


private void generateExportHeaders(ArrayList<Instance> instances) {
    final String tt = t + "buildExportHeaders(): ";
    Iterator<Instance> t = instances.iterator();
    while (t.hasNext()) {
        Instance i = t.next();
        if (i.getChildren().isEmpty()) {
            String[] xpathElements = i.getXPath().split("/");
            String xpathPrefix = "";
            if (xpathElements.length > 3) {
                for (int e = 3; e < xpathElements.length; e++) {
                    xpathPrefix = xpathPrefix + xpathElements[e] + " ";
                }
            }
            if (Collect.Log.VERBOSE)
                Log.v(Collect.LOGTAG, tt + "add export column index " + i.getXPath() + " with column header " + xpathPrefix + i.getName());
            mExportHeaders.put(i.getXPath(), xpathPrefix + i.getName());
        } else {
            mErrorMsg = "This form template contains one or more repeated groups.\n\nExport of form data with repeated groups is not supported by this version of GC Mobile.\n\nSupport for exporting these types of forms will be added in a future release.";
            return;
        }
    }
}

######


private String getExportTimestamp() {
    Calendar calendar = Calendar.getInstance();
    SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);
    formatter.setTimeZone(TimeZone.getDefault());
    formatter.applyPattern(DATETIME);
    return formatter.format(calendar.getTime());
}

######


private String getStringValue(String s) {
    if (s == null)
        return "";
    else
        return s.trim();
}

######


@Override
public void execute(XMLTag arg0) {
    readData(arg0, xpath + "/" + arg0.getCurrentTagName());
}

######


private void readData(XMLTag node, final String xpath) {
    final String tt = t + "readData(): ";
    if (mExportHeaders.containsKey(xpath)) {
        if (Collect.Log.VERBOSE)
            Log.v(Collect.LOGTAG, tt + "insert data into record at using index " + mExportHeaders.get(xpath) + " (" + node.getText() + ")");
        mExportData.getLast().put(mExportHeaders.get(xpath), getStringValue(node.getText()));
    }
    node.forEachChild(new CallBack() {

        @Override
        public void execute(XMLTag arg0) {
            readData(arg0, xpath + "/" + arg0.getCurrentTagName());
        }
    });
}

######


@Test
public void testSetNClob() throws Exception {
    createTable("testSetNClob", "id int not null primary key, strm text", "CHARSET utf8");
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into testSetNClob (id, strm) values (?,?)");
    NClob nclob = sharedConnection.createNClob();
    OutputStream stream = nclob.setAsciiStream(1);
    byte[] bytes = "hello".getBytes();
    stream.write(bytes);
    stmt.setInt(1, 1);
    stmt.setNClob(2, nclob);
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from testSetNClob");
    assertTrue(rs.next());
    assertTrue(rs.getObject(2) instanceof String);
    assertTrue(rs.getString(2).equals("hello"));
    NClob resultNClob = rs.getNClob(2);
    assertNotNull(resultNClob);
    assertEquals(5, resultNClob.getAsciiStream().available());
}

######


@Test
public void testSetObjectNClob() throws Exception {
    createTable("testSetObjectNClob", "id int not null primary key, strm text, strm2 text", "CHARSET utf8");
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into testSetObjectNClob (id, strm, strm2) values (?,?,?)");
    NClob nclob = sharedConnection.createNClob();
    OutputStream stream = nclob.setAsciiStream(1);
    byte[] bytes = "hello".getBytes();
    stream.write(bytes);
    stmt.setInt(1, 2);
    stmt.setObject(2, nclob);
    stmt.setObject(3, nclob, Types.NCLOB);
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from testSetObjectNClob");
    assertTrue(rs.next());
    assertTrue(rs.getObject(2) instanceof String);
    assertTrue(rs.getString(2).equals("hello"));
    assertEquals(5, rs.getNClob(2).getAsciiStream().available());
    assertTrue(rs.getObject(3) instanceof String);
    assertTrue(rs.getString(3).equals("hello"));
    assertEquals(5, rs.getNClob(3).getAsciiStream().available());
}

######


@Test
public void testSetNString() throws Exception {
    createTable("testSetNString", "id int not null primary key, strm varchar(10)", "CHARSET utf8");
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into testSetNString (id, strm) values (?,?)");
    stmt.setInt(1, 1);
    stmt.setNString(2, "hello");
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from testSetNString");
    assertTrue(rs.next());
    assertTrue(rs.getObject(2) instanceof String);
    assertTrue(rs.getNString(2).equals("hello"));
}

######


@Test
public void testSetObjectNString() throws Exception {
    createTable("testSetObjectNString", "id int not null primary key, strm varchar(10), strm2 varchar(10)", "CHARSET utf8");
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into testSetObjectNString (id, strm, strm2) values (?, ?, ?)");
    stmt.setInt(1, 2);
    stmt.setObject(2, "hello");
    stmt.setObject(3, "hello", Types.NCLOB);
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from testSetObjectNString");
    assertTrue(rs.next());
    assertTrue(rs.getObject(2) instanceof String);
    assertTrue(rs.getString(2).equals("hello"));
    assertTrue(rs.getObject(3) instanceof String);
    assertTrue(rs.getString(3).equals("hello"));
    assertEquals(5, rs.getNClob(2).getAsciiStream().available());
    assertEquals(5, rs.getNClob(3).getAsciiStream().available());
}

######


@Test
public void testSetNCharacter() throws Exception {
    createTable("testSetNCharacter", "id int not null primary key, strm text", "CHARSET utf8");
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into testSetNCharacter (id, strm) values (?,?)");
    String toInsert = "Øabcdefgh\njklmn\"";
    stmt.setInt(1, 1);
    stmt.setNCharacterStream(2, new StringReader(toInsert));
    stmt.execute();
    stmt.setInt(1, 2);
    stmt.setNCharacterStream(2, new StringReader(toInsert), 3);
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from testSetNCharacter");
    assertTrue(rs.next());
    assertTrue(rs.getObject(2) instanceof String);
    assertTrue(rs.getCharacterStream(2) instanceof Reader);
    checkCharStream(rs.getCharacterStream(2), toInsert);
    assertTrue(rs.next());
    checkCharStream(rs.getCharacterStream(2), toInsert.substring(0, 3));
}

######


@Test
public void testSetObjectNCharacter() throws Exception {
    createTable("testSetObjectNCharacter", "id int not null primary key, strm text", "CHARSET utf8");
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into testSetObjectNCharacter (id, strm) values (?,?)");
    String toInsert = "Øabcdefgh\njklmn\"";
    stmt.setInt(1, 1);
    stmt.setObject(2, new StringReader(toInsert));
    stmt.execute();
    stmt.setInt(1, 2);
    stmt.setObject(2, new StringReader(toInsert), Types.LONGNVARCHAR);
    stmt.execute();
    stmt.setInt(1, 3);
    stmt.setObject(2, new StringReader(toInsert), Types.LONGNVARCHAR, 3);
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from testSetObjectNCharacter");
    assertTrue(rs.next());
    Reader reader1 = rs.getObject(2, Reader.class);
    assertNotNull(reader1);
    assertTrue(rs.getObject(2) instanceof String);
    assertTrue(rs.getCharacterStream(2) instanceof Reader);
    checkCharStream(rs.getCharacterStream(2), toInsert);
    assertTrue(rs.next());
    assertTrue(rs.getObject(2) instanceof String);
    checkCharStream(rs.getCharacterStream(2), toInsert);
    assertTrue(rs.next());
    checkCharStream(rs.getCharacterStream(2), toInsert.substring(0, 3));
}

######


private void checkCharStream(Reader reader, String comparedValue) throws Exception {
    StringBuilder sb = new StringBuilder();
    int ch;
    while ((ch = reader.read()) != -1) {
        sb.append((char) ch);
    }
    assertEquals(comparedValue, sb.toString());
}

######


public static ArrayList<ArrayList<String>> readJSONTagsPerUser(String file) throws SQLException {
    System.out.println("Start reading Tags");
    String sql = "select username from dfs.`" + file + "`";
    Properties properties = new Properties();
    properties.setProperty(ExecConstants.HTTP_ENABLE, "false");
    Connection con = null;
    String jdbcUrl = "jdbc:drill:zk=local";
    ArrayList<ArrayList<String>> tagsPerUser = new ArrayList<ArrayList<String>>();
    con = new Driver().connect(jdbcUrl, properties);
    try {
        Statement stmt = con.createStatement();
        ResultSet rs = stmt.executeQuery(sql);
        ArrayList<String> users = new ArrayList<String>();
        while (rs.next()) {
            if (rs.getString(1) != null && !users.contains(rs.getString(1))) {
                users.add(rs.getString(1));
            }
        }
        for (String user : users) {
            ArrayList<String> tags = new ArrayList<String>();
            tags.add(user);
            sql = "select tagNames from dfs.`" + file + "` where username='" + user + "'";
            rs = stmt.executeQuery(sql);
            while (rs.next()) {
                if (rs.getString(1).length() > 2) {
                    tags.add(rs.getString(1));
                }
            }
            tagsPerUser.add(tags);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        con.close();
    }
    System.out.println("Finish reading Tags");
    return tagsPerUser;
}

######


public static ArrayList<ArrayList<String>> readJSONEventsPerUserPerSession(String file) throws SQLException {
    System.out.println("Start reading Events");
    Properties properties = new Properties();
    properties.setProperty(ExecConstants.HTTP_ENABLE, "false");
    Connection con = null;
    String jdbcUrl = "jdbc:drill:zk=local";
    ArrayList<ArrayList<String>> eventsPerUserPerSession = new ArrayList<ArrayList<String>>();
    con = new Driver().connect(jdbcUrl, properties);
    try {
        String sql = "select username from dfs.`" + file + "`";
        Statement stmt = con.createStatement();
        ResultSet rs = stmt.executeQuery(sql);
        ArrayList<String> users = new ArrayList<String>();
        while (rs.next()) {
            if (rs.getString(1) != null && !users.contains(rs.getString(1))) {
                users.add(rs.getString(1));
            }
        }
        for (String user : users) {
            ArrayList<ArrayList<String>> featuresPerUserPerSession = new ArrayList<ArrayList<String>>();
            ArrayList<String> featuresPerSession = new ArrayList<String>();
            featuresPerSession.add(user);
            sql = "select feature,substr(timestamp1, 1, 10) from dfs.`" + file + "` where username='" + user + "'";
            rs = stmt.executeQuery(sql);
            String featureList = null;
            while (rs.next()) {
                featureList = rs.getString(2) + "," + rs.getString(1);
            }
            featuresPerSession.add(featureList);
            eventsPerUserPerSession.add(featuresPerSession);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        con.close();
    }
    System.out.println("Finish reading Events");
    return eventsPerUserPerSession;
}

######


public String getAlgorithm() {
    return algorithm;
}

######


public void setAlgorithm(String algorithm) throws NoSuchAlgorithmException {
    ConcurrentMessageDigest.init(algorithm);
    this.algorithm = algorithm;
}

######


public String getDataSourceName() {
    return dataSourceName;
}

######


public void setDataSourceName(String dataSourceName) {
    this.dataSourceName = dataSourceName;
}

######


public boolean getLocalDataSource() {
    return localDataSource;
}

######


public void setLocalDataSource(boolean localDataSource) {
    this.localDataSource = localDataSource;
}

######


public String getRoleNameCol() {
    return roleNameCol;
}

######


public void setRoleNameCol(String roleNameCol) {
    this.roleNameCol = roleNameCol;
}

######


public String getUserCredCol() {
    return userCredCol;
}

######


public void setUserCredCol(String userCredCol) {
    this.userCredCol = userCredCol;
}

######


public String getUserNameCol() {
    return userNameCol;
}

######


public void setUserNameCol(String userNameCol) {
    this.userNameCol = userNameCol;
}

######


public String getUserRoleTable() {
    return userRoleTable;
}

######


public void setUserRoleTable(String userRoleTable) {
    this.userRoleTable = userRoleTable;
}

######


public String getUserTable() {
    return userTable;
}

######


public void setUserTable(String userTable) {
    this.userTable = userTable;
}

######


protected Boolean authenticate_safe(Connection dbConnection, String username, String credentials) {
    if (username == null || credentials == null) {
        if (containerLog.isTraceEnabled())
            containerLog.trace(sm.getString("dataSourceRealm.authenticateFailure", username));
        return null;
    }
    String dbCredentials = getPassword(dbConnection, username);
    if (dbCredentials == null) {
        mutate(credentials);
        return false;
    }
    boolean validated = matches(credentials, dbCredentials);
    if (!validated) {
        System.out.println("User not validated ...");
        return false;
    }
    return true;
}

######


public String mutate(String userCredential) {
    Random random = new Random();
    byte[] salt = null;
    int iterations = 20000;
    int saltLength = 32;
    if (saltLength == 0) {
        salt = new byte[0];
    } else if (saltLength > 0) {
        salt = new byte[saltLength];
        random.nextBytes(salt);
    }
    String serverCredential = mutate(userCredential, salt, iterations);
    if (serverCredential == null) {
        return null;
    }
    if (saltLength == 0 && iterations == 1) {
        return serverCredential;
    } else {
        StringBuilder result = new StringBuilder((saltLength << 1) + 10 + serverCredential.length() + 2);
        result.append(HexUtils.toHexString(salt));
        result.append('$');
        result.append(iterations);
        result.append('$');
        result.append(serverCredential);
        return result.toString();
    }
}

######


public boolean matches(String inputCredentials, String storedCredentials) {
    if (inputCredentials == null || storedCredentials == null) {
        return false;
    }
    if (storedCredentials.startsWith("{MD5}") || storedCredentials.startsWith("{SHA}")) {
        String serverDigest = storedCredentials.substring(5);
        String userDigest = Base64.encodeBase64String(ConcurrentMessageDigest.digest(getAlgorithm(), inputCredentials.getBytes(StandardCharsets.ISO_8859_1)));
        return userDigest.equals(serverDigest);
    } else if (storedCredentials.startsWith("{SSHA}")) {
        String serverDigestPlusSalt = storedCredentials.substring(6);
        byte[] serverDigestPlusSaltBytes = Base64.decodeBase64(serverDigestPlusSalt);
        final int saltPos = 20;
        byte[] serverDigestBytes = new byte[saltPos];
        System.arraycopy(serverDigestPlusSaltBytes, 0, serverDigestBytes, 0, saltPos);
        final int saltLength = serverDigestPlusSaltBytes.length - saltPos;
        byte[] serverSaltBytes = new byte[saltLength];
        System.arraycopy(serverDigestPlusSaltBytes, saltPos, serverSaltBytes, 0, saltLength);
        byte[] userDigestBytes = ConcurrentMessageDigest.digest(getAlgorithm(), inputCredentials.getBytes(StandardCharsets.ISO_8859_1), serverSaltBytes);
        return Arrays.equals(userDigestBytes, serverDigestBytes);
    } else {
        String userDigest = mutate(inputCredentials, null, 1);
        return equalsIgnoreCase(userDigest, storedCredentials);
    }
}

######


public boolean equalsIgnoreCase(String anotherString, String thisString) {
    return (thisString == anotherString) ? true : (anotherString != null) && (anotherString.length() == thisString.length()) && regionMatches(true, 0, anotherString, 0, thisString.length(), thisString);
}

######


public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len, String thisString) {
    char[] ta = thisString.toCharArray();
    int to = toffset;
    char[] pa = other.toCharArray();
    int po = ooffset;
    if ((ooffset < 0) || (toffset < 0) || (toffset > (long) thisString.length() - len) || (ooffset > (long) other.length() - len)) {
        return false;
    }
    while (len-- > 0) {
        char c1 = ta[to++];
        char c2 = pa[po++];
        if (c1 == c2) {
            continue;
        }
        if (ignoreCase) {
            char u1 = Character.toUpperCase(c1);
            char u2 = Character.toUpperCase(c2);
            if (u1 == u2) {
                continue;
            }
            if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) {
                continue;
            }
        }
        return false;
    }
    return true;
}

######


protected String mutate(String inputCredentials, byte[] salt, int iterations) {
    if (algorithm == null) {
        return inputCredentials;
    } else {
        byte[] userDigest;
        if (salt == null) {
            userDigest = ConcurrentMessageDigest.digest(algorithm, iterations, inputCredentials.getBytes(encoding));
        } else {
            userDigest = ConcurrentMessageDigest.digest(algorithm, iterations, salt, inputCredentials.getBytes(encoding));
        }
        return HexUtils.toHexString(userDigest);
    }
}

######


protected Boolean authenticate_unsafe(Connection dbConnection, String username, String credentials) {
    if (username == null || credentials == null) {
        return null;
    }
    System.out.println("Looking up the user's credentials ...");
    String dbCredentials = getPassword(dbConnection, username);
    if (dbCredentials == null) {
        System.out.println("User not found ...");
        return false;
    }
    boolean validated = matches(credentials, dbCredentials);
    if (!validated) {
        System.out.println("User not validated...");
        return false;
    }
    System.out.println("User is validated...");
    return true;
}

######


protected void close(Connection dbConnection) {
    if (dbConnection == null)
        return;
    try {
        if (!dbConnection.getAutoCommit()) {
            dbConnection.commit();
        }
    } catch (SQLException e) {
        containerLog.error("Exception committing connection before closing:", e);
    }
    try {
        dbConnection.close();
    } catch (SQLException e) {
        containerLog.error(sm.getString("dataSourceRealm.close"), e);
    }
}

######


protected Connection open() {
    try {
        System.out.println("Connecting to database...");
        Connection conn = DriverManager.getConnection("jdbc:h2:~/tomcat", "sa", "");
        return conn;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}

######


protected String getName() {
    return (name);
}

######


@Override
protected String getPassword(String username) {
    Connection dbConnection = null;
    dbConnection = open();
    if (dbConnection == null) {
        return null;
    }
    try {
        return getPassword(dbConnection, username);
    } finally {
        close(dbConnection);
    }
}

######


protected String getPassword(Connection dbConnection, String username) {
    String dbCredentials = null;
    try {
        Statement st = dbConnection.createStatement();
        String sql = "SELECT * FROM users where user_name='" + username + "';";
        ResultSet rs = st.executeQuery(sql);
        if (rs.next()) {
            dbCredentials = rs.getString(2);
        }
        return (dbCredentials != null) ? dbCredentials.trim() : null;
    } catch (SQLException e) {
        return null;
    }
}

######


@Override
protected Principal getPrincipal(String username) {
    Connection dbConnection = open();
    if (dbConnection == null) {
        return new GenericPrincipal(username, null, null);
    }
    try {
        return (new GenericPrincipal(username, getPassword(dbConnection, username), getRoles(dbConnection, username)));
    } finally {
        close(dbConnection);
    }
}

######


protected ArrayList<String> getRoles(String username) {
    Connection dbConnection = null;
    dbConnection = open();
    if (dbConnection == null) {
        return null;
    }
    try {
        return getRoles(dbConnection, username);
    } finally {
        close(dbConnection);
    }
}

######


protected ArrayList<String> getRoles(Connection dbConnection, String username) {
    if (allRolesMode != AllRolesMode.STRICT_MODE && !isRoleStoreDefined()) {
        return null;
    }
    ArrayList<String> list = null;
    try (PreparedStatement stmt = roles(dbConnection, username);
        ResultSet rs = stmt.executeQuery()) {
        list = new ArrayList<>();
        while (rs.next()) {
            String role = rs.getString(1);
            if (role != null) {
                list.add(role.trim());
            }
        }
        return list;
    } catch (SQLException e) {
        containerLog.error(sm.getString("dataSourceRealm.getRoles.exception", username), e);
    }
    return null;
}

######


private PreparedStatement credentials(Connection dbConnection, String username) throws SQLException {
    PreparedStatement credentials = dbConnection.prepareStatement(preparedCredentials);
    credentials.setString(1, username);
    return (credentials);
}

######


private PreparedStatement roles(Connection dbConnection, String username) throws SQLException {
    PreparedStatement roles = dbConnection.prepareStatement(preparedRoles);
    roles.setString(1, username);
    return (roles);
}

######


private boolean isRoleStoreDefined() {
    return userRoleTable != null || roleNameCol != null;
}

######


@Override
protected void startInternal() throws LifecycleException {
    StringBuilder temp = new StringBuilder("SELECT ");
    temp.append(roleNameCol);
    temp.append(" FROM ");
    temp.append(userRoleTable);
    temp.append(" WHERE ");
    temp.append(userNameCol);
    temp.append(" = ?");
    preparedRoles = temp.toString();
    temp = new StringBuilder("SELECT ");
    temp.append(userCredCol);
    temp.append(" FROM ");
    temp.append(userTable);
    temp.append(" WHERE ");
    temp.append(userNameCol);
    temp.append(" = ?");
    preparedCredentials = temp.toString();
    super.startInternal();
}

######


@RequestMapping(value = "/dataTable_bq", method = RequestMethod.POST)
public ResponseEntity<String> bqDataTableJson(@RequestParam(value = "idlist", required = true) String idlist, @RequestParam(value = "fllist", required = true) String fllist, @RequestParam(value = "corename", required = true) String dataTypeName, HttpServletRequest request, HttpServletResponse response, Model model) throws IOException, URISyntaxException, SolrServerException {
    String content = null;
    List<String> queryIds = Arrays.asList(idlist.split(","));
    Long time = System.currentTimeMillis();
    List<String> mgiIds = new ArrayList<>();
    List<GeneDTO> genes = new ArrayList<>();
    List<QueryResponse> solrResponses = new ArrayList<>();
    if (dataTypeName.equals("marker_symbol")) {
        dataTypeName = "gene";
    }
    List<String> batchIdList = new ArrayList<>();
    String batchIdListStr = null;
    int counter = 0;
    System.out.println("id length: " + queryIds.size());
    for (String id : queryIds) {
        counter++;
        if (counter < 11) {
            batchIdList.add(id);
        }
    }
    queryIds = batchIdList;
    if (dataTypeName.equals("ensembl")) {
        genes.addAll(geneService.getGeneByEnsemblId(batchIdList));
    } else if (dataTypeName.equals("marker_symbol")) {
        genes.addAll(geneService.getGeneByGeneSymbolsOrGeneSynonyms(batchIdList));
    }
    batchIdListStr = StringUtils.join(batchIdList, ",");
    solrResponses.add(solrIndex.getBatchQueryJson(batchIdListStr, fllist, dataTypeName));
    for (GeneDTO gene : genes) {
        if (gene.getMgiAccessionId() != null) {
            mgiIds.add("\"" + gene.getMgiAccessionId() + "\"");
        }
    }
    if (genes.size() == 0) {
        mgiIds = queryIds;
    }
    System.out.println("Get " + mgiIds.size() + " out of " + queryIds.size() + " mgi genes by ensembl id took: " + (System.currentTimeMillis() - time));
    content = fetchBatchQueryDataTableJson(request, solrResponses, fllist, dataTypeName, mgiIds);
    return new ResponseEntity<String>(content, createResponseHeaders(), HttpStatus.CREATED);
}

######


private JSONObject prepareHpMpMapping(QueryResponse solrResponse) {
    JSONObject j = new JSONObject();
    Map<String, List<String>> hp2mp = new HashMap<>();
    Set<String> mpids = new HashSet<>();
    SolrDocumentList results = solrResponse.getResults();
    for (int i = 0; i < results.size(); ++i) {
        SolrDocument doc = results.get(i);
        Map<String, Object> docMap = doc.getFieldValueMap();
        String hpidTerm = (String) docMap.get("hp_id") + "_" + (String) docMap.get("hp_term");
        String mp_id = (String) docMap.get("mp_id");
        mpids.add("\"" + mp_id + "\"");
        if (!hp2mp.containsKey(hpidTerm)) {
            hp2mp.put(hpidTerm, new ArrayList<String>());
        }
        hp2mp.get(hpidTerm).add(mp_id);
    }
    j.put("map", hp2mp);
    List<String> ids = new ArrayList<>();
    ids.addAll(mpids);
    String idlist = StringUtils.join(ids, ",");
    j.put("idlist", idlist);
    return j;
}

######


public String fetchBatchQueryDataTableJson(HttpServletRequest request, List<QueryResponse> solrResponses, String fllist, String dataTypeName, List<String> queryIds) {
    String hostName = request.getAttribute("mappedHostname").toString().replace("https:", "http:");
    String baseUrl = request.getAttribute("baseUrl").toString();
    String NA = "info not available";
    String[] flList = StringUtils.split(fllist, ",");
    Set<String> foundIds = new HashSet<>();
    System.out.println("responses: " + solrResponses.size());
    SolrDocumentList results = new SolrDocumentList();
    for (QueryResponse solrResponse : solrResponses) {
        results.addAll(solrResponse.getResults());
    }
    int totalDocs = results.size();
    Map<String, String> dataTypeId = new HashMap<>();
    dataTypeId.put("gene", "mgi_accession_id");
    dataTypeId.put("marker_name", "mgi_accession_id");
    dataTypeId.put("ensembl", "mgi_accession_id");
    dataTypeId.put("mp", "mp_id");
    dataTypeId.put("ma", "ma_id");
    dataTypeId.put("hp", "hp_id");
    dataTypeId.put("disease", "disease_id");
    Map<String, String> dataTypePath = new HashMap<>();
    dataTypePath.put("gene", "genes");
    dataTypePath.put("mp", "phenotypes");
    dataTypePath.put("ma", "anatomy");
    dataTypePath.put("disease", "disease");
    JSONObject j = new JSONObject();
    j.put("aaData", new Object[0]);
    j.put("iTotalRecords", totalDocs);
    j.put("iTotalDisplayRecords", totalDocs);
    int fieldCount = 0;
    for (int i = 0; i < results.size(); ++i) {
        SolrDocument doc = results.get(i);
        List<String> rowData = new ArrayList<String>();
        Map<String, Collection<Object>> docMap = doc.getFieldValuesMap();
        List<String> orthologousDiseaseIdAssociations = new ArrayList<>();
        List<String> orthologousDiseaseTermAssociations = new ArrayList<>();
        List<String> phenotypicDiseaseIdAssociations = new ArrayList<>();
        List<String> phenotypicDiseaseTermAssociations = new ArrayList<>();
        if (docMap.get("mgi_accession_id") != null && !(dataTypeName.equals("ma") || dataTypeName.equals("disease"))) {
            Collection<Object> mgiGeneAccs = docMap.get("mgi_accession_id");
            for (Object acc : mgiGeneAccs) {
                String mgi_gene_id = (String) acc;
                GeneIdentifier geneIdentifier = new GeneIdentifier(mgi_gene_id, mgi_gene_id);
                List<DiseaseAssociationSummary> diseaseAssociationSummarys = new ArrayList<>();
                try {
                    diseaseAssociationSummarys = phenoDigmDao.getGeneToDiseaseAssociationSummaries(geneIdentifier, rawScoreCutoff);
                } catch (RuntimeException e) {
                    log.error(ExceptionUtils.getFullStackTrace(e));
                }
                for (DiseaseAssociationSummary diseaseAssociationSummary : diseaseAssociationSummarys) {
                    AssociationSummary associationSummary = diseaseAssociationSummary.getAssociationSummary();
                    if (associationSummary.isAssociatedInHuman()) {
                        orthologousDiseaseIdAssociations.add(diseaseAssociationSummary.getDiseaseIdentifier().toString());
                        orthologousDiseaseTermAssociations.add(diseaseAssociationSummary.getDiseaseTerm());
                    } else {
                        phenotypicDiseaseIdAssociations.add(diseaseAssociationSummary.getDiseaseIdentifier().toString());
                        phenotypicDiseaseTermAssociations.add(diseaseAssociationSummary.getDiseaseTerm());
                    }
                }
            }
        }
        fieldCount = 0;
        for (int k = 0; k < flList.length; k++) {
            String fieldName = flList[k];
            if (fieldName.equals("images_link")) {
                String impcImgBaseUrl = baseUrl + "/impcImages/images?";
                String qryField = null;
                String imgQryField = null;
                if (dataTypeName.equals("gene")) {
                    qryField = "mgi_accession_id";
                    imgQryField = "gene_accession_id";
                } else if (dataTypeName.equals("ma")) {
                    qryField = "ma_id";
                    imgQryField = "ma_id";
                }
                Collection<Object> accs = docMap.get(qryField);
                String accStr = null;
                for (Object acc : accs) {
                    accStr = imgQryField + ":\"" + (String) acc + "\"";
                }
                String imgLink = "<a target='_blank' href='" + hostName + impcImgBaseUrl + "q=" + accStr + " AND observation_type:image_record&fq=biological_sample_group:experimental" + "'>image url</a>";
                fieldCount++;
                rowData.add(imgLink);
            } else if (docMap.get(fieldName) == null) {
                fieldCount++;
                String vals = NA;
                if (fieldName.equals("disease_id_by_gene_orthology")) {
                    vals = orthologousDiseaseIdAssociations.size() == 0 ? NA : StringUtils.join(orthologousDiseaseIdAssociations, ", ");
                } else if (fieldName.equals("disease_term_by_gene_orthology")) {
                    vals = orthologousDiseaseTermAssociations.size() == 0 ? NA : StringUtils.join(orthologousDiseaseTermAssociations, ", ");
                } else if (fieldName.equals("disease_id_by_phenotypic_similarity")) {
                    vals = phenotypicDiseaseIdAssociations.size() == 0 ? NA : StringUtils.join(phenotypicDiseaseIdAssociations, ", ");
                } else if (fieldName.equals("disease_term_by_phenotypic_similarity")) {
                    vals = phenotypicDiseaseTermAssociations.size() == 0 ? NA : StringUtils.join(phenotypicDiseaseTermAssociations, ", ");
                }
                rowData.add(vals);
            } else {
                try {
                    String value = null;
                    try {
                        Collection<Object> vals = docMap.get(fieldName);
                        Set<Object> valSet = new HashSet<>(vals);
                        value = StringUtils.join(valSet, ", ");
                        if (!dataTypeName.equals("hp") && dataTypeId.get(dataTypeName).equals(fieldName)) {
                            String coreName = dataTypeName.equals("marker_symbol") || dataTypeName.equals("ensembl") ? "gene" : dataTypeName;
                            foundIds.add("\"" + value + "\"");
                            value = "<a target='_blank' href='" + hostName + baseUrl + "/" + dataTypePath.get(coreName) + "/" + value + "'>" + value + "</a>";
                        } else if (dataTypeName.equals("hp") && dataTypeId.get(dataTypeName).equals(fieldName)) {
                            foundIds.add("\"" + value + "\"");
                        }
                    } catch (ClassCastException c) {
                        value = docMap.get(fieldName).toString();
                    }
                    fieldCount++;
                    rowData.add(value);
                } catch (Exception e) {
                    if (e.getMessage().equals("java.lang.Integer cannot be cast to java.lang.String")) {
                        Collection<Object> vals = docMap.get(fieldName);
                        if (vals.size() > 0) {
                            Iterator it = vals.iterator();
                            String value = (String) it.next();
                            fieldCount++;
                            rowData.add(value);
                        }
                    }
                }
            }
        }
        j.getJSONArray("aaData").add(rowData);
    }
    ArrayList nonFoundIds = (java.util.ArrayList) CollectionUtils.disjunction(queryIds, new ArrayList(foundIds));
    for (int i = 0; i < nonFoundIds.size(); i++) {
        List<String> rowData = new ArrayList<String>();
        for (int l = 0; l < fieldCount; l++) {
            rowData.add(l == 0 ? nonFoundIds.get(i).toString().replaceAll("\"", "") : NA);
        }
        j.getJSONArray("aaData").add(rowData);
    }
    return j.toString();
}

######


@RequestMapping(value = "/dataTable", method = RequestMethod.GET)
public ResponseEntity<String> dataTableJson(@RequestParam(value = "iDisplayStart", required = false) int iDisplayStart, @RequestParam(value = "iDisplayLength", required = false) int iDisplayLength, @RequestParam(value = "solrParams", required = false) String solrParams, HttpServletRequest request, HttpServletResponse response, Model model) throws IOException, URISyntaxException {
    JSONObject jParams = (JSONObject) JSONSerializer.toJSON(solrParams);
    String solrCoreName = jParams.containsKey("solrCoreName") ? jParams.getString("solrCoreName") : jParams.getString("facetName");
    String queryOri = jParams.getString("qOri");
    String query = "";
    String fqOri = "";
    String mode = jParams.getString("mode");
    String solrParamStr = jParams.getString("params");
    boolean legacyOnly = jParams.getBoolean("legacyOnly");
    String evidRank = jParams.containsKey("evidRank") ? jParams.getString("evidRank") : "";
    String[] pairs = solrParamStr.split("&");
    for (String pair : pairs) {
        try {
            String[] parts = pair.split("=");
            if (parts[0].equals("q")) {
                query = parts[1];
            }
            if (parts[0].equals("fq")) {
                fqOri = "&fq=" + parts[1];
            }
        } catch (Exception e) {
            log.error("Error getting value of key");
        }
    }
    boolean showImgView = false;
    if (jParams.containsKey("showImgView")) {
        showImgView = jParams.getBoolean("showImgView");
    }
    JSONObject json = solrIndex.getQueryJson(query, solrCoreName, solrParamStr, mode, iDisplayStart, iDisplayLength, showImgView);
    String content = fetchDataTableJson(request, json, mode, queryOri, fqOri, iDisplayStart, iDisplayLength, solrParamStr, showImgView, solrCoreName, legacyOnly, evidRank);
    return new ResponseEntity<String>(content, createResponseHeaders(), HttpStatus.CREATED);
}

######


@ExceptionHandler(Exception.class)
private ResponseEntity<String> getSolrErrorResponse(Exception e) {
    e.printStackTrace();
    String bootstrap = "<div class=\"alert\"><strong>Warning!</strong>  Error: Search functionality is currently unavailable</div>";
    String errorJSON = "{'aaData':[[' " + bootstrap + "','  ', ' ']], 'iTotalRecords':1,'iTotalDisplayRecords':1}";
    JSONObject errorJson = (JSONObject) JSONSerializer.toJSON(errorJSON);
    return new ResponseEntity<String>(errorJson.toString(), createResponseHeaders(), HttpStatus.CREATED);
}

######


private HttpHeaders createResponseHeaders() {
    HttpHeaders responseHeaders = new HttpHeaders();
    responseHeaders.setContentType(MediaType.APPLICATION_JSON);
    return responseHeaders;
}

######


public String fetchDataTableJson(HttpServletRequest request, JSONObject json, String mode, String query, String fqOri, int start, int length, String solrParams, boolean showImgView, String solrCoreName, boolean legacyOnly, String evidRank) throws IOException, URISyntaxException {
    String jsonStr = null;
    if (mode.equals("geneGrid")) {
        jsonStr = parseJsonforGeneDataTable(json, request, query, solrCoreName, legacyOnly);
    } else if (mode.equals("pipelineGrid")) {
        jsonStr = parseJsonforProtocolDataTable(json, request, solrCoreName, start);
    } else if (mode.equals("impc_imagesGrid")) {
        jsonStr = parseJsonforImpcImageDataTable(json, start, length, solrParams, showImgView, request, query, fqOri, solrCoreName);
    } else if (mode.equals("imagesGrid")) {
        jsonStr = parseJsonforImageDataTable(json, start, length, solrParams, showImgView, request, query, fqOri, solrCoreName);
    } else if (mode.equals("mpGrid")) {
        jsonStr = parseJsonforMpDataTable(json, request, query, solrCoreName, start);
    } else if (mode.equals("maGrid")) {
        jsonStr = parseJsonforMaDataTable(json, request, query, solrCoreName, start);
    } else if (mode.equals("diseaseGrid")) {
        jsonStr = parseJsonforDiseaseDataTable(json, request, solrCoreName, start);
    } else if (mode.equals("gene2go")) {
        jsonStr = parseJsonforGoDataTable(json, request, solrCoreName, evidRank);
    }
    return jsonStr;
}

######


public String parseJsonforGoDataTable(JSONObject json, HttpServletRequest request, String solrCoreName, String evidRank) {
    String hostName = request.getAttribute("mappedHostname").toString();
    String baseUrl = request.getAttribute("baseUrl").toString();
    JSONArray docs = json.getJSONObject("response").getJSONArray("docs");
    int totalDocs = json.getJSONObject("response").getInt("numFound");
    log.debug("TOTAL GENE2GO: " + totalDocs);
    JSONObject j = new JSONObject();
    j.put("aaData", new Object[0]);
    j.put("iTotalRecords", totalDocs);
    j.put("iTotalDisplayRecords", totalDocs);
    Map<String, Integer> codeRank = SolrIndex.getGoCodeRank();
    for (int i = 0; i < docs.size(); i++) {
        JSONObject doc = docs.getJSONObject(i);
        String marker_symbol = doc.getString("marker_symbol");
        String gId = doc.getString("mgi_accession_id");
        String glink = "<a href='" + hostName + baseUrl + "/" + gId + "'>" + marker_symbol + "</a>";
        String phenoStatus = doc.getString("latest_phenotype_status");
        String NOINFO = "no info available";
        if (doc.containsKey("go_count")) {
            List<String> rowData = new ArrayList<String>();
            rowData.add(glink);
            rowData.add(phenoStatus);
            rowData.add(Integer.toString(doc.getInt("go_count")));
            rowData.add("<i class='fa fa-plus-square'></i>");
            j.getJSONArray("aaData").add(rowData);
        } else {
            List<String> rowData = new ArrayList<String>();
            rowData.add(glink);
            rowData.add(phenoStatus);
            rowData.add(NOINFO);
            rowData.add("");
            j.getJSONArray("aaData").add(rowData);
        }
    }
    return j.toString();
}

######


public String parseJsonforGeneDataTable(JSONObject json, HttpServletRequest request, String qryStr, String solrCoreName, boolean legacyOnly) {
    RegisterInterestDrupalSolr registerInterest = new RegisterInterestDrupalSolr(config.get("drupalBaseUrl"), request);
    JSONArray docs = json.getJSONObject("response").getJSONArray("docs");
    int totalDocs = json.getJSONObject("response").getInt("numFound");
    log.debug("TOTAL GENEs: " + totalDocs);
    JSONObject j = new JSONObject();
    j.put("aaData", new Object[0]);
    j.put("iTotalRecords", totalDocs);
    j.put("iTotalDisplayRecords", totalDocs);
    for (int i = 0; i < docs.size(); i++) {
        List<String> rowData = new ArrayList<String>();
        JSONObject doc = docs.getJSONObject(i);
        String geneInfo = concateGeneInfo(doc, json, qryStr, request);
        rowData.add(geneInfo);
        String mgiId = doc.getString("mgi_accession_id");
        String geneLink = request.getAttribute("baseUrl") + "/genes/" + mgiId;
        boolean toExport = false;
        String prodStatus = geneService.getLatestProductionStatusForEsCellAndMice(doc, request, toExport, geneLink);
        rowData.add(prodStatus);
        String phenotypeStatusHTMLRepresentation = geneService.getPhenotypingStatus(doc, request, toExport, legacyOnly);
        rowData.add(phenotypeStatusHTMLRepresentation);
        if (registerInterest.loggedIn()) {
            if (registerInterest.alreadyInterested(doc.getString("mgi_accession_id"))) {
                String uinterest = "<div class='registerforinterest' oldtitle='Unregister interest' title=''>" + "<i class='fa fa-sign-out'></i>" + "<a id='" + doc.getString("mgi_accession_id") + "' class='regInterest primary interest' href=''>&nbsp;Unregister interest</a>" + "</div>";
                rowData.add(uinterest);
            } else {
                String rinterest = "<div class='registerforinterest' oldtitle='Register interest' title=''>" + "<i class='fa fa-sign-in'></i>" + "<a id='" + doc.getString("mgi_accession_id") + "' class='regInterest primary interest' href=''>&nbsp;Register interest</a>" + "</div>";
                rowData.add(rinterest);
            }
        } else {
            String interest = "<div class='registerforinterest' oldtitle='Login to register interest' title=''>" + "<i class='fa fa-sign-in'></i>" + "<a class='regInterest' href='/user/login?destination=data/search#fq=*:*&facet=gene'>&nbsp;Interest</a>" + "</div>";
            rowData.add(interest);
        }
        j.getJSONArray("aaData").add(rowData);
    }
    return j.toString();
}

######


public String parseJsonforProtocolDataTable(JSONObject json, HttpServletRequest request, String solrCoreName, int start) {
    JSONArray docs = json.getJSONObject("response").getJSONArray("docs");
    int totalDocs = json.getJSONObject("response").getInt("numFound");
    JSONObject j = new JSONObject();
    j.put("aaData", new Object[0]);
    j.put("iTotalRecords", totalDocs);
    j.put("iTotalDisplayRecords", totalDocs);
    String impressBaseUrl = request.getAttribute("drupalBaseUrl") + "/impress/impress/displaySOP/";
    for (int i = 0; i < docs.size(); i++) {
        List<String> rowData = new ArrayList<String>();
        JSONObject doc = docs.getJSONObject(i);
        String parameter = doc.getString("parameter_name");
        rowData.add(parameter);
        JSONArray procedures = doc.getJSONArray("procedure_name");
        JSONArray procedure_stable_keys = doc.getJSONArray("procedure_stable_key");
        List<String> procedureLinks = new ArrayList<String>();
        for (int p = 0; p < procedures.size(); p++) {
            String procedure = procedures.get(p).toString();
            String procedure_stable_key = procedure_stable_keys.get(p).toString();
            procedureLinks.add("<a href='" + impressBaseUrl + procedure_stable_key + "'>" + procedure + "</a>");
        }
        rowData.add(StringUtils.join(procedureLinks, "<br>"));
        String pipeline = doc.getString("pipeline_name");
        rowData.add(pipeline);
        j.getJSONArray("aaData").add(rowData);
    }
    return j.toString();
}

######


public String parseJsonforMpDataTable(JSONObject json, HttpServletRequest request, String qryStr, String solrCoreName, int start) {
    RegisterInterestDrupalSolr registerInterest = new RegisterInterestDrupalSolr(config.get("drupalBaseUrl"), request);
    String baseUrl = request.getAttribute("baseUrl") + "/phenotypes/";
    JSONObject j = new JSONObject();
    j.put("aaData", new Object[0]);
    JSONArray docs = json.getJSONObject("response").getJSONArray("docs");
    int totalDocs = json.getJSONObject("response").getInt("numFound");
    j.put("iTotalRecords", totalDocs);
    j.put("iTotalDisplayRecords", totalDocs);
    for (int i = 0; i < docs.size(); i++) {
        List<String> rowData = new ArrayList<String>();
        JSONObject doc = docs.getJSONObject(i);
        String mpId = doc.getString("mp_id");
        String mpTerm = doc.getString("mp_term");
        String mpLink = "<a href='" + baseUrl + mpId + "'>" + mpTerm + "</a>";
        String mpCol = null;
        if (doc.containsKey("mp_term_synonym") || doc.containsKey("hp_term")) {
            mpCol = "<div class='title'>" + mpLink + "</div>";
            if (doc.containsKey("mp_term_synonym")) {
                List<String> mpSynonyms = doc.getJSONArray("mp_term_synonym");
                List<String> prefixSyns = new ArrayList();
                for (String sn : mpSynonyms) {
                    prefixSyns.add(Tools.highlightMatchedStrIfFound(qryStr, sn, "span", "subMatch"));
                }
                String syns = null;
                if (prefixSyns.size() > 1) {
                    syns = "<ul class='synonym'><li>" + StringUtils.join(prefixSyns, "</li><li>") + "</li></ul>";
                } else {
                    syns = prefixSyns.get(0);
                }
                mpCol += "<div class='subinfo'>" + "<span class='label'>synonym</span>: " + syns + "</div>";
            }
            if (doc.containsKey("hp_term")) {
                Set<SimpleOntoTerm> hpTerms = mpService.getComputationalHPTerms(doc);
                String mappedHpTerms = "";
                if (hpTerms.size() > 1) {
                    for (SimpleOntoTerm term : hpTerms) {
                        if (!term.getTermName().equals("")) {
                            mappedHpTerms += "<li>" + term.getTermName() + "</li>";
                        }
                    }
                    mappedHpTerms = "<ul class='hpTerms'>" + mappedHpTerms + "</ul>";
                } else {
                    Iterator hi = hpTerms.iterator();
                    SimpleOntoTerm term = (SimpleOntoTerm) hi.next();
                    mappedHpTerms = term.getTermName();
                }
                mpCol += "<div class='subinfo'>" + "<span class='label'>computationally mapped HP term</span>: " + mappedHpTerms + "</div>";
            }
            mpCol = "<div class='mpCol'>" + mpCol + "</div>";
            rowData.add(mpCol);
        } else {
            rowData.add(mpLink);
        }
        String mpDef = "No definition data available";
        try {
            mpDef = Tools.highlightMatchedStrIfFound(qryStr, doc.getString("mp_definition"), "span", "subMatch");
        } catch (Exception e) {
        }
        rowData.add(mpDef);
        int numCalls = doc.containsKey("pheno_calls") ? doc.getInt("pheno_calls") : 0;
        rowData.add(Integer.toString(numCalls));
        if (registerInterest.loggedIn()) {
            if (registerInterest.alreadyInterested(mpId)) {
                String uinterest = "<div class='registerforinterest' oldtitle='Unregister interest' title=''>" + "<i class='fa fa-sign-out'></i>" + "<a id='" + mpId + "' class='regInterest primary interest' href=''>&nbsp;Unregister interest</a>" + "</div>";
                rowData.add(uinterest);
            } else {
                String rinterest = "<div class='registerforinterest' oldtitle='Register interest' title=''>" + "<i class='fa fa-sign-in'></i>" + "<a id='" + mpId + "' class='regInterest primary interest' href=''>&nbsp;Register interest</a>" + "</div>";
                rowData.add(rinterest);
            }
        } else {
            String interest = "<div class='registerforinterest' oldtitle='Login to register interest' title=''>" + "<i class='fa fa-sign-in'></i>" + "<a class='regInterest' href='/user/login?destination=data/search#fq=*:*&facet=mp'>&nbsp;Interest</a>" + "</div>";
            rowData.add(interest);
        }
        j.getJSONArray("aaData").add(rowData);
    }
    return j.toString();
}

######


public String parseJsonforMaDataTable(JSONObject json, HttpServletRequest request, String qryStr, String solrCoreName, int start) {
    String baseUrl = request.getAttribute("baseUrl") + "/anatomy/";
    JSONArray docs = json.getJSONObject("response").getJSONArray("docs");
    int totalDocs = json.getJSONObject("response").getInt("numFound");
    JSONObject j = new JSONObject();
    j.put("aaData", new Object[0]);
    j.put("iTotalRecords", totalDocs);
    j.put("iTotalDisplayRecords", totalDocs);
    for (int i = 0; i < docs.size(); i++) {
        List<String> rowData = new ArrayList<String>();
        JSONObject doc = docs.getJSONObject(i);
        String maId = doc.getString("ma_id");
        String maTerm = doc.getString("ma_term");
        String maLink = "<a href='" + baseUrl + maId + "'>" + maTerm + "</a>";
        if (doc.containsKey("ma_term_synonym")) {
            List<String> maSynonyms = doc.getJSONArray("ma_term_synonym");
            List<String> prefixSyns = new ArrayList();
            for (String sn : maSynonyms) {
                prefixSyns.add(Tools.highlightMatchedStrIfFound(qryStr, sn, "span", "subMatch"));
            }
            String syns = null;
            if (prefixSyns.size() > 1) {
                syns = "<ul class='synonym'><li>" + StringUtils.join(prefixSyns, "</li><li>") + "</li></ul>";
            } else {
                syns = prefixSyns.get(0);
            }
            String maCol = "<div class='maCol'><div class='title'>" + maLink + "</div>" + "<div class='subinfo'>" + "<span class='label'>synonym: </span>" + syns + "</div>";
            rowData.add(maCol);
        } else {
            rowData.add(maLink);
        }
        j.getJSONArray("aaData").add(rowData);
    }
    return j.toString();
}

######


public String parseJsonforImpcImageDataTable(JSONObject json, int start, int length, String solrParams, boolean showImgView, HttpServletRequest request, String query, String fqOri, String solrCoreName) throws IOException, URISyntaxException {
    String baseUrl = (String) request.getAttribute("baseUrl");
    String mediaBaseUrl = baseUrl + "/impcImages/images?";
    if (showImgView) {
        JSONArray docs = json.getJSONObject("response").getJSONArray("docs");
        int totalDocs = json.getJSONObject("response").getInt("numFound");
        JSONObject j = new JSONObject();
        j.put("aaData", new Object[0]);
        j.put("iTotalRecords", totalDocs);
        j.put("iTotalDisplayRecords", totalDocs);
        for (int i = 0; i < docs.size(); i++) {
            List<String> rowData = new ArrayList<String>();
            JSONObject doc = docs.getJSONObject(i);
            String annots = "";
            String imgLink = null;
            if (doc.containsKey("jpeg_url")) {
                String fullSizePath = doc.getString("jpeg_url");
                String thumbnailPath = fullSizePath.replace("render_image", "render_thumbnail");
                String smallThumbNailPath = thumbnailPath + "/200";
                String largeThumbNailPath = thumbnailPath + "/800";
                String img = "<img src='" + smallThumbNailPath + "'/>";
                if (doc.getString("download_url").contains("annotation")) {
                    imgLink = "<a href='" + doc.getString("download_url") + "'>" + img + "</a>";
                } else {
                    imgLink = "<a class='fancybox' fullres='" + fullSizePath + "' href='" + largeThumbNailPath + "'>" + img + "</a>";
                }
            } else {
                imgLink = IMG_NOT_FOUND;
            }
            try {
                ArrayList<String> ma = new ArrayList<String>();
                ArrayList<String> procedures = new ArrayList<String>();
                int counter = 0;
                if (doc.has("ma_id")) {
                    JSONArray termIds = doc.getJSONArray("ma_id");
                    JSONArray termNames = doc.getJSONArray("ma_term");
                    for (Object s : termIds) {
                        log.info(i + " - MA: " + termNames.get(counter).toString());
                        log.debug(i + " - MA: " + termNames.get(counter).toString());
                        String name = termNames.get(counter).toString();
                        String maid = termIds.get(counter).toString();
                        String url = request.getAttribute("baseUrl") + "/anatomy/" + maid;
                        ma.add("<a href='" + url + "'>" + name + "</a>");
                        counter++;
                    }
                }
                if (doc.has("procedure_name")) {
                    String procedureName = doc.getString("procedure_name");
                    procedures.add(procedureName);
                }
                if (ma.size() == 1) {
                    annots += "<span class='imgAnnots'><span class='annotType'>MA</span>: " + StringUtils.join(ma, ", ") + "</span>";
                } else if (ma.size() > 1) {
                    String list = "<ul class='imgMa'><li>" + StringUtils.join(ma, "</li><li>") + "</li></ul>";
                    annots += "<span class='imgAnnots'><span class='annotType'>MA</span>: " + list + "</span>";
                }
                if (procedures.size() == 1) {
                    annots += "<span class='imgAnnots'><span class='annotType'>Procedure</span>: " + StringUtils.join(procedures, ", ") + "</span>";
                } else if (procedures.size() > 1) {
                    String list = "<ul class='imgProcedure'><li>" + StringUtils.join(procedures, "</li><li>") + "</li></ul>";
                    annots += "<span class='imgAnnots'><span class='annotType'>Procedure</span>: " + list + "</span>";
                }
                if (doc.has("gene_symbol")) {
                    String geneSymbol = doc.getString("gene_symbol");
                    String geneAccessionId = doc.getString("gene_accession_id");
                    String url = baseUrl + "/genes/" + geneAccessionId;
                    String geneLink = "<a href='" + url + "'>" + geneSymbol + "</a>";
                    annots += "<span class='imgAnnots'><span class='annotType'>Gene</span>: " + geneLink + "</span>";
                }
                rowData.add(annots);
                rowData.add(imgLink);
                j.getJSONArray("aaData").add(rowData);
            } catch (Exception e) {
                rowData.add("No information available");
                rowData.add(imgLink);
                j.getJSONArray("aaData").add(rowData);
            }
        }
        return j.toString();
    } else {
        String fqStr = fqOri;
        String defaultQStr = "observation_type:image_record&qf=auto_suggest&defType=edismax";
        if (query != "") {
            defaultQStr = "q=" + query + " AND " + defaultQStr;
        } else {
            defaultQStr = "q=" + defaultQStr;
        }
        String defaultFqStr = "fq=(biological_sample_group:experimental)";
        if (!fqOri.contains("fq=*:*")) {
            fqStr = fqStr.replace("&fq=", "");
            defaultFqStr = defaultFqStr + " AND " + fqStr;
        }
        List<AnnotNameValCount> annots = solrIndex.mergeImpcFacets(json, baseUrl);
        int numAnnots = annots.size();
        JSONObject j = new JSONObject();
        j.put("aaData", new Object[0]);
        j.put("iTotalRecords", numAnnots);
        j.put("iTotalDisplayRecords", numAnnots);
        int end = start + length > numAnnots ? numAnnots : start + length;
        for (int i = start; i < end; i = i + 1) {
            List<String> rowData = new ArrayList<String>();
            AnnotNameValCount annot = annots.get(i);
            String displayAnnotName = annot.name;
            String annotVal = annot.val;
            String annotId = annot.id;
            String link = annot.link != null ? annot.link : "";
            String valLink = "<a href='" + link + "'>" + annotVal + "</a>";
            String thisFqStr = defaultFqStr + " AND " + annot.facet + ":\"" + annotVal + "\"";
            String imgSubSetLink = null;
            String thisImgUrl = null;
            List pathAndImgCount = solrIndex.fetchImpcImagePathByAnnotName(query, thisFqStr);
            int imgCount = (int) pathAndImgCount.get(1);
            String unit = imgCount > 1 ? "images" : "image";
            if (imgCount == 0) {
                imgSubSetLink = imgCount + " " + unit;
            } else {
                String currFqStr = null;
                if (displayAnnotName.equals("Gene")) {
                    currFqStr = defaultFqStr + " AND gene_symbol:\"" + annotVal + "\"";
                } else if (displayAnnotName.equals("Procedure")) {
                    currFqStr = defaultFqStr + " AND procedure_name:\"" + annotVal + "\"";
                } else if (displayAnnotName.equals("MA")) {
                    currFqStr = defaultFqStr + " AND ma_id:\"" + annotId + "\"";
                }
                thisImgUrl = mediaBaseUrl + defaultQStr + '&' + currFqStr;
                imgSubSetLink = "<a href='" + thisImgUrl + "'>" + imgCount + " " + unit + "</a>";
            }
            rowData.add("<span class='annotType'>" + displayAnnotName + "</span>: " + valLink + " (" + imgSubSetLink + ")");
            rowData.add(pathAndImgCount.get(0).toString());
            j.getJSONArray("aaData").add(rowData);
        }
        return j.toString();
    }
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("pk_test", "val varchar(20), id1 int not null, id2 int not null,primary key(id1, id2)", "engine=innodb");
    createTable("datetime_test", "dt datetime");
    createTable("`manycols`", "  `tiny` tinyint(4) DEFAULT NULL,\n" + "  `tiny_uns` tinyint(3) unsigned DEFAULT NULL,\n" + "  `small` smallint(6) DEFAULT NULL,\n" + "  `small_uns` smallint(5) unsigned DEFAULT NULL,\n" + "  `medium` mediumint(9) DEFAULT NULL,\n" + "  `medium_uns` mediumint(8) unsigned DEFAULT NULL,\n" + "  `int_col` int(11) DEFAULT NULL,\n" + "  `int_col_uns` int(10) unsigned DEFAULT NULL,\n" + "  `big` bigint(20) DEFAULT NULL,\n" + "  `big_uns` bigint(20) unsigned DEFAULT NULL,\n" + "  `decimal_col` decimal(10,5) DEFAULT NULL,\n" + "  `fcol` float DEFAULT NULL,\n" + "  `fcol_uns` float unsigned DEFAULT NULL,\n" + "  `dcol` double DEFAULT NULL,\n" + "  `dcol_uns` double unsigned DEFAULT NULL,\n" + "  `date_col` date DEFAULT NULL,\n" + "  `time_col` time DEFAULT NULL,\n" + "  `timestamp_col` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE\n" + "CURRENT_TIMESTAMP,\n" + "  `year_col` year(4) DEFAULT NULL,\n" + "  `bit_col` bit(5) DEFAULT NULL,\n" + "  `char_col` char(5) DEFAULT NULL,\n" + "  `varchar_col` varchar(10) DEFAULT NULL,\n" + "  `binary_col` binary(10) DEFAULT NULL,\n" + "  `varbinary_col` varbinary(10) DEFAULT NULL,\n" + "  `tinyblob_col` tinyblob,\n" + "  `blob_col` blob,\n" + "  `mediumblob_col` mediumblob,\n" + "  `longblob_col` longblob,\n" + "  `text_col` text,\n" + "  `mediumtext_col` mediumtext,\n" + "  `longtext_col` longtext");
    createTable("ytab", "y year");
    createTable("maxcharlength", "maxcharlength char(1)", "character set utf8");
    if (doPrecisionTest) {
        createTable("time_test", "ID int unsigned NOT NULL, time_test time(6), PRIMARY KEY (ID)", "engine=InnoDB");
        if (testSingleHost) {
            sharedConnection.createStatement().execute("insert into time_test(id, time_test) values(1, '00:00:00'), (2, '00:00:00.123'), (3, null)");
        }
    }
}

######


@Test
public void testIntegerTypes() throws SQLException {
    assertType("TINYINT", Integer.class, Types.TINYINT, "127", 127);
    assertType("TINYINT UNSIGNED", Integer.class, Types.TINYINT, "255", 255);
    assertType("SMALLINT", Integer.class, Types.SMALLINT, "0x7FFF", 0x7FFF);
    assertType("SMALLINT UNSIGNED", Integer.class, Types.SMALLINT, "0xFFFF", 0xFFFF);
    assertType("MEDIUMINT", Integer.class, Types.INTEGER, "0x7FFFFF", 0x7FFFFF);
    assertType("MEDIUMINT UNSIGNED", Integer.class, Types.INTEGER, "0xFFFFFF", 0xFFFFFF);
    assertType("INT", Integer.class, Types.INTEGER, "0x7FFFFFFF", 0x7FFFFFFF);
    assertType("INT UNSIGNED", Long.class, Types.INTEGER, "0xFFFFFFFF", 0xFFFFFFFFL);
    assertType("INTEGER", Integer.class, Types.INTEGER, "0x7FFFFFFF", 0x7FFFFFFF);
    assertType("INTEGER UNSIGNED", Long.class, Types.INTEGER, "0xFFFFFFFF", 0xFFFFFFFFL);
    assertType("BIGINT", Long.class, Types.BIGINT, "0x7FFFFFFFFFFFFFFF", Long.MAX_VALUE);
    assertType("BIGINT UNSIGNED", BigInteger.class, Types.BIGINT, "0xFFFFFFFFFFFFFFFF", new BigInteger("FFFFFFFFFFFFFFFF", 16));
}

######


@SuppressWarnings("BigDecimalMethodWithoutRoundingCalled")
@Test
public void testFixedPointTypes() throws SQLException {
    requireMinimumVersion(5, 0);
    assertType("DECIMAL(5,2)", BigDecimal.class, Types.DECIMAL, "-999.99", new BigDecimal(-99999).divide(new BigDecimal(100)));
    assertType("DECIMAL(5,2) UNSIGNED", BigDecimal.class, Types.DECIMAL, "999.99", new BigDecimal(99999).divide(new BigDecimal(100)));
    assertType("NUMERIC(5,2)", BigDecimal.class, Types.DECIMAL, "-999.99", new BigDecimal(-99999).divide(new BigDecimal(100)));
    assertType("NUMERIC(5,2) UNSIGNED", BigDecimal.class, Types.DECIMAL, "999.99", new BigDecimal(99999).divide(new BigDecimal(100)));
}

######


@Test
public void testFloatingPointTypes() throws SQLException {
    assertType("FLOAT", Float.class, Types.REAL, "-1.0", -1.0f);
    assertType("FLOAT UNSIGNED", Float.class, Types.REAL, "1.0", 1.0f);
    assertType("DOUBLE", Double.class, Types.DOUBLE, "-1.0", -1.0d);
    assertType("DOUBLE UNSIGNED", Double.class, Types.DOUBLE, "1.0", 1.0d);
}

######


@Test
public void testBitTypes() throws SQLException {
    requireMinimumVersion(5, 0);
    assertType("BIT", Boolean.class, Types.BIT, "0", false);
    assertType("BIT(1)", Boolean.class, Types.BIT, "1", true);
    assertType("BIT(2)", byte[].class, Types.VARBINARY, "b'11'", new byte[] { 3 });
    assertType("BIT(8)", byte[].class, Types.VARBINARY, "b'11111111'", new byte[] { -1 });
    assertType("BIT(16)", byte[].class, Types.VARBINARY, "b'1111111111111111'", new byte[] { -1, -1 });
    assertType("BIT(24)", byte[].class, Types.VARBINARY, "b'111111111111111111111111'", new byte[] { -1, -1, -1 });
    assertType("BIT(32)", byte[].class, Types.VARBINARY, "b'11111111111111111111111111111111'", new byte[] { -1, -1, -1, -1 });
    assertType("BIT(64)", byte[].class, Types.VARBINARY, "b'1111111111111111111111111111111111111111111111111111" + "111111111111'", new byte[] { -1, -1, -1, -1, -1, -1, -1, -1 });
}

######


private void assertType(String columnType, Class expectedClass, int expectedJdbcType, String strValue, Object expectedObjectValue) throws SQLException {
    assertNotNull(expectedObjectValue);
    assertSame("bad test spec: ", expectedClass, expectedObjectValue.getClass());
    try (Statement statement = sharedConnection.createStatement()) {
        createTable("my_table", "my_col " + columnType);
        statement.execute("INSERT INTO my_table(my_col) VALUES (" + strValue + ")");
        statement.execute("SELECT * FROM my_table");
        try (ResultSet resultSet = statement.getResultSet()) {
            ResultSetMetaData metaData = resultSet.getMetaData();
            assertEquals("class name  for " + columnType, expectedClass.getName(), metaData.getColumnClassName(1));
            assertEquals("java.sql.Types code for " + columnType, expectedJdbcType, metaData.getColumnType(1));
            resultSet.next();
            Object objectValue = resultSet.getObject(1);
            assertEquals(expectedClass, objectValue.getClass());
            if (expectedClass.isArray()) {
                assertTrue(Arrays.equals((byte[]) expectedObjectValue, (byte[]) objectValue));
            } else {
                assertEquals(expectedObjectValue, objectValue);
            }
        }
    }
}

######


@SuppressWarnings("deprecation")
@Test
public void timeAsTimestamp() throws Exception {
    Time testTime = new Time(12, 0, 0);
    PreparedStatement ps = sharedConnection.prepareStatement("SELECT CONVERT(?, TIME)");
    ps.setTime(1, testTime);
    ResultSet rs = ps.executeQuery();
    assertTrue(rs.next());
    Timestamp ts = rs.getTimestamp(1);
    Time time = rs.getTime(1);
    assertEquals(testTime, ts);
    assertEquals(testTime, time);
}

######


public void testStatementGetTime(Connection connection) throws SQLException {
    Assume.assumeTrue(doPrecisionTest);
    try (Statement statement = connection.createStatement()) {
        try (ResultSet resultSet = statement.executeQuery(sql)) {
            assertTrue(resultSet.next());
            assertEquals("00:00:00", "" + resultSet.getTime(2));
            assertTrue(resultSet.next());
            assertEquals("00:00:00", "" + resultSet.getTime(2));
            assertTrue(resultSet.next());
            assertNull(resultSet.getTime(2));
            assertFalse(resultSet.next());
        }
    }
}

######


public void testStatementGetString(Connection connection) throws SQLException {
    Assume.assumeTrue(doPrecisionTest);
    try (Statement statement = connection.createStatement()) {
        try (ResultSet resultSet = statement.executeQuery(sql)) {
            assertTrue(resultSet.next());
            assertEquals("00:00:00.000000", resultSet.getString(2));
            assertTrue(resultSet.next());
            assertEquals("00:00:00.123000", resultSet.getString(2));
            assertTrue(resultSet.next());
            assertNull(resultSet.getString(2));
            assertFalse(resultSet.next());
        }
    }
}

######


public void testPreparedStatementGetTime(Connection connection) throws SQLException {
    Assume.assumeTrue(doPrecisionTest);
    try (Statement statement = connection.createStatement()) {
        try (ResultSet resultSet = statement.executeQuery(sql)) {
            assertTrue(resultSet.next());
            assertEquals("00:00:00", "" + resultSet.getTime(2));
            assertTrue(resultSet.next());
            assertEquals("00:00:00", "" + resultSet.getTime(2));
            assertTrue(resultSet.next());
            assertNull(resultSet.getTime(2));
            assertFalse(resultSet.next());
        }
    }
}

######


public void testPreparedStatementGetString(Connection connection) throws SQLException {
    Assume.assumeTrue(doPrecisionTest);
    try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
        try (ResultSet resultSet = preparedStatement.executeQuery()) {
            assertTrue(resultSet.next());
            assertEquals("00:00:00.000000", resultSet.getString(2));
            assertTrue(resultSet.next());
            assertEquals("00:00:00.123000", resultSet.getString(2));
            assertTrue(resultSet.next());
            assertNull(resultSet.getString(2));
            assertFalse(resultSet.next());
        }
    }
}

######


@Test
public void testTimePrepareStatement() {
    Assume.assumeTrue(doPrecisionTest);
    try (Connection connection = setConnection("&useServerPrepStmts=true")) {
        testStatementGetTime(connection);
        testPreparedStatementGetTime(connection);
        testStatementGetString(connection);
        testPreparedStatementGetString(connection);
    } catch (Exception e) {
        e.printStackTrace();
        fail();
    }
}

######


@Test
public void testTimeNotPrepareStatement() throws SQLException {
    Assume.assumeTrue(doPrecisionTest);
    try (Connection connection = setConnection("&useServerPrepStmts=false")) {
        testStatementGetTime(connection);
        testPreparedStatementGetTime(connection);
        testStatementGetString(connection);
        testPreparedStatementGetString(connection);
    }
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("signedTinyIntTest", "id TINYINT");
    createTable("signedSmallIntTest", "id SMALLINT");
    createTable("signedMediumIntTest", "id MEDIUMINT");
    createTable("signedIntTest", "id INT");
    createTable("signedBigIntTest", "id BIGINT");
    createTable("signedDecimalTest", "id DECIMAL(65,20)");
}

######


@Test
public void unsignedTinyIntTest() throws SQLException {
    sharedConnection.createStatement().execute("insert into signedTinyIntTest values (120)");
    sharedConnection.createStatement().execute("insert into signedTinyIntTest values (1)");
    sharedConnection.createStatement().execute("insert into signedTinyIntTest values (null)");
    sharedConnection.createStatement().execute("insert into signedTinyIntTest values (-1)");
    try (ResultSet rs = DatatypeTest.getResultSet("select * from signedTinyIntTest", false)) {
        assertTrue(signedTinyIntTestResult(rs));
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from signedTinyIntTest", true)) {
        assertTrue(signedTinyIntTestResult(rs));
    }
}

######


private boolean signedTinyIntTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        assertEquals(120, rs.getByte(1));
        assertEquals(120, rs.getShort(1));
        assertEquals(120, rs.getInt(1));
        assertEquals(120L, rs.getLong(1));
        assertEquals(120D, rs.getDouble(1), .000001);
        assertEquals(120F, rs.getFloat(1), .000001);
        assertEquals("120", rs.getString(1));
        assertEquals(new BigDecimal("120"), rs.getBigDecimal(1));
        if (rs.next()) {
            oneNullNegativeTest(rs);
            return true;
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
    return false;
}

######


@Test
public void signedSmallIntTest() throws SQLException {
    sharedConnection.createStatement().execute("insert into signedSmallIntTest values (32767)");
    sharedConnection.createStatement().execute("insert into signedSmallIntTest values (1)");
    sharedConnection.createStatement().execute("insert into signedSmallIntTest values (null)");
    sharedConnection.createStatement().execute("insert into signedSmallIntTest values (-1)");
    try (ResultSet rs = DatatypeTest.getResultSet("select * from signedSmallIntTest", false)) {
        signedSmallIntTestResult(rs);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from signedSmallIntTest", true)) {
        signedSmallIntTestResult(rs);
    }
}

######


private void signedSmallIntTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        assertEquals(32767, rs.getShort(1));
        assertEquals(32767, rs.getInt(1));
        assertEquals(32767L, rs.getLong(1));
        assertEquals(32767D, rs.getDouble(1), .000001);
        assertEquals(32767F, rs.getFloat(1), .000001);
        assertEquals(new BigDecimal("32767"), rs.getBigDecimal(1));
        assertEquals("32767", rs.getString(1));
        if (rs.next()) {
            oneNullNegativeTest(rs);
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void signedMediumIntTest() throws SQLException {
    sharedConnection.createStatement().execute("insert into signedMediumIntTest values (8388607)");
    sharedConnection.createStatement().execute("insert into signedMediumIntTest values (1)");
    sharedConnection.createStatement().execute("insert into signedMediumIntTest values (null)");
    sharedConnection.createStatement().execute("insert into signedMediumIntTest values (-1)");
    try (ResultSet rs = DatatypeTest.getResultSet("select * from signedMediumIntTest", false)) {
        signedMediumIntTestResult(rs);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from signedMediumIntTest", true)) {
        signedMediumIntTestResult(rs);
    }
}

######


private void signedMediumIntTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        shortMustFail(rs);
        assertEquals(8388607, rs.getInt(1));
        assertEquals(8388607L, rs.getLong(1));
        assertEquals(8388607D, rs.getDouble(1), .000001);
        assertEquals(8388607F, rs.getFloat(1), .000001);
        assertEquals(new BigDecimal("8388607"), rs.getBigDecimal(1));
        assertEquals("8388607", rs.getString(1));
        if (rs.next()) {
            oneNullNegativeTest(rs);
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void signedIntTest() throws SQLException {
    sharedConnection.createStatement().execute("insert into signedIntTest values (2147483647)");
    sharedConnection.createStatement().execute("insert into signedIntTest values (1)");
    sharedConnection.createStatement().execute("insert into signedIntTest values (null)");
    sharedConnection.createStatement().execute("insert into signedIntTest values (-1)");
    try (ResultSet rs = DatatypeTest.getResultSet("select * from signedIntTest", false)) {
        signedIntTestResult(rs);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from signedIntTest", true)) {
        signedIntTestResult(rs);
    }
}

######


private void signedIntTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        shortMustFail(rs);
        assertEquals(2147483647, rs.getInt(1));
        assertEquals(2147483647L, rs.getLong(1));
        assertEquals(2147483647D, rs.getDouble(1), .000001);
        assertEquals(2147483647F, rs.getFloat(1), .000001);
        assertEquals(new BigDecimal("2147483647"), rs.getBigDecimal(1));
        assertEquals("2147483647", rs.getString(1));
        if (rs.next()) {
            oneNullNegativeTest(rs);
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void signedBigIntTest() throws SQLException {
    sharedConnection.createStatement().execute("insert into signedBigIntTest values (9223372036854775807)");
    sharedConnection.createStatement().execute("insert into signedBigIntTest values (1)");
    sharedConnection.createStatement().execute("insert into signedBigIntTest values (null)");
    sharedConnection.createStatement().execute("insert into signedBigIntTest values (-1)");
    try (ResultSet rs = DatatypeTest.getResultSet("select * from signedBigIntTest", false)) {
        signedBigIntTestResult(rs);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from signedBigIntTest", true)) {
        signedBigIntTestResult(rs);
    }
}

######


private void signedBigIntTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        shortMustFail(rs);
        intMustFail(rs);
        assertEquals(9223372036854775807L, rs.getLong(1));
        assertEquals(9223372036854775807F, rs.getFloat(1), .000001);
        assertEquals(9223372036854775807D, rs.getDouble(1), .000001);
        assertEquals(new BigDecimal("9223372036854775807"), rs.getBigDecimal(1));
        assertEquals("9223372036854775807", rs.getString(1));
        if (rs.next()) {
            oneNullNegativeTest(rs);
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void signedDecimalTest() throws SQLException {
    try (Statement statement = sharedConnection.createStatement()) {
        statement.execute("insert into signedDecimalTest values (123456789012345678901234567890.12345678901234567890)");
        statement.execute("insert into signedDecimalTest values (9223372036854775806)");
        statement.execute("insert into signedDecimalTest values (1.1)");
        statement.execute("insert into signedDecimalTest values (1.0)");
        statement.execute("insert into signedDecimalTest values (null)");
        statement.execute("insert into signedDecimalTest values (-1)");
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from signedDecimalTest", false)) {
        signedDecimalTestResult(rs);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from signedDecimalTest", true)) {
        signedDecimalTestResult(rs);
    }
}

######


private void signedDecimalTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        shortMustFail(rs);
        intMustFail(rs);
        longMustFail(rs);
        assertEquals(123456789012345678901234567890.12345678901234567890F, rs.getFloat(1), 1000000000000000000000000D);
        assertEquals(123456789012345678901234567890.12345678901234567890F, rs.getFloat(1), 1000000000000000000000000D);
        assertEquals(123456789012345678901234567890.12345678901234567890D, rs.getDouble(1), 1000000000000000000000000D);
        assertEquals(new BigDecimal("123456789012345678901234567890.12345678901234567890"), rs.getBigDecimal(1));
        assertEquals("123456789012345678901234567890.12345678901234567890", rs.getString(1));
        if (rs.next()) {
            byteMustFail(rs);
            shortMustFail(rs);
            intMustFail(rs);
            assertEquals(9223372036854775806L, rs.getLong(1));
            assertEquals(9223372036854775806F, rs.getFloat(1), .000001);
            assertEquals(9223372036854775806D, rs.getDouble(1), .000001);
            assertEquals(new BigDecimal("9223372036854775806.00000000000000000000"), rs.getBigDecimal(1));
            assertEquals("9223372036854775806.00000000000000000000", rs.getString(1));
            if (rs.next()) {
                assertEquals(1, rs.getByte(1));
                assertEquals(1, rs.getShort(1));
                assertEquals(1, rs.getInt(1));
                assertEquals(1, rs.getLong(1));
                assertEquals(1.1F, rs.getFloat(1), .000001);
                assertEquals(1.1D, rs.getDouble(1), .000001);
                assertEquals("1.10000000000000000000", rs.getString(1));
                assertEquals(new BigDecimal("1.10000000000000000000"), rs.getBigDecimal(1));
                if (rs.next()) {
                    oneNullNegativeTest(rs, true, false);
                } else {
                    fail("must have result !");
                }
            } else {
                fail("must have result !");
            }
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


private void byteMustFail(ResultSet rs) {
    try {
        rs.getByte(1);
        fail("getByte must have thrown error !");
    } catch (SQLException e) {
        assertEquals("22003", e.getSQLState());
    }
}

######


private void shortMustFail(ResultSet rs) {
    try {
        rs.getShort(1);
        fail("getShort must have thrown error !");
    } catch (SQLException e) {
        assertEquals("22003", e.getSQLState());
    }
}

######


private void intMustFail(ResultSet rs) {
    try {
        rs.getInt(1);
        fail("getInt must have thrown error !");
    } catch (SQLException e) {
        assertEquals("22003", e.getSQLState());
    }
}

######


private void longMustFail(ResultSet rs) {
    try {
        rs.getLong(1);
        fail("getLong must have thrown error !");
    } catch (SQLException e) {
        assertEquals("22003", e.getSQLState());
    }
}

######


private void oneNullNegativeTest(ResultSet rs) throws SQLException {
    oneNullNegativeTest(rs, false, false);
}

######


private void oneNullNegativeTest(ResultSet rs, boolean decimal, boolean floatingPoint) throws SQLException {
    try {
        if (!decimal && !floatingPoint) {
            assertTrue(rs.getBoolean(1));
        }
        assertEquals(1, rs.getByte(1));
        assertEquals(1, rs.getShort(1));
        assertEquals(1, rs.getInt(1));
        assertEquals(1L, rs.getLong(1));
        assertEquals(1D, rs.getDouble(1), .000001);
        assertEquals(1F, rs.getFloat(1), .000001);
        if (decimal) {
            if (floatingPoint) {
                BigDecimal bd = rs.getBigDecimal(1);
                if (!bd.equals(new BigDecimal("1")) && !bd.equals(new BigDecimal("1.0"))) {
                    fail("getBigDecimal error : is " + bd.toString());
                }
                assertEquals("1.0", rs.getString(1));
            } else {
                assertEquals(new BigDecimal("1.00000000000000000000"), rs.getBigDecimal(1));
                assertEquals("1.00000000000000000000", rs.getString(1));
            }
        } else {
            assertEquals(new BigDecimal("1"), rs.getBigDecimal(1));
            assertEquals("1", rs.getString(1));
        }
    } catch (SQLException e) {
        e.printStackTrace();
        fail("must not have thrown error");
    }
    if (rs.next()) {
        nullNegativeTest(rs, decimal);
    } else {
        fail("must have result !");
    }
}

######


private void nullNegativeTest(ResultSet rs, boolean decimal) throws SQLException {
    try {
        assertFalse(rs.getBoolean(1));
        assertEquals(0, rs.getByte(1));
        assertTrue(rs.wasNull());
        assertEquals(0, rs.getShort(1));
        assertEquals(0, rs.getInt(1));
        assertEquals(0, rs.getLong(1));
        assertEquals(0, rs.getDouble(1), .00001);
        assertEquals(0, rs.getFloat(1), .00001);
        assertNull(rs.getBigDecimal(1));
        assertNull(rs.getString(1));
    } catch (SQLException e) {
        e.printStackTrace();
        fail("must not have thrown error");
    }
    if (rs.next()) {
        try {
            assertTrue(rs.getBoolean(1));
            assertFalse(rs.wasNull());
            assertEquals(-1, rs.getByte(1));
            assertEquals(-1, rs.getShort(1));
            assertEquals(-1, rs.getInt(1));
            assertEquals(-1, rs.getLong(1));
            assertEquals(-1, rs.getDouble(1), .00001);
            assertEquals(-1, rs.getFloat(1), .00001);
            if (decimal) {
                assertTrue(new BigDecimal("-1.00000000000000000000").equals(rs.getBigDecimal(1)));
                assertEquals("-1.00000000000000000000", rs.getString(1));
            } else {
                assertTrue(new BigDecimal("-1").equals(rs.getBigDecimal(1)));
                assertEquals("-1", rs.getString(1));
            }
        } catch (SQLException e) {
            e.printStackTrace();
            fail("must not have thrown error");
        }
    } else {
        fail("must have result !");
    }
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("Driverstreamtest", "id int not null primary key, strm text");
    createTable("Driverstreamtest2", "id int primary key not null, strm text");
    createTable("objecttest", "int_test int primary key not null, string_test varchar(30), " + "timestamp_test timestamp, serial_test blob");
    createTable("bintest", "id int not null primary key auto_increment, bin1 varbinary(300), bin2 varbinary(300)");
    createTable("bigdectest", "id int not null primary key auto_increment, bd decimal", "engine=innodb");
    createTable("bytetest", "id int not null primary key auto_increment, a int", "engine=innodb");
    createTable("shorttest", "id int not null primary key auto_increment,a int", "engine=innodb");
    createTable("doubletest", "id int not null primary key auto_increment,a double", "engine=innodb");
    createTable("bittest", "id int not null primary key auto_increment, b int");
    createTable("emptytest", "id int");
    createTable("test_setobjectconv", "id int not null primary key auto_increment, v1 varchar(40), v2 varchar(40)");
    createTable("blabla", "valsue varchar(20)");
    createTable("TestBigIntType", "t1 bigint(20), t2 bigint(20), t3 bigint(20), t4 bigint(20)");
    createTable("time_period", "ID int unsigned NOT NULL, START time NOT NULL, END time NOT NULL, PRIMARY KEY (ID)");
    createTable("bitBoolTest", "d1 BOOLEAN, d2 BIT");
}

######


public static ResultSet getResultSet(String query, boolean prepared) throws SQLException {
    return getResultSet(query, prepared, sharedConnection);
}

######


public static ResultSet getResultSet(String query, boolean prepared, Connection connection) throws SQLException {
    if (prepared) {
        PreparedStatement preparedStatement = connection.prepareStatement(query + " WHERE 1 = ?");
        preparedStatement.setInt(1, 1);
        return preparedStatement.executeQuery();
    } else {
        return connection.createStatement().executeQuery(query);
    }
}

######


@Before
public void checkSupported() throws Exception {
    requireMinimumVersion(5, 0);
}

######


private void checkClass(String column, Class<?> clazz, String mysqlType, int javaSqlType) throws Exception {
    int index = resultSet.findColumn(column);
    Object obj = resultSet.getObject(column);
    if (obj != null) {
        if (!clazz.equals(obj.getClass())) {
            System.out.println("test");
        }
        assertEquals("Unexpected class for column " + column, clazz, resultSet.getObject(column).getClass());
    }
    assertEquals("Unexpected class name for column " + column, clazz.getName(), resultSet.getMetaData().getColumnClassName(index));
    assertEquals("Unexpected MySQL type for column " + column, mysqlType, resultSet.getMetaData().getColumnTypeName(index));
    assertEquals("Unexpected java sql type for column " + column, javaSqlType, resultSet.getMetaData().getColumnType(index));
}

######


private void createDataTypeTables() throws SQLException {
    createTable("datatypetest", "bit1 BIT(1) default 0," + "bit2 BIT(2) default 1," + "tinyint1 TINYINT(1) default 0," + "tinyint2 TINYINT(2) default 1," + "bool0 BOOL default 0," + "smallint0 SMALLINT default 1," + "smallint_unsigned SMALLINT UNSIGNED default 0," + "mediumint0 MEDIUMINT default 1," + "mediumint_unsigned MEDIUMINT UNSIGNED default 0," + "int0 INT default 1," + "int_unsigned INT UNSIGNED default 0," + "bigint0 BIGINT default 1," + "bigint_unsigned BIGINT UNSIGNED default 0," + "float0 FLOAT default 0," + "double0 DOUBLE default 1," + "decimal0 DECIMAL default 0," + "date0 DATE default '2001-01-01'," + "datetime0 DATETIME default '2001-01-01 00:00:00'," + "timestamp0 TIMESTAMP default  '2001-01-01 00:00:00'," + "time0 TIME default '22:11:00'," + ((minVersion(5, 6) && strictBeforeVersion(10, 0)) ? "year2 YEAR(4) default 99," : "year2 YEAR(2) default 99,") + "year4 YEAR(4) default 2011," + "char0 CHAR(1) default '0'," + "char_binary CHAR (1) binary default '0'," + "varchar0 VARCHAR(1) default '1'," + "varchar_binary VARCHAR(10) BINARY default 0x1," + "binary0 BINARY(10) default 0x1," + "varbinary0 VARBINARY(10) default 0x1," + "tinyblob0 TINYBLOB," + "tinytext0 TINYTEXT," + "blob0 BLOB," + "text0 TEXT," + "mediumblob0 MEDIUMBLOB," + "mediumtext0 MEDIUMTEXT," + "longblob0 LONGBLOB," + "longtext0 LONGTEXT," + "enum0 ENUM('a','b') default 'a'," + "set0 SET('a','b') default 'a' ");
}

######


public void datatypes(Connection connection, boolean tinyInt1isBit, boolean yearIsDateType) throws Exception {
    createDataTypeTables();
    connection.createStatement().execute("insert into datatypetest (tinyblob0,mediumblob0,blob0,longblob0," + "tinytext0,mediumtext0,text0, longtext0) values(0x1,0x1,0x1,0x1, 'a', 'a', 'a', 'a')");
    resultSet = connection.createStatement().executeQuery("select * from datatypetest");
    resultSet.next();
    Class<?> byteArrayClass = (new byte[0]).getClass();
    checkClass("bit1", Boolean.class, "BIT", Types.BIT);
    checkClass("bit2", byteArrayClass, "BIT", Types.VARBINARY);
    checkClass("tinyint1", tinyInt1isBit ? Boolean.class : Integer.class, "TINYINT", tinyInt1isBit ? Types.BIT : Types.TINYINT);
    checkClass("tinyint2", Integer.class, "TINYINT", Types.TINYINT);
    checkClass("bool0", tinyInt1isBit ? Boolean.class : Integer.class, "TINYINT", tinyInt1isBit ? Types.BIT : Types.TINYINT);
    checkClass("smallint0", Integer.class, "SMALLINT", Types.SMALLINT);
    checkClass("smallint_unsigned", Integer.class, "SMALLINT UNSIGNED", Types.SMALLINT);
    checkClass("mediumint0", Integer.class, "MEDIUMINT", Types.INTEGER);
    checkClass("mediumint_unsigned", Integer.class, "MEDIUMINT UNSIGNED", Types.INTEGER);
    checkClass("int0", Integer.class, "INTEGER", Types.INTEGER);
    checkClass("int_unsigned", Long.class, "INTEGER UNSIGNED", Types.INTEGER);
    checkClass("bigint0", Long.class, "BIGINT", Types.BIGINT);
    checkClass("bigint_unsigned", BigInteger.class, "BIGINT UNSIGNED", Types.BIGINT);
    checkClass("float0", Float.class, "FLOAT", Types.REAL);
    checkClass("double0", Double.class, "DOUBLE", Types.DOUBLE);
    checkClass("decimal0", BigDecimal.class, "DECIMAL", Types.DECIMAL);
    checkClass("date0", Date.class, "DATE", Types.DATE);
    checkClass("time0", Time.class, "TIME", Types.TIME);
    checkClass("timestamp0", Timestamp.class, "TIMESTAMP", Types.TIMESTAMP);
    if (minVersion(5, 6) && strictBeforeVersion(10, 0)) {
        checkClass("year2", yearIsDateType ? Date.class : Short.class, "YEAR", yearIsDateType ? Types.DATE : Types.SMALLINT);
    }
    checkClass("year4", yearIsDateType ? Date.class : Short.class, "YEAR", yearIsDateType ? Types.DATE : Types.SMALLINT);
    checkClass("char0", String.class, "CHAR", Types.CHAR);
    checkClass("char_binary", String.class, "CHAR", Types.CHAR);
    checkClass("varchar0", String.class, "VARCHAR", Types.VARCHAR);
    checkClass("varchar_binary", String.class, "VARCHAR", Types.VARCHAR);
    checkClass("binary0", byteArrayClass, "BINARY", Types.BINARY);
    checkClass("varbinary0", byteArrayClass, "VARBINARY", Types.VARBINARY);
    checkClass("tinyblob0", byteArrayClass, "TINYBLOB", Types.VARBINARY);
    checkClass("tinytext0", String.class, "VARCHAR", Types.VARCHAR);
    checkClass("blob0", byteArrayClass, "BLOB", Types.VARBINARY);
    checkClass("text0", String.class, "VARCHAR", Types.VARCHAR);
    checkClass("mediumblob0", byteArrayClass, "MEDIUMBLOB", Types.VARBINARY);
    checkClass("mediumtext0", String.class, "VARCHAR", Types.VARCHAR);
    checkClass("longblob0", byteArrayClass, "LONGBLOB", Types.LONGVARBINARY);
    checkClass("longtext0", String.class, "VARCHAR", Types.LONGVARCHAR);
    checkClass("enum0", String.class, "CHAR", Types.CHAR);
    checkClass("set0", String.class, "CHAR", Types.CHAR);
    resultSet = connection.createStatement().executeQuery("select NULL as foo");
    resultSet.next();
    checkClass("foo", String.class, "NULL", Types.NULL);
}

######


@Test
public void datatypes1() throws Exception {
    datatypes(sharedConnection, true, true);
}

######


@Test
public void datatypes2() throws Exception {
    try (Connection connection = setConnection("&tinyInt1isBit=0&yearIsDateType=0")) {
        datatypes(connection, false, false);
    }
}

######


@Test
public void datatypes3() throws Exception {
    try (Connection connection = setConnection("&tinyInt1isBit=1&yearIsDateType=0")) {
        datatypes(connection, true, false);
    }
}

######


@Test
public void datatypes4() throws Exception {
    try (Connection connection = setConnection("&tinyInt1isBit=0&yearIsDateType=1")) {
        datatypes(connection, false, true);
    }
}

######


@SuppressWarnings("deprecation")
@Test
public void testCharacterStreams() throws SQLException, IOException {
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into Driverstreamtest (id, strm) values (?,?)");
    stmt.setInt(1, 2);
    String toInsert = "abcdefgh\njklmn\"";
    Reader reader = new StringReader(toInsert);
    stmt.setCharacterStream(2, reader);
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from Driverstreamtest");
    assertTrue(rs.next());
    Reader rdr = rs.getCharacterStream("strm");
    StringBuilder sb = new StringBuilder();
    int ch;
    while ((ch = rdr.read()) != -1) {
        sb.append((char) ch);
    }
    assertEquals(sb.toString(), (toInsert));
    rdr = rs.getCharacterStream(2);
    sb = new StringBuilder();
    while ((ch = rdr.read()) != -1) {
        sb.append((char) ch);
    }
    assertEquals(sb.toString(), (toInsert));
    InputStream is = rs.getAsciiStream("strm");
    sb = new StringBuilder();
    while ((ch = is.read()) != -1) {
        sb.append((char) ch);
    }
    assertEquals(sb.toString(), (toInsert));
    is = rs.getUnicodeStream("strm");
    sb = new StringBuilder();
    while ((ch = is.read()) != -1) {
        sb.append((char) ch);
    }
    assertEquals(sb.toString(), (toInsert));
    assertEquals(sb.toString(), rs.getString("strm"));
}

######


@Test
public void testCharacterStreamWithLength() throws SQLException, IOException {
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into Driverstreamtest2 (id, strm) values (?,?)");
    stmt.setInt(1, 2);
    String toInsert = "abcdefgh\njklmn\"";
    Reader reader = new StringReader(toInsert);
    stmt.setCharacterStream(2, reader, 5);
    stmt.execute();
    testCharacterStreamWithLength(getResultSet("select * from Driverstreamtest2", false), toInsert);
    testCharacterStreamWithLength(getResultSet("select * from Driverstreamtest2", true), toInsert);
}

######


private void testCharacterStreamWithLength(ResultSet rs, String toInsert) throws SQLException, IOException {
    assertTrue(rs.next());
    Reader rdr = rs.getCharacterStream("strm");
    StringBuilder sb = new StringBuilder();
    int ch;
    while ((ch = rdr.read()) != -1) {
        sb.append((char) ch);
    }
    assertEquals(sb.toString(), toInsert.substring(0, 5));
    assertEquals(rs.getString("strm"), toInsert.substring(0, 5));
}

######


@Test
public void testEmptyResultSet() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    assertEquals(true, stmt.execute("SELECT * FROM emptytest"));
    assertEquals(false, stmt.getResultSet().next());
}

######


@Test
public void testLongColName() throws SQLException {
    DatabaseMetaData dbmd = sharedConnection.getMetaData();
    StringBuilder str = new StringBuilder();
    for (int i = 0; i < dbmd.getMaxColumnNameLength(); i++) {
        str.append("x");
    }
    createTable("longcol", str + " int not null primary key");
    sharedConnection.createStatement().execute("insert into longcol values (1)");
    try (ResultSet rs = getResultSet("select * from longcol", false)) {
        assertEquals(true, rs.next());
        assertEquals(1, rs.getInt(1));
        assertEquals(1, rs.getInt(str.toString()));
        assertEquals("1", rs.getString(1));
    }
    try (ResultSet rs = getResultSet("select * from longcol", true)) {
        assertEquals(true, rs.next());
        assertEquals(1, rs.getInt(1));
        assertEquals(1, rs.getInt(str.toString()));
        assertEquals("1", rs.getString(1));
    }
}

######


@Test(expected = SQLException.class)
public void testBadParamlist() throws SQLException {
    PreparedStatement ps = sharedConnection.prepareStatement("insert into blah values (?)");
    ps.execute();
}

######


@Test
public void setBitBoolObjectTest() throws SQLException {
    PreparedStatement ps = sharedConnection.prepareStatement("insert into bitBoolTest values (?,?)");
    ps.setObject(1, 0);
    ps.setObject(2, 0);
    ps.addBatch();
    ps.setObject(1, 1);
    ps.setObject(2, 1);
    ps.addBatch();
    ps.setObject(1, "0", Types.BOOLEAN);
    ps.setObject(2, "0", Types.BIT);
    ps.addBatch();
    ps.setObject(1, "1", Types.BOOLEAN);
    ps.setObject(2, "1", Types.BIT);
    ps.addBatch();
    ps.setObject(1, "true", Types.BOOLEAN);
    ps.setObject(2, "true", Types.BIT);
    ps.addBatch();
    ps.setObject(1, "truee", Types.BOOLEAN);
    ps.setObject(2, "truee", Types.BIT);
    ps.addBatch();
    ps.setObject(1, "false", Types.BOOLEAN);
    ps.setObject(2, "false", Types.BIT);
    ps.addBatch();
    ps.executeBatch();
    try (ResultSet rs = sharedConnection.createStatement().executeQuery("select * from bitBoolTest")) {
        assertValue(rs, false);
        assertValue(rs, true);
        assertValue(rs, false);
        assertValue(rs, true);
        assertValue(rs, true);
        assertValue(rs, true);
        assertValue(rs, false);
        assertFalse(rs.next());
    }
}

######


private void assertValue(ResultSet rs, boolean bool) throws SQLException {
    assertTrue(rs.next());
    if (bool) {
        assertTrue(rs.getBoolean(1));
        assertTrue(rs.getBoolean(2));
    } else {
        assertFalse(rs.getBoolean(1));
        assertFalse(rs.getBoolean(2));
    }
}

######


@Test
public void setObjectTest() throws SQLException, IOException, ClassNotFoundException {
    PreparedStatement ps = sharedConnection.prepareStatement("insert into objecttest values (?,?,?,?)");
    ps.setObject(1, 5);
    ps.setObject(2, "aaa");
    ps.setObject(3, Timestamp.valueOf("2009-01-17 15:41:01"));
    ps.setObject(4, new SerializableClass("testing", 8));
    ps.execute();
    try (ResultSet rs = getResultSet("select * from objecttest", false)) {
        if (rs.next()) {
            setObjectTestResult(rs);
        } else {
            fail();
        }
    }
    try (ResultSet rs = getResultSet("select * from objecttest", true)) {
        if (rs.next()) {
            setObjectTestResult(rs);
        } else {
            fail();
        }
    }
}

######


private void setObjectTestResult(ResultSet rs) throws SQLException, IOException, ClassNotFoundException {
    assertEquals("5", rs.getString(1));
    assertEquals("aaa", rs.getString(2));
    assertEquals("2009-01-17 15:41:01.0", rs.getString(3));
    Object theInt = rs.getObject(1);
    assertTrue(theInt instanceof Integer);
    Object theInt2 = rs.getObject("int_test");
    assertTrue(theInt2 instanceof Integer);
    Object theString = rs.getObject(2);
    assertTrue(theString instanceof String);
    Object theTimestamp = rs.getObject(3);
    assertTrue(theTimestamp instanceof Timestamp);
    Object theBlob = rs.getObject(4);
    assertNotNull(theBlob);
    byte[] rawBytes = rs.getBytes(4);
    ByteArrayInputStream bais = new ByteArrayInputStream(rawBytes);
    ObjectInputStream ois = new ObjectInputStream(bais);
    SerializableClass sc = (SerializableClass) ois.readObject();
    assertEquals(sc.getVal(), "testing");
    assertEquals(sc.getVal2(), 8);
    rawBytes = rs.getBytes("serial_test");
    bais = new ByteArrayInputStream(rawBytes);
    ois = new ObjectInputStream(bais);
    sc = (SerializableClass) ois.readObject();
    assertEquals(sc.getVal(), "testing");
    assertEquals(sc.getVal2(), 8);
}

######


@Test
public void setObjectBitInt() throws SQLException {
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO TestBigIntType " + "(t1, t2, t3, t4) VALUES (?, ?, ?, ?)");
    final long valueLong = System.currentTimeMillis();
    final String maxValue = String.valueOf(Long.MAX_VALUE);
    preparedStatement.setObject(1, valueLong, Types.BIGINT);
    preparedStatement.setObject(2, maxValue, Types.BIGINT);
    preparedStatement.setObject(3, valueLong);
    preparedStatement.setObject(4, maxValue);
    preparedStatement.executeUpdate();
    try (ResultSet rs = getResultSet("select * from TestBigIntType", false)) {
        validateResultBigIntType(valueLong, maxValue, rs);
    }
    try (ResultSet rs = getResultSet("select * from TestBigIntType", true)) {
        validateResultBigIntType(valueLong, maxValue, rs);
    }
}

######


private void validateResultBigIntType(long valueLong, String maxValue, ResultSet resultSet) throws SQLException {
    if (resultSet.next()) {
        assertEquals(resultSet.getLong(1), valueLong);
        assertEquals(resultSet.getLong(2), Long.parseLong(maxValue));
        assertEquals(resultSet.getLong(3), valueLong);
        assertEquals(resultSet.getLong(4), Long.parseLong(maxValue));
        assertEquals(resultSet.getString(1), String.valueOf(valueLong));
        assertEquals(resultSet.getString(2), String.valueOf(Long.parseLong(maxValue)));
        assertEquals(resultSet.getString(3), String.valueOf(valueLong));
        assertEquals(resultSet.getString(4), String.valueOf(Long.parseLong(maxValue)));
    } else {
        fail();
    }
}

######


@Test
public void binTest() throws SQLException, IOException {
    byte[] allBytes = new byte[256];
    for (int i = 0; i < 256; i++) {
        allBytes[i] = (byte) (i & 0xff);
    }
    ByteArrayInputStream bais = new ByteArrayInputStream(allBytes);
    PreparedStatement ps = sharedConnection.prepareStatement("insert into bintest (bin1,bin2) values (?,?)");
    ps.setBytes(1, allBytes);
    ps.setBinaryStream(2, bais);
    ps.execute();
    try (ResultSet rs = getResultSet("select bin1,bin2 from bintest", false)) {
        binTestResult(rs, allBytes);
    }
    try (ResultSet rs = getResultSet("select bin1,bin2 from bintest", true)) {
        binTestResult(rs, allBytes);
    }
}

######


private void binTestResult(ResultSet rs, byte[] allBytes) throws SQLException, IOException {
    if (rs.next()) {
        rs.getBlob(1);
        InputStream is = rs.getBinaryStream(1);
        for (int i = 0; i < 256; i++) {
            int read = is.read();
            assertEquals(i, read);
        }
        assertEquals(rs.getString(1), new String(allBytes, StandardCharsets.UTF_8));
        is = rs.getBinaryStream(2);
        for (int i = 0; i < 256; i++) {
            int read = is.read();
            assertEquals(i, read);
        }
        assertEquals(rs.getString(2), new String(allBytes, StandardCharsets.UTF_8));
    } else {
        fail("Must have result !");
    }
}

######


@Test
public void binTest2() throws SQLException {
    createTable("bintest2", "bin1 longblob", "engine=innodb");
    byte[] buf = new byte[1000000];
    for (int i = 0; i < 1000000; i++) {
        buf[i] = (byte) i;
    }
    InputStream is = new ByteArrayInputStream(buf);
    try (Connection connection = setConnection()) {
        PreparedStatement ps = connection.prepareStatement("insert into bintest2 (bin1) values (?)");
        ps.setBinaryStream(1, is);
        ps.execute();
        ps = connection.prepareStatement("insert into bintest2 (bin1) values (?)");
        is = new ByteArrayInputStream(buf);
        ps.setBinaryStream(1, is);
        ps.execute();
        try (ResultSet rs = getResultSet("select bin1 from bintest2", false)) {
            binTest2Result(rs, buf);
        }
        try (ResultSet rs = getResultSet("select bin1 from bintest2", true)) {
            binTest2Result(rs, buf);
        }
    }
}

######


@Test
public void binTest3() throws SQLException {
    byte[] buf = new byte[1000000];
    for (int i = 0; i < 1000000; i++) {
        buf[i] = (byte) i;
    }
    InputStream is = new ByteArrayInputStream(buf);
    try (Connection connection = setConnection()) {
        createTable("bintest3", "bin1 longblob", "engine=innodb");
        Statement stmt = connection.createStatement();
        try (PreparedStatement ps = connection.prepareStatement("insert into bintest3 (bin1) values (?)")) {
            ps.setBinaryStream(1, is);
            ps.execute();
        }
        ResultSet rs = stmt.executeQuery("select bin1 from bintest3");
        assertTrue(rs.next());
        byte[] buf2 = rs.getBytes(1);
        assertEquals(1000000, buf2.length);
        for (int i = 0; i < 1000000; i++) {
            assertEquals(buf[i], buf2[i]);
        }
    }
}

######


private void binTest2Result(ResultSet rs, byte[] buf) throws SQLException {
    if (rs.next()) {
        byte[] buf2 = rs.getBytes(1);
        for (int i = 0; i < 1000000; i++) {
            assertEquals((byte) i, buf2[i]);
        }
        assertEquals(rs.getString(1), new String(buf, Charset.forName("UTF-8")));
        if (rs.next()) {
            buf2 = rs.getBytes(1);
            for (int i = 0; i < 1000000; i++) {
                assertEquals((byte) i, buf2[i]);
            }
            assertEquals(rs.getString(1), new String(buf, Charset.forName("UTF-8")));
            if (rs.next()) {
                fail();
            }
        } else {
            fail();
        }
    } else {
        fail();
    }
}

######


@Test
public void bigDecimalTest() throws SQLException {
    requireMinimumVersion(5, 0);
    BigDecimal bd = BigDecimal.TEN;
    PreparedStatement ps = sharedConnection.prepareStatement("insert into bigdectest (bd) values (?)");
    ps.setBigDecimal(1, bd);
    ps.execute();
    try (ResultSet rs = getResultSet("select bd from bigdectest", false)) {
        bigDecimalTestResult(rs, bd);
    }
    try (ResultSet rs = getResultSet("select bd from bigdectest", true)) {
        bigDecimalTestResult(rs, bd);
    }
}

######


private void bigDecimalTestResult(ResultSet rs, BigDecimal bd) throws SQLException {
    if (rs.next()) {
        Object bb = rs.getObject(1);
        assertEquals(bd, bb);
        BigDecimal bigD = rs.getBigDecimal(1);
        BigDecimal bigD2 = rs.getBigDecimal("bd");
        assertEquals(bd, bigD);
        assertEquals(bd, bigD2);
        assertEquals(rs.getString(1), "10");
        bigD = rs.getBigDecimal("bd");
        assertEquals(bd, bigD);
    } else {
        fail("Must have resultset");
    }
}

######


@Test
public void byteTest() throws SQLException {
    PreparedStatement ps = sharedConnection.prepareStatement("insert into bytetest (a) values (?)");
    ps.setByte(1, Byte.MAX_VALUE);
    assertFalse(ps.execute());
    try (ResultSet rs = getResultSet("select a from bytetest", false)) {
        byteTestResult(rs);
    }
    try (ResultSet rs = getResultSet("select a from bytetest", true)) {
        byteTestResult(rs);
    }
}

######


private void byteTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        Byte bc = rs.getByte(1);
        Byte bc2 = rs.getByte("a");
        assertTrue(Byte.MAX_VALUE == bc);
        assertEquals(bc2, bc);
        assertEquals(rs.getString(1), "127");
    } else {
        fail();
    }
}

######


@Test
public void shortTest() throws SQLException {
    PreparedStatement ps = sharedConnection.prepareStatement("insert into shorttest (a) values (?)");
    ps.setShort(1, Short.MAX_VALUE);
    ps.execute();
    try (ResultSet rs = getResultSet("select a from shorttest", false)) {
        shortTestResult(rs);
    }
    try (ResultSet rs = getResultSet("select a from shorttest", true)) {
        shortTestResult(rs);
    }
}

######


private void shortTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        Short bc = rs.getShort(1);
        Short bc2 = rs.getShort("a");
        assertTrue(Short.MAX_VALUE == bc);
        assertEquals(bc2, bc);
        assertEquals(rs.getString(1), "32767");
    } else {
        fail("must have result !");
    }
}

######


@Test
public void doubleTest() throws SQLException {
    PreparedStatement ps = sharedConnection.prepareStatement("insert into doubletest (a) values (?)");
    double sendDoubleValue = 1.5;
    ps.setDouble(1, sendDoubleValue);
    ps.execute();
    try (ResultSet rs = getResultSet("select a from doubletest", false)) {
        doubleTestResult(rs, sendDoubleValue);
    }
    try (ResultSet rs = getResultSet("select a from doubletest", true)) {
        doubleTestResult(rs, sendDoubleValue);
    }
}

######


private void doubleTestResult(ResultSet rs, Double sendDoubleValue) throws SQLException {
    if (rs.next()) {
        Object returnObject = rs.getObject(1);
        assertEquals(returnObject.getClass(), Double.class);
        Double bc = rs.getDouble(1);
        Double bc2 = rs.getDouble("a");
        assertTrue(sendDoubleValue.doubleValue() == bc);
        assertEquals(bc2, bc);
        assertEquals(rs.getString(1), "1.5");
    } else {
        fail("must have result !");
    }
}

######


@Test
public void getUrlTest() throws SQLException {
    try (ResultSet rs = getResultSet("select 'http://mariadb.org' as url FROM dual", false)) {
        getUrlTestResult(rs);
    }
    try (ResultSet rs = getResultSet("select 'http://mariadb.org' as url FROM dual", true)) {
        getUrlTestResult(rs);
    }
}

######


private void getUrlTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        URL url = rs.getURL(1);
        assertEquals("http://mariadb.org", url.toString());
        url = rs.getURL("url");
        assertEquals("http://mariadb.org", url.toString());
        assertEquals("http://mariadb.org", rs.getString(1));
    } else {
        fail("must have result");
    }
}

######


@Test
public void getUrlFailTest() throws SQLException {
    try (ResultSet rs = getResultSet("select 'asdf' as url FROM dual", false)) {
        getUrlFailTestResult(rs);
    }
    try (ResultSet rs = getResultSet("select 'asdf' as url FROM dual", true)) {
        getUrlFailTestResult(rs);
    }
}

######


private void getUrlFailTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        try {
            rs.getURL(1);
            fail("must have thrown error");
        } catch (SQLException e) {
        }
        try {
            rs.getURL("url");
            fail("must have thrown error");
        } catch (SQLException e) {
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void setNull() throws SQLException {
    PreparedStatement ps = sharedConnection.prepareStatement("insert blabla VALUE (?)");
    ps.setString(1, null);
    ps.executeQuery();
    try (ResultSet rs = getResultSet("select * from blabla", false)) {
        setNullResult(rs);
    }
    try (ResultSet rs = getResultSet("select * from blabla", true)) {
        setNullResult(rs);
    }
}

######


private void setNullResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        assertNull(rs.getString(1));
        assertNull(rs.getObject(1));
    } else {
        fail("must have result !");
    }
}

######


@Test
public void testSetObject() throws SQLException {
    PreparedStatement ps = sharedConnection.prepareStatement("insert into test_setobjectconv values (null, ?, ?)");
    ps.setObject(1, "2009-01-01 00:00:00", Types.TIMESTAMP);
    ps.setObject(2, "33", Types.DOUBLE);
    ps.execute();
}

######


@Test
public void testBit() throws SQLException {
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into bittest values(null, ?)");
    stmt.setBoolean(1, true);
    stmt.execute();
    stmt.setBoolean(1, false);
    stmt.execute();
    try (ResultSet rs = getResultSet("select * from bittest", false)) {
        testBitResult(rs);
    }
    try (ResultSet rs = getResultSet("select * from bittest", true)) {
        testBitResult(rs);
    }
}

######


private void testBitResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        assertTrue(rs.getBoolean("b"));
        assertEquals(rs.getString("b"), "1");
        if (rs.next()) {
            assertFalse(rs.getBoolean("b"));
            assertEquals(rs.getString("b"), "0");
        } else {
            fail("must have result");
        }
    } else {
        fail("must have result");
    }
}

######


@Test
@SuppressWarnings("deprecation")
public void testNullTimePreparedStatement() throws Exception {
    sharedConnection.createStatement().execute("insert into time_period(id, start, end) values(1, '00:00:00', '08:00:00');");
    final String sql = "SELECT id, start, end FROM time_period WHERE id=?";
    PreparedStatement preparedStatement = sharedConnection.prepareStatement(sql);
    preparedStatement.setInt(1, 1);
    try (ResultSet resultSet = preparedStatement.executeQuery()) {
        if (resultSet.next()) {
            Time timeStart = resultSet.getTime(2);
            Time timeEnd = resultSet.getTime(3);
            assertEquals(timeStart, new Time(0, 0, 0));
            assertEquals(timeEnd, new Time(8, 0, 0));
        }
    }
}

######


@Test
public void longMinValueSpecificity() throws SQLException {
    createTable("longMinValueSpecificity", "ii BIGINT");
    try (Statement statement = sharedConnection.createStatement()) {
        try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO longMinValueSpecificity values (?)")) {
            preparedStatement.setLong(1, Long.MAX_VALUE);
            preparedStatement.executeQuery();
            preparedStatement.setLong(1, Long.MIN_VALUE);
            preparedStatement.executeQuery();
        }
        try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT * from longMinValueSpecificity")) {
            ResultSet resultSet = preparedStatement.executeQuery();
            assertTrue(resultSet.next());
            assertEquals(Long.MAX_VALUE, resultSet.getLong(1));
            assertTrue(resultSet.next());
            assertEquals(Long.MIN_VALUE, resultSet.getLong(1));
        }
        ResultSet resultSet = statement.executeQuery("SELECT * from longMinValueSpecificity");
        assertTrue(resultSet.next());
        assertEquals(Long.MAX_VALUE, resultSet.getLong(1));
        assertTrue(resultSet.next());
        assertEquals(Long.MIN_VALUE, resultSet.getLong(1));
    }
}

######


@Test
public void testBinarySetter() throws Throwable {
    createTable("LatinTable", "t1 varchar(30)", "DEFAULT CHARSET=latin1");
    try (Connection connection = DriverManager.getConnection(connU + "?user=" + username + ((password != null && !password.isEmpty()) ? "&password=" + password : "") + "&useServerPrepStmts=true")) {
        checkCharactersInsert(connection);
    }
    Statement stmt = sharedConnection.createStatement();
    assertFalse(stmt.execute("truncate LatinTable"));
    try (Connection connection = DriverManager.getConnection(connU + "?user=" + username + (password != null && !"".equals(password) ? "&password=" + password : "") + "&useServerPrepStmts=false")) {
        checkCharactersInsert(connection);
    }
}

######


private void checkCharactersInsert(Connection connection) throws Throwable {
    try (PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO LatinTable(t1)  values (?)")) {
        String str = "你好(hello in Chinese)";
        try {
            preparedStatement.setString(1, str);
            preparedStatement.execute();
            fail("must have fail");
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage().contains("Incorrect string value"));
        }
        try {
            preparedStatement.setBytes(1, str.getBytes(StandardCharsets.UTF_8));
            preparedStatement.execute();
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage().contains("Incorrect string value"));
        }
        ByteArrayInputStream bais = new ByteArrayInputStream(str.getBytes(StandardCharsets.UTF_8));
        preparedStatement.setBinaryStream(1, bais);
        preparedStatement.execute();
    }
}

######


@Test
public void testBitValues() throws SQLException {
    createTable("testShortBit", "bitVal BIT(1), bitVal2 BIT(40)");
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("INSERT INTO testShortBit VALUES (0,0), (1,1), (1, b'01010101'), (1, 21845), (1, b'1101010101010101')" + ", (1, b'10000000000000000000000000000000')");
    validResultSetBitValue(stmt.executeQuery("SELECT * FROM testShortBit"));
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT * FROM testShortBit")) {
        validResultSetBitValue(preparedStatement.executeQuery());
    }
}

######


@Test
public void testNullGetObject() throws SQLException {
    createTable("testTextNullValue", "id int, val text");
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("INSERT INTO testTextNullValue VALUES (1, 'abc'), (2, null)");
    ResultSet rs = stmt.executeQuery("SELECT * FROM testTextNullValue");
    assertTrue(rs.next());
    assertArrayEquals(rs.getObject(2, byte[].class), "abc".getBytes());
    assertTrue(rs.next());
    assertNull(rs.getObject(2, byte[].class));
}

######


private void validResultSetBitValue(ResultSet rs) throws SQLException {
    assertTrue(rs.next());
    checkAllDataType(rs, 1, 0);
    checkAllDataType(rs, 2, 0);
    assertTrue(rs.next());
    checkAllDataType(rs, 1, 1);
    checkAllDataType(rs, 2, 1);
    assertTrue(rs.next());
    checkAllDataType(rs, 1, 1);
    checkAllDataType(rs, 2, 85);
    assertTrue(rs.next());
    checkAllDataType(rs, 1, 1);
    checkAllDataType(rs, 2, 21845);
    assertTrue(rs.next());
    checkAllDataType(rs, 1, 1);
    checkAllDataType(rs, 2, 54613);
    assertTrue(rs.next());
    checkAllDataType(rs, 1, 1);
    checkAllDataType(rs, 2, 2147483648L);
}

######


private void checkAllDataType(ResultSet rs, int index, long expectedValue) throws SQLException {
    try {
        assertEquals((byte) expectedValue, rs.getByte(index));
        if (expectedValue > Byte.MAX_VALUE) {
            fail();
        }
    } catch (SQLException sqle) {
        if (expectedValue < Byte.MAX_VALUE) {
            fail();
        }
        assertTrue(sqle.getMessage().contains("Out of range"));
    }
    try {
        assertEquals((short) expectedValue, rs.getShort(index));
        if (expectedValue > Short.MAX_VALUE) {
            fail();
        }
    } catch (SQLException sqle) {
        if (expectedValue < Short.MAX_VALUE) {
            fail();
        }
        assertTrue(sqle.getMessage().contains("Out of range"));
    }
    try {
        assertEquals((int) expectedValue, rs.getInt(index));
        if (expectedValue > Integer.MAX_VALUE) {
            fail();
        }
    } catch (SQLException sqle) {
        if (expectedValue < Integer.MAX_VALUE) {
            fail();
        }
        assertTrue(sqle.getMessage().contains("Out of range"));
    }
    assertEquals(expectedValue != 0, rs.getBoolean(index));
    assertEquals(expectedValue, rs.getLong(index));
    assertEquals((float) expectedValue, rs.getFloat(index), 0.01);
    assertEquals((double) expectedValue, rs.getDouble(index), 0.01);
    assertEquals(new BigDecimal(expectedValue), rs.getBigDecimal(index));
    assertEquals(String.valueOf(expectedValue), rs.getString(index));
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("unsignedBitTest", "id BIT(8)");
    createTable("unsignedTinyIntTest", "id TINYINT UNSIGNED");
    createTable("unsignedSmallIntTest", "id SMALLINT UNSIGNED");
    createTable("yearTest", "id YEAR(4) ");
    createTable("unsignedMediumIntTest", "id MEDIUMINT UNSIGNED");
    createTable("unsignedIntTest", "id INT UNSIGNED");
    createTable("unsignedBigIntTest", "id BIGINT UNSIGNED");
    createTable("unsignedDecimalTest", "id DECIMAL(65,20) UNSIGNED");
    createTable("unsignedFloatTest", "id FLOAT UNSIGNED");
    createTable("unsignedDoubleTest", "id DOUBLE UNSIGNED");
}

######


@Test
public void unsignedBitTest() throws SQLException {
    sharedConnection.createStatement().execute("insert into unsignedBitTest values (b'01000000')");
    sharedConnection.createStatement().execute("insert into unsignedBitTest values (b'00000001')");
    sharedConnection.createStatement().execute("insert into unsignedBitTest values (b'00000000')");
    sharedConnection.createStatement().execute("insert into unsignedBitTest values (null)");
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedBitTest", false)) {
        unsignedBitTestResult(rs);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedBitTest", true)) {
        unsignedBitTestResult(rs);
    }
}

######


private void unsignedBitTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        assertEquals(64, rs.getByte(1));
        if (rs.next()) {
            assertTrue(rs.getBoolean(1));
            assertEquals(1, rs.getByte(1));
            if (rs.next()) {
                assertFalse(rs.getBoolean(1));
                assertEquals(0, rs.getByte(1));
                if (rs.next()) {
                    assertFalse(rs.getBoolean(1));
                    assertEquals(0, rs.getByte(1));
                } else {
                    fail("must have result !");
                }
            } else {
                fail("must have result !");
            }
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void unsignedTinyIntTest() throws SQLException {
    sharedConnection.createStatement().execute("insert into unsignedTinyIntTest values (200)");
    sharedConnection.createStatement().execute("insert into unsignedTinyIntTest values (120)");
    sharedConnection.createStatement().execute("insert into unsignedTinyIntTest values (1)");
    sharedConnection.createStatement().execute("insert into unsignedTinyIntTest values (null)");
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedTinyIntTest", false)) {
        unsignedTinyIntTestResult(rs);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedTinyIntTest", true)) {
        unsignedTinyIntTestResult(rs);
    }
}

######


private void unsignedTinyIntTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        assertEquals(200, rs.getShort(1));
        assertEquals(200, rs.getInt(1));
        assertEquals(200L, rs.getLong(1));
        assertEquals(200D, rs.getDouble(1), .000001);
        assertEquals(200F, rs.getFloat(1), .000001);
        assertEquals("200", rs.getString(1));
        assertEquals(new BigDecimal("200"), rs.getBigDecimal(1));
        if (rs.next()) {
            assertEquals(120, rs.getByte(1));
            assertEquals(120, rs.getShort(1));
            assertEquals(120, rs.getInt(1));
            assertEquals(120L, rs.getLong(1));
            assertEquals(120D, rs.getDouble(1), .000001);
            assertEquals(120F, rs.getFloat(1), .000001);
            assertEquals("120", rs.getString(1));
            assertEquals(new BigDecimal("120"), rs.getBigDecimal(1));
            if (rs.next()) {
                oneNullTest(rs);
            } else {
                fail("must have result !");
            }
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void unsignedSmallIntTest() throws SQLException {
    sharedConnection.createStatement().execute("insert into unsignedSmallIntTest values (65535)");
    sharedConnection.createStatement().execute("insert into unsignedSmallIntTest values (32767)");
    sharedConnection.createStatement().execute("insert into unsignedSmallIntTest values (1)");
    sharedConnection.createStatement().execute("insert into unsignedSmallIntTest values (null)");
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedSmallIntTest", false)) {
        unsignedSmallIntTestResult(rs);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedSmallIntTest", true)) {
        unsignedSmallIntTestResult(rs);
    }
}

######


private void unsignedSmallIntTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        shortMustFail(rs);
        assertEquals(65535, rs.getInt(1));
        assertEquals(65535L, rs.getLong(1));
        assertEquals(65535D, rs.getDouble(1), .000001);
        assertEquals(65535F, rs.getFloat(1), .000001);
        assertEquals("65535", rs.getString(1));
        assertEquals(new BigDecimal("65535"), rs.getBigDecimal(1));
        if (rs.next()) {
            byteMustFail(rs);
            assertEquals(32767, rs.getShort(1));
            assertEquals(32767, rs.getInt(1));
            assertEquals(32767L, rs.getLong(1));
            assertEquals(32767D, rs.getDouble(1), .000001);
            assertEquals(32767F, rs.getFloat(1), .000001);
            assertEquals(new BigDecimal("32767"), rs.getBigDecimal(1));
            assertEquals("32767", rs.getString(1));
            if (rs.next()) {
                oneNullTest(rs);
            } else {
                fail("must have result !");
            }
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void yearTest() throws SQLException {
    sharedConnection.createStatement().execute("insert into yearTest values (2155)");
    sharedConnection.createStatement().execute("insert into yearTest values (0)");
    sharedConnection.createStatement().execute("insert into yearTest values (null)");
    try (Connection connection = setConnection("&yearIsDateType=false")) {
        try (ResultSet rs = DatatypeTest.getResultSet("select * from yearTest", false, connection)) {
            yearTestResult(rs, false);
        }
        try (ResultSet rs = DatatypeTest.getResultSet("select * from yearTest", true, connection)) {
            yearTestResult(rs, sharedOptions().useServerPrepStmts);
        }
    }
}

######


private void yearTestResult(ResultSet rs, boolean binary) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        assertEquals(2155, rs.getShort(1));
        assertEquals(2155, rs.getInt(1));
        assertEquals(2155L, rs.getLong(1));
        assertEquals(2155D, rs.getDouble(1), .000001);
        assertEquals(2155F, rs.getFloat(1), .000001);
        assertEquals("2155", rs.getString(1));
        assertEquals(new BigDecimal("2155"), rs.getBigDecimal(1));
        if (rs.next()) {
            assertEquals(0, rs.getByte(1));
            assertEquals(0, rs.getShort(1));
            assertEquals(0, rs.getInt(1));
            assertEquals(0, rs.getLong(1));
            assertEquals(0, rs.getDouble(1), .000001);
            assertEquals(0, rs.getFloat(1), .000001);
            assertEquals(new BigDecimal("0"), rs.getBigDecimal(1));
            assertEquals(binary ? "0" : "0000", rs.getString(1));
            if (rs.next()) {
                nullTest(rs, false);
            } else {
                fail("must have result !");
            }
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void unsignedMediumIntTest() throws SQLException {
    sharedConnection.createStatement().execute("insert into unsignedMediumIntTest values (16777215)");
    sharedConnection.createStatement().execute("insert into unsignedMediumIntTest values (8388607)");
    sharedConnection.createStatement().execute("insert into unsignedMediumIntTest values (1)");
    sharedConnection.createStatement().execute("insert into unsignedMediumIntTest values (null)");
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedMediumIntTest", false)) {
        unsignedMediumIntTestResult(rs);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedMediumIntTest", true)) {
        unsignedMediumIntTestResult(rs);
    }
}

######


private void unsignedMediumIntTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        shortMustFail(rs);
        assertEquals(16777215, rs.getInt(1));
        assertEquals(16777215L, rs.getLong(1));
        assertEquals(16777215D, rs.getDouble(1), .000001);
        assertEquals(16777215F, rs.getFloat(1), .000001);
        assertEquals(new BigDecimal("16777215"), rs.getBigDecimal(1));
        assertEquals("16777215", rs.getString(1));
        if (rs.next()) {
            byteMustFail(rs);
            shortMustFail(rs);
            assertEquals(8388607, rs.getInt(1));
            assertEquals(8388607L, rs.getLong(1));
            assertEquals(8388607D, rs.getDouble(1), .000001);
            assertEquals(8388607F, rs.getFloat(1), .000001);
            assertEquals(new BigDecimal("8388607"), rs.getBigDecimal(1));
            assertEquals("8388607", rs.getString(1));
            if (rs.next()) {
                oneNullTest(rs);
            } else {
                fail("must have result !");
            }
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void unsignedIntTest() throws SQLException {
    sharedConnection.createStatement().execute("insert into unsignedIntTest values (4294967295)");
    sharedConnection.createStatement().execute("insert into unsignedIntTest values (2147483647)");
    sharedConnection.createStatement().execute("insert into unsignedIntTest values (1)");
    sharedConnection.createStatement().execute("insert into unsignedIntTest values (null)");
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedIntTest", false)) {
        unsignedIntTestResult(rs);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedIntTest", true)) {
        unsignedIntTestResult(rs);
    }
}

######


private void unsignedIntTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        shortMustFail(rs);
        intMustFail(rs);
        assertEquals(4294967295L, rs.getLong(1));
        assertEquals(4294967295D, rs.getDouble(1), .000001);
        assertEquals(4294967295F, rs.getFloat(1), .000001);
        assertEquals(new BigDecimal("4294967295"), rs.getBigDecimal(1));
        assertEquals("4294967295", rs.getString(1));
        if (rs.next()) {
            byteMustFail(rs);
            shortMustFail(rs);
            assertEquals(2147483647, rs.getInt(1));
            assertEquals(2147483647L, rs.getLong(1));
            assertEquals(2147483647D, rs.getDouble(1), .000001);
            assertEquals(2147483647F, rs.getFloat(1), .000001);
            assertEquals(new BigDecimal("2147483647"), rs.getBigDecimal(1));
            assertEquals("2147483647", rs.getString(1));
            if (rs.next()) {
                oneNullTest(rs);
            } else {
                fail("must have result !");
            }
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void unsignedBigIntTest() throws SQLException {
    sharedConnection.createStatement().execute("insert into unsignedBigIntTest values (18446744073709551615)");
    sharedConnection.createStatement().execute("insert into unsignedBigIntTest values (9223372036854775807)");
    sharedConnection.createStatement().execute("insert into unsignedBigIntTest values (1)");
    sharedConnection.createStatement().execute("insert into unsignedBigIntTest values (null)");
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedBigIntTest", false)) {
        unsignedBigIntTestResult(rs);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedBigIntTest", true)) {
        unsignedBigIntTestResult(rs);
    }
}

######


private void unsignedBigIntTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        shortMustFail(rs);
        intMustFail(rs);
        longMustFail(rs);
        assertEquals(18446744073709551615F, rs.getFloat(1), .000001);
        assertEquals(18446744073709551615D, rs.getDouble(1), .000001);
        assertEquals(new BigDecimal("18446744073709551615"), rs.getBigDecimal(1));
        assertEquals("18446744073709551615", rs.getString(1));
        if (rs.next()) {
            byteMustFail(rs);
            shortMustFail(rs);
            intMustFail(rs);
            assertEquals(9223372036854775807L, rs.getLong(1));
            assertEquals(9223372036854775807F, rs.getFloat(1), .000001);
            assertEquals(9223372036854775807D, rs.getDouble(1), .000001);
            assertEquals(new BigDecimal("9223372036854775807"), rs.getBigDecimal(1));
            assertEquals("9223372036854775807", rs.getString(1));
            if (rs.next()) {
                oneNullTest(rs);
            } else {
                fail("must have result !");
            }
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void unsignedDecimalTest() throws SQLException {
    try (Statement statement = sharedConnection.createStatement()) {
        statement.execute("insert into unsignedDecimalTest values (123456789012345678901234567890.12345678901234567890)");
        statement.execute("insert into unsignedDecimalTest values (9223372036854775806)");
        statement.execute("insert into unsignedDecimalTest values (1.1)");
        statement.execute("insert into unsignedDecimalTest values (1.0)");
        statement.execute("insert into unsignedDecimalTest values (null)");
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedDecimalTest", false)) {
        unsignedDecimalTestResult(rs);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedDecimalTest", true)) {
        unsignedDecimalTestResult(rs);
    }
}

######


private void unsignedDecimalTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        shortMustFail(rs);
        intMustFail(rs);
        longMustFail(rs);
        assertEquals(123456789012345678901234567890.12345678901234567890F, rs.getFloat(1), 1000000000000000000000000D);
        assertEquals(123456789012345678901234567890.12345678901234567890F, rs.getFloat(1), 1000000000000000000000000D);
        assertEquals(123456789012345678901234567890.12345678901234567890D, rs.getDouble(1), 1000000000000000000000000D);
        assertEquals(new BigDecimal("123456789012345678901234567890.12345678901234567890"), rs.getBigDecimal(1));
        assertEquals("123456789012345678901234567890.12345678901234567890", rs.getString(1));
        if (rs.next()) {
            byteMustFail(rs);
            shortMustFail(rs);
            intMustFail(rs);
            assertEquals(9223372036854775806L, rs.getLong(1));
            assertEquals(9223372036854775806F, rs.getFloat(1), .000001);
            assertEquals(9223372036854775806D, rs.getDouble(1), .000001);
            assertEquals(new BigDecimal("9223372036854775806.00000000000000000000"), rs.getBigDecimal(1));
            assertEquals("9223372036854775806.00000000000000000000", rs.getString(1));
            if (rs.next()) {
                assertEquals(1, rs.getByte(1));
                assertEquals(1, rs.getShort(1));
                assertEquals(1, rs.getInt(1));
                assertEquals(1, rs.getLong(1));
                assertEquals(1.1F, rs.getFloat(1), .000001);
                assertEquals(1.1D, rs.getDouble(1), .000001);
                assertEquals("1.10000000000000000000", rs.getString(1));
                assertEquals(new BigDecimal("1.10000000000000000000"), rs.getBigDecimal(1));
                if (rs.next()) {
                    oneNullTest(rs, true, false);
                } else {
                    fail("must have result !");
                }
            } else {
                fail("must have result !");
            }
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void unsignedFloatTest() throws SQLException {
    try (Statement statement = sharedConnection.createStatement()) {
        statement.execute("insert into unsignedFloatTest values (123456789012345678901234567890.12345678901234567890)");
        statement.execute("insert into unsignedFloatTest values (9223372036854775806)");
        statement.execute("insert into unsignedFloatTest values (1.1)");
        statement.execute("insert into unsignedFloatTest values (1.0)");
        statement.execute("insert into unsignedFloatTest values (null)");
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedFloatTest", false)) {
        unsignedFloatTestResult(rs, false);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedFloatTest", true)) {
        unsignedFloatTestResult(rs, sharedUsePrepare());
    }
}

######


private void unsignedFloatTestResult(ResultSet rs, boolean binary) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        shortMustFail(rs);
        intMustFail(rs);
        longMustFail(rs);
        assertEquals(123456789012345678901234567890F, rs.getFloat(1), 2E25F);
        assertEquals(123456789012345678901234567890D, rs.getDouble(1), 2E25F);
        assertEquals(123456789012345678901234567890F, rs.getBigDecimal(1).floatValue(), 2E25F);
        assertEquals(binary ? "1.2345679E29" : "1.23457e29", rs.getString(1));
        if (rs.next()) {
            byteMustFail(rs);
            shortMustFail(rs);
            intMustFail(rs);
            if (binary) {
                assertEquals(9223372036854775807L, rs.getLong(1));
            } else {
                assertEquals(9223369837831520256L, rs.getLong(1));
            }
            assertEquals(9223372036854775806F, rs.getFloat(1), 1E14F);
            assertEquals(9223372036854775806F, rs.getDouble(1), 1E14F);
            assertEquals(9223372036854775806F, rs.getBigDecimal(1).floatValue(), 1E14F);
            assertEquals(binary ? "9.223372E18" : "9.22337e18", rs.getString(1));
            if (rs.next()) {
                assertEquals(1, rs.getByte(1));
                assertEquals(1, rs.getShort(1));
                assertEquals(1, rs.getInt(1));
                assertEquals(1, rs.getLong(1));
                assertEquals(1.1F, rs.getFloat(1), .000001);
                assertEquals(1.1D, rs.getDouble(1), .000001);
                assertEquals("1.1", rs.getString(1));
                assertEquals(1.1f, rs.getBigDecimal(1).floatValue(), 1e-5f);
                if (rs.next()) {
                    oneNullTest(rs, true, true);
                } else {
                    fail("must have result !");
                }
            } else {
                fail("must have result !");
            }
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


@Test
public void unsignedDoubleTest() throws SQLException {
    try (Statement statement = sharedConnection.createStatement()) {
        statement.execute("insert into unsignedDoubleTest values (123456789012345678901234567890.12345678901234567890)");
        statement.execute("insert into unsignedDoubleTest values (9223372036854775806)");
        statement.execute("insert into unsignedDoubleTest values (1.1)");
        statement.execute("insert into unsignedDoubleTest values (1.0)");
        statement.execute("insert into unsignedDoubleTest values (null)");
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedDoubleTest", false)) {
        unsignedDoubleTestResult(rs);
    }
    try (ResultSet rs = DatatypeTest.getResultSet("select * from unsignedDoubleTest", true)) {
        unsignedDoubleTestResult(rs);
    }
}

######


private void unsignedDoubleTestResult(ResultSet rs) throws SQLException {
    if (rs.next()) {
        byteMustFail(rs);
        shortMustFail(rs);
        intMustFail(rs);
        longMustFail(rs);
        assertEquals(1.2345678901234568e29F, rs.getFloat(1), 1);
        assertEquals(1.2345678901234568e29D, rs.getDouble(1), 1);
        assertEquals(new BigDecimal("1.2345678901234568e29"), rs.getBigDecimal(1));
        assertEquals("1.2345678901234568e29", rs.getString(1).toLowerCase());
        if (rs.next()) {
            byteMustFail(rs);
            shortMustFail(rs);
            intMustFail(rs);
            assertEquals(9223372036854775807L, rs.getLong(1));
            assertEquals(9223372036854775806F, rs.getFloat(1), .000001);
            assertEquals(9223372036854775806D, rs.getDouble(1), .000001);
            assertEquals(new BigDecimal("9.223372036854776E+18"), rs.getBigDecimal(1));
            assertEquals("9.223372036854776e18", rs.getString(1).toLowerCase());
            if (rs.next()) {
                assertEquals(1, rs.getByte(1));
                assertEquals(1, rs.getShort(1));
                assertEquals(1, rs.getInt(1));
                assertEquals(1, rs.getLong(1));
                assertEquals(1.1F, rs.getFloat(1), .000001);
                assertEquals(1.1D, rs.getDouble(1), .000001);
                assertEquals("1.1", rs.getString(1));
                assertEquals(new BigDecimal("1.1"), rs.getBigDecimal(1));
                if (rs.next()) {
                    oneNullTest(rs, true, true);
                } else {
                    fail("must have result !");
                }
            } else {
                fail("must have result !");
            }
        } else {
            fail("must have result !");
        }
    } else {
        fail("must have result !");
    }
}

######


private void byteMustFail(ResultSet rs) {
    try {
        rs.getByte(1);
        fail("getByte must have thrown error !");
    } catch (SQLException e) {
        assertEquals("22003", e.getSQLState());
    }
}

######


private void shortMustFail(ResultSet rs) {
    try {
        rs.getShort(1);
        fail("getShort must have thrown error !");
    } catch (SQLException e) {
        assertEquals("22003", e.getSQLState());
    }
}

######


private void intMustFail(ResultSet rs) {
    try {
        rs.getInt(1);
        fail("getInt must have thrown error !");
    } catch (SQLException e) {
        assertEquals("22003", e.getSQLState());
    }
}

######


private void longMustFail(ResultSet rs) {
    try {
        rs.getLong(1);
        fail("getLong must have thrown error !");
    } catch (SQLException e) {
        assertEquals("22003", e.getSQLState());
    }
}

######


private void oneNullTest(ResultSet rs) throws SQLException {
    oneNullTest(rs, false, false);
}

######


private void oneNullTest(ResultSet rs, boolean decimal, boolean floatingPoint) throws SQLException {
    try {
        if (!decimal && !floatingPoint) {
            assertTrue(rs.getBoolean(1));
        }
        assertEquals(1, rs.getByte(1));
        assertEquals(1, rs.getShort(1));
        assertEquals(1, rs.getInt(1));
        assertEquals(1L, rs.getLong(1));
        assertEquals(1D, rs.getDouble(1), .000001);
        assertEquals(1F, rs.getFloat(1), .000001);
        if (decimal) {
            if (floatingPoint) {
                BigDecimal bd = rs.getBigDecimal(1);
                if (!bd.equals(new BigDecimal("1")) && !bd.equals(new BigDecimal("1.0"))) {
                    fail("getBigDecimal error : is " + bd.toString());
                }
            } else {
                assertEquals(new BigDecimal("1.00000000000000000000"), rs.getBigDecimal(1));
                assertEquals("1.00000000000000000000", rs.getString(1));
            }
        } else {
            assertEquals(new BigDecimal("1"), rs.getBigDecimal(1));
            assertEquals("1", rs.getString(1));
        }
    } catch (SQLException e) {
        e.printStackTrace();
        fail("must not have thrown error");
    }
    if (rs.next()) {
        nullTest(rs, decimal);
    } else {
        fail("must have result !");
    }
}

######


private void nullTest(ResultSet rs, boolean decimal) throws SQLException {
    if (!decimal) {
        assertFalse(rs.getBoolean(1));
    }
    assertEquals(0, rs.getByte(1));
    assertTrue(rs.wasNull());
    assertEquals(0, rs.getShort(1));
    assertEquals(0, rs.getInt(1));
    assertEquals(0, rs.getLong(1));
    assertEquals(0, rs.getDouble(1), .00001);
    assertEquals(0, rs.getFloat(1), .00001);
    assertNull(rs.getBigDecimal(1));
    assertNull(rs.getString(1));
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("dtest", "d date");
    createTable("date_test2", "id int not null primary key auto_increment, d_from datetime ,d_to datetime");
    createTable("timetest", "t time");
    createTable("timetest2", "t time");
    createTable("timestampzerotest", "ts timestamp, dt datetime, dd date");
    createTable("dtest", "d datetime");
    createTable("dtest2", "d date");
    createTable("dtest3", "d date");
    createTable("dtest4", "d  time");
    createTable("date_test3", " x date");
    createTable("date_test4", "x date");
    if (doPrecisionTest) {
        createTable("timestampAsDate", "ts timestamp(6), dt datetime(6), dd date");
    }
}

######


@Test
public void dateTestLegacy() throws SQLException {
    dateTest(true);
}

######


@Test
public void dateTestWithoutLegacy() throws SQLException {
    dateTest(false);
}

######


public void dateTest(boolean useLegacy) throws SQLException {
    Assume.assumeFalse(sharedIsRewrite());
    try (Connection connection = setConnection("&useLegacyDatetimeCode=" + useLegacy + "&serverTimezone=+5:00&maximizeMysqlCompatibility=false&useServerPrepStmts=true")) {
        setSessionTimeZone(connection, "+5:00");
        createTable("date_test", "id int not null primary key auto_increment, d_test date,dt_test datetime, " + "t_test time");
        Statement stmt = connection.createStatement();
        Date date = Date.valueOf("2009-01-17");
        Timestamp timestamp = Timestamp.valueOf("2009-01-17 15:41:01");
        Time time = Time.valueOf("23:59:59");
        PreparedStatement ps = connection.prepareStatement("insert into date_test (d_test, dt_test, t_test) " + "values (?,?,?)");
        ps.setDate(1, date);
        ps.setTimestamp(2, timestamp);
        ps.setTime(3, time);
        ps.executeUpdate();
        ResultSet rs = stmt.executeQuery("select d_test, dt_test, t_test from date_test");
        assertEquals(true, rs.next());
        Date date2 = rs.getDate(1);
        Date date3 = rs.getDate("d_test");
        Time time2 = rs.getTime(3);
        assertEquals(date.toString(), date2.toString());
        assertEquals(date.toString(), date3.toString());
        assertEquals(time.toString(), time2.toString());
        Time time3 = rs.getTime("t_test");
        assertEquals(time.toString(), time3.toString());
        Timestamp timestamp2 = rs.getTimestamp(2);
        assertEquals(timestamp.toString(), timestamp2.toString());
        Timestamp timestamp3 = rs.getTimestamp("dt_test");
        assertEquals(timestamp.toString(), timestamp3.toString());
    }
}

######


@Test
public void dateRangeTest() throws SQLException {
    PreparedStatement ps = sharedConnection.prepareStatement("insert into date_test2 (id, d_from, d_to) values " + "(1, ?,?)");
    Timestamp timestamp1 = Timestamp.valueOf("2009-01-17 15:41:01");
    Timestamp timestamp2 = Timestamp.valueOf("2015-01-17 15:41:01");
    ps.setTimestamp(1, timestamp1);
    ps.setTimestamp(2, timestamp2);
    ps.executeUpdate();
    PreparedStatement ps1 = sharedConnection.prepareStatement("select d_from, d_to from date_test2 " + "where d_from <= ? and d_to >= ?");
    Timestamp timestamp3 = Timestamp.valueOf("2014-01-17 15:41:01");
    ps1.setTimestamp(1, timestamp3);
    ps1.setTimestamp(2, timestamp3);
    ResultSet rs = ps1.executeQuery();
    assertEquals(true, rs.next());
    Timestamp ts1 = rs.getTimestamp(1);
    Timestamp ts2 = rs.getTimestamp(2);
    assertEquals(ts1.toString(), timestamp1.toString());
    assertEquals(ts2.toString(), timestamp2.toString());
}

######


@Test(expected = SQLException.class)
public void dateTest2() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    ResultSet rs = stmt.executeQuery("select 1");
    assertTrue(rs.next());
    rs.getDate(1);
}

######


@Test(expected = SQLException.class)
public void dateTest3() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    ResultSet rs = stmt.executeQuery("select 1 as a");
    assertTrue(rs.next());
    rs.getDate("a");
}

######


@Test(expected = SQLException.class)
public void timeTest3() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    ResultSet rs = stmt.executeQuery("select 'aaa' as a");
    assertTrue(rs.next());
    rs.getTimestamp("a");
}

######


@Test
public void yearTest() throws SQLException {
    Assume.assumeTrue(isMariadbServer());
    createTable("yeartest", "y1 year, y2 year(2)");
    sharedConnection.createStatement().execute("insert into yeartest values (null, null), (1901, 70), (0, 0), " + "(2155, 69)");
    Statement stmt = sharedConnection.createStatement();
    ResultSet rs = stmt.executeQuery("select * from yeartest");
    Date[] data1 = new Date[] { null, Date.valueOf("1901-01-01"), Date.valueOf("0000-01-01"), Date.valueOf("2155-01-01") };
    Date[] data2 = new Date[] { null, Date.valueOf("1970-01-01"), Date.valueOf("2000-01-01"), Date.valueOf("2069-01-01") };
    checkDateResult(data1, data2, rs);
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT * FROM yeartest");
    rs = preparedStatement.executeQuery();
    checkDateResult(data1, data2, rs);
}

######


private void checkDateResult(Date[] data1, Date[] data2, ResultSet rs) throws SQLException {
    int count = 0;
    while (rs.next()) {
        assertEquals(data1[count], rs.getObject(1));
        assertEquals(data2[count], rs.getObject(2));
        assertEquals(data1[count], rs.getDate(1));
        assertEquals(data2[count], rs.getDate(2));
        count++;
    }
}

######


@Test
public void timeTestLegacy() {
    try (Connection connection = setConnection("&useLegacyDatetimeCode=true&serverTimezone=+05:00")) {
        setSessionTimeZone(connection, "+05:00");
        connection.createStatement().execute("insert into timetest values (null), ('-838:59:59'), ('00:00:00'), " + "('838:59:59')");
        Time[] data = new Time[] { null, Time.valueOf("-838:59:59"), Time.valueOf("00:00:00"), Time.valueOf("838:59:59") };
        Statement stmt = connection.createStatement();
        try (ResultSet rs = stmt.executeQuery("select * from timetest")) {
            testTime(rs, data);
        }
        PreparedStatement pstmt = connection.prepareStatement("select * from timetest");
        try (ResultSet rs = pstmt.executeQuery()) {
            testTime(rs, data);
        }
        try (ResultSet rs = stmt.executeQuery("select '11:11:11'")) {
            testTime11(rs);
        }
        PreparedStatement pstmt2 = connection.prepareStatement("select TIME('11:11:11') ");
        try (ResultSet rs = pstmt2.executeQuery()) {
            testTime11(rs);
        }
    } catch (SQLException sqle) {
        sqle.printStackTrace();
        fail();
    }
}

######


@Test
public void timeTest() {
    try (Connection connection = setConnection("&useLegacyDatetimeCode=false&serverTimezone=+5:00")) {
        setSessionTimeZone(connection, "+5:00");
        connection.createStatement().execute("insert into timetest2 values (null), ('00:00:00'), ('23:59:59')");
        Time[] data = new Time[] { null, Time.valueOf("00:00:00"), Time.valueOf("23:59:59") };
        Statement stmt = connection.createStatement();
        try (ResultSet rs = stmt.executeQuery("select * from timetest2")) {
            testTime(rs, data);
        }
        PreparedStatement pstmt = connection.prepareStatement("select * from timetest2");
        try (ResultSet rs = pstmt.executeQuery()) {
            testTime(rs, data);
        }
        try (ResultSet rs = stmt.executeQuery("select '11:11:11'")) {
            testTime11(rs);
        }
        PreparedStatement pstmt2 = connection.prepareStatement("select TIME('11:11:11') ");
        try (ResultSet rs = pstmt2.executeQuery()) {
            testTime11(rs);
        }
    } catch (SQLException sqle) {
        sqle.printStackTrace();
        fail();
    }
}

######


private void testTime(ResultSet rs, Time[] data) throws SQLException {
    int count = 0;
    while (rs.next()) {
        Time t1 = data[count];
        Time t2 = (Time) rs.getObject(1);
        assertEquals(t1, t2);
        count++;
    }
}

######


private void testTime11(ResultSet rs) throws SQLException {
    assertTrue(rs.next());
    Calendar cal = Calendar.getInstance();
    assertEquals("11:11:11", rs.getTime(1, cal).toString());
}

######


@Test
public void timestampZeroTest() throws SQLException {
    Assume.assumeTrue(isMariadbServer());
    String timestampZero = "0000-00-00 00:00:00";
    String dateZero = "0000-00-00";
    sharedConnection.createStatement().execute("insert into timestampzerotest values ('" + timestampZero + "', '" + timestampZero + "', '" + dateZero + "')");
    Statement stmt = sharedConnection.createStatement();
    try (ResultSet rs = stmt.executeQuery("select * from timestampzerotest")) {
        Timestamp ts = null;
        Timestamp datetime = null;
        Date date = null;
        while (rs.next()) {
            assertEquals(null, rs.getObject(1));
            ts = rs.getTimestamp(1);
            assertEquals(rs.wasNull(), true);
            datetime = rs.getTimestamp(2);
            assertEquals(rs.wasNull(), true);
            date = rs.getDate(3);
            assertEquals(rs.wasNull(), true);
        }
        assertEquals(ts, null);
        assertEquals(datetime, null);
        assertEquals(date, null);
    }
}

######


@Test
public void timestampAsDate() throws SQLException {
    Assume.assumeTrue(doPrecisionTest);
    Calendar cal = Calendar.getInstance();
    cal.set(Calendar.HOUR_OF_DAY, 0);
    cal.set(Calendar.MINUTE, 0);
    cal.set(Calendar.SECOND, 0);
    cal.set(Calendar.MILLISECOND, 0);
    Calendar cal2 = Calendar.getInstance();
    cal2.set(Calendar.YEAR, 1970);
    cal2.set(Calendar.MONTH, 0);
    cal2.set(Calendar.DAY_OF_YEAR, 1);
    Calendar cal3 = Calendar.getInstance();
    cal3.set(Calendar.HOUR_OF_DAY, 0);
    cal3.set(Calendar.MINUTE, 0);
    cal3.set(Calendar.SECOND, 0);
    cal3.set(Calendar.MILLISECOND, 0);
    cal3.set(Calendar.YEAR, 1970);
    cal3.set(Calendar.MONTH, 0);
    cal3.set(Calendar.DAY_OF_YEAR, 1);
    Timestamp currentTimeStamp = new Timestamp(System.currentTimeMillis());
    PreparedStatement preparedStatement1 = sharedConnection.prepareStatement("/*CLIENT*/ insert into timestampAsDate values (?, ?, ?)");
    preparedStatement1.setTimestamp(1, currentTimeStamp);
    preparedStatement1.setTimestamp(2, currentTimeStamp);
    preparedStatement1.setDate(3, new Date(currentTimeStamp.getTime()));
    preparedStatement1.addBatch();
    preparedStatement1.execute();
    Date dateWithoutTime = new Date(cal.getTimeInMillis());
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from timestampAsDate");
    checkResult(rs, currentTimeStamp, cal, dateWithoutTime);
    PreparedStatement pstmt = sharedConnection.prepareStatement("select * from timestampAsDate where 1 = ?");
    pstmt.setInt(1, 1);
    pstmt.addBatch();
    rs = pstmt.executeQuery();
    checkResult(rs, currentTimeStamp, cal, dateWithoutTime);
}

######


private void checkResult(ResultSet rs, Timestamp currentTimeStamp, Calendar cal, Date dateWithoutTime) throws SQLException {
    if (rs.next()) {
        assertEquals(rs.getTimestamp(1), currentTimeStamp);
        assertEquals(rs.getTimestamp(2), currentTimeStamp);
        assertEquals(rs.getTimestamp(3), new Timestamp(cal.getTimeInMillis()));
        assertEquals(rs.getDate(1), new Date(currentTimeStamp.getTime()));
        assertEquals(rs.getDate(2), new Date(currentTimeStamp.getTime()));
        assertEquals(rs.getDate(3), dateWithoutTime);
        assertEquals(rs.getTime(1), new Time(currentTimeStamp.getTime()));
        assertEquals(rs.getTime(2), new Time(currentTimeStamp.getTime()));
        try {
            rs.getTime(3);
            fail();
        } catch (SQLException e) {
            assertTrue(e.getMessage().contains("Cannot read Time using a Types.DATE field"));
        }
    } else {
        fail("Must have a result");
    }
    rs.close();
}

######


@Test
public void javaUtilDateInPreparedStatementAsTimeStamp() throws Exception {
    java.util.Date currentDate = Calendar.getInstance(TimeZone.getDefault()).getTime();
    PreparedStatement ps = sharedConnection.prepareStatement("insert into dtest values(?)");
    ps.setObject(1, currentDate, Types.TIMESTAMP);
    ps.executeUpdate();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from dtest");
    assertTrue(rs.next());
    assertTrue(Math.abs((currentDate.getTime() - rs.getTimestamp(1).getTime())) <= 1000);
}

######


@Test
public void nullTimestampTest() throws SQLException {
    PreparedStatement ps = sharedConnection.prepareStatement("insert into dtest2 values(null)");
    ps.executeUpdate();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from dtest2 where d is null");
    assertTrue(rs.next());
    Calendar cal = new GregorianCalendar();
    assertEquals(null, rs.getTimestamp(1, cal));
}

######


@SuppressWarnings("deprecation")
@Test
public void javaUtilDateInPreparedStatementAsDate() throws Exception {
    java.util.Date currentDate = Calendar.getInstance(TimeZone.getDefault()).getTime();
    PreparedStatement ps = sharedConnection.prepareStatement("insert into dtest3 values(?)");
    ps.setObject(1, currentDate, Types.DATE);
    ps.executeUpdate();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from dtest3");
    assertTrue(rs.next());
    assertEquals(currentDate.getYear(), rs.getDate(1).getYear());
    assertEquals(currentDate.getMonth(), rs.getDate(1).getMonth());
    assertEquals(currentDate.getDay(), rs.getDate(1).getDay());
}

######


@SuppressWarnings("deprecation")
@Test
public void javaUtilDateInPreparedStatementAsTime() throws Exception {
    java.util.Date currentDate = Calendar.getInstance(TimeZone.getDefault()).getTime();
    PreparedStatement ps = sharedConnection.prepareStatement("insert into dtest4 values(?)");
    ps.setObject(1, currentDate, Types.TIME);
    ps.executeUpdate();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select * from dtest4");
    assertTrue(rs.next());
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(currentDate);
    calendar.set(Calendar.YEAR, 1970);
    calendar.set(Calendar.MONTH, 0);
    calendar.set(Calendar.DAY_OF_MONTH, 1);
    assertTrue(Math.abs(calendar.getTimeInMillis() - rs.getTime(1).getTime()) <= 1000);
}

######


@Test
public void serverTimezone() throws Exception {
    TimeZone tz = TimeZone.getDefault();
    try (Connection connection = setConnection("&serverTimezone=+5:00")) {
        setSessionTimeZone(connection, "+5:00");
        java.util.Date now = new java.util.Date();
        TimeZone canadaTimeZone = TimeZone.getTimeZone("GMT+5:00");
        long clientOffset = tz.getOffset(now.getTime());
        long serverOffset = canadaTimeZone.getOffset(System.currentTimeMillis());
        long totalOffset = serverOffset - clientOffset;
        PreparedStatement ps = connection.prepareStatement("select now()");
        ResultSet rs = ps.executeQuery();
        assertTrue(rs.next());
        Timestamp ts = rs.getTimestamp(1);
        long differenceToServer = ts.getTime() - now.getTime();
        long diff = Math.abs(differenceToServer - totalOffset);
        assertTrue(diff < 5000);
        ps = connection.prepareStatement("select utc_timestamp(), ?");
        ps.setObject(1, now);
        rs = ps.executeQuery();
        assertTrue(rs.next());
        ts = rs.getTimestamp(1);
        Timestamp ts2 = rs.getTimestamp(2);
        long diff2 = Math.abs(ts.getTime() - ts2.getTime() + clientOffset);
        assertTrue(diff2 < 5000);
    }
}

######


@Test
public void timestampMillisecondsTest() throws SQLException {
    Statement statement = sharedConnection.createStatement();
    boolean isMariadbServer = isMariadbServer();
    if (isMariadbServer) {
        createTable("tt", "id decimal(10), create_time datetime(6)");
        statement.execute("INSERT INTO tt (id, create_time) VALUES (1,'2013-07-18 13:44:22.123456')");
    } else {
        createTable("tt", "id decimal(10), create_time datetime");
        statement.execute("INSERT INTO tt (id, create_time) VALUES (1,'2013-07-18 13:44:22')");
    }
    PreparedStatement ps = sharedConnection.prepareStatement("insert into tt (id, create_time) values (?,?)");
    ps.setInt(1, 2);
    Timestamp writeTs = new Timestamp(1273017612999L);
    Timestamp writeTsWithoutMilliSec = new Timestamp(1273017612999L);
    ps.setTimestamp(2, writeTs);
    ps.execute();
    ResultSet rs = statement.executeQuery("SELECT * FROM tt");
    assertTrue(rs.next());
    if (isMariadbServer) {
        assertTrue("2013-07-18 13:44:22.123456".equals(rs.getString(2)));
    } else {
        assertTrue("2013-07-18 13:44:22.0".equals(rs.getString(2)));
    }
    assertTrue(rs.next());
    Timestamp readTs = rs.getTimestamp(2);
    if (isMariadbServer) {
        assertEquals(writeTs, readTs);
    } else {
        assertEquals(writeTs, writeTsWithoutMilliSec);
    }
}

######


@Test
public void dateTestWhenServerDifference() throws Throwable {
    try (Connection connection = setConnection("&serverTimezone=UTC")) {
        try (PreparedStatement pst = connection.prepareStatement("insert into date_test3 values (?)")) {
            Date date = Date.valueOf("2013-02-01");
            pst.setDate(1, date);
            pst.execute();
            try (PreparedStatement pst2 = connection.prepareStatement("select x from date_test3 WHERE x = ?")) {
                pst2.setDate(1, date);
                try (ResultSet rs = pst2.executeQuery()) {
                    assertTrue(rs.next());
                    Date dd = rs.getDate(1);
                    assertEquals(dd, date);
                }
            }
        }
    }
}

######


@Test
public void dateTestWhenServerDifferenceClient() throws Throwable {
    try (Connection connection = setConnection("&serverTimezone=UTC")) {
        try (PreparedStatement pst = connection.prepareStatement("/*CLIENT*/insert into date_test4 values (?)")) {
            Date date = Date.valueOf("2013-02-01");
            pst.setDate(1, date);
            pst.execute();
            try (PreparedStatement pst2 = connection.prepareStatement("/*CLIENT*/ select x from date_test4 WHERE x = ?")) {
                pst2.setDate(1, date);
                try (ResultSet rs = pst2.executeQuery()) {
                    assertTrue(rs.next());
                    Date dd = rs.getDate(1);
                    assertEquals(dd, date);
                }
            }
        }
    }
}

######


@Test
public void nullDateString() throws Throwable {
    createTable("date_test5", "x date");
    Statement stmt = sharedConnection.createStatement();
    try {
        stmt.execute("INSERT INTO date_test5 (x) VALUES ('0000-00-00')");
        PreparedStatement pst = sharedConnection.prepareStatement("SELECT * FROM date_test5 WHERE 1 = ?");
        pst.setInt(1, 1);
        ResultSet rs = pst.executeQuery();
        assertTrue(rs.next());
        if (sharedUsePrepare()) {
            assertNull(rs.getString(1));
            assertTrue(rs.wasNull());
            assertNull(rs.getDate(1));
            assertTrue(rs.wasNull());
        } else {
            assertEquals("0000-00-00", rs.getString(1));
            assertFalse(rs.wasNull());
            assertNull(rs.getDate(1));
            assertTrue(rs.wasNull());
        }
    } catch (SQLDataException sqldataException) {
    }
}

######


@Test
public void nullDateFromTimestamp() throws Throwable {
    Assume.assumeTrue(isMariadbServer());
    createTable("nulltimestamp", "ts timestamp(6) NULL ");
    Statement stmt = sharedConnection.createStatement();
    try {
        stmt.execute("INSERT INTO nulltimestamp (ts) VALUES ('0000-00-00'), (null)");
        PreparedStatement pst = sharedConnection.prepareStatement("SELECT * FROM nulltimestamp WHERE 1 = ?");
        pst.setInt(1, 1);
        ResultSet rs = pst.executeQuery();
        assertTrue(rs.next());
        if (sharedUsePrepare()) {
            assertEquals(null, rs.getString(1));
        } else {
            assertTrue(rs.getString(1).contains("0000-00-00 00:00:00"));
        }
        assertNull(rs.getDate(1));
        assertNull(rs.getTimestamp(1));
        assertNull(rs.getTime(1));
        assertTrue(rs.next());
        assertNull(rs.getString(1));
        assertNull(rs.getDate(1));
        assertNull(rs.getTimestamp(1));
        assertNull(rs.getTime(1));
    } catch (SQLDataException sqldataException) {
    }
}

######


@Test
public void getZeroDateString() throws SQLException {
    Assume.assumeTrue(isMariadbServer());
    createTable("zeroTimestamp", "ts timestamp NULL ");
    try (Statement statement = sharedConnection.createStatement()) {
        statement.execute("INSERT INTO zeroTimestamp values ('0000-00-00 00:00:00')");
        try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT * from zeroTimestamp")) {
            ResultSet resultSet = preparedStatement.executeQuery();
            assertTrue(resultSet.next());
            assertEquals(null, resultSet.getDate(1));
            if (sharedUsePrepare()) {
                assertEquals(null, resultSet.getString(1));
                assertTrue(resultSet.wasNull());
            } else {
                assertTrue(resultSet.getString(1).contains("0000-00-00 00:00:00"));
                assertFalse(resultSet.wasNull());
            }
        }
        ResultSet resultSet = statement.executeQuery("SELECT * from zeroTimestamp");
        assertTrue(resultSet.next());
        assertEquals(null, resultSet.getDate(1));
        assertTrue(resultSet.getString(1).contains("0000-00-00 00:00:00"));
    }
}

######


public ResultSet ar(ResultSet st) {
    return st;
}

######


public Statement baglan() {
    if (conn != null) {
        kapat();
    }
    try {
        Class.forName(driver);
        conn = DriverManager.getConnection(url + dbName + encode, dbUser, dbPass);
        st = conn.createStatement();
        System.out.println("Bağlantı başarılı !");
    } catch (ClassNotFoundException | SQLException e) {
        System.err.println("Bağlantı hatası !" + e);
    }
    return st;
}

######


public PreparedStatement preBaglan(String query) {
    try {
        if (conn != null) {
            kapat();
        }
        Class.forName(driver);
        conn = DriverManager.getConnection(url + dbName + encode, dbUser, dbPass);
        preSt = conn.prepareStatement(query);
    } catch (ClassNotFoundException | SQLException e) {
        System.err.println("PreparedStatement hatası : " + e);
    }
    return preSt;
}

######


public void kapat() {
    try {
        if (preSt != null) {
            preSt.close();
            System.out.println("PraperedStatement Kapandı");
            preSt = null;
        }
        if (st != null) {
            st.close();
            System.out.println("st kapatıldı !");
            st = null;
        }
        if (conn != null) {
            conn.close();
            System.out.println("conn kapatıldı !");
            conn = null;
        }
    } catch (SQLException e) {
        System.err.println("St ve Conn kapatma hatası !" + e);
    }
}

######


public void giris(String gkadi, String gsifre) throws SQLException {
    try {
        String sorgu = "select * from uyeler where kulAdi ='" + gkadi + "' and sifresi ='" + gsifre + "'";
        ResultSet rs = st.executeQuery(sorgu);
        AnaSayfa ac = new AnaSayfa();
        AdminMenu ad = new AdminMenu(0, gkadi, gkadi);
        UyeMenuu um = new UyeMenuu();
        if (rs.first()) {
            if (rs.getString("yetki").equals("Yetkili")) {
                ac.setVisible(false);
                ad.setVisible(true);
            } else {
                ac.setVisible(false);
                um.setVisible(true);
            }
        } else {
            System.out.println("kul adi veya sifre hatalı");
        }
    } catch (Exception ex) {
        System.err.println("yanliş bişiler var " + ex);
    }
}

######


public boolean GirisKontrol(UyelerProperti kul) {
    String query = "select count(*) as eslesme from uyeler where " + UyelerEnum.kulAdi + "='" + kul.getKulAdi() + "'" + "and " + UyelerEnum.sifre + "='" + kul.getSifre() + "'";
    try {
        ResultSet rs = baglan().executeQuery(query);
        System.out.println(query);
        System.out.println(rs.getString("eslesme"));
        if (Integer.valueOf(rs.getString("eslesme")) > 0) {
            return true;
        } else {
            return false;
        }
    } catch (Exception e) {
        System.err.println("yanliş bişilerrrrrr  " + e);
    }
    return false;
}

######


public static Appointment getAppointment(int appointmentID) {
    String sql = "SELECT ID, Tid_start, Tid_slutt, Tittel, Beskrivelse FROM Avtale WHERE Avtale.ID = " + appointmentID + ";";
    try {
        ResultSet results = Database.execute(sql);
        while (results.next()) {
            int id = results.getInt("ID");
            long start = results.getLong("Tid_start");
            long end = results.getLong("Tid_slutt");
            String title = results.getString("Tittel");
            String desc = results.getString("Beskrivelse");
            return new Appointment(id, start, end, title, desc);
        }
    } catch (Exception e) {
        System.out.println("N� gikk det til helvete!");
        e.printStackTrace();
    }
    return null;
}

######


public static Appointment newAppointment(int userID, long start, long end, String title, String desc) {
    String insertAppointment = "INSERT INTO Avtale(Tid_start, Tid_slutt, Tittel, Beskrivelse)" + " VALUES (" + start + ", " + end + ", '" + title + "', '" + desc + "');";
    int id = Database.executeUpdate(insertAppointment, true);
    String insertOwner = "INSERT INTO Oppretter_og_Eier(Bruker_ID, Avtale_ID) VALUES(" + userID + ", " + id + ");";
    Database.executeUpdate(insertOwner);
    return DBAppointment.getAppointment(id);
}

######


public static int deleteAppointment(int id) {
    String sql = "DELETE FROM Avtale WHERE ID = " + id + ";";
    int successful = Database.executeUpdate(sql);
    return successful;
}

######


public static ArrayList<Appointment> getAppointmentsInInterval(long from, long to, int userID) {
    ArrayList<Appointment> list = new ArrayList<Appointment>();
    String sql = "SELECT * FROM Avtale WHERE ID IN " + "(SELECT Avtale_ID FROM Deltaker JOIN Bruker ON Bruker.ID = Bruker_ID" + " WHERE Tid_start > " + from + " AND Tid_slutt < " + to + " AND Bruker.ID = " + userID + ") ORDER BY Tid_start;";
    try {
        ResultSet results = Database.execute(sql);
        while (results.next()) {
            int id = results.getInt("ID");
            long start = results.getTimestamp("Tid_start").getTime();
            long end = results.getTimestamp("Tid_slutt").getTime();
            String title = results.getString("Tittel");
            String desc = results.getString("Beskrivelse");
            list.add(new Appointment(id, start, end, title, desc));
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return list;
}

######


public static int changeTimeOfAppointment(long newTimeFrom, long newTimeTo, int appointmentID) {
    String sql = "UPDATE Avtale SET Tid_start=" + newTimeFrom + ", Tid_slutt=" + newTimeTo + " WHERE ID = " + appointmentID + ";";
    return Database.executeUpdate(sql);
}

######


public static int changeAppointmentDescription(int appointmentID, String newDescription) {
    String sql = "UPDATE Avtale set Beskrivelse = '" + newDescription + "' WHERE ID = " + appointmentID + ";";
    return Database.executeUpdate(sql);
}

######


public static void main(String[] args) {
}

######


public void init() {
    try {
        Thread.sleep(10 * 1000);
    } catch (InterruptedException e) {
        e.getMessage();
    }
    InetAddress dbAddr = null;
    try {
        dbAddr = InetAddress.getByName("dbsession");
    } catch (UnknownHostException e) {
        e.printStackTrace();
    }
    c = null;
    try {
        Class.forName("org.postgresql.Driver");
        c = DriverManager.getConnection("jdbc:postgresql://" + dbAddr.getHostAddress() + ":5432/postgres", "postgres", "postgres");
        Statement stmt = c.createStatement();
        String sessionTable = "create table if not exists sessions (id SERIAL primary key, userId char(50) not null," + " username char(20) not null, deviceId char(50) unique not null, token char(50) unique, tokenExpiration Timestamp, latitude double precision, longitude double precision" + ", gcmId char (257) unique, updatedat Timestamp with time zone DEFAULT ('now'::text)::date)";
        String updateFunction = "CREATE OR REPLACE FUNCTION update_changetimestamp_column() " + "RETURNS TRIGGER AS $$ " + "BEGIN NEW.updatedAt = now();  " + "RETURN NEW; " + "END; " + "$$ language 'plpgsql';";
        String updateTrigger = " CREATE TRIGGER update_ab_changetimestamp " + "BEFORE UPDATE" + "    ON sessions FOR EACH ROW EXECUTE PROCEDURE " + "    update_changetimestamp_column();";
        String setTimezone = "set Timezone = 'America/Santiago'";
        stmt.execute(sessionTable);
        stmt.execute(updateFunction);
        stmt.execute(updateTrigger);
        stmt.execute(setTimezone);
    } catch (Exception e) {
        e.printStackTrace();
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
    }
}

######


public boolean tokenExists(String tkn) {
    try {
        Statement stmt = c.createStatement();
        String get = "select * from sessions where username = \'" + tkn + "\';";
        ResultSet set = stmt.executeQuery(get);
        return set.next();
    } catch (Exception e) {
        e.printStackTrace();
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
        return false;
    }
}

######


public String getUserToken(String username) {
    try {
        Statement stmt = c.createStatement();
        String get = "select token from sessions where username = \'" + username + "\';";
        ResultSet set = stmt.executeQuery(get);
        if (set.next())
            return set.getString("token").trim();
        else
            return "";
    } catch (Exception e) {
        e.printStackTrace();
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
        return "";
    }
}

######


public Timestamp getTokenExpiration(String token) {
    try {
        Statement stmt = c.createStatement();
        String get = "select tokenExpiration from sessions where token = \'" + token + "\';";
        ResultSet set = stmt.executeQuery(get);
        if (set.next())
            return set.getTimestamp("tokenExpiration");
        else
            return null;
    } catch (Exception e) {
        e.printStackTrace();
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
        return null;
    }
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL("create table " + EXERCISES_TABLE_NAME + "(id integer primary key, " + EXERCISES_COLUMN_EXERCISE + " text, " + EXERCISES_COLUMN_WEIGHT + " integer, " + EXERCISES_COLUMN_INCREASE + " integer, " + EXERCISES_COLUMN_MIN_REP + " integer, " + EXERCISES_COLUMN_MAX_REP + " integer, " + EXERCISES_COLUMN_NUM_SETS + " integer)");
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    db.execSQL("DROP TABLE IF EXISTS " + EXERCISES_TABLE_NAME);
    onCreate(db);
}

######


public boolean insertWorkout(String exercise, int weight, int increase, int minRep, int maxRep, int numSets) {
    SQLiteDatabase db = this.getWritableDatabase();
    ContentValues contentValues = new ContentValues();
    contentValues.put(EXERCISES_COLUMN_EXERCISE, exercise);
    contentValues.put(EXERCISES_COLUMN_WEIGHT, weight);
    contentValues.put(EXERCISES_COLUMN_INCREASE, increase);
    contentValues.put(EXERCISES_COLUMN_MIN_REP, minRep);
    contentValues.put(EXERCISES_COLUMN_MAX_REP, maxRep);
    contentValues.put(EXERCISES_COLUMN_NUM_SETS, numSets);
    db.insertOrThrow(EXERCISES_TABLE_NAME, null, contentValues);
    return true;
}

######


public int getId(String exName) {
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor res;
    try {
        res = db.rawQuery("select * from " + EXERCISES_TABLE_NAME + " where " + EXERCISES_COLUMN_EXERCISE + "=\"" + exName + "\";", null);
        res.moveToFirst();
        return res.getInt(res.getColumnIndex("id"));
    } catch (Exception e) {
        e.printStackTrace();
        return -1;
    }
}

######


public Cursor getData(int id) {
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor res = db.rawQuery("select * from " + EXERCISES_TABLE_NAME + " where id=" + id + "", null);
    return res;
}

######


public Cursor getExercise(String exercise) {
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor res = db.rawQuery("select * from " + EXERCISES_TABLE_NAME + " where " + EXERCISES_COLUMN_EXERCISE + "=\"" + exercise + "\";", null);
    return res;
}

######


public int numberOfRows() {
    SQLiteDatabase db = this.getReadableDatabase();
    int numRows = (int) DatabaseUtils.queryNumEntries(db, EXERCISES_TABLE_NAME);
    return numRows;
}

######


public boolean updateWorkout(Integer id, String exercise, int weight, int increase, int minRep, int maxRep, int numSets) {
    SQLiteDatabase db = this.getWritableDatabase();
    ContentValues contentValues = new ContentValues();
    contentValues.put(EXERCISES_COLUMN_EXERCISE, exercise);
    contentValues.put(EXERCISES_COLUMN_WEIGHT, weight);
    contentValues.put(EXERCISES_COLUMN_INCREASE, increase);
    contentValues.put(EXERCISES_COLUMN_MIN_REP, minRep);
    contentValues.put(EXERCISES_COLUMN_MAX_REP, maxRep);
    contentValues.put(EXERCISES_COLUMN_NUM_SETS, numSets);
    db.update(EXERCISES_TABLE_NAME, contentValues, "id = ? ", new String[] { Integer.toString(id) });
    return true;
}

######


public Integer deleteWorkout(Integer id) {
    SQLiteDatabase db = this.getWritableDatabase();
    return db.delete(EXERCISES_TABLE_NAME, "id = ? ", new String[] { Integer.toString(id) });
}

######


public ArrayList<String> getAllExercises() {
    ArrayList<String> array_list = new ArrayList<String>();
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor res = db.rawQuery("select * from " + EXERCISES_TABLE_NAME, null);
    res.moveToFirst();
    while (res.isAfterLast() == false) {
        array_list.add(res.getString(res.getColumnIndex(EXERCISES_TABLE_NAME)));
        res.moveToNext();
    }
    return array_list;
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL("create table " + EXERCISES_TABLE_NAME + "(id integer primary key, " + EXERCISES_COLUMN_EXERCISE + " text, " + EXERCISES_COLUMN_WEIGHT + " integer, " + EXERCISES_COLUMN_INCREASE + " integer, " + EXERCISES_COLUMN_MIN_REP + " integer, " + EXERCISES_COLUMN_MAX_REP + " integer, " + EXERCISES_COLUMN_NUM_SETS + " integer)");
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    db.execSQL("DROP TABLE IF EXISTS " + EXERCISES_TABLE_NAME);
    onCreate(db);
}

######


public boolean insertWorkout(String exercise, int weight, int increase, int minRep, int maxRep, int numSets) {
    SQLiteDatabase db = this.getWritableDatabase();
    ContentValues contentValues = new ContentValues();
    contentValues.put(EXERCISES_COLUMN_EXERCISE, exercise);
    contentValues.put(EXERCISES_COLUMN_WEIGHT, weight);
    contentValues.put(EXERCISES_COLUMN_INCREASE, increase);
    contentValues.put(EXERCISES_COLUMN_MIN_REP, minRep);
    contentValues.put(EXERCISES_COLUMN_MAX_REP, maxRep);
    contentValues.put(EXERCISES_COLUMN_NUM_SETS, numSets);
    db.insertOrThrow(EXERCISES_TABLE_NAME, null, contentValues);
    return true;
}

######


public int getId(String exName) {
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor res;
    try {
        res = db.rawQuery("select * from " + EXERCISES_TABLE_NAME + " where " + EXERCISES_COLUMN_EXERCISE + "=\"" + exName + "\";", null);
        res.moveToFirst();
        return res.getInt(res.getColumnIndex("id"));
    } catch (Exception e) {
        e.printStackTrace();
        return -1;
    }
}

######


public Cursor getData(int id) {
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor res = db.rawQuery("select * from " + EXERCISES_TABLE_NAME + " where id=" + id + "", null);
    return res;
}

######


public Cursor getExercise(String exercise) {
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor res = db.rawQuery("select * from " + EXERCISES_TABLE_NAME + " where " + EXERCISES_COLUMN_EXERCISE + "=\"" + exercise + "\";", null);
    return res;
}

######


public int numberOfRows() {
    SQLiteDatabase db = this.getReadableDatabase();
    int numRows = (int) DatabaseUtils.queryNumEntries(db, EXERCISES_TABLE_NAME);
    return numRows;
}

######


public boolean updateWorkout(Integer id, String exercise, int weight, int increase, int minRep, int maxRep, int numSets) {
    SQLiteDatabase db = this.getWritableDatabase();
    ContentValues contentValues = new ContentValues();
    contentValues.put(EXERCISES_COLUMN_EXERCISE, exercise);
    contentValues.put(EXERCISES_COLUMN_WEIGHT, weight);
    contentValues.put(EXERCISES_COLUMN_INCREASE, increase);
    contentValues.put(EXERCISES_COLUMN_MIN_REP, minRep);
    contentValues.put(EXERCISES_COLUMN_MAX_REP, maxRep);
    contentValues.put(EXERCISES_COLUMN_NUM_SETS, numSets);
    db.update(EXERCISES_TABLE_NAME, contentValues, "id = ? ", new String[] { Integer.toString(id) });
    return true;
}

######


public Integer deleteWorkout(Integer id) {
    SQLiteDatabase db = this.getWritableDatabase();
    return db.delete(EXERCISES_TABLE_NAME, "id = ? ", new String[] { Integer.toString(id) });
}

######


public ArrayList<String> getAllExercises() {
    ArrayList<String> array_list = new ArrayList<String>();
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor res = db.rawQuery("select * from " + EXERCISES_TABLE_NAME, null);
    res.moveToFirst();
    while (res.isAfterLast() == false) {
        array_list.add(res.getString(res.getColumnIndex(EXERCISES_TABLE_NAME)));
        res.moveToNext();
    }
    return array_list;
}

######


public boolean isLabGroupInserted(String group) {
    boolean res = false;
    PreparedStatement stmt = null;
    try {
        stmt = MyConnection.prepareStatement("INSERT INTO laboratorygroups (lgroup) VALUES (?)");
        stmt.setString(1, group);
        stmt.executeUpdate();
        res = true;
    } catch (SQLException e) {
        System.out.println("Exception inserting laboratory group: " + e.getMessage());
    } finally {
        if (stmt != null)
            try {
                stmt.close();
            } catch (SQLException e) {
                System.out.println("Exception inserting laboratory group: " + e.getMessage());
            }
    }
    return res;
}

######


public boolean isLabGroupDeleted(int id) {
    boolean res = false;
    PreparedStatement stmt = null;
    try {
        stmt = MyConnection.prepareStatement("DELETE FROM laboratorygroups WHERE id=?");
        stmt.setInt(1, id);
        stmt.executeUpdate();
        res = true;
    } catch (SQLException e) {
        System.out.println("Exception deleting laboratory group: " + e.getMessage());
    } finally {
        if (stmt != null)
            try {
                stmt.close();
            } catch (SQLException e) {
                System.out.println("Exception deleting laboratory group: " + e.getMessage());
            }
    }
    return res;
}

######


public boolean isLabGroupUpdated(int id, String group) {
    boolean res = false;
    PreparedStatement stmt = null;
    try {
        stmt = MyConnection.prepareStatement("UPDATE laboratorygroups SET lgroup=? WHERE id=?");
        stmt.setString(1, group);
        stmt.setInt(2, id);
        stmt.executeUpdate();
        int[] aiTota1Updated = stmt.executeBatch();
        res = true;
    } catch (SQLException e) {
        System.out.println("Exception updating laboratory group: " + e.getMessage());
    } finally {
        if (stmt != null)
            try {
                stmt.close();
            } catch (SQLException e) {
                System.out.println("Exception updating laboratory group: " + e.getMessage());
            }
    }
    return res;
}

######


public ArrayList<LaboratoryGroup> getLabGroups() {
    ArrayList<LaboratoryGroup> laboratoryGroups = new ArrayList<LaboratoryGroup>();
    PreparedStatement stmt = null;
    ResultSet rs = null;
    try {
        stmt = MyConnection.prepareStatement("SELECT id, lgroup FROM laboratorygroups");
        rs = stmt.executeQuery();
        while (rs.next()) {
            laboratoryGroups.add(new LaboratoryGroup(rs.getInt("id"), rs.getString("lgroup")));
        }
    } catch (SQLException e) {
        System.out.println("Exception getting laboratory groups: " + e.getMessage());
    } finally {
        if (stmt != null)
            try {
                stmt.close();
            } catch (SQLException e) {
                System.out.println("Exception getting laboratory groups: " + e.getMessage());
            }
        if (rs != null)
            try {
                rs.close();
            } catch (SQLException e) {
                System.out.println("Exception getting laboratory groups: " + e.getMessage());
            }
    }
    return laboratoryGroups;
}

######


public void closeConexion() {
    try {
        MyConnection.close();
    } catch (SQLException e) {
        System.out.println("Exception closing the connection: " + e.getMessage());
    }
}

######


public void add(List<CacheData> cacheDatas) {
    db.beginTransaction();
    try {
        for (CacheData cacheData : cacheDatas) {
            db.execSQL("INSERT INTO " + TABLENAME_STRING + " VALUES(?, ?, datetime('now'))", new Object[] { cacheData.url, cacheData.value });
        }
        db.setTransactionSuccessful();
    } finally {
        db.endTransaction();
    }
}

######


public void updateValue(CacheData cacheData) {
    db.execSQL(" REPLACE INTO " + TABLENAME_STRING + " (url,value,date) VALUES (?, ?, datetime('now'))", new Object[] { cacheData.url, cacheData.value });
}

######


public void updateData(CacheData cacheData) {
    ContentValues cv = new ContentValues();
    cv.put("value", cacheData.value);
    db.update(TABLENAME_STRING, cv, "url = ?", new String[] { cacheData.url });
}

######


public void delete(CacheData cacheData) {
    db.delete(TABLENAME_STRING, "url = ?", new String[] { cacheData.url });
}

######


public List<CacheData> queryAll() {
    ArrayList<CacheData> cacheDatas = new ArrayList<CacheData>();
    Cursor c = queryTheCursor("SELECT * FROM " + TABLENAME_STRING);
    while (c.moveToNext()) {
        CacheData cacheData = new CacheData();
        cacheData.url = c.getString(c.getColumnIndex("url"));
        cacheData.value = c.getString(c.getColumnIndex("value"));
        cacheData.date = c.getString(c.getColumnIndex("date"));
        cacheDatas.add(cacheData);
    }
    c.close();
    return cacheDatas;
}

######


public Cursor queryTheCursor(String sql) {
    Cursor c = db.rawQuery(sql, null);
    return c;
}

######


public String queryValuebyUrl(String url) {
    Cursor c = null;
    try {
        c = db.rawQuery(" select value from " + TABLENAME_STRING + " where url = ? ", new String[] { url });
        c.moveToFirst();
        return c.getString(0);
    } catch (Exception e) {
        return null;
    } finally {
        c.close();
    }
}

######


public void closeDB() {
    db.close();
}

######


public static int deleteMeeting(int appointmentID) {
    boolean successfulAppointmentDeletion = DBAppointment.deleteAppointment(appointmentID) > 0;
    boolean successfulReservationDeletion = DBRoom.deleteReservation(appointmentID) > 0;
    return (successfulAppointmentDeletion && successfulReservationDeletion ? 1 : -1);
}

######


public static Meeting getMeeting(int appointmentID) {
    ArrayList<User> invited = DBMeeting.getInvitedUsers(appointmentID);
    Appointment appointment = DBAppointment.getAppointment(appointmentID);
    String fetchReservation = "SELECT Romnr FROM Reservasjon WHERE Avtale_ID = " + appointmentID + ";";
    String fetchOwner = "SELECT * FROM Bruker JOIN Oppretter_og_Eier ON Bruker.ID = Bruker_ID" + " WHERE Avtale_ID = " + appointment.getId() + ";";
    User owner = null;
    try {
        ResultSet results = Database.execute(fetchOwner);
        if (results.next()) {
            owner = DBUser.getUser(results.getInt("Bruker_ID"));
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    try {
        ResultSet results = Database.execute(fetchReservation);
        if (results.next()) {
            int roomNumber = results.getInt("Romnr");
            return new Meeting(owner, DBRoom.getRoom(roomNumber), appointment.getId(), appointment.getStart(), appointment.getEnd(), appointment.getTitle(), appointment.getDescription());
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return null;
}

######


public static int deleteMeeting(int roomNumber, long from, long to) {
    String getId = "SELECT Avtale_ID From Reservasjon WHERE Romnr = " + roomNumber + " AND Tid_start = " + from + " AND Tid_slutt = " + to + ";";
    int appointmentID = -1;
    try {
        ResultSet results = Database.execute(getId);
        if (results.next()) {
            appointmentID = results.getInt("Avtale_ID");
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return deleteMeeting(appointmentID);
}

######


public static Meeting newMeeting(User owner, int appointmentID, int roomNumber, long from, long to) {
    String sql = "INSERT INTO Oppretter_og_Eier VALUES " + owner.getId() + ", " + appointmentID + ";";
    Database.executeUpdate(sql);
    try {
        int roomInsertionID = DBRoom.reserveRoom(roomNumber, appointmentID, from, to);
        return DBMeeting.getMeeting(appointmentID);
    } catch (ReservationAlreadyMadeException e) {
        e.printStackTrace();
        return null;
    }
}

######


public static Meeting newMeeting(User owner, int roomNumber, long from, long to, String title, String description, ArrayList<User> participants) {
    int appointmentID = DBAppointment.newAppointment(owner.getId(), from, to, title, description).getId();
    String makeNotificationRef = "INSERT INTO Varsel(Avtale_ID, Beskrivelse) VALUES (" + appointmentID + ", '" + title + "');";
    Database.executeUpdate(makeNotificationRef);
    for (User user : participants) {
        String addParticipants = "INSERT INTO Deltaker(Avtale_ID, Bruker_ID, Varsel_ID, Status) VALUES (" + appointmentID + ", " + user.getId() + ", " + DBNotification.getNotificationID(appointmentID) + ", 1);";
        Database.executeUpdate(addParticipants);
    }
    System.out.println("meeting added to db");
    try {
        int roomInsertionId = DBRoom.reserveRoom(roomNumber, appointmentID, from, to);
        return DBMeeting.getMeeting(appointmentID);
    } catch (ReservationAlreadyMadeException e) {
        e.printStackTrace();
        return null;
    }
}

######


public static ArrayList<User> getInvitedUsers(int appointmentID) {
    ArrayList<User> list = new ArrayList<User>();
    String sql = "SELECT * FROM Bruker WHERE ID IN " + "(SELECT Bruker_ID FROM Bruker JOIN Deltaker ON " + "Bruker.ID = Bruker_ID WHERE Avtale_ID = " + appointmentID + ") ORDER BY Navn ASC;";
    try {
        ResultSet results = Database.execute(sql);
        while (results.next()) {
            int userID = results.getInt("ID");
            String name = results.getString("Navn");
            String username = results.getString("Brukernavn");
            list.add(new User(userID, name, username));
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return list;
}

######


public static int changeParticipants(int appointmentID, ArrayList<User> oldParticipants, ArrayList<User> newParticipants) {
    int successfulDeletion = -1;
    for (User user : oldParticipants) {
        String delete = "DELETE FROM Deltaker WHERE Avtale_ID = " + appointmentID + " AND Bruker_ID = " + user.getId() + ";";
        successfulDeletion = Database.executeUpdate(delete);
    }
    int successfulInsertion = -1;
    for (User user : newParticipants) {
        String insert = "INSERT INTO Deltaker(Avtale_ID, Bruker_ID, Varsel_ID) VALUES(" + appointmentID + ", " + user.getId() + ", " + DBNotification.getNotificationID(appointmentID) + ");";
        successfulInsertion = Database.executeUpdate(insert);
    }
    return (successfulDeletion > -1 && successfulInsertion > 0 ? 1 : -1);
}

######


public static int inviteParticipants(int appointmentID, ArrayList<User> participants) {
    for (User user : participants) {
        String sql = "INSERT INTO Deltaker(Avtale_ID, Bruker_ID, Varsel_ID) VALUES (" + appointmentID + ", " + user.getId() + ", " + DBNotification.getNotificationID(appointmentID) + ");";
        return Database.executeUpdate(sql);
    }
    return -1;
}

######


public static void main(String[] args) {
}

######


public static int getNotificationID(int appointmentID) {
    String sql = "SELECT * FROM Varsel WHERE Avtale_ID = " + appointmentID + ";";
    try {
        ResultSet results = Database.execute(sql);
        if (results.next()) {
            return results.getInt("ID");
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return -1;
}

######


public static ArrayList<Notification> getNotifications(int userID) {
    String sql = "SELECT * FROM Varsel WHERE Varsel.ID IN " + "(SELECT Varsel_ID FROM Deltaker WHERE Bruker_ID = " + userID + " AND Status = 1);";
    List<Notification> list = new ArrayList<Notification>();
    try {
        ResultSet results = Database.execute(sql);
        while (results.next()) {
            User owner = DBUser.getUser(userID);
            int id = results.getInt("ID");
            int appointmentID = results.getInt("Avtale_ID");
            String desc = results.getString("Beskrivelse");
            list.add(new Notification(id, owner, appointmentID, desc));
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return (ArrayList<Notification>) list;
}

######


public static void main(String[] args) {
    ArrayList<Notification> list = DBNotification.getNotifications(35);
    for (Notification n : list) {
        System.out.println("Beskrivelse: " + n.getDescription());
        System.out.println("ID: " + n.getId());
        System.out.println("Eier: " + n.getOwner().getName());
    }
}

######


public boolean isProblemGroupInserted(String group) {
    boolean res = false;
    PreparedStatement stmt = null;
    try {
        stmt = MyConnection.prepareStatement("INSERT INTO problemgroups (pgroup) VALUES (?)");
        stmt.setString(1, group);
        stmt.executeUpdate();
        res = true;
    } catch (SQLException e) {
        System.out.println("Exception inserting problem group: " + e.getMessage());
    } finally {
        if (stmt != null)
            try {
                stmt.close();
            } catch (SQLException e) {
                System.out.println("Exception inserting problem group: " + e.getMessage());
            }
    }
    return res;
}

######


public boolean isProblemGroupDeleted(int id) {
    boolean res = false;
    PreparedStatement stmt = null;
    try {
        stmt = MyConnection.prepareStatement("DELETE FROM problemgroups WHERE id=?");
        stmt.setInt(1, id);
        stmt.executeUpdate();
        res = true;
    } catch (SQLException e) {
        System.out.println("Exception deleting problem group: " + e.getMessage());
    } finally {
        if (stmt != null)
            try {
                stmt.close();
            } catch (SQLException e) {
                System.out.println("Exception deleting problem group: " + e.getMessage());
            }
    }
    return res;
}

######


public boolean isProblemGroupUpdated(int id, String group) {
    boolean res = false;
    PreparedStatement stmt = null;
    try {
        stmt = MyConnection.prepareStatement("UPDATE problemgroups SET pgroup=? WHERE id=?");
        stmt.setString(1, group);
        stmt.setInt(2, id);
        stmt.executeUpdate();
        res = true;
    } catch (SQLException e) {
        System.out.println("Exception updating problem group: " + e.getMessage());
    } finally {
        if (stmt != null)
            try {
                stmt.close();
            } catch (SQLException e) {
                System.out.println("Exception updating problem group: " + e.getMessage());
            }
    }
    return res;
}

######


public ArrayList<ProblemGroups> getProblemGroups() {
    ArrayList<ProblemGroups> problemGroups = new ArrayList<ProblemGroups>();
    PreparedStatement stmt = null;
    ResultSet rs = null;
    try {
        stmt = MyConnection.prepareStatement("SELECT id, pgroup FROM problemgroups");
        rs = stmt.executeQuery();
        while (rs.next()) {
            problemGroups.add(new ProblemGroups(rs.getInt("id"), rs.getString("pgroup")));
        }
    } catch (SQLException e) {
        System.out.println("Exception getting problem groups: " + e.getMessage());
    } finally {
        if (stmt != null)
            try {
                stmt.close();
            } catch (SQLException e) {
                System.out.println("Exception getting problem groups: " + e.getMessage());
            }
        if (rs != null)
            try {
                rs.close();
            } catch (SQLException e) {
                System.out.println("Exception getting problem groups: " + e.getMessage());
            }
    }
    return problemGroups;
}

######


public void closeConexion() {
    try {
        MyConnection.close();
    } catch (SQLException e) {
        System.out.println("Exception closing the connection: " + e.getMessage());
    }
}

######


public static ArrayList<Room> getAvailibleRooms(int numberOfParticipants, long start, long end) throws NoAvailableRoomsException {
    ArrayList<Room> list = new ArrayList<Room>();
    String sql = "SELECT * FROM Rom WHERE Romnr NOT IN" + " (SELECT Rom.Romnr FROM Rom JOIN Reservasjon " + "ON Rom.Romnr = Reservasjon.Romnr WHERE " + "(Tid_start <= " + start + " AND Tid_slutt >= " + start + ") OR (Tid_start <= " + end + " AND Tid_slutt >= " + end + ")) AND St�rrelse >= " + +numberOfParticipants + " ORDER BY St�rrelse;";
    System.out.println(sql);
    try {
        ResultSet results = Database.execute(sql);
        while (results.next()) {
            int roomNo = results.getInt("Romnr");
            int size = results.getInt("St�rrelse");
            list.add(new Room(roomNo, size));
        }
        if (list.isEmpty()) {
            throw new NoAvailableRoomsException();
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return list;
}

######


private static boolean reservationInDatabase(int appointmentID) {
    String sql = "SELECT * FROM Reservasjon WHERE Avtale_ID = " + appointmentID + ";";
    try {
        ResultSet results = Database.execute(sql);
        while (results.next()) {
            if (results.getInt("Avtale_ID") == appointmentID) {
                System.out.println("Shite");
                return true;
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return false;
}

######


public static int reserveRoom(int roomNumber, int appointmentID, long from, long to) throws ReservationAlreadyMadeException {
    if (reservationInDatabase(appointmentID)) {
        throw new ReservationAlreadyMadeException();
    }
    String sql = "INSERT INTO Reservasjon(Avtale_ID, Romnr, Tid_start, " + "Tid_slutt) VALUES (" + appointmentID + ", " + roomNumber + ", " + from + ", " + to + ");";
    return Database.executeUpdate(sql);
}

######


public static int deleteReservation(int appointmentID) {
    String sql = "DELETE FROM Reservasjon WHERE Avtale_ID = " + appointmentID + ";";
    return Database.executeUpdate(sql);
}

######


public static int deleteReservation(int roomNumber, long from, long to) {
    String sql = "DELETE FROM Reservasjon WHERE Romnr = " + roomNumber + "AND Tid_start = " + from + "AND Tid_slutt = " + to + ";";
    return Database.executeUpdate(sql);
}

######


private static boolean roomInDatabase(int roomNumber) {
    String sql = "SELECT Romnr FROM Rom";
    try {
        ResultSet results = Database.execute(sql);
        while (results.next()) {
            int dbroom = results.getInt("Romnr");
            if (dbroom == roomNumber) {
                return true;
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return false;
}

######


public static int addRoom(int roomNumber, int size) throws RoomAlreadyExistsException {
    if (roomInDatabase(roomNumber)) {
        throw new RoomAlreadyExistsException();
    }
    String sql = "INSERT INTO Room(Romnr, St�rrelse) VALUES(" + roomNumber + ", " + size + ");";
    return Database.executeUpdate(sql);
}

######


public static int changeReservation(int appointmentID, int newRoomNumber) {
    String sql = "UPDATE Reservasjon SET Romnr = " + newRoomNumber + " WHERE Avtale_ID = " + appointmentID + ";";
    return Database.executeUpdate(sql);
}

######


public static Room getRoom(int roomNumber) {
    String sql = "SELECT * FROM Rom WHERE Romnr = " + roomNumber + ";";
    try {
        ResultSet results = Database.execute(sql);
        if (results.next()) {
            return new Room(results.getInt("Romnr"), results.getInt("St�rrelse"));
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return null;
}

######


public boolean isStudentInserted(String idnum, String name, String surname, String email, int idprob, int idpract) {
    boolean res = false;
    PreparedStatement stmt = null;
    Date date = new Date();
    Timestamp stamp = new Timestamp(date.getTime());
    try {
        stmt = MyConnection.prepareStatement("Insert into students (sname, surname, email, idprob, idpract, sdate, idnum) Values (?,?,?,?,?,?,?)");
        stmt.setString(1, name);
        stmt.setString(2, surname);
        stmt.setString(3, email);
        stmt.setInt(4, idprob);
        stmt.setInt(5, idpract);
        stmt.setTimestamp(6, stamp);
        stmt.setString(7, idnum);
        stmt.executeUpdate();
        res = true;
    } catch (SQLException e) {
        System.out.println("Exception inserting students: " + e.getMessage());
    } finally {
        if (stmt != null)
            try {
                stmt.close();
            } catch (SQLException e) {
                System.out.println("Exception inserting students: " + e.getMessage());
            }
    }
    return res;
}

######


public boolean isStudentsDeleted(int id) {
    boolean res = false;
    PreparedStatement stmt = null;
    try {
        stmt = MyConnection.prepareStatement("DELETE FROM students WHERE id=?");
        stmt.setInt(1, id);
        stmt.executeUpdate();
        res = true;
    } catch (SQLException e) {
        System.out.println("Exception deleting students: " + e.getMessage());
    } finally {
        if (stmt != null)
            try {
                stmt.close();
            } catch (SQLException e) {
                System.out.println("Exception deleting students: " + e.getMessage());
            }
    }
    return res;
}

######


public boolean isStudentUpdated(int id, String idnum, String name, String surname, String email, int idprob, int idpract) {
    boolean res = false;
    PreparedStatement stmt = null;
    Date date = new Date();
    Timestamp stamp = new Timestamp(date.getTime());
    try {
        stmt = MyConnection.prepareStatement("UPDATE students SET sname=?, surname=?, email=?, idnum=?, idprob=?, idpract=?, sdate=? WHERE id=?");
        stmt.setString(1, name);
        stmt.setString(2, surname);
        stmt.setString(3, email);
        stmt.setString(4, idnum);
        stmt.setInt(5, idprob);
        stmt.setInt(6, idpract);
        stmt.setTimestamp(7, stamp);
        stmt.setInt(8, id);
        stmt.executeUpdate();
        res = true;
    } catch (SQLException e) {
        System.out.println("Exception updating students: " + e.getMessage());
    } finally {
        if (stmt != null)
            try {
                stmt.close();
            } catch (SQLException e) {
                System.out.println("Exception updating students: " + e.getMessage());
            }
    }
    return res;
}

######


public ArrayList<Students> getStudents() {
    ArrayList<Students> students = new ArrayList<Students>();
    PreparedStatement stmt = null;
    ResultSet rs = null;
    try {
        stmt = MyConnection.prepareStatement("Select students.*,laboratorygroups.lgroup " + "as lab_group,problemgroups.pgroup " + "as prob_group From students " + "Inner Join laboratorygroups " + "ON laboratorygroups.id = students.idpract " + "Inner Join problemgroups " + "ON problemgroups.id = students.idprob");
        rs = stmt.executeQuery();
        while (rs.next()) {
            students.add(new Students(rs.getInt("id"), rs.getInt("idprob"), rs.getInt("idpract"), rs.getString("idnum"), rs.getString("sname"), rs.getString("surname"), rs.getString("email"), rs.getString("prob_group"), rs.getString("lab_group"), rs.getString("sdate")));
        }
    } catch (SQLException e) {
        System.out.println("Exception selecting students: " + e.getMessage());
    } finally {
        if (stmt != null)
            try {
                stmt.close();
            } catch (SQLException e) {
                System.out.println("Exception selecting students: " + e.getMessage());
            }
        if (rs != null)
            try {
                rs.close();
            } catch (SQLException e) {
                System.out.println("Exception selecting students: " + e.getMessage());
            }
    }
    return students;
}

######


public void closeConnection() {
    try {
        MyConnection.close();
    } catch (SQLException e) {
        System.out.println("Exception closing connection: " + e.getMessage());
    }
}

######


@Override
public void dbCreateTask(Task task) throws SQLException {
    PreparedStatement ps = conn.prepareStatement(DB_CREATE_TASK);
    ps.setString(1, task.getTitle());
    ps.setString(2, task.getPhase());
    ps.setString(3, task.getCreationDate());
    ps.setString(4, task.getDueDate());
    ps.execute();
    ps.close();
}

######


@Override
public void dbChangeTaskPhase(Task task, String phase) throws SQLException {
    PreparedStatement ps = conn.prepareStatement(DB_CHANGE_TASK_PHASE);
    ps.setString(1, phase);
    ps.setInt(2, task.getId());
    ps.execute();
    ps.close();
}

######


@Override
public List<Task> dbGetTasks() throws SQLException {
    List<Task> tasks = new ArrayList<Task>();
    PreparedStatement ps = conn.prepareStatement(DB_GET_TASKS);
    ResultSet rs = ps.executeQuery();
    int col1Pos = rs.findColumn("ID");
    int col2Pos = rs.findColumn("TITLE");
    int col3Pos = rs.findColumn("PHASE");
    int col4Pos = rs.findColumn("CREATION_DATE");
    int col5Pos = rs.findColumn("DUE_DATE");
    while (rs.next()) {
        int id = rs.getInt(col1Pos);
        String title = rs.getString(col2Pos);
        String phase = rs.getString(col3Pos);
        String creationDate = rs.getString(col4Pos);
        String dueDate = rs.getString(col5Pos);
        Task task = new Task(id, title, phase, creationDate, dueDate);
        task.print();
        tasks.add(task);
    }
    ps.close();
    return tasks;
}

######


public static ArrayList<User> getUsersInSystem() {
    String sql = "SELECT ID, Brukernavn, Navn FROM Bruker;";
    ArrayList<User> list = new ArrayList<User>();
    try {
        ResultSet results = Database.execute(sql);
        while (results.next()) {
            int userID = results.getInt("ID");
            String name = results.getString("Navn");
            String username = results.getString("Brukernavn");
            list.add(new User(userID, name, username));
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return list;
}

######


public static User newUser(String name, String username, String password) {
    String sql = "INSERT INTO Bruker(Navn, Brukernavn, Passord) VALUES('" + name + "', '" + username + "', '" + password + "');";
    int userID = Database.executeUpdate(sql, true);
    return DBUser.getUser(userID);
}

######


public static ArrayList<Appointment> getUserAppointments(int userID) {
    ArrayList<Appointment> list = new ArrayList<Appointment>();
    String sql = "SELECT * " + "FROM Avtale, Oppretter_og_Eier " + "WHERE Avtale.ID = Oppretter_og_Eier.Avtale_ID " + "AND Oppretter_og_Eier.Bruker_ID = " + userID + " ORDER BY Tid_start;";
    try {
        ResultSet results = Database.execute(sql);
        while (results.next()) {
            int id = results.getInt("ID");
            long start = results.getLong("Tid_start");
            long end = results.getLong("Tid_slutt");
            String title = results.getString("Tittel");
            String desc = results.getString("Beskrivelse");
            new Appointment(id, start, end, title, desc);
            list.add(new Appointment(id, start, end, title, desc));
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return list;
}

######


public static User getUser(int userID) {
    String sql = "SELECT * FROM Bruker WHERE ID = " + userID + ";";
    try {
        ResultSet results = Database.execute(sql);
        if (results.next()) {
            String name = results.getString("Navn");
            String username = results.getString("Brukernavn");
            return new User(userID, name, username);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return null;
}

######


public static User getUser(String username) {
    String sql = "SELECT * FROM Bruker WHERE Brukernavn = '" + username + "';";
    try {
        ResultSet results = Database.execute(sql);
        if (results.next()) {
            String name = results.getString("Navn");
            String password = results.getString("Passord");
            int id = results.getInt("ID");
            return new User(id, name, username, password);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return null;
}

######


public static Options defaultValues(final HaMode haMode) {
    return parse(haMode, "", new Properties());
}

######


public static Options defaultValues(HaMode haMode, boolean pool) {
    Properties properties = new Properties();
    properties.setProperty("pool", String.valueOf(pool));
    Options options = parse(haMode, "", properties);
    optionCoherenceValidation(options);
    return options;
}

######


public static void parse(final HaMode haMode, final String urlParameters, final Options options) {
    Properties prop = new Properties();
    parse(haMode, urlParameters, prop, options);
    optionCoherenceValidation(options);
}

######


private static Options parse(final HaMode haMode, final String urlParameters, final Properties properties) {
    Options options = parse(haMode, urlParameters, properties, null);
    optionCoherenceValidation(options);
    return options;
}

######


public static Options parse(final HaMode haMode, final String urlParameters, final Properties properties, final Options options) {
    if (urlParameters != null && !urlParameters.isEmpty()) {
        String[] parameters = urlParameters.split("&");
        for (String parameter : parameters) {
            int pos = parameter.indexOf('=');
            if (pos == -1) {
                if (!properties.containsKey(parameter)) {
                    properties.setProperty(parameter, "");
                }
            } else {
                if (!properties.containsKey(parameter.substring(0, pos))) {
                    properties.setProperty(parameter.substring(0, pos), parameter.substring(pos + 1));
                }
            }
        }
    }
    return parse(haMode, properties, options);
}

######


private static Options parse(final HaMode haMode, final Properties properties, final Options paramOptions) {
    final Options options = paramOptions != null ? paramOptions : new Options();
    try {
        for (final String key : properties.stringPropertyNames()) {
            final String propertyValue = properties.getProperty(key);
            final DefaultOptions o = OptionUtils.OPTIONS_MAP.get(key);
            if (o != null && propertyValue != null) {
                final Field field = Options.class.getField(o.optionName);
                if (o.objType.equals(String.class)) {
                    field.set(options, propertyValue);
                } else if (o.objType.equals(Boolean.class)) {
                    switch(propertyValue.toLowerCase()) {
                        case "":
                        case "1":
                        case "true":
                            field.set(options, Boolean.TRUE);
                            break;
                        case "0":
                        case "false":
                            field.set(options, Boolean.FALSE);
                            break;
                        default:
                            throw new IllegalArgumentException("Optional parameter " + o.optionName + " must be boolean (true/false or 0/1) was \"" + propertyValue + "\"");
                    }
                } else if (o.objType.equals(Integer.class)) {
                    try {
                        final Integer value = Integer.parseInt(propertyValue);
                        assert o.minValue != null;
                        assert o.maxValue != null;
                        if (value.compareTo((Integer) o.minValue) < 0 || value.compareTo((Integer) o.maxValue) > 0) {
                            throw new IllegalArgumentException("Optional parameter " + o.optionName + " must be greater or equal to " + o.minValue + (((Integer) o.maxValue != Integer.MAX_VALUE) ? " and smaller than " + o.maxValue : " ") + ", was \"" + propertyValue + "\"");
                        }
                        field.set(options, value);
                    } catch (NumberFormatException n) {
                        throw new IllegalArgumentException("Optional parameter " + o.optionName + " must be Integer, was \"" + propertyValue + "\"");
                    }
                } else if (o.objType.equals(Long.class)) {
                    try {
                        final Long value = Long.parseLong(propertyValue);
                        assert o.minValue != null;
                        assert o.maxValue != null;
                        if (value.compareTo((Long) o.minValue) < 0 || value.compareTo((Long) o.maxValue) > 0) {
                            throw new IllegalArgumentException("Optional parameter " + o.optionName + " must be greater or equal to " + o.minValue + (((Long) o.maxValue != Long.MAX_VALUE) ? " and smaller than " + o.maxValue : " ") + ", was \"" + propertyValue + "\"");
                        }
                        field.set(options, value);
                    } catch (NumberFormatException n) {
                        throw new IllegalArgumentException("Optional parameter " + o.optionName + " must be Long, was \"" + propertyValue + "\"");
                    }
                }
            }
        }
        if (options.socketTimeout == null) {
            options.socketTimeout = ((Integer[]) SOCKET_TIMEOUT.defaultValue)[haMode.ordinal()];
        }
    } catch (NoSuchFieldException | IllegalAccessException n) {
        n.printStackTrace();
    } catch (SecurityException s) {
        throw new IllegalArgumentException("Security too restrictive : " + s.getMessage());
    }
    return options;
}

######


public static void optionCoherenceValidation(final Options options) {
    if (options.rewriteBatchedStatements) {
        options.useServerPrepStmts = false;
    }
    if (options.pipe != null) {
        options.useBatchMultiSend = false;
        options.usePipelineAuth = false;
    }
    if (options.pool) {
        options.minPoolSize = options.minPoolSize == null ? options.maxPoolSize : Math.min(options.minPoolSize, options.maxPoolSize);
    }
}

######


public static void propertyString(final Options options, final HaMode haMode, final StringBuilder sb) {
    try {
        boolean first = true;
        for (DefaultOptions o : DefaultOptions.values()) {
            final Object value = Options.class.getField(o.optionName).get(options);
            if (value != null && !value.equals(o.defaultValue)) {
                if (first) {
                    first = false;
                    sb.append('?');
                } else {
                    sb.append('&');
                }
                sb.append(o.optionName).append('=');
                if (o.objType.equals(String.class)) {
                    sb.append((String) value);
                } else if (o.objType.equals(Boolean.class)) {
                    sb.append(((Boolean) value).toString());
                } else if (o.objType.equals(Integer.class) || o.objType.equals(Long.class)) {
                    sb.append(value);
                }
            }
        }
    } catch (NoSuchFieldException | IllegalAccessException n) {
        n.printStackTrace();
    }
}

######


public String getOptionName() {
    return optionName;
}

######


public String getDescription() {
    return description;
}

######


public boolean isRequired() {
    return required;
}

######


public static void main(String[] args) throws Exception {
    Class.forName("com.mysql.jdbc.Driver");
    Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/karthik", "root", "visog");
    Statement stmt = con.createStatement();
    String sql = "Delete  from employee  where  id in(1,	2)";
    int rs = stmt.executeUpdate(sql);
    System.out.println(rs + "rows affected");
    con.close();
}

######


public static void main(String[] args) throws Exception {
    Class.forName("com.mysql.jdbc.Driver");
    Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/karthik", "root", "visog");
    Statement stmt = con.createStatement();
    String sql = "Delete  from employee  where  id in(1,	2)";
    int rs = stmt.executeUpdate(sql);
    System.out.println(rs + "rows affected");
    con.close();
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
}

######


public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException {
    final java.lang.String _jspx_method = request.getMethod();
    if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method) && !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET POST or HEAD");
        return;
    }
    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;
    try {
        response.setContentType("text/html");
        pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true);
        _jspx_page_context = pageContext;
        application = pageContext.getServletContext();
        config = pageContext.getServletConfig();
        session = pageContext.getSession();
        out = pageContext.getOut();
        _jspx_out = out;
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        int empid = (int) session.getAttribute("empid");
        String sql = "select * from `truckparam`  order by `capacity`";
        try {
            Connection con = Connect.getconnection();
            PreparedStatement ps = con.prepareStatement(sql);
            ResultSet rs = ps.executeQuery();
            String[] selected;
            selected = request.getParameterValues("check");
            int j = 0;
            while (rs.next()) {
                for (int i = 0; i < selected.length; i++) {
                    if (Integer.parseInt(selected[i]) == j) {
                        String sql1 = "Delete from `truckparam`  where typeofgood= ?";
                        String sql2 = "Delete from `routeparam`  where typeofgood= ?";
                        PreparedStatement ps1 = con.prepareStatement(sql1);
                        PreparedStatement ps2 = con.prepareStatement(sql2);
                        ps1.setString(1, rs.getString("typeofgood"));
                        ps1.execute();
                        ps2.setString(1, rs.getString("typeofgood"));
                        ps2.execute();
                    }
                    j++;
                }
            }
            RequestDispatcher ReqDis = request.getRequestDispatcher("adminCapex.jsp");
            ReqDis.forward(request, response);
        } catch (Exception e) {
            e.printStackTrace();
            RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
            ReqDis.forward(request, response);
        }
    } catch (java.lang.Throwable t) {
        if (!(t instanceof javax.servlet.jsp.SkipPageException)) {
            out = _jspx_out;
            if (out != null && out.getBufferSize() != 0)
                try {
                    if (response.isCommitted()) {
                        out.flush();
                    } else {
                        out.clearBuffer();
                    }
                } catch (java.io.IOException e) {
                }
            if (_jspx_page_context != null)
                _jspx_page_context.handlePageException(t);
            else
                throw new ServletException(t);
        }
    } finally {
        _jspxFactory.releasePageContext(_jspx_page_context);
    }
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL("CREATE TABLE demo (_id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, latitude REAL, longitude REAL, weather INTEGER);");
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
}

######


public void init() {
    SQLiteDatabase db = getWritableDatabase();
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396214 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396279 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396333 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396380 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396430 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396480 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396559 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396602 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396648 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396699 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396740 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396781 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396826 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396865 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396905 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396955 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.396996 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397037 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397084 + ", " + 127.109694 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397129 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397175 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397218 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397263 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397306 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397353 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397353 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397394 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397444 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397485 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397530 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397573 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397573 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397616 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397659 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397659 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397706 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397743 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397784 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397829 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397869 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397900 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397940 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.397980 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398020 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398060 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398100 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398140 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398180 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398220 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398260 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398300 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398340 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398380 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398420 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398460 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398500 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398540 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398580 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398620 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398660 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398700 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398740 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398780 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398820 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398860 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398900 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398940 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.398980 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399020 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399060 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399100 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399140 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399180 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399220 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399260 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399300 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399340 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399380 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399420 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399460 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399500 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399540 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399580 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399620 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399660 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399700 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399740 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399780 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.109692 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.109740 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.109780 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.109820 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.109860 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.109900 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.109940 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.109980 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110020 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110060 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110100 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110140 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110180 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110220 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110260 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110300 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110340 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110380 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110420 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110460 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110500 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110540 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110580 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110620 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110660 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110700 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110740 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110780 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110820 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110860 + ", " + 0 + ");");
    db.execSQL("INSERT INTO demo VALUES (NULL, " + "'Continental'" + ", " + 37.399820 + ", " + 127.110900 + ", " + 0 + ");");
    Log.e("DB INSERT", "Insert all instance");
    db.close();
}

######


public void delete() {
    SQLiteDatabase db = getWritableDatabase();
    db.execSQL("DELETE FROM demo");
    Log.e("DB DELETE", "Delete all instance");
    db.close();
}

######


public void demoKookmin(Queue<Demo> KookminQueue) {
    SQLiteDatabase db = getReadableDatabase();
    Cursor cursor = db.rawQuery("SELECT * FROM demo", null);
    while (cursor.moveToNext()) {
        String name = cursor.getString(cursor.getColumnIndex("name"));
        Double latitude = cursor.getDouble(cursor.getColumnIndex("latitude"));
        Double longitude = cursor.getDouble(cursor.getColumnIndex("longitude"));
        Integer weather = cursor.getInt(cursor.getColumnIndex("weather"));
        Demo demo = new Demo(name, latitude, longitude, weather);
        KookminQueue.offer(demo);
    }
}

######


public List findAll() {
    String sql = "select * from dept";
    List deptList = null;
    try {
        deptList = SqlSession.selectList(sql, Dept.class);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return deptList;
}

######


public int checkDname(String dname) {
    String sql = "select * from dept where dname='" + dname + "'";
    List deptList = null;
    try {
        deptList = SqlSession.selectList(sql, Dept.class);
    } catch (Exception e) {
        e.printStackTrace();
    }
    int result = deptList.size();
    return result;
}

######


public int deleteDpet(String deptNo) throws Exception {
    String sql = "delete from dept where deptno=" + deptNo;
    int num = SqlSession.delete(sql);
    return num;
}

######


public static void findCoffee(int coffeeId, String[] coffeeDescription) throws SQLException {
    Connection connection = null;
    PreparedStatement statement = null;
    try {
        connection = DriverManager.getConnection("jdbc:default:connection");
        String sql = "SELECT * FROM COFFEE_BEVERAGES WHERE ID = ? ";
        statement = connection.prepareStatement(sql);
        statement.setLong(1, coffeeId);
        ResultSet resultset = statement.executeQuery();
        resultset.next();
        coffeeDescription[0] = resultset.getString("COFFEE_DESCRIPTION");
    } finally {
        JdbcUtils.closeStatement(statement);
        JdbcUtils.closeConnection(connection);
    }
}

######


public static void findAllCoffeeBeverages(ResultSet[] coffeeBeverages) throws SQLException {
    Connection connection = null;
    PreparedStatement statement = null;
    connection = DriverManager.getConnection("jdbc:default:connection");
    String sql = "SELECT * FROM COFFEE_BEVERAGES";
    statement = connection.prepareStatement(sql);
    coffeeBeverages[0] = statement.executeQuery();
}

######


public void setup() throws SQLException {
    logger = Logger.getMyLogger(this.getClass().getName());
    try {
        localIPAddress = InetAddress.getLocalHost().getHostAddress();
    } catch (Exception e) {
        localIPAddress = "localhost";
    }
    ConnectionWrapper wrapper = getConnectionWrapper();
    Connection conn = wrapper.getConnection();
    try {
        conn.setAutoCommit(false);
    } catch (Exception e) {
        if (logger.isLoggable(Logger.WARNING)) {
            logger.log(Logger.WARNING, "Disabling auto-commit failed.");
        }
    }
    if (cleanTables) {
        dropDFTables();
    }
    createDFTables();
    tablesReady = true;
    PreparedStatements ps = new PreparedStatements(conn);
    wrapper.setInfo(ps);
    clean();
}

######


protected void initConnectionWrapper(ConnectionWrapper wrapper) throws SQLException {
    Connection conn = wrapper.getConnection();
    try {
        conn.setAutoCommit(false);
    } catch (Exception e) {
        if (logger.isLoggable(Logger.WARNING)) {
            logger.log(Logger.WARNING, "Disabling auto-commit failed.");
        }
    }
    if (tablesReady) {
        PreparedStatements ps = new PreparedStatements(conn);
        wrapper.setInfo(ps);
    }
}

######


private PreparedStatements getPreparedStatements() throws SQLException {
    ConnectionWrapper wrapper = getConnectionWrapper();
    return (PreparedStatements) wrapper.getInfo();
}

######


protected String getLongVarCharType() {
    String bestMatch = DEFAULT_LONGVARCHAR_TYPE;
    try {
        DatabaseMetaData md = getConnectionWrapper().getConnection().getMetaData();
        ResultSet typeInfo = md.getTypeInfo();
        long maxPrecision = -1;
        while (typeInfo.next()) {
            long jdbcType = Long.parseLong(typeInfo.getString("DATA_TYPE"));
            long precision = Long.parseLong(typeInfo.getString("PRECISION"));
            if (jdbcType == Types.LONGVARCHAR && precision > maxPrecision) {
                maxPrecision = precision;
                bestMatch = typeInfo.getString("TYPE_NAME");
            }
        }
    } catch (SQLException e) {
    }
    return bestMatch;
}

######


protected String getGUID() {
    UID uid = new UID();
    return localIPAddress + ":" + uid;
}

######


protected void dropTable(Statement stmt, String tableName) {
    try {
        stmt.execute("DROP TABLE " + tableName + " CASCADE CONSTRAINTS");
        getConnectionWrapper().getConnection().commit();
    } catch (SQLException e) {
        if (tableExists(tableName)) {
            logger.log(Logger.WARNING, "Cannot clean table " + tableName, e);
        }
    }
}

######


protected void dropDFTables() throws SQLException {
    logger.log(Logger.INFO, "Cleaning DF tables...");
    Statement stmt = getConnectionWrapper().getConnection().createStatement();
    dropTable(stmt, SUBSCRIPTION);
    dropTable(stmt, SERVICEPROTOCOL);
    dropTable(stmt, SERVICEONTOLOGY);
    dropTable(stmt, SERVICELANGUAGE);
    dropTable(stmt, SERVICEPROPERTY);
    dropTable(stmt, SERVICE);
    dropTable(stmt, LANGUAGE);
    dropTable(stmt, ONTOLOGY);
    dropTable(stmt, PROTOCOL);
    dropTable(stmt, AGENTUSERDEFSLOT);
    dropTable(stmt, AGENTRESOLVER);
    dropTable(stmt, AGENTADDRESS);
    dropTable(stmt, DFAGENTDESCR);
    stmt.close();
}

######


protected boolean tableExists(String name) {
    Statement stmt = null;
    try {
        stmt = getConnectionWrapper().getConnection().createStatement();
        stmt.execute("SELECT COUNT(*) FROM " + name);
        return true;
    } catch (SQLException e) {
        return false;
    } finally {
        if (stmt != null) {
            try {
                stmt.close();
            } catch (SQLException see) {
                see.printStackTrace();
            }
        }
    }
}

######


protected void createTable(String name, String[] entries) {
    if (!tableExists(name)) {
        Statement stmt = null;
        try {
            Connection conn = getConnectionWrapper().getConnection();
            stmt = conn.createStatement();
            String sql = "CREATE TABLE " + name + " (";
            for (int i = 0; i < entries.length; i++) {
                sql += entries[i];
                if (i < entries.length - 1)
                    sql += ", ";
                else
                    sql += ")";
            }
            stmt.executeUpdate(sql);
            conn.commit();
        } catch (SQLException e) {
            if (logger.isLoggable(Logger.SEVERE))
                logger.log(Logger.SEVERE, "Error creating table '" + name + "'", e);
        } finally {
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException see) {
                    see.printStackTrace();
                }
            }
        }
    }
}

######


protected void createIndices() {
    Statement stmt = null;
    try {
        Connection conn = getConnectionWrapper().getConnection();
        stmt = conn.createStatement();
        stmt.execute("CREATE INDEX dfagentDescrIdx ON dfagentdescr( aid )");
        stmt.execute("CREATE INDEX leaseIdx ON dfagentdescr( lease )");
        stmt.execute("CREATE INDEX agentAddressIdx ON agentaddress( aid )");
        stmt.execute("CREATE INDEX agentResolverIdx ON agentresolver( aid )");
        stmt.execute("CREATE INDEX agentUserdefslotIdx ON agentuserdefslot( aid )");
        stmt.execute("CREATE INDEX serviceLanguageIdx ON servicelanguage( serviceid )");
        stmt.execute("CREATE INDEX serviceProtocolIdx ON serviceprotocol( serviceid )");
        stmt.execute("CREATE INDEX serviceOntologyIdx ON serviceontology( serviceid )");
        stmt.execute("CREATE INDEX servicePropertyIdx ON serviceproperty( serviceid )");
        stmt.execute("CREATE INDEX ontologyIdx ON ontology( descrid )");
        stmt.execute("CREATE INDEX protocolIdx ON ontology( descrid )");
        stmt.execute("CREATE INDEX languageIdx ON ontology( descrid )");
        conn.commit();
    } catch (SQLException e) {
        if (logger.isLoggable(Logger.FINE))
            logger.log(Logger.FINE, "Indices for DF tables couldn't be created", e);
    } finally {
        if (stmt != null) {
            try {
                stmt.close();
            } catch (SQLException see) {
                see.printStackTrace();
            }
        }
    }
}

######


protected void createDFTables() {
    String LONGVARCHAR_TYPE = getLongVarCharType();
    createTable(DFAGENTDESCR, new String[] { "id VARCHAR(" + MAX_PROP_LENGTH + ")", "aid VARCHAR(" + MAX_PROP_LENGTH + ")", "lease VARCHAR(20)", "PRIMARY KEY( id )" });
    createTable(AGENTADDRESS, new String[] { "id VARCHAR(" + MAX_PROP_LENGTH + ")", "aid VARCHAR(" + MAX_PROP_LENGTH + ")", "address VARCHAR(" + MAX_PROP_LENGTH + ")", "PRIMARY KEY( id )" });
    createTable(AGENTRESOLVER, new String[] { "id VARCHAR(" + MAX_PROP_LENGTH + ")", "aid VARCHAR(" + MAX_PROP_LENGTH + ")", "resolveraid VARCHAR(" + MAX_PROP_LENGTH + ")", "PRIMARY KEY( id )" });
    createTable(AGENTUSERDEFSLOT, new String[] { "id VARCHAR(" + MAX_PROP_LENGTH + ")", "aid	VARCHAR(" + MAX_PROP_LENGTH + ")", "slotkey	VARCHAR(" + MAX_PROP_LENGTH + ")", "slotval	" + LONGVARCHAR_TYPE, "PRIMARY KEY( id )" });
    createTable(ONTOLOGY, new String[] { "descrid VARCHAR(" + MAX_PROP_LENGTH + ")", "ontology VARCHAR(64)", "PRIMARY KEY( descrid, ontology )", "FOREIGN KEY( descrid ) REFERENCES dfagentdescr( id )" });
    createTable(PROTOCOL, new String[] { "descrid VARCHAR(" + MAX_PROP_LENGTH + ")", "protocol VARCHAR(64)", "PRIMARY KEY( descrid, protocol )", "FOREIGN KEY( descrid ) REFERENCES dfagentdescr( id )" });
    createTable(LANGUAGE, new String[] { "descrid VARCHAR(" + MAX_PROP_LENGTH + ")", "language VARCHAR(32)", "PRIMARY KEY( descrid, language )", "FOREIGN KEY( descrid ) REFERENCES dfagentdescr( id )" });
    createTable(SERVICE, new String[] { "id VARCHAR(" + MAX_PROP_LENGTH + ")", "descrid VARCHAR(" + MAX_PROP_LENGTH + ")", "sname VARCHAR(" + MAX_PROP_LENGTH + ")", "stype VARCHAR(64)", "sownership VARCHAR(64)", "PRIMARY KEY( id )", "FOREIGN KEY( descrid ) REFERENCES dfagentdescr( id )" });
    createTable(SERVICEPROTOCOL, new String[] { "serviceid VARCHAR(" + MAX_PROP_LENGTH + ")", "protocol VARCHAR(64)", "PRIMARY KEY( serviceid, protocol )", "FOREIGN KEY( serviceid ) REFERENCES service( id )" });
    createTable(SERVICEONTOLOGY, new String[] { "serviceid VARCHAR(" + MAX_PROP_LENGTH + ")", "ontology VARCHAR(64)", "PRIMARY KEY( serviceid, ontology )", "FOREIGN KEY( serviceid ) REFERENCES service( id )" });
    createTable(SERVICELANGUAGE, new String[] { "serviceid VARCHAR(" + MAX_PROP_LENGTH + ")", "language VARCHAR(32)", "PRIMARY KEY( serviceid, language )", "FOREIGN KEY( serviceid ) REFERENCES service( id )" });
    createTable(SERVICEPROPERTY, new String[] { "serviceid VARCHAR(" + MAX_PROP_LENGTH + ")", "propkey VARCHAR(" + MAX_PROP_LENGTH + ")", "propval_obj " + LONGVARCHAR_TYPE, "propval_str VARCHAR(" + MAX_PROP_LENGTH + ")", "propvalhash VARCHAR(100)", "PRIMARY KEY( serviceid, propkey )", "FOREIGN KEY( serviceid ) REFERENCES service( id )" });
    createTable(SUBSCRIPTION, new String[] { "id	 VARCHAR(" + MAX_PROP_LENGTH + ")", "aclm " + LONGVARCHAR_TYPE, "PRIMARY KEY( id )" });
    createIndices();
    if (logger.isLoggable(Logger.FINE))
        logger.log(Logger.FINE, "Tables correctly created");
}

######


private String getBatchUpdateErroMsg(BatchUpdateException e) {
    StringBuffer msg = new StringBuffer("SQLException: " + e.getMessage() + "\n");
    msg.append("SQLState:  " + e.getSQLState() + "\n");
    msg.append("Message:  " + e.getMessage() + "\n");
    msg.append("Vendor:  " + e.getErrorCode() + "\n");
    msg.append("Update counts: ");
    int[] updateCounts = e.getUpdateCounts();
    for (int i = 0; i < updateCounts.length; i++) {
        msg.append(updateCounts[i] + "   ");
    }
    return msg.toString();
}

######


private void saveResolverAID(AID aid, AID resolverAid) throws SQLException {
    saveAID(resolverAid);
    PreparedStatements pss = getPreparedStatements();
    pss.stm_insAgentResolverAID.setString(1, getGUID());
    pss.stm_insAgentResolverAID.setString(2, aid.getName());
    pss.stm_insAgentResolverAID.setString(3, resolverAid.getName());
    pss.stm_insAgentResolverAID.addBatch();
}

######


private void saveAID(AID aid) throws SQLException {
    String name = aid.getName();
    PreparedStatements pss = getPreparedStatements();
    Iterator iter = aid.getAllAddresses();
    if (iter.hasNext()) {
        pss.stm_insAgentAddress.clearBatch();
        while (iter.hasNext()) {
            pss.stm_insAgentAddress.setString(1, getGUID());
            pss.stm_insAgentAddress.setString(2, name);
            pss.stm_insAgentAddress.setString(3, (String) iter.next());
            pss.stm_insAgentAddress.addBatch();
        }
        pss.stm_insAgentAddress.executeBatch();
    }
    Properties props = aid.getAllUserDefinedSlot();
    if (props.size() > 0) {
        pss.stm_insAgentUserDefSlot.clearBatch();
        java.util.Iterator pIter = props.entrySet().iterator();
        while (pIter.hasNext()) {
            Map.Entry entry = (Map.Entry) pIter.next();
            pss.stm_insAgentUserDefSlot.setString(1, getGUID());
            pss.stm_insAgentUserDefSlot.setString(2, name);
            pss.stm_insAgentUserDefSlot.setString(3, (String) entry.getKey());
            pss.stm_insAgentUserDefSlot.setString(4, (String) entry.getValue());
            pss.stm_insAgentUserDefSlot.addBatch();
        }
        pss.stm_insAgentUserDefSlot.executeBatch();
    }
    iter = aid.getAllResolvers();
    if (iter.hasNext()) {
        pss.stm_insAgentResolverAID.clearBatch();
        while (iter.hasNext()) {
            AID resolverAID = (AID) iter.next();
            saveResolverAID(aid, resolverAID);
        }
        pss.stm_insAgentResolverAID.executeBatch();
    }
}

######


private Collection getResolverAIDs(String aid) throws SQLException {
    ArrayList res = new ArrayList();
    PreparedStatements pss = getPreparedStatements();
    pss.stm_selAgentResolverAIDs.setString(1, aid);
    ResultSet rs = pss.stm_selAgentResolverAIDs.executeQuery();
    while (rs.next()) {
        res.add(rs.getString(1));
    }
    return res;
}

######


private void saveServices(String descrId, Iterator iter) throws SQLException {
    if (iter.hasNext()) {
        PreparedStatements pss = getPreparedStatements();
        pss.stm_insService.clearBatch();
        pss.stm_insServiceOntology.clearBatch();
        pss.stm_insServiceOntology.clearBatch();
        pss.stm_insServiceLanguage.clearBatch();
        pss.stm_insServiceProperty.clearBatch();
        boolean executeProtocolsBatch = false;
        boolean executeOntologiesBatch = false;
        boolean executeLanguagesBatch = false;
        boolean executePropertiesBatch = false;
        while (iter.hasNext()) {
            ServiceDescription service = (ServiceDescription) iter.next();
            String serviceId = getGUID();
            pss.stm_insService.clearParameters();
            pss.stm_insService.setString(1, serviceId);
            pss.stm_insService.setString(2, descrId);
            pss.stm_insService.setString(3, service.getName());
            pss.stm_insService.setString(4, service.getType());
            pss.stm_insService.setString(5, service.getOwnership());
            pss.stm_insService.addBatch();
            Iterator iterS = service.getAllProtocols();
            while (iterS.hasNext()) {
                pss.stm_insServiceProtocol.setString(1, serviceId);
                pss.stm_insServiceProtocol.setString(2, (String) iterS.next());
                pss.stm_insServiceProtocol.addBatch();
                executeProtocolsBatch = true;
            }
            iterS = service.getAllOntologies();
            while (iterS.hasNext()) {
                pss.stm_insServiceOntology.setString(1, serviceId);
                pss.stm_insServiceOntology.setString(2, (String) iterS.next());
                pss.stm_insServiceOntology.addBatch();
                executeOntologiesBatch = true;
            }
            iterS = service.getAllLanguages();
            while (iterS.hasNext()) {
                pss.stm_insServiceLanguage.setString(1, serviceId);
                pss.stm_insServiceLanguage.setString(2, (String) iterS.next());
                pss.stm_insServiceLanguage.addBatch();
                executeLanguagesBatch = true;
            }
            iterS = service.getAllProperties();
            while (iterS.hasNext()) {
                Property prop = (Property) iterS.next();
                try {
                    pss.stm_insServiceProperty.setString(1, serviceId);
                    pss.stm_insServiceProperty.setString(2, prop.getName());
                    Object value = prop.getValue();
                    if (needSerialization(value)) {
                        String valueStr = serializeObj(value);
                        pss.stm_insServiceProperty.setString(3, valueStr);
                        pss.stm_insServiceProperty.setString(4, null);
                        String hashStr = getHashValue(value);
                        pss.stm_insServiceProperty.setString(5, hashStr);
                    } else {
                        pss.stm_insServiceProperty.setString(3, null);
                        pss.stm_insServiceProperty.setString(4, (String) value);
                        pss.stm_insServiceProperty.setString(5, null);
                    }
                    ;
                    pss.stm_insServiceProperty.addBatch();
                    executePropertiesBatch = true;
                } catch (Exception e) {
                    if (logger.isLoggable(Logger.SEVERE))
                        logger.log(Logger.SEVERE, "Cannot serialize property '" + prop.getName() + "' for service '" + service.getName() + "'", e);
                }
            }
        }
        pss.stm_insService.executeBatch();
        if (executeProtocolsBatch) {
            pss.stm_insServiceProtocol.executeBatch();
        }
        if (executeOntologiesBatch) {
            pss.stm_insServiceOntology.executeBatch();
        }
        if (executeLanguagesBatch) {
            pss.stm_insServiceLanguage.executeBatch();
        }
        if (executePropertiesBatch) {
            pss.stm_insServiceProperty.executeBatch();
        }
    }
}

######


private static final boolean needSerialization(Object value) {
    return !((value instanceof String) && (((String) value).length() <= MAX_PROP_LENGTH));
}

######


protected Object insertSingle(Object name, Object fact) throws SQLException {
    DFAgentDescription dfd = (DFAgentDescription) fact;
    AID agentAID = dfd.getName();
    String agentName = agentAID.getName();
    DFAgentDescription dfdToReturn = null;
    String batchErrMsg = "";
    Connection conn = getConnectionWrapper().getConnection();
    PreparedStatements pss = getPreparedStatements();
    try {
        dfdToReturn = (DFAgentDescription) removeSingle(dfd.getName());
        Date leaseTime = dfd.getLeaseTime();
        long lt = (leaseTime != null ? leaseTime.getTime() : -1);
        String descrId = getGUID();
        pss.stm_insAgentDescr.setString(1, descrId);
        pss.stm_insAgentDescr.setString(2, agentName);
        pss.stm_insAgentDescr.setString(3, String.valueOf(lt));
        pss.stm_insAgentDescr.executeUpdate();
        saveAID(agentAID);
        Iterator iter = dfd.getAllLanguages();
        if (iter.hasNext()) {
            pss.stm_insLanguage.clearBatch();
            while (iter.hasNext()) {
                pss.stm_insLanguage.setString(1, descrId);
                pss.stm_insLanguage.setString(2, (String) iter.next());
                pss.stm_insLanguage.addBatch();
            }
            pss.stm_insLanguage.executeBatch();
        }
        iter = dfd.getAllOntologies();
        if (iter.hasNext()) {
            pss.stm_insOntology.clearBatch();
            while (iter.hasNext()) {
                pss.stm_insOntology.setString(1, descrId);
                pss.stm_insOntology.setString(2, (String) iter.next());
                pss.stm_insOntology.addBatch();
            }
            pss.stm_insOntology.executeBatch();
        }
        iter = dfd.getAllProtocols();
        if (iter.hasNext()) {
            pss.stm_insProtocol.clearBatch();
            while (iter.hasNext()) {
                pss.stm_insProtocol.setString(1, descrId);
                pss.stm_insProtocol.setString(2, (String) iter.next());
                pss.stm_insProtocol.addBatch();
            }
            pss.stm_insProtocol.executeBatch();
        }
        saveServices(descrId, dfd.getAllServices());
        regsCnt++;
        if (regsCnt > MAX_REGISTER_WITHOUT_CLEAN) {
            regsCnt = 0;
            clean();
        }
        conn.commit();
    } catch (SQLException sqle) {
        try {
            conn.rollback();
        } catch (SQLException se) {
            logger.log(Logger.SEVERE, "Rollback for incomplete insertion of DFD for agent " + dfd.getName() + " failed.", se);
        }
        throw sqle;
    }
    return dfdToReturn;
}

######


protected Object removeSingle(Object name) throws SQLException {
    AID agentAID = (AID) name;
    String n = agentAID.getName();
    DFAgentDescription dfd = getDFD(n);
    if (dfd != null) {
        remove(n);
    }
    return dfd;
}

######


protected List searchSingle(Object template, int maxResult) throws SQLException {
    List matchingAIDs = new ArrayList();
    String select = null;
    ResultSet rs = null;
    Statement s = null;
    try {
        select = createSelect((DFAgentDescription) template);
        s = getConnectionWrapper().getConnection().createStatement();
        if (maxResult >= 0) {
            s.setMaxRows(maxResult);
            s.setFetchSize(maxResult);
        }
        rs = s.executeQuery(select);
        while (rs.next()) {
            String aidS = rs.getString("aid");
            matchingAIDs.add(aidS);
        }
    } catch (SQLException sqle) {
        throw sqle;
    } catch (Exception e) {
        logger.log(Logger.SEVERE, "Couldn't create the SQL SELECT statement.", e);
        throw new SQLException("Couldn't create the SQL SELECT statement. " + e.getMessage());
    } finally {
        closeResultSet(rs);
        closeStatement(s);
    }
    List dfds = new ArrayList(matchingAIDs.size());
    Iterator it = matchingAIDs.iterator();
    if (matchingAIDs.size() < 10) {
        while (it.hasNext()) {
            dfds.add(getDFD((String) it.next()));
        }
    } else {
        PreparedStatements pss = getPreparedStatements();
        Map allLanguages = preloadIdValueTable(pss.stm_selCountAllLanguages, pss.stm_selAllLanguages);
        Map allOntologies = preloadIdValueTable(pss.stm_selCountAllOntologies, pss.stm_selAllOntologies);
        Map allProtocols = preloadIdValueTable(pss.stm_selCountAllProtocols, pss.stm_selAllProtocols);
        while (it.hasNext()) {
            dfds.add(getDFD((String) it.next(), allLanguages, allOntologies, allProtocols));
        }
    }
    return dfds;
}

######


private Map preloadIdValueTable(PreparedStatement cntStm, PreparedStatement stm) throws SQLException {
    Map m = null;
    ResultSet rs = cntStm.executeQuery();
    rs.next();
    long recordCount = rs.getLong(1);
    closeResultSet(rs);
    if (recordCount < MAX_PRELOAD_CNT) {
        rs = stm.executeQuery();
        if (true) {
            m = new HashMap();
            String currentId = null;
            List l = null;
            while (rs.next()) {
                String id = rs.getString(1);
                if (!id.equals(currentId)) {
                    l = new ArrayList();
                    m.put(id, l);
                    currentId = id;
                }
                l.add(rs.getString(2));
            }
            closeResultSet(rs);
        }
    }
    return m;
}

######


protected KBIterator iteratorSingle(Object template) throws SQLException {
    String select = null;
    ResultSet rs = null;
    Statement s = null;
    try {
        select = createSelect((DFAgentDescription) template);
        s = getConnectionWrapper().getConnection().createStatement();
        rs = s.executeQuery(select);
        return new DFDBKBIterator(s, rs);
    } catch (SQLException se) {
        logger.log(Logger.SEVERE, "Error accessing DB: " + select, se);
        closeResultSet(rs);
        closeStatement(s);
        throw se;
    } catch (Exception e) {
        logger.log(Logger.SEVERE, "Error creating SQL SELECT statement.", e);
        throw new SQLException("Error creating SQL SELECT statement. " + e.getMessage());
    }
}

######


public boolean hasNext() {
    return hasMoreElements;
}

######


public Object next() {
    if (hasMoreElements) {
        try {
            String name = rs.getString("aid");
            DFAgentDescription dfd = getDFD(name);
            hasMoreElements = rs.next();
            return dfd;
        } catch (SQLException sqle) {
            hasMoreElements = false;
            throw new NoSuchElementException("DB Error. " + sqle.getMessage());
        }
    }
    throw new NoSuchElementException("");
}

######


public void remove() {
}

######


public void close() {
    closeResultSet(rs);
    closeStatement(s);
}

######


private AID getAID(String aidN) throws SQLException {
    ResultSet rs = null;
    AID id = new AID(aidN, AID.ISGUID);
    PreparedStatements pss = getPreparedStatements();
    pss.stm_selAgentAddresses.setString(1, aidN);
    rs = pss.stm_selAgentAddresses.executeQuery();
    while (rs.next()) {
        id.addAddresses(rs.getString(1));
    }
    Collection resolvers = getResolverAIDs(aidN);
    Iterator iter = resolvers.iterator();
    while (iter.hasNext()) {
        id.addResolvers(getAID((String) iter.next()));
    }
    pss.stm_selAgentUserDefSlot.setString(1, aidN);
    rs = pss.stm_selAgentUserDefSlot.executeQuery();
    while (rs.next()) {
        String key = rs.getString("slotkey");
        String value = rs.getString("slotval");
        id.addUserDefinedSlot(key, value);
    }
    return id;
}

######


private DFAgentDescription getDFD(String aidN) throws SQLException {
    return getDFD(aidN, null, null, null);
}

######


private DFAgentDescription getDFD(String aidN, Map allLanguages, Map allOntologies, Map allProtocols) throws SQLException {
    DFAgentDescription dfd = null;
    AID id = null;
    ResultSet rs = null;
    ResultSet rsS = null;
    String descrId = null;
    try {
        PreparedStatements pss = getPreparedStatements();
        pss.stm_selLease.setString(1, aidN);
        rs = pss.stm_selLease.executeQuery();
        if (rs.next()) {
            dfd = new DFAgentDescription();
            id = getAID(aidN);
            dfd.setName(id);
            String sLease = rs.getString("lease");
            descrId = rs.getString("id");
            long lease = Long.parseLong(sLease);
            if (lease != -1) {
                dfd.setLeaseTime(new Date(lease));
            }
        } else {
            return null;
        }
        closeResultSet(rs);
        loadProtocols(descrId, dfd, allProtocols);
        loadLanguages(descrId, dfd, allLanguages);
        loadOntologies(descrId, dfd, allOntologies);
        pss.stm_selServices.setString(1, descrId);
        rs = pss.stm_selServices.executeQuery();
        while (rs.next()) {
            ServiceDescription sd = new ServiceDescription();
            String serviceId = rs.getString("id");
            sd.setName(rs.getString("sname"));
            sd.setType(rs.getString("stype"));
            sd.setOwnership(rs.getString("sownership"));
            pss.stm_selServiceProtocols.setString(1, serviceId);
            rsS = pss.stm_selServiceProtocols.executeQuery();
            while (rsS.next()) {
                sd.addProtocols(rsS.getString(PROTOCOL));
            }
            closeResultSet(rsS);
            pss.stm_selServiceLanguages.setString(1, serviceId);
            rsS = pss.stm_selServiceLanguages.executeQuery();
            while (rsS.next()) {
                sd.addOntologies(rsS.getString(ONTOLOGY));
            }
            closeResultSet(rsS);
            pss.stm_selServiceOntologies.setString(1, serviceId);
            rsS = pss.stm_selServiceOntologies.executeQuery();
            while (rsS.next()) {
                sd.addLanguages(rsS.getString(LANGUAGE));
            }
            closeResultSet(rsS);
            pss.stm_selServiceProperties.setString(1, serviceId);
            rsS = pss.stm_selServiceProperties.executeQuery();
            while (rsS.next()) {
                Property prop = new Property();
                prop.setName(rsS.getString("propkey"));
                String objStrVal = rsS.getString("propval_obj");
                String strStrVal = rsS.getString("propval_str");
                Object value = (objStrVal == null) ? strStrVal : deserializeObj(objStrVal);
                prop.setValue(value);
                sd.addProperties(prop);
            }
            dfd.addServices(sd);
        }
    } catch (SQLException sqle) {
        throw sqle;
    } catch (Exception e) {
        logger.log(Logger.SEVERE, "Unexpected error retrieving DFD for agent " + aidN, e);
        throw new SQLException("Unexpected error retrieving DFD for agent " + aidN + ". " + e.getMessage());
    } finally {
        closeResultSet(rs);
        closeResultSet(rsS);
    }
    return dfd;
}

######


private final void loadOntologies(String descrId, DFAgentDescription dfd, Map allOntologies) throws SQLException {
    if (allOntologies != null) {
        List ontos = (List) allOntologies.get(descrId);
        if (ontos != null) {
            Iterator it = ontos.iterator();
            while (it.hasNext()) {
                dfd.addOntologies((String) it.next());
            }
        }
    } else {
        PreparedStatements pss = getPreparedStatements();
        pss.stm_selOntologies.setString(1, descrId);
        ResultSet rs = pss.stm_selOntologies.executeQuery();
        while (rs.next()) {
            dfd.addOntologies(rs.getString(ONTOLOGY));
        }
        closeResultSet(rs);
    }
}

######


private final void loadLanguages(String descrId, DFAgentDescription dfd, Map allLanguages) throws SQLException {
    if (allLanguages != null) {
        List langs = (List) allLanguages.get(descrId);
        if (langs != null) {
            Iterator it = langs.iterator();
            while (it.hasNext()) {
                dfd.addLanguages((String) it.next());
            }
        }
    } else {
        PreparedStatements pss = getPreparedStatements();
        pss.stm_selLanguages.setString(1, descrId);
        ResultSet rs = pss.stm_selLanguages.executeQuery();
        while (rs.next()) {
            dfd.addLanguages(rs.getString(LANGUAGE));
        }
        closeResultSet(rs);
    }
}

######


private final void loadProtocols(String descrId, DFAgentDescription dfd, Map allProtocols) throws SQLException {
    if (allProtocols != null) {
        List protos = (List) allProtocols.get(descrId);
        if (protos != null) {
            Iterator it = protos.iterator();
            while (it.hasNext()) {
                dfd.addProtocols((String) it.next());
            }
        }
    } else {
        PreparedStatements pss = getPreparedStatements();
        pss.stm_selProtocols.setString(1, descrId);
        ResultSet rs = pss.stm_selProtocols.executeQuery();
        while (rs.next()) {
            dfd.addProtocols(rs.getString(PROTOCOL));
        }
        closeResultSet(rs);
    }
}

######


private void removeAID(String aid) throws SQLException {
    PreparedStatements pss = getPreparedStatements();
    pss.stm_selNrOfDescrForAID.setString(1, aid);
    ResultSet rs = pss.stm_selNrOfDescrForAID.executeQuery();
    int found = 0;
    if (rs.next())
        found = Integer.parseInt(rs.getString(1));
    if (found == 0) {
        pss.stm_delAgentUserDefSlot.setString(1, aid);
        pss.stm_delAgentUserDefSlot.execute();
        Collection resolverAIDs = getResolverAIDs(aid);
        Iterator iter = resolverAIDs.iterator();
        while (iter.hasNext()) {
            removeAID((String) iter.next());
        }
        pss.stm_delAgentResolver.setString(1, aid);
        pss.stm_delAgentResolver.execute();
        pss.stm_delAgentAddress.setString(1, aid);
        pss.stm_delAgentAddress.execute();
    }
}

######


private void removeServices(String descrId) throws SQLException {
    ResultSet rs = null;
    PreparedStatements pss = getPreparedStatements();
    pss.stm_selServiceId.setString(1, descrId);
    rs = pss.stm_selServiceId.executeQuery();
    boolean executeBatch = false;
    while (rs.next()) {
        String serviceId = rs.getString("id");
        pss.stm_delServiceLanguage.setString(1, serviceId);
        pss.stm_delServiceLanguage.addBatch();
        pss.stm_delServiceOntology.setString(1, serviceId);
        pss.stm_delServiceOntology.addBatch();
        pss.stm_delServiceProtocol.setString(1, serviceId);
        pss.stm_delServiceProtocol.addBatch();
        pss.stm_delServiceProperty.setString(1, serviceId);
        pss.stm_delServiceProperty.addBatch();
        pss.stm_delService.setString(1, descrId);
        pss.stm_delService.addBatch();
        executeBatch = true;
    }
    rs.close();
    if (executeBatch) {
        pss.stm_delServiceLanguage.executeBatch();
        pss.stm_delServiceOntology.executeBatch();
        pss.stm_delServiceProtocol.executeBatch();
        pss.stm_delServiceProperty.executeBatch();
        pss.stm_delService.executeBatch();
    }
}

######


private void remove(String aid) throws SQLException {
    ResultSet rs = null;
    Connection conn = getConnectionWrapper().getConnection();
    try {
        PreparedStatements pss = getPreparedStatements();
        pss.stm_selDescrId.setString(1, aid);
        rs = pss.stm_selDescrId.executeQuery();
        if (rs.next()) {
            String descrId = rs.getString("id");
            closeResultSet(rs);
            pss.stm_delOntology.setString(1, descrId);
            pss.stm_delOntology.execute();
            pss.stm_delProtocol.setString(1, descrId);
            pss.stm_delProtocol.execute();
            pss.stm_delLanguage.setString(1, descrId);
            pss.stm_delLanguage.execute();
            removeServices(descrId);
            pss.stm_delAgentDescr.setString(1, descrId);
            pss.stm_delAgentDescr.execute();
            removeAID(aid);
            conn.commit();
        } else {
            if (logger.isLoggable(Logger.FINE))
                logger.log(Logger.FINE, "No DF description found to remove for agent '" + aid + "'");
        }
    } catch (SQLException sqle) {
        try {
            conn.rollback();
        } catch (SQLException se) {
            logger.log(Logger.SEVERE, "Rollback for incomplete remotion of DFD for agent " + aid + " failed.", se);
        }
        throw sqle;
    } finally {
        closeResultSet(rs);
    }
}

######


private String createSelect(DFAgentDescription dfdTemplate) throws Exception {
    StringBuffer select = new StringBuffer("SELECT dfagentdescr.aid FROM dfagentdescr");
    List lAs = new ArrayList();
    List lWhere = new ArrayList();
    AID agentAID = dfdTemplate.getName();
    if (agentAID != null) {
        lWhere.add(" dfagentdescr.aid = '" + agentAID.getName() + "'");
    }
    Date lease = dfdTemplate.getLeaseTime();
    long currTime = System.currentTimeMillis();
    lWhere.add(" (dfagentdescr.lease = '-1' OR dfagentdescr.lease > '" + currTime + "')");
    Iterator iter = dfdTemplate.getAllLanguages();
    int i = 0;
    while (iter.hasNext()) {
        String tmp = LANGUAGE + i;
        lAs.add(", language " + tmp);
        lWhere.add(tmp + ".language='" + (String) iter.next() + "'");
        lWhere.add(tmp + ".descrid=dfagentdescr.id");
        i++;
    }
    iter = dfdTemplate.getAllOntologies();
    i = 0;
    while (iter.hasNext()) {
        String tmp = ONTOLOGY + i;
        lAs.add(", ontology " + tmp);
        lWhere.add(tmp + ".ontology='" + (String) iter.next() + "'");
        lWhere.add(tmp + ".descrid=dfagentdescr.id");
        i++;
    }
    iter = dfdTemplate.getAllProtocols();
    i = 0;
    while (iter.hasNext()) {
        String tmp = PROTOCOL + i;
        lAs.add(", protocol " + tmp);
        lWhere.add(tmp + ".protocol='" + (String) iter.next() + "'");
        lWhere.add(tmp + ".descrid=dfagentdescr.id");
        i++;
    }
    iter = dfdTemplate.getAllServices();
    i = 0;
    while (iter.hasNext()) {
        ServiceDescription service = (ServiceDescription) iter.next();
        String serviceName = service.getName();
        String serviceType = service.getType();
        String serviceOwner = service.getOwnership();
        String tmp = SERVICE + i;
        lAs.add(", service " + tmp);
        if (serviceName != null) {
            lWhere.add(tmp + ".sname='" + serviceName + "'");
        }
        if (serviceType != null) {
            lWhere.add(tmp + ".stype='" + serviceType + "'");
        }
        if (serviceOwner != null) {
            lWhere.add(tmp + ".sownership='" + serviceOwner + "'");
        }
        lWhere.add(tmp + ".descrid=dfagentdescr.id");
        i++;
        Iterator iterS = service.getAllLanguages();
        int j = 0;
        while (iterS.hasNext()) {
            String tmp1 = SERVICELANGUAGE + j;
            lAs.add(", servicelanguage " + tmp1);
            lWhere.add(tmp1 + ".language='" + (String) iterS.next() + "'");
            lWhere.add(tmp1 + ".serviceid=" + tmp + ".id");
            j++;
        }
        iterS = service.getAllOntologies();
        j = 0;
        while (iterS.hasNext()) {
            String tmp1 = SERVICEONTOLOGY + j;
            lAs.add(", serviceontology " + tmp1);
            lWhere.add(tmp1 + ".ontology='" + (String) iterS.next() + "'");
            lWhere.add(tmp1 + ".serviceid=" + tmp + ".id");
            j++;
        }
        iterS = service.getAllProtocols();
        j = 0;
        while (iterS.hasNext()) {
            String tmp1 = SERVICEPROTOCOL + j;
            lAs.add(", serviceprotocol " + tmp1);
            lWhere.add(tmp1 + ".protocol='" + (String) iterS.next() + "'");
            lWhere.add(tmp1 + ".serviceid=" + tmp + ".id");
            j++;
        }
        iterS = service.getAllProperties();
        j = 0;
        while (iterS.hasNext()) {
            String tmp1 = SERVICEPROPERTY + j;
            lAs.add(", serviceproperty " + tmp1);
            Property prop = (Property) iterS.next();
            if (prop.getName() != null)
                lWhere.add(tmp1 + ".propkey='" + prop.getName() + "'");
            Object value = prop.getValue();
            if (value != null) {
                if (needSerialization(value)) {
                    String hashStr = getHashValue(prop.getValue());
                    lWhere.add(tmp1 + ".propvalhash='" + hashStr + "'");
                } else {
                    lWhere.add(tmp1 + ".propval_str='" + value + "'");
                }
            }
            lWhere.add(tmp1 + ".serviceid=" + tmp + ".id");
            j++;
        }
    }
    iter = lAs.iterator();
    while (iter.hasNext()) {
        select.append((String) iter.next());
    }
    if (lWhere.size() > 0) {
        select.append(" WHERE ");
    }
    iter = lWhere.iterator();
    i = 0;
    while (iter.hasNext()) {
        if (i > 0) {
            select.append(" and ");
        }
        select.append((String) iter.next());
        ++i;
    }
    return select.toString();
}

######


private void clean() {
    cleanExpiredRegistrations();
    cleanExpiredSubscriptions();
}

######


private void cleanExpiredRegistrations() {
    ResultSet rs = null;
    long currTime = System.currentTimeMillis();
    try {
        PreparedStatements pss = getPreparedStatements();
        pss.stm_selExpiredDescr.setString(1, String.valueOf(currTime));
        rs = pss.stm_selExpiredDescr.executeQuery();
        while (rs.next()) {
            remove(rs.getString("aid"));
        }
    } catch (SQLException se) {
        if (logger.isLoggable(Logger.WARNING))
            logger.log(Logger.WARNING, "Error cleaning expired DF registrations", se);
    } finally {
        closeResultSet(rs);
    }
}

######


private void cleanExpiredSubscriptions() {
}

######


protected void subscribeSingle(Object dfd, SubscriptionResponder.Subscription s) throws SQLException, NotUnderstoodException {
    ACLMessage aclM = s.getMessage();
    String msgStr = aclM.toString();
    String convID = aclM.getConversationId();
    registerSubscription(convID, msgStr);
}

######


private void registerSubscription(String convID, String aclM) throws SQLException {
    Connection conn = getConnectionWrapper().getConnection();
    try {
        PreparedStatements pss = getPreparedStatements();
        String base64Str = new String(Base64.encodeBase64(aclM.getBytes("US-ASCII")), "US-ASCII");
        pss.stm_insSubscription.setString(1, convID);
        pss.stm_insSubscription.setString(2, base64Str);
        pss.stm_insSubscription.execute();
        conn.commit();
    } catch (SQLException sqle) {
        try {
            conn.rollback();
        } catch (SQLException se) {
            logger.log(Logger.SEVERE, "Rollback for incomplete subscription failed.", se);
        }
        throw sqle;
    } catch (Exception e) {
        logger.log(Logger.SEVERE, "Error encoding subscription message in Base64.", e);
        throw new SQLException("Error encoding subscription message in Base64. " + e.getMessage());
    }
}

######


public Enumeration getSubscriptions() {
    Vector subscriptions = new Vector();
    StringACLCodec codec = new StringACLCodec();
    ResultSet rs = null;
    try {
        rs = getPreparedStatements().stm_selSubscriptions.executeQuery();
        while (rs.next()) {
            String base64Str = rs.getString("aclm");
            String aclmStr = new String(Base64.decodeBase64(base64Str.getBytes("US-ASCII")), "US-ASCII");
            ACLMessage aclm = codec.decode(aclmStr.getBytes(), ACLCodec.DEFAULT_CHARSET);
            subscriptions.add(sr.createSubscription(aclm));
        }
    } catch (Exception e) {
        if (logger.isLoggable(Logger.SEVERE))
            logger.log(Logger.SEVERE, "Error retrieving subscriptions from the database", e);
    } finally {
        closeResultSet(rs);
    }
    return subscriptions.elements();
}

######


protected void unsubscribeSingle(SubscriptionResponder.Subscription sub) throws SQLException {
    ACLMessage aclM = sub.getMessage();
    String convID = aclM.getConversationId();
    boolean deleted = deregisterSubscription(convID);
    if (!deleted)
        if (logger.isLoggable(Logger.WARNING))
            logger.log(Logger.WARNING, "No subscription to delete.");
}

######


private boolean deregisterSubscription(String convID) throws SQLException {
    Connection conn = getConnectionWrapper().getConnection();
    try {
        PreparedStatements pss = getPreparedStatements();
        pss.stm_delSubscription.setString(1, convID);
        int rowCount = pss.stm_delSubscription.executeUpdate();
        conn.commit();
        return (rowCount != 0);
    } catch (SQLException sqle) {
        try {
            conn.rollback();
        } catch (SQLException se) {
            logger.log(Logger.SEVERE, "Rollback for incomplete un-subscription failed.", se);
        }
        throw sqle;
    }
}

######


private void closeResultSet(ResultSet rs) {
    try {
        if (rs != null) {
            rs.close();
            rs = null;
        }
    } catch (SQLException e) {
    }
}

######


private void closeStatement(Statement s) {
    try {
        if (s != null) {
            s.close();
            s = null;
        }
    } catch (Exception e) {
        if (logger.isLoggable(Logger.WARNING))
            logger.log(Logger.WARNING, "Closing SQL statement failed.");
    }
}

######


private String serializeObj(Object obj) throws IOException {
    if (obj == null)
        return null;
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(baos);
    oos.writeObject(obj);
    oos.close();
    byte[] data = baos.toByteArray();
    return new String(Base64.encodeBase64(data), "US-ASCII");
}

######


private Object deserializeObj(String str) throws IOException, ClassNotFoundException {
    if (str == null)
        return null;
    byte[] data = Base64.decodeBase64(str.getBytes("US-ASCII"));
    ByteArrayInputStream bais = new ByteArrayInputStream(data);
    ObjectInputStream ois = new ObjectInputStream(bais);
    return ois.readObject();
}

######


protected String getHashValue(Object obj) throws Exception {
    final String HASH_ALGORITHM = "MD5";
    if (obj == null)
        return "null";
    try {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(obj);
        oos.close();
        byte[] data = baos.toByteArray();
        MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);
        byte[] digest = md.digest(data);
        return new String(Base64.encodeBase64(digest), "US-ASCII");
    } catch (Exception e) {
        throw new Exception("Couldn't create " + HASH_ALGORITHM + " hash for given object.", e);
    }
}

######


protected String prepDBStr(String s) {
    if (s == null) {
        return "";
    }
    String result = replace(s, "'", "''");
    result = replace(result, "\"", "\"\"");
    return result;
}

######


protected String replace(String str, String pattern, String replaceWith) {
    int s = 0;
    int e = 0;
    StringBuffer result = new StringBuffer();
    while ((e = str.indexOf(pattern, s)) >= 0) {
        result.append(str.substring(s, e));
        if (replaceWith != null)
            result.append(replaceWith);
        s = e + pattern.length();
    }
    result.append(str.substring(s));
    return result.toString();
}

######


public Long getId() {
    return id;
}

######


public void setId(Long id) {
    this.id = id;
}

######


public String getNomorDipa() {
    return nomorDipa;
}

######


public void setNomorDipa(String nomorDipa) {
    this.nomorDipa = nomorDipa;
}

######


public String getPagu() {
    return pagu;
}

######


public void setPagu(String pagu) {
    this.pagu = pagu;
}

######


public String getRealisasi() {
    return realisasi;
}

######


public void setRealisasi(String realisasi) {
    this.realisasi = realisasi;
}

######


public String getSisaDana() {
    return sisaDana;
}

######


public void setSisaDana() {
    BigInteger iPagu = new BigInteger(this.pagu);
    BigInteger iRealisasi = new BigInteger(this.realisasi);
    BigInteger iSisa = iPagu.subtract(iRealisasi);
    this.sisaDana = iSisa.toString();
}

######


public RincianKegiatan getRincianKegiatan() {
    return rincianKegiatan;
}

######


public void setRincianKegiatan(RincianKegiatan rincianKegiatan) {
    this.rincianKegiatan = rincianKegiatan;
}

######


@Override
public int hashCode() {
    int hash = 0;
    hash += (id != null ? id.hashCode() : 0);
    return hash;
}

######


@Override
public String toString() {
    return "apdol.entity.Dipa[ id=" + id + " ]";
}

######


public boolean isKodeNoChange(String kode) {
    if (kode.equalsIgnoreCase(this.nomorDipa)) {
        return true;
    } else {
        return false;
    }
}

######


public boolean isRincianKegiatanNoChange(RincianKegiatan rkeg) {
    if (rkeg.toString().equals(this.rincianKegiatan.toString())) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    String CREATE_DISNEYLANDLOCATIONS_TABLE = "CREATE TABLE IF NOT EXISTS " + TBL_DISNEYLANDLOCATIONS + "(" + COL_PARKID + " INTEGER PRIMARY KEY," + COL_PARKNAME + " TEXT," + COL_PARKADDRESS + " TEXT," + COL_LATITUDE + " FLOAT," + COL_LONGITUDE + " FLOAT" + ")";
    db.execSQL(CREATE_DISNEYLANDLOCATIONS_TABLE);
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    if (newVersion > oldVersion) {
        db.execSQL("DROP TABLE IF EXISTS " + TBL_DISNEYLANDLOCATIONS);
        onCreate(db);
    }
}

######


public void dbCreate() throws IOException {
    boolean dbExist = dbCheck();
    if (!dbExist) {
        this.getReadableDatabase();
        try {
            copyDBFromAssets();
        } catch (IOException e) {
            throw new Error("Error copying database");
        }
    }
}

######


private boolean dbCheck() {
    SQLiteDatabase db = null;
    try {
        String dbPath = DB_PATH + DB_NAME;
        db = SQLiteDatabase.openDatabase(dbPath, null, SQLiteDatabase.OPEN_READONLY);
        db.setLocale(Locale.getDefault());
        db.setVersion(1);
    } catch (SQLiteException e) {
        Log.e("SQLHelper", "Database not Found!");
    }
    if (db != null) {
        db.close();
    }
    return db != null ? true : false;
}

######


private void copyDBFromAssets() throws IOException {
    InputStream dbInput = null;
    OutputStream dbOutput = null;
    String dbFileName = DB_PATH + DB_NAME;
    try {
        dbInput = appContext.getAssets().open(DB_NAME);
        dbOutput = new FileOutputStream(dbFileName);
        byte[] buffer = new byte[1024];
        int length;
        while ((length = dbInput.read(buffer)) > 0) {
            dbOutput.write(buffer, 0, length);
        }
        dbOutput.flush();
        dbOutput.close();
        dbInput.close();
    } catch (IOException e) {
        throw new Error("Problems copying DB!");
    }
}

######


public void addaMapDisneyLandLocationsEntry(disneyMapData aMapDisneyLandLocations) {
    ContentValues values = new ContentValues();
    values.put(COL_PARKID, aMapDisneyLandLocations.getParkID());
    values.put(COL_PARKNAME, aMapDisneyLandLocations.getParkName());
    values.put(COL_PARKADDRESS, aMapDisneyLandLocations.getParkAddress());
    values.put(COL_LATITUDE, aMapDisneyLandLocations.getLatitude());
    values.put(COL_LONGITUDE, aMapDisneyLandLocations.getLongitude());
    SQLiteDatabase db = this.getWritableDatabase();
    db.insert(TBL_DISNEYLANDLOCATIONS, null, values);
    db.close();
}

######


public disneyMapData getMapDisneyLandLocationsEntry(String aMapDisneyLandLocationsEntry) {
    String query = "Select * FROM " + TBL_DISNEYLANDLOCATIONS + " WHERE " + COL_PARKID + " =  \"" + aMapDisneyLandLocationsEntry + "\"";
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor cursor = db.rawQuery(query, null);
    disneyMapData MapDataEntry = new disneyMapData();
    if (cursor.moveToFirst()) {
        cursor.moveToFirst();
        MapDataEntry.setParkID(Integer.parseInt(cursor.getString(0)));
        MapDataEntry.setParkName(cursor.getString(1));
        MapDataEntry.setParkAddress(cursor.getString(2));
        MapDataEntry.setLatitude(Float.parseFloat(cursor.getString(3)));
        MapDataEntry.setLongitude(Float.parseFloat(cursor.getString(4)));
        cursor.close();
    } else {
        MapDataEntry = null;
    }
    db.close();
    return MapDataEntry;
}

######


public List<disneyMapData> allMapData() {
    String query = "Select * FROM " + TBL_DISNEYLANDLOCATIONS;
    List<disneyMapData> disneyMapDataList = new ArrayList<disneyMapData>();
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor cursor = db.rawQuery(query, null);
    if (cursor.moveToFirst()) {
        while (cursor.isAfterLast() == false) {
            disneyMapData MapDataEntry = new disneyMapData();
            MapDataEntry.setParkID(Integer.parseInt(cursor.getString(0)));
            MapDataEntry.setParkName(cursor.getString(1));
            MapDataEntry.setParkAddress(cursor.getString(2));
            MapDataEntry.setLatitude(Float.parseFloat(cursor.getString(3)));
            MapDataEntry.setLongitude(Float.parseFloat(cursor.getString(4)));
            disneyMapDataList.add(MapDataEntry);
            cursor.moveToNext();
        }
    } else {
        disneyMapDataList.add(null);
    }
    db.close();
    return disneyMapDataList;
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("xatable", "i int", "ENGINE=InnoDB");
}

######


@Before
public void checkSupported() throws SQLException {
    requireMinimumVersion(5, 0);
}

######


private Xid newXid() {
    return new MariaDbXid(1, UUID.randomUUID().toString().getBytes(), UUID.randomUUID().toString().getBytes());
}

######


private Xid newXid(Xid branchFrom) {
    return new MariaDbXid(1, branchFrom.getGlobalTransactionId(), UUID.randomUUID().toString().getBytes());
}

######


private int test2PhaseCommit(boolean doCommit) throws Exception {
    int connectionNumber = 1;
    Xid parentXid = newXid();
    Connection[] connections = new Connection[connectionNumber];
    XAConnection[] xaConnections = new XAConnection[connectionNumber];
    XAResource[] xaResources = new XAResource[connectionNumber];
    Xid[] xids = new Xid[connectionNumber];
    try {
        for (int i = 0; i < connectionNumber; i++) {
            xaConnections[i] = dataSource.getXAConnection();
            connections[i] = xaConnections[i].getConnection();
            xaResources[i] = xaConnections[i].getXAResource();
            xids[i] = newXid(parentXid);
        }
        startAllResources(connectionNumber, xaResources, xids);
        insertDatas(connectionNumber, connections);
        endAllResources(connectionNumber, xaResources, xids);
        prepareAllResources(connectionNumber, xaResources, xids);
        for (int i = 0; i < connectionNumber; i++) {
            if (doCommit) {
                xaResources[i].commit(xids[i], false);
            } else {
                xaResources[i].rollback(xids[i]);
            }
        }
    } finally {
        for (int i = 0; i < connectionNumber; i++) {
            try {
                if (xaConnections[i] != null) {
                    xaConnections[i].close();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    return connectionNumber;
}

######


private void startAllResources(int connectionNumber, XAResource[] xaResources, Xid[] xids) throws XAException {
    for (int i = 0; i < connectionNumber; i++) {
        xaResources[i].start(xids[i], XAResource.TMNOFLAGS);
    }
}

######


private void endAllResources(int connectionNumber, XAResource[] xaResources, Xid[] xids) throws XAException {
    for (int i = 0; i < connectionNumber; i++) {
        xaResources[i].end(xids[i], XAResource.TMSUCCESS);
    }
}

######


private void prepareAllResources(int connectionNumber, XAResource[] xaResources, Xid[] xids) throws XAException {
    for (int i = 0; i < connectionNumber; i++) {
        xaResources[i].prepare(xids[i]);
    }
}

######


private void insertDatas(int connectionNumber, Connection[] connections) throws SQLException {
    for (int i = 0; i < connectionNumber; i++) {
        connections[i].createStatement().executeUpdate("INSERT INTO xatable VALUES (" + i + ")");
    }
}

######


@Test
public void testCommit() throws Exception {
    int connectionNumber = test2PhaseCommit(true);
    try (ResultSet rs = sharedConnection.createStatement().executeQuery("SELECT * from xatable order by i")) {
        for (int i = 0; i < connectionNumber; i++) {
            assertTrue(rs.next());
            assertEquals(rs.getInt(1), i);
        }
    }
}

######


@Test
public void testRollback() throws Exception {
    test2PhaseCommit(false);
    try (ResultSet rs = sharedConnection.createStatement().executeQuery("SELECT * from xatable order by i")) {
        assertFalse(rs.next());
    }
}

######


@Test
public void testRecover() throws Exception {
    XAConnection xaConnection = dataSource.getXAConnection();
    try {
        Connection connection = xaConnection.getConnection();
        Xid xid = newXid();
        XAResource xaResource = xaConnection.getXAResource();
        xaResource.start(xid, XAResource.TMNOFLAGS);
        connection.createStatement().executeQuery("SELECT 1");
        xaResource.end(xid, XAResource.TMSUCCESS);
        xaResource.prepare(xid);
        Xid[] recoveredXids = xaResource.recover(XAResource.TMSTARTRSCAN | XAResource.TMENDRSCAN);
        assertTrue(recoveredXids != null);
        assertTrue(recoveredXids.length > 0);
        boolean found = false;
        for (Xid x : recoveredXids) {
            if (x != null && x.equals(xid)) {
                found = true;
                break;
            }
        }
        assertTrue(found);
    } finally {
        xaConnection.close();
    }
}

######


@Test
public void resumeAndJoinTest() throws Exception {
    Connection conn1;
    MariaDbDataSource ds = new MariaDbDataSource();
    ds.setUrl(connU);
    ds.setDatabaseName(database);
    ds.setUser(username);
    ds.setPassword(password);
    ds.setPort(port);
    XAConnection xaConn1 = null;
    Xid xid = newXid();
    try {
        xaConn1 = ds.getXAConnection();
        XAResource xaRes1 = xaConn1.getXAResource();
        conn1 = xaConn1.getConnection();
        xaRes1.start(xid, XAResource.TMNOFLAGS);
        conn1.createStatement().executeQuery("SELECT 1");
        xaRes1.end(xid, XAResource.TMSUCCESS);
        xaRes1.start(xid, XAResource.TMRESUME);
        conn1.createStatement().executeQuery("SELECT 1");
        xaRes1.end(xid, XAResource.TMSUCCESS);
        xaRes1.commit(xid, true);
        xaConn1.close();
        xaConn1 = ds.getXAConnection();
        xaRes1 = xaConn1.getXAResource();
        conn1 = xaConn1.getConnection();
        xaRes1.start(xid, XAResource.TMNOFLAGS);
        conn1.createStatement().executeQuery("SELECT 1");
        xaRes1.end(xid, XAResource.TMSUCCESS);
        try {
            xaRes1.start(xid, XAResource.TMJOIN);
            fail();
        } catch (XAException xaex) {
            xaConn1.close();
        }
        xid = newXid();
        ds.setUrl(connU + "?pinGlobalTxToPhysicalConnection=true");
        xaConn1 = ds.getXAConnection();
        xaRes1 = xaConn1.getXAResource();
        conn1 = xaConn1.getConnection();
        xaRes1.start(xid, XAResource.TMNOFLAGS);
        conn1.createStatement().executeQuery("SELECT 1");
        xaRes1.end(xid, XAResource.TMSUCCESS);
        xaRes1.start(xid, XAResource.TMJOIN);
        conn1.createStatement().executeQuery("SELECT 1");
        xaRes1.end(xid, XAResource.TMSUCCESS);
        xaRes1.commit(xid, true);
    } finally {
        if (xaConn1 != null) {
            xaConn1.close();
        }
    }
}

######


public List<HospitalModel> getHospitalByDistrict(DistrictModel districtModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM HospitalModel e WHERE e.districtModel = :districtModel ORDER BY e.hospitalName");
    query.setParameter("districtModel", districtModel);
    return query.getResultList();
}

######


public List<HospitalPoliclinicRelModel> getPoliclinicByDistrict(DistrictModel districtModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM HospitalPoliclinicRelModel e WHERE e.hospital.districtModel = :districtModel ORDER BY e.policlinic.policlinicName");
    query.setParameter("districtModel", districtModel);
    return query.getResultList();
}

######


public DoctorModel loginDoctor(DoctorModel doctorModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM DoctorModel e WHERE e.recordNumber = :RECORD_NUMBER AND e.password = :PASSWORD");
    query.setParameter("RECORD_NUMBER", doctorModel.getRecordNumber());
    query.setParameter("PASSWORD", Encryptor.encrypt(doctorModel.getPassword()));
    if (query.getResultList().size() > 0) {
        return (DoctorModel) query.getResultList().get(0);
    } else {
        return null;
    }
}

######


public List<AppointmentModel> getAppointmentHistoryByDoctor(DoctorModel doctorModel) {
    List<AppointmentStatusEnum> appointmentStatusEnums = Arrays.asList(AppointmentStatusEnum.COMPLETED, AppointmentStatusEnum.RESERVED);
    Query query = getEntitymanager().createQuery("SELECT e FROM AppointmentModel e WHERE e.inspectionPlace.doctor = :DOCTOR AND e.appointmentStatus IN :APPOINTMENT_STATUS AND e.patient IS NOT NULL ORDER BY e.appointmentDate DESC");
    query.setParameter("DOCTOR", doctorModel);
    query.setParameter("APPOINTMENT_STATUS", appointmentStatusEnums);
    return query.getResultList();
}

######


public long remainingAppointment(DoctorModel doctorModel) {
    Query query = getEntitymanager().createQuery("SELECT COUNT (e) FROM AppointmentModel e WHERE e.inspectionPlace.doctor = :DOCTOR AND e.appointmentStatus = :APPOINTMENT_STATUS AND e.appointmentDate BETWEEN :NOW AND :END_OF_DAY");
    query.setParameter("DOCTOR", doctorModel);
    query.setParameter("APPOINTMENT_STATUS", AppointmentStatusEnum.RESERVED);
    query.setParameter("NOW", new Date());
    query.setParameter("END_OF_DAY", DateUtil.getEndOfDay());
    return (long) query.getResultList().get(0);
}

######


public List<AppointmentModel> getAppointmentsNote(DoctorModel doctorModel) {
    Query query = getEntitymanager().createQuery("SELECT ap FROM AppointmentModel ap " + "WHERE ap.inspectionPlace.doctor = :DOCTOR AND ap.appointmentStatus = :APPOINTMENT_STATUS AND ap.messageToDoctor IS NOT NULL ORDER BY ap.creationTime DESC");
    query.setParameter("DOCTOR", doctorModel);
    query.setParameter("APPOINTMENT_STATUS", AppointmentStatusEnum.RESERVED);
    return query.getResultList();
}

######


public int getId() {
    return id;
}

######


public String getName() {
    return name;
}

######


public void addSpecialty(int specialty_id) {
    this.specialty_id = specialty_id;
    String sql = "UPDATE doctors SET specialty_id = :specialty_id WHERE id = :id";
    try (Connection con = DB.sql2o.open()) {
        con.createQuery(sql).addParameter("specialty_id", specialty_id).addParameter("id", id).executeUpdate();
    }
}

######


public int getSpecialty() {
    return specialty_id;
}

######


public List<Patient> getPatients() {
    try (Connection con = DB.sql2o.open()) {
        String sql = "SELECT * FROM patients WHERE doctor_id = :id";
        return con.createQuery(sql).addParameter("id", id).executeAndFetch(Patient.class);
    }
}

######


public int getNumberOfPatients() {
    try (Connection con = DB.sql2o.open()) {
        String sql = "SELECT COUNT(doctor_id) FROM patients WHERE doctor_id = :id";
        return con.createQuery(sql).addParameter("id", id).executeScalar(Integer.class);
    }
}

######


@Override
public boolean equals(Object otherDoctorsInstance) {
    if (!(otherDoctorsInstance instanceof Doctors)) {
        return false;
    } else {
        Doctors newDoctorsInstance = (Doctors) otherDoctorsInstance;
        return this.getName().equals(newDoctorsInstance.getName()) && this.getSpecialty() == newDoctorsInstance.getSpecialty() && this.getId() == newDoctorsInstance.getId();
    }
}

######


public static List<Doctors> all() {
    String sql = "SELECT * FROM doctors ORDER BY name ASC";
    try (Connection con = DB.sql2o.open()) {
        return con.createQuery(sql).executeAndFetch(Doctors.class);
    }
}

######


public void save() {
    try (Connection con = DB.sql2o.open()) {
        String sql = "INSERT INTO doctors (name, specialty_id) VALUES (:name, :specialty_id)";
        this.id = (int) con.createQuery(sql, true).addParameter("name", name).addParameter("specialty_id", specialty_id).executeUpdate().getKey();
    }
}

######


public static Doctors find(int id) {
    try (Connection con = DB.sql2o.open()) {
        String sql = "SELECT * FROM doctors where id=:id";
        Doctors doctor = con.createQuery(sql).addParameter("id", id).executeAndFetchFirst(Doctors.class);
        return doctor;
    }
}

######


public void delete() {
    try (Connection con = DB.sql2o.open()) {
        String sql = "DELETE FROM doctors WHERE id = :id";
        con.createQuery(sql).addParameter("id", id).executeUpdate();
    }
}

######


@Override
public void addDoctor(Doctor doctor) {
    dao.save(doctor);
}

######


@Override
public void updateDoctor(Doctor doctor) {
    dao.update(doctor);
}

######


@Override
public boolean updateAmount(int doctorId, int amount) {
    String hql = "update Doctor set amount = ? where doctorId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(amount);
    object.add(doctorId);
    if (dao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public boolean updateRegiDoctorInfo(int id, String hospital, String office) {
    String hql = "update Doctor set hospital = ?,office = ? where doctorId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(hospital);
    object.add(office);
    object.add(id);
    if (dao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public boolean updateRegiDoctor(int id) {
    String hql = "update Doctor set amount=0 where doctorId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(id);
    if (dao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public boolean updateDLikesNum(int doctorId, int likenum) {
    String hql = "update Doctor set likenum=? where doctorId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(likenum);
    object.add(doctorId);
    if (dao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public List<Doctor> findAllDoctor() {
    String hql = "from Doctor";
    return dao.find(hql);
}

######


@Override
public List<Doctor> findDoctorByOffice(String office) {
    String hql = "from Doctor where office=?";
    List<Object> idObject = new ArrayList<Object>();
    idObject.add(office);
    List<Doctor> doctorList = dao.find(hql, idObject);
    return doctorList;
}

######


@Override
public List<Doctor> findDoctorById(int id) {
    String hql = "from Doctor where id=?";
    List<Object> idObject = new ArrayList<Object>();
    idObject.add(id);
    List<Doctor> doctorList = dao.find(hql, idObject);
    return doctorList;
}

######


@Override
public List<Doctor> findDoctorByDoctorId(int doctorId) {
    String hql = "from Doctor where doctorId=?";
    List<Object> doctorIdObject = new ArrayList<Object>();
    doctorIdObject.add(doctorId);
    List<Doctor> doctList = dao.find(hql, doctorIdObject);
    return doctList;
}

######


@Override
public List<DoctorDto> findAllnoDoctors() {
    List<DoctorDto> doctorDtoList = new ArrayList<DoctorDto>();
    String hql = "from Doctor where amount=-1";
    List<Doctor> doctList = dao.find(hql);
    if (doctList != null && doctList.size() > 0) {
        String hqluser = "from User where id=?";
        for (Doctor doctor : doctList) {
            DoctorDto dto = new DoctorDto();
            dto.setHospital(doctor.getHospital());
            dto.setOffice(doctor.getOffice());
            dto.setAmount(doctor.getAmount());
            dto.setLikenum(doctor.getLikenum());
            User user = userdao.get(hqluser, new Object[] { doctor.getDoctorId() });
            if (user != null) {
                dto.setId(user.getId());
                dto.setName(user.getName());
                dto.setNickname(user.getNickname());
                dto.setPassword(user.getPassword());
                dto.setGender(user.getGender());
                dto.setAge(user.getAge());
                dto.setPhone(user.getPhone());
                dto.setAddress(user.getAddress());
                dto.setSignature(user.getSignature());
                dto.setIntroduction(user.getIntroduction());
            }
            doctorDtoList.add(dto);
        }
    }
    return doctorDtoList;
}

######


@Override
public void deleteDoctor(List<Doctor> findDoctor) {
    List<Doctor> list = findDoctor;
    if (list != null && list.size() > 0) {
        for (int i = 0; i < list.size(); i++) {
            dao.delete(list.get(i));
        }
    }
}

######


@Override
public boolean deleteDoctorByDoctorId(int doctorId) {
    String hql = "delete Doctor where doctorId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(doctorId);
    if (dao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


public static void main(String[] args) {
    if (args.length != 1) {
        System.out.println("Expects file name as parameter");
        return;
    }
    boolean pwCorrect;
    String user = "";
    String pw = "";
    int minNumberOfBytes = Byte.BYTES + 2 * Character.BYTES;
    int maxNumberOfBytes = Byte.BYTES + USERNAME_MAX_LENGTH * Character.BYTES + PASSWORD_MAX_LENGTH * Character.BYTES;
    List<Byte> valueList = new ArrayList<>();
    try (FileInputStream fis = new FileInputStream(args[0])) {
        byte[] values = new byte[1];
        int i = 0;
        while (fis.read(values) != -1 && i < maxNumberOfBytes) {
            valueList.add(values[0]);
            i++;
        }
        if (i < minNumberOfBytes) {
            throw new RuntimeException("Not enough data!");
        }
        pwCorrect = valueList.get(0) > 0 ? true : false;
        int remainingSize = valueList.size() - 1;
        int usernameSize;
        int pwSize;
        if ((remainingSize / 2) >= (USERNAME_MAX_LENGTH * Character.BYTES)) {
            usernameSize = USERNAME_MAX_LENGTH * Character.BYTES;
        } else {
            usernameSize = remainingSize / 2;
        }
        if (usernameSize % Character.BYTES == 1) {
            usernameSize--;
        }
        pwSize = Math.min(remainingSize - usernameSize, PASSWORD_MAX_LENGTH * Character.BYTES);
        if (pwSize % Character.BYTES == 1) {
            pwSize--;
        }
        for (int j = 1; j < 1 + usernameSize; j += Character.BYTES) {
            byte[] bytes = new byte[Character.BYTES];
            for (int k = 0; k < Character.BYTES; k++) {
                bytes[k] = valueList.get(j + k);
            }
            user += ByteBuffer.wrap(bytes).getChar();
        }
        for (int j = 1 + usernameSize; j < 1 + usernameSize + pwSize; j += Character.BYTES) {
            byte[] bytes = new byte[Character.BYTES];
            for (int k = 0; k < Character.BYTES; k++) {
                bytes[k] = valueList.get(j + k);
            }
            pw += ByteBuffer.wrap(bytes).getChar();
        }
        System.out.println("user=" + user);
        System.out.println("pw=" + pw);
    } catch (IOException e) {
        System.err.println("Error reading input");
        e.printStackTrace();
        return;
    }
    UsernamePasswordCredentials cred = new UsernamePasswordCredentials(user, pw, "");
    DataSource ds = JdbcConnectionPool.create("jdbc:h2:~/pac4j-fuzz", "sa", "");
    DBI dbi = new DBI(ds);
    DbAuthenticator dbAuth = new DbAuthenticator();
    dbAuth.dbi = dbi;
    Handle h = dbi.open();
    try {
        String processedPW = dbAuth.getPasswordEncoder().encode(pw);
        if (!pwCorrect) {
            processedPW = processedPW.substring(0, processedPW.length() - 1) + (char) (processedPW.charAt(processedPW.length() - 1) + 1);
        }
        h.execute("insert into users (id, username, password) values (1, ?, ?)", user, processedPW);
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        h.close();
    }
    Mem.clear();
    boolean authenticated1 = false;
    try {
        if (RUN_UNSAFE_VERSION) {
            dbAuth.validate_unsafe(cred);
        } else {
            dbAuth.validate_safe(cred);
        }
        if (cred.getUserProfile() != null) {
            authenticated1 = true;
        }
    } catch (Exception e) {
    }
    long cost1 = Mem.instrCost;
    System.out.println("authenticated1: " + authenticated1);
    System.out.println("cost1=" + cost1);
    h = dbi.open();
    try {
        h.execute("delete from users where id = 1");
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        h.close();
    }
    Mem.clear();
    boolean authenticated2 = false;
    try {
        if (RUN_UNSAFE_VERSION) {
            dbAuth.validate_unsafe(cred);
        } else {
            dbAuth.validate_safe(cred);
        }
        if (cred.getUserProfile() != null) {
            authenticated2 = true;
        }
    } catch (Exception e) {
    }
    long cost2 = Mem.instrCost;
    System.out.println("authenticated2: " + authenticated2);
    System.out.println("cost2=" + cost2);
    Kelinci.addCost(Math.abs(cost1 - cost2));
    h = dbi.open();
    try {
        h.execute("delete from users");
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        h.close();
    }
    System.out.println("Done.");
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("tt1", "id int , name varchar(20)");
    createTable("tt2", "id int , name varchar(20)");
    createTable("Drivert2", "id int not null primary key auto_increment, test varchar(10)");
    createTable("utente", "id int not null primary key auto_increment, test varchar(10)");
    createTable("Drivert3", "id int not null primary key auto_increment, test varchar(10)");
    createTable("Drivert30", "id int not null primary key auto_increment, test varchar(20)", "engine=innodb");
    createTable("Drivert4", "id int not null primary key auto_increment, test varchar(20)", "engine=innodb");
    createTable("Drivert5", "id int not null primary key auto_increment, test varchar(20)", "engine=innodb");
    createTable("Drivert6", "id int not null primary key auto_increment, test varchar(20)", "engine=innodb");
    createTable("test_float", "id int not null primary key auto_increment, a float");
    createTable("test_big_autoinc2", "id int not null primary key auto_increment, test varchar(10)");
    createTable("test_big_update", "id int primary key not null, updateme int");
    createTable("sharedConnection", "id int");
    createTable("extest", "id int not null primary key");
    createTable("commentPreparedStatements", "id int not null primary key auto_increment, a varchar(10)");
    createTable("quotesPreparedStatements", "id int not null primary key auto_increment, a varchar(10) , " + "b varchar(10)");
    createTable("ressetpos", "i int not null primary key", "engine=innodb");
    createTable("streamingressetpos", "i int not null primary key", "engine=innodb");
    createTable("streamingtest", "val varchar(20)");
    createTable("testBlob2", "a blob");
    createTable("testString2", "a varchar(10)");
    createTable("testBlob2", "a blob");
    createTable("unsignedtest", "a int unsigned");
    createTable("conj25", "a VARCHAR(1024)");
    createTable("DriverTestt1", "id int not null primary key auto_increment, test varchar(20)");
    createTable("DriverTestt2", "id int not null primary key auto_increment, test varchar(20)");
    createTable("DriverTestt3", "id int not null primary key auto_increment, test varchar(20)");
    createTable("DriverTestt4", "id int not null primary key auto_increment, test varchar(20)");
    createTable("DriverTestt5", "id int not null primary key auto_increment, test varchar(20)");
    createProcedure("foo", "() BEGIN SELECT 1; END");
    createTable("conj275", "a VARCHAR(10)");
}

######


@Test
public void doQuery() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("insert into DriverTestt1 (test) values ('hej1')");
    stmt.execute("insert into DriverTestt1 (test) values ('hej2')");
    stmt.execute("insert into DriverTestt1 (test) values ('hej3')");
    stmt.execute("insert into DriverTestt1 (test) values (null)");
    ResultSet rs = stmt.executeQuery("select * from DriverTestt1");
    int[] autoInc = setAutoInc();
    for (int i = 1; i < 4; i++) {
        assertTrue(rs.next());
        assertEquals(String.valueOf(autoInc[1] + autoInc[0] * i), rs.getString(1));
        assertEquals("hej" + i, rs.getString("test"));
    }
    assertTrue(rs.next());
    assertEquals(null, rs.getString("test"));
}

######


@Test(expected = SQLException.class)
public void askForBadColumnTest() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("insert into DriverTestt2 (test) values ('hej1')");
    stmt.execute("insert into DriverTestt2 (test) values ('hej2')");
    stmt.execute("insert into DriverTestt2 (test) values ('hej3')");
    stmt.execute("insert into DriverTestt2 (test) values (null)");
    ResultSet rs = stmt.executeQuery("select * from DriverTestt2");
    if (rs.next()) {
        rs.getInt("non_existing_column");
    } else {
        fail();
    }
}

######


@Test(expected = SQLException.class)
public void askForBadColumnIndexTest() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("insert into DriverTestt3 (test) values ('hej1')");
    stmt.execute("insert into DriverTestt3 (test) values ('hej2')");
    stmt.execute("insert into DriverTestt3 (test) values ('hej3')");
    stmt.execute("insert into DriverTestt3 (test) values (null)");
    ResultSet rs = stmt.executeQuery("select * from DriverTestt3");
    assertTrue(rs.next());
    rs.getInt(102);
}

######


@Test
public void tableDotColumnInResultSet() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("insert into tt1 values(1, 'one')");
    stmt.execute("insert into tt2 values(1, 'two')");
    ResultSet rs = stmt.executeQuery("select tt1.*, tt2.* from tt1, tt2 where tt1.id = tt2.id");
    assertTrue(rs.next());
    assertEquals(1, rs.getInt("tt1.id"));
    assertEquals(1, rs.getInt("tt2.id"));
    assertEquals("one", rs.getString("tt1.name"));
    assertEquals("two", rs.getString("tt2.name"));
}

######


@Test(expected = SQLException.class)
public void badQuery() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.executeQuery("whraoaooa");
}

######


@Test
public void preparedTest() throws SQLException {
    try (Statement stmt = sharedConnection.createStatement()) {
        stmt.execute("insert into DriverTestt4 (test) values ('hej1')");
    }
    int[] autoInc = setAutoInc();
    String query = "SELECT * FROM DriverTestt4 WHERE test = ? and id = ?";
    PreparedStatement prepStmt = sharedConnection.prepareStatement(query);
    prepStmt.setString(1, "hej1");
    prepStmt.setInt(2, autoInc[0] + autoInc[1]);
    ResultSet results = prepStmt.executeQuery();
    String res = "";
    while (results.next()) {
        res = results.getString("test");
    }
    assertEquals("hej1", res);
    assertEquals(2, prepStmt.getParameterMetaData().getParameterCount());
}

######


@Test
public void parameterMetaDataTypeNotAvailable() throws SQLException {
    String query = "SELECT * FROM DriverTestt4 WHERE test = ? and id = ?";
    try (PreparedStatement prepStmt = sharedConnection.prepareStatement(query)) {
        ParameterMetaData parameterMetaData = prepStmt.getParameterMetaData();
        assertEquals(2, parameterMetaData.getParameterCount());
        try {
            parameterMetaData.getParameterType(1);
            fail("must have thrown an error");
        } catch (SQLException sqle) {
            assertTrue(sqle instanceof SQLFeatureNotSupportedException);
        }
    }
}

######


@Test
public void parameterMetaDataNotPreparable() throws SQLException {
    Assume.assumeFalse(sharedUsePrepare());
    Statement stmt = sharedConnection.createStatement();
    Map<String, Integer> initValues = loadVariables(stmt);
    try (PreparedStatement pstmt = sharedConnection.prepareStatement("select  TMP.field1 from (select ? from dual) TMP")) {
        try {
            pstmt.getParameterMetaData();
            fail();
        } catch (SQLException sqle) {
            assertEquals("42S22", sqle.getSQLState());
            assertTrue(sqle.getMessage().contains("Unknown column"));
        }
    }
    Map<String, Integer> endingValues = loadVariables(stmt);
    assertEquals(initValues.get("Prepared_stmt_count"), endingValues.get("Prepared_stmt_count"));
    assertEquals((Integer) (initValues.get("Com_stmt_prepare") + 1), endingValues.get("Com_stmt_prepare"));
    assertEquals(initValues.get("Com_stmt_close"), endingValues.get("Com_stmt_close"));
}

######


@Test
public void parameterMetaDataReturnException() throws SQLException {
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("selec1t 2 from dual")) {
        try {
            preparedStatement.getParameterMetaData();
            fail();
        } catch (SQLException sqle) {
            assertEquals("42000", sqle.getSQLState());
            assertTrue(sqle.getMessage().contains(" You have an error in your SQL syntax"));
        }
    }
}

######


private Map<String, Integer> loadVariables(Statement stmt) throws SQLException {
    Map<String, Integer> variables = new HashMap<>();
    ResultSet rs = stmt.executeQuery("SHOW SESSION STATUS WHERE Variable_name in ('Prepared_stmt_count','Com_stmt_prepare', 'Com_stmt_close')");
    assertTrue(rs.next());
    variables.put(rs.getString(1), rs.getInt(2));
    assertTrue(rs.next());
    variables.put(rs.getString(1), rs.getInt(2));
    assertTrue(rs.next());
    variables.put(rs.getString(1), rs.getInt(2));
    return variables;
}

######


@Test
public void parameterMetaDataPreparable() throws SQLException {
    Assume.assumeFalse(sharedUsePrepare());
    Statement stmt = sharedConnection.createStatement();
    Map<String, Integer> initValues = loadVariables(stmt);
    try (PreparedStatement pstmt = sharedConnection.prepareStatement("select  ?")) {
        ParameterMetaData parameterMetaData = pstmt.getParameterMetaData();
        parameterMetaData.getParameterCount();
    }
    Map<String, Integer> endingValues = loadVariables(stmt);
    assertEquals(initValues.get("Prepared_stmt_count"), endingValues.get("Prepared_stmt_count"));
    assertEquals((Integer) (initValues.get("Com_stmt_prepare") + 1), endingValues.get("Com_stmt_prepare"));
    assertEquals((Integer) (initValues.get("Com_stmt_close") + 1), endingValues.get("Com_stmt_close"));
}

######


@Test
public void streamingResultSet() throws Exception {
    Statement stmt = sharedConnection.createStatement();
    stmt.setFetchSize(Integer.MIN_VALUE);
    ResultSet rs = stmt.executeQuery("SELECT 1");
    assertTrue(rs.isBeforeFirst());
    try {
        rs.first();
        fail("should not get there");
    } catch (SQLException sqle) {
        assertTrue(sqle.getMessage().toLowerCase().contains("invalid operation"));
    }
}

######


@Test
public void updateTest() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("insert into DriverTestt5 (test) values ('hej1')");
    stmt.execute("insert into DriverTestt5 (test) values ('hej2')");
    stmt.execute("insert into DriverTestt5 (test) values ('hej3')");
    stmt.execute("insert into DriverTestt5 (test) values (null)");
    int[] autoInc = setAutoInc();
    String query = "UPDATE DriverTestt5 SET test = ? where id = ?";
    PreparedStatement prepStmt = sharedConnection.prepareStatement(query);
    prepStmt.setString(1, "updated");
    prepStmt.setInt(2, autoInc[1] + 3 * autoInc[0]);
    int updateCount = prepStmt.executeUpdate();
    assertEquals(1, updateCount);
    String query2 = "SELECT * FROM DriverTestt5 WHERE id=?";
    prepStmt = sharedConnection.prepareStatement(query2);
    prepStmt.setInt(1, autoInc[1] + 3 * autoInc[0]);
    ResultSet results = prepStmt.executeQuery();
    String result = "";
    while (results.next()) {
        result = results.getString("test");
    }
    assertEquals("updated", result);
}

######


public static void main(String[] args) {
    try {
        Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
    } catch (Exception e) {
        System.out.println("Class not found");
    }
    try {
        String url = "jdbc:odbc:SSRMS";
        Connection con = DriverManager.getConnection(url);
        System.out.println("Made connection");
        PreparedStatement pst = con.prepareStatement("insert into emp values(?,?,?)");
        Scanner sc = new Scanner(System.in);
        Statement stmt = con.createStatement();
        System.out.println("Enter Employee ID:");
        int empid = sc.nextInt();
        System.out.println("Enter Salary:");
        int sal = sc.nextInt();
        System.out.println("Enter Name:");
        String name = sc.next();
        pst.setInt(1, empid);
        pst.setString(2, name);
        pst.setInt(3, sal);
        pst.executeUpdate();
        ResultSet rs = stmt.executeQuery("SELECT * FROM emp");
        System.out.println("Details of Employees:");
        while (rs.next()) {
            System.out.print(rs.getString("id") + "\t" + rs.getString("name") + "\t" + rs.getString("salary"));
            System.out.println();
        }
        pst.close();
        stmt.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


@Test
public void shouldDemonstrateSimpleExpectedTextWithNoLoopsOrConditionals() throws Exception {
    final String expected = "SELECT * FROM BLOG";
    final MixedSqlNode sqlNode = mixedContents(new TextSqlNode(expected));
    DynamicSqlSource source = createDynamicSqlSource(sqlNode);
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldDemonstrateMultipartExpectedTextWithNoLoopsOrConditionals() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE ID = ?";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new TextSqlNode("WHERE ID = ?"));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldConditionallyIncludeWhere() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE ID = ?";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new IfSqlNode(mixedContents(new TextSqlNode("WHERE ID = ?")), "true"));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldConditionallyExcludeWhere() throws Exception {
    final String expected = "SELECT * FROM BLOG";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new IfSqlNode(mixedContents(new TextSqlNode("WHERE ID = ?")), "false"));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldConditionallyDefault() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE CATEGORY = 'DEFAULT'";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new ChooseSqlNode(new ArrayList<SqlNode>() {

        {
            add(new IfSqlNode(mixedContents(new TextSqlNode("WHERE CATEGORY = ?")), "false"));
            add(new IfSqlNode(mixedContents(new TextSqlNode("WHERE CATEGORY = 'NONE'")), "false"));
        }
    }, mixedContents(new TextSqlNode("WHERE CATEGORY = 'DEFAULT'"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldConditionallyChooseFirst() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE CATEGORY = ?";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new ChooseSqlNode(new ArrayList<SqlNode>() {

        {
            add(new IfSqlNode(mixedContents(new TextSqlNode("WHERE CATEGORY = ?")), "true"));
            add(new IfSqlNode(mixedContents(new TextSqlNode("WHERE CATEGORY = 'NONE'")), "false"));
        }
    }, mixedContents(new TextSqlNode("WHERE CATEGORY = 'DEFAULT'"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldConditionallyChooseSecond() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE CATEGORY = 'NONE'";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new ChooseSqlNode(new ArrayList<SqlNode>() {

        {
            add(new IfSqlNode(mixedContents(new TextSqlNode("WHERE CATEGORY = ?")), "false"));
            add(new IfSqlNode(mixedContents(new TextSqlNode("WHERE CATEGORY = 'NONE'")), "true"));
        }
    }, mixedContents(new TextSqlNode("WHERE CATEGORY = 'DEFAULT'"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldTrimWHEREInsteadOfANDForFirstCondition() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE  ID = ?";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new WhereSqlNode(new Configuration(), mixedContents(new IfSqlNode(mixedContents(new TextSqlNode("   and ID = ?  ")), "true"), new IfSqlNode(mixedContents(new TextSqlNode("   or NAME = ?  ")), "false"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldTrimWHEREANDWithLFForFirstCondition() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE \n ID = ?";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new WhereSqlNode(new Configuration(), mixedContents(new IfSqlNode(mixedContents(new TextSqlNode("   and\n ID = ?  ")), "true"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldTrimWHEREANDWithCRLFForFirstCondition() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE \r\n ID = ?";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new WhereSqlNode(new Configuration(), mixedContents(new IfSqlNode(mixedContents(new TextSqlNode("   and\r\n ID = ?  ")), "true"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldTrimWHEREANDWithTABForFirstCondition() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE \t ID = ?";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new WhereSqlNode(new Configuration(), mixedContents(new IfSqlNode(mixedContents(new TextSqlNode("   and\t ID = ?  ")), "true"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldTrimWHEREORWithLFForFirstCondition() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE \n ID = ?";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new WhereSqlNode(new Configuration(), mixedContents(new IfSqlNode(mixedContents(new TextSqlNode("   or\n ID = ?  ")), "true"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldTrimWHEREORWithCRLFForFirstCondition() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE \r\n ID = ?";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new WhereSqlNode(new Configuration(), mixedContents(new IfSqlNode(mixedContents(new TextSqlNode("   or\r\n ID = ?  ")), "true"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldTrimWHEREORWithTABForFirstCondition() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE \t ID = ?";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new WhereSqlNode(new Configuration(), mixedContents(new IfSqlNode(mixedContents(new TextSqlNode("   or\t ID = ?  ")), "true"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldTrimWHEREInsteadOfORForSecondCondition() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE  NAME = ?";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new WhereSqlNode(new Configuration(), mixedContents(new IfSqlNode(mixedContents(new TextSqlNode("   and ID = ?  ")), "false"), new IfSqlNode(mixedContents(new TextSqlNode("   or NAME = ?  ")), "true"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldTrimWHEREInsteadOfANDForBothConditions() throws Exception {
    final String expected = "SELECT * FROM BLOG WHERE  ID = ?   OR NAME = ?";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new WhereSqlNode(new Configuration(), mixedContents(new IfSqlNode(mixedContents(new TextSqlNode("   and ID = ?   ")), "true"), new IfSqlNode(mixedContents(new TextSqlNode("OR NAME = ?  ")), "true"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldTrimNoWhereClause() throws Exception {
    final String expected = "SELECT * FROM BLOG";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new WhereSqlNode(new Configuration(), mixedContents(new IfSqlNode(mixedContents(new TextSqlNode("   and ID = ?   ")), "false"), new IfSqlNode(mixedContents(new TextSqlNode("OR NAME = ?  ")), "false"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldTrimSETInsteadOfCOMMAForBothConditions() throws Exception {
    final String expected = "UPDATE BLOG SET ID = ?,  NAME = ?";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("UPDATE BLOG"), new SetSqlNode(new Configuration(), mixedContents(new IfSqlNode(mixedContents(new TextSqlNode(" ID = ?, ")), "true"), new IfSqlNode(mixedContents(new TextSqlNode(" NAME = ?, ")), "true"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldTrimNoSetClause() throws Exception {
    final String expected = "UPDATE BLOG";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("UPDATE BLOG"), new SetSqlNode(new Configuration(), mixedContents(new IfSqlNode(mixedContents(new TextSqlNode("   , ID = ?   ")), "false"), new IfSqlNode(mixedContents(new TextSqlNode(", NAME = ?  ")), "false"))));
    BoundSql boundSql = source.getBoundSql(null);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldIterateOnceForEachItemInCollection() throws Exception {
    final HashMap<String, String[]> parameterObject = new HashMap<String, String[]>() {

        {
            put("array", new String[] { "one", "two", "three" });
        }
    };
    final String expected = "SELECT * FROM BLOG WHERE ID in (  one = ? AND two = ? AND three = ? )";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG WHERE ID in"), new ForEachSqlNode(new Configuration(), mixedContents(new TextSqlNode("${item} = #{item}")), "array", "index", "item", "(", ")", "AND"));
    BoundSql boundSql = source.getBoundSql(parameterObject);
    assertEquals(expected, boundSql.getSql());
    assertEquals(3, boundSql.getParameterMappings().size());
    assertEquals("__frch_item_0", boundSql.getParameterMappings().get(0).getProperty());
    assertEquals("__frch_item_1", boundSql.getParameterMappings().get(1).getProperty());
    assertEquals("__frch_item_2", boundSql.getParameterMappings().get(2).getProperty());
}

######


@Test
public void shouldHandleOgnlExpression() throws Exception {
    final HashMap<String, String> parameterObject = new HashMap<String, String>() {

        {
            put("name", "Steve");
        }
    };
    final String expected = "Expression test: 3 / yes.";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("Expression test: ${name.indexOf('v')} / ${name in {'Bob', 'Steve'\\} ? 'yes' : 'no'}."));
    BoundSql boundSql = source.getBoundSql(parameterObject);
    assertEquals(expected, boundSql.getSql());
}

######


@Test
public void shouldSkipForEachWhenCollectionIsEmpty() throws Exception {
    final HashMap<String, Integer[]> parameterObject = new HashMap<String, Integer[]>() {

        {
            put("array", new Integer[] {});
        }
    };
    final String expected = "SELECT * FROM BLOG";
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("SELECT * FROM BLOG"), new ForEachSqlNode(new Configuration(), mixedContents(new TextSqlNode("#{item}")), "array", null, "item", "WHERE id in (", ")", ","));
    BoundSql boundSql = source.getBoundSql(parameterObject);
    assertEquals(expected, boundSql.getSql());
    assertEquals(0, boundSql.getParameterMappings().size());
}

######


@Test
public void shouldPerformStrictMatchOnForEachVariableSubstitution() throws Exception {
    final Map<String, Object> param = new HashMap<String, Object>();
    final Map<String, String> uuu = new HashMap<String, String>();
    uuu.put("u", "xyz");
    List<Bean> uuuu = new ArrayList<Bean>();
    uuuu.add(new Bean("bean id"));
    param.put("uuu", uuu);
    param.put("uuuu", uuuu);
    DynamicSqlSource source = createDynamicSqlSource(new TextSqlNode("INSERT INTO BLOG (ID, NAME, NOTE, COMMENT) VALUES"), new ForEachSqlNode(new Configuration(), mixedContents(new TextSqlNode("#{uuu.u}, #{u.id}, #{ u,typeHandler=org.apache.ibatis.type.StringTypeHandler}," + " #{u:VARCHAR,typeHandler=org.apache.ibatis.type.StringTypeHandler}")), "uuuu", "uu", "u", "(", ")", ","));
    BoundSql boundSql = source.getBoundSql(param);
    assertEquals(4, boundSql.getParameterMappings().size());
    assertEquals("uuu.u", boundSql.getParameterMappings().get(0).getProperty());
    assertEquals("__frch_u_0.id", boundSql.getParameterMappings().get(1).getProperty());
    assertEquals("__frch_u_0", boundSql.getParameterMappings().get(2).getProperty());
    assertEquals("__frch_u_0", boundSql.getParameterMappings().get(3).getProperty());
}

######


private DynamicSqlSource createDynamicSqlSource(SqlNode... contents) throws IOException, SQLException {
    createBlogDataSource();
    final String resource = "org/apache/ibatis/builder/MapperConfig.xml";
    final Reader reader = Resources.getResourceAsReader(resource);
    SqlSessionFactory sqlMapper = new SqlSessionFactoryBuilder().build(reader);
    Configuration configuration = sqlMapper.getConfiguration();
    MixedSqlNode sqlNode = mixedContents(contents);
    return new DynamicSqlSource(configuration, sqlNode);
}

######


private MixedSqlNode mixedContents(SqlNode... contents) {
    return new MixedSqlNode(Arrays.asList(contents));
}

######


@Test
public void shouldMapNullStringsToEmptyStrings() {
    final String expected = "id=${id}";
    final MixedSqlNode sqlNode = mixedContents(new TextSqlNode(expected));
    final DynamicSqlSource source = new DynamicSqlSource(new Configuration(), sqlNode);
    String sql = source.getBoundSql(new Bean(null)).getSql();
    Assert.assertEquals("id=", sql);
}

######


public String getId() {
    return id;
}

######


public void setId(String property) {
    this.id = property;
}

######


@Override
public String toString() {
    return "Education{" + "id=" + super.getId() + ", name=" + super.getId() + ", students=" + students + ", courses=" + courses + '}';
}

######


@Override
public boolean equals(Object obj) {
    return super.equals(obj);
}

######


@Override
public int hashCode() {
    return super.hashCode();
}

######


public List<Student> getStudents() {
    if (students == null) {
        students = new ArrayList<>();
    }
    return students;
}

######


public void setStudents(List<Student> students) {
    this.students = students;
}

######


public void addStudent(Student student) {
    getStudents().add(student);
    student.setEducation(this);
}

######


public void removeStudent(Student student) {
    getStudents().remove(student);
    student.setEducation(null);
}

######


public List<Course> getCourses() {
    if (courses == null) {
        courses = new ArrayList<>();
    }
    return courses;
}

######


public void setCourses(List<Course> courses) {
    this.courses = courses;
}

######


public void addCourse(Course course) {
    getCourses().add(course);
    course.getEducations().add(this);
}

######


public void removeCourse(Course course) {
    getCourses().remove(course);
    course.getEducations().remove(this);
}

######


public void init() {
    ServletContext context = getServletContext();
    host = context.getInitParameter("host");
    port = context.getInitParameter("port");
    user = context.getInitParameter("user");
    pass = context.getInitParameter("pass");
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String uname = "";
    String accesscode = "";
    String recipient = request.getParameter("emailid");
    if (recipient != null) {
        int flag;
        try {
            flag = databaseConnectivity(recipient);
            if (flag == 1) {
                String subject = "User Verification System";
                uname = getusername(recipient);
                String content = "Your username:" + uname;
                String resultMessage = "";
                try {
                    EmailUtility.sendEmail(host, port, user, pass, recipient, subject, content);
                    resultMessage = "Your username is sent to your email address";
                } catch (Exception ex) {
                    ex.printStackTrace();
                    resultMessage = "There were an error: " + ex.getMessage();
                } finally {
                    request.setAttribute("Message", resultMessage);
                    getServletContext().getRequestDispatcher("/usernameLink.jsp").forward(request, response);
                }
            } else {
                JOptionPane.showMessageDialog(null, "Invalid Emailaddress");
                response.sendRedirect("forgotUsername.jsp");
            }
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }
    } else {
        String emailadd = null;
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals("emailid"))
                    emailadd = cookie.getValue();
            }
        }
        recipient = emailadd;
        String subject = "User Verification System";
        Random rand = new Random();
        int posRandInt = rand.nextInt(Integer.MAX_VALUE) + 1;
        String str = Integer.toString(posRandInt);
        String content = "AccessCode:" + str;
        String resultMessage = "";
        try {
            EmailUtility.sendEmail(host, port, user, pass, recipient, subject, content);
            resultMessage = "Your username is sent to your email address";
        } catch (Exception ex) {
            ex.printStackTrace();
            resultMessage = "There were an error: " + ex.getMessage();
        } finally {
            request.setAttribute("Message", resultMessage);
            HttpSession session = request.getSession();
            session.setAttribute("accesscode", str);
            getServletContext().getRequestDispatcher("/resetpassword.jsp").forward(request, response);
        }
    }
}

######


protected int databaseConnectivity(String emailid) throws IOException, SQLException, ClassNotFoundException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/userVerificationdb", "root", "root");
    Statement st = con.createStatement();
    ResultSet rs;
    rs = st.executeQuery("select username,emailid from account where emailid='" + emailid + "'");
    if (rs.next()) {
        int flag = 1;
        return flag;
    } else {
        int flag = 0;
        return flag;
    }
}

######


protected String getusername(String emailid) throws IOException, SQLException, ClassNotFoundException {
    String uname = "";
    Class.forName("com.mysql.jdbc.Driver");
    Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/userVerificationdb", "root", "root");
    Statement st = con.createStatement();
    ResultSet rs;
    rs = st.executeQuery("select username from account where emailid='" + emailid + "'");
    if (rs.next()) {
        uname = rs.getString("username");
        return uname;
    }
    return uname;
}

######


public List findEmpAll() {
    String sql = "select * from emp";
    List list = null;
    try {
        list = SqlSession.selectList(sql, Emp.class);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return list;
}

######


public Emp login(Emp emp) {
    String sql = "select * from emp where empno=" + emp.getEmpNo() + " and ename='" + emp.getEname() + "'";
    List list = null;
    try {
        list = SqlSession.selectList(sql, Emp.class);
    } catch (Exception e) {
        e.printStackTrace();
    }
    if (list == null || list.size() == 0) {
        return null;
    } else {
        return (Emp) list.get(0);
    }
}

######


public int deleteEmp(String deptNo) throws Exception {
    String sql = "delete form emp where deptno=" + deptNo;
    int num = SqlSession.delete(sql);
    return num;
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
}

######


protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String[] array = null;
    String sql = "delete from emp where empno=?";
    PreparedStatement ps = null;
    array = request.getParameterValues("empNo");
    ps = DBUtil.createStatement(sql);
    try {
        for (String empNo : array) {
            ps.setString(1, empNo);
            ps.addBatch();
        }
        ps.executeBatch();
    } catch (Exception ex) {
        ex.printStackTrace();
    } finally {
        DBUtil.close(null);
    }
}

######


public void insertar(Empleado vo) throws SQLException {
    PreparedStatement sentencia = cnn.prepareStatement("INSERT INTO empleado (nombre,apellido,celular,direccion,correo,cargo) " + "VALUES(?,?,?,?,?,?)");
    sentencia.setString(1, vo.getNombre());
    sentencia.setString(2, vo.getApellido());
    sentencia.setString(3, vo.getCelular());
    sentencia.setString(4, vo.getDireccion());
    sentencia.setString(5, vo.getCorreo());
    sentencia.setString(6, vo.getCargo());
    sentencia.executeUpdate();
}

######


public void modificar(Empleado vo) throws SQLException {
    PreparedStatement sentencia = cnn.prepareStatement("UPDATE empleado SET nombre= ?,apellido= ?,celular= ?,direccion=?,correo= ?,cargo= ? " + "WHERE idempleado = ?");
    sentencia.setString(1, vo.getNombre());
    sentencia.setString(2, vo.getApellido());
    sentencia.setString(3, vo.getCelular());
    sentencia.setString(4, vo.getDireccion());
    sentencia.setString(4, vo.getCorreo());
    sentencia.setString(5, vo.getCargo());
    sentencia.setInt(6, vo.getIdempleado());
    sentencia.executeUpdate();
}

######


public List<Empleado> consultar() throws SQLException {
    List<Empleado> listaEmpleado = new ArrayList<>();
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM empleado");
    ResultSet resultado = sentencia.executeQuery();
    while (resultado.next()) {
        Empleado voTemp = new Empleado();
        voTemp.setIdempleado(resultado.getInt("idempleado"));
        voTemp.setNombre(resultado.getString("nombre"));
        voTemp.setApellido(resultado.getString("apellido"));
        voTemp.setCelular(resultado.getString("celular"));
        voTemp.setDireccion(resultado.getString("direccion"));
        voTemp.setCorreo(resultado.getString("correo"));
        voTemp.setCargo(resultado.getString("cargo"));
        listaEmpleado.add(voTemp);
    }
    if (listaEmpleado.size() > 0) {
        return listaEmpleado;
    } else {
        return null;
    }
}

######


public List<Empleado> consultarnombre(String nombre) throws SQLException {
    List<Empleado> listaEmpleado = new ArrayList<>();
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM empleado");
    ResultSet resultado = sentencia.executeQuery();
    while (resultado.next()) {
        Empleado voTemp = new Empleado();
        voTemp.setIdempleado(resultado.getInt("idempleado"));
        voTemp.setNombre(resultado.getString("nombre"));
        voTemp.setApellido(resultado.getString("apellido"));
        voTemp.setCelular(resultado.getString("celular"));
        voTemp.setDireccion(resultado.getString("direccion"));
        voTemp.setCorreo(resultado.getString("correo"));
        voTemp.setCargo(resultado.getString("cargo"));
        listaEmpleado.add(voTemp);
    }
    if (listaEmpleado.size() > 0) {
        return listaEmpleado;
    } else {
        return null;
    }
}

######


public Empleado queryNombre(String nombre) throws SQLException {
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM empleado WHERE nombre=?");
    sentencia.setString(1, nombre);
    ResultSet resultado = sentencia.executeQuery();
    if (resultado.next()) {
        return getVo(resultado);
    }
    return null;
}

######


public Empleado consultaridEmpleado(int idempleado) throws SQLException, ParseException {
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM empleado WHERE idempleado=?");
    sentencia.setInt(1, idempleado);
    ResultSet resultado = sentencia.executeQuery();
    if (resultado.next()) {
        return getVo(resultado);
    }
    return null;
}

######


public Empleado getVo(ResultSet resultado) throws SQLException {
    Empleado vot = new Empleado();
    vot.setIdempleado(resultado.getInt("idempleado"));
    vot.setNombre(resultado.getString("nombre"));
    vot.setApellido(resultado.getString("apellido"));
    vot.setCelular(resultado.getString("celular"));
    vot.setDireccion(resultado.getString("direccion"));
    vot.setCorreo(resultado.getString("correo"));
    vot.setCargo(resultado.getString("cargo"));
    return vot;
}

######


public List<Employee> findByNameAndPass(Employee emp) {
    return find("select p from Employee p where p.name = ?0 and p.pass=?1", emp.getName(), emp.getPass());
}

######


public Employee findByName(String name) {
    List<Employee> emps = find("select e from Employee e where e.name = ?0", name);
    if (emps != null && emps.size() >= 1) {
        return emps.get(0);
    }
    return null;
}

######


@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String action = req.getParameter("action");
    if (action == null) {
        action = "list";
    }
    switch(action) {
        case "edit":
            showEditEmployeeForm(resp);
            break;
        case "maxSalary":
            showEmployeeWithMaxSalary(resp);
            break;
        case "list":
        default:
            listEmployees(resp);
            break;
    }
}

######


@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String action = req.getParameter("action");
    switch(action) {
        case "edit":
            editEmployee(req, resp);
            break;
        case "remove":
            removeEmployee(req, resp);
            break;
        default:
            resp.sendRedirect("employees");
            break;
    }
}

######


private void showEmployeeWithMaxSalary(HttpServletResponse resp) throws ServletException {
    EntityManager em = JPASessionUtil.getEntityManager();
    EntityTransaction transaction = em.getTransaction();
    try {
        transaction.begin();
        createStoredProcedure();
        StoredProcedureQuery query = em.createStoredProcedureQuery(STORED_PROCEDURE_EMPLOYEE_NAME_MAX_SALARY);
        String name = (String) query.getSingleResult();
        PrintWriter writer = resp.getWriter();
        writer.println("Employee with maximum salary: " + name);
        transaction.commit();
    } catch (Exception e) {
        transaction.rollback();
        throw new ServletException(e);
    } finally {
        em.close();
    }
}

######


private void createStoredProcedure() throws ServletException {
    EntityManager em = JPASessionUtil.getEntityManager();
    EntityTransaction transaction = em.getTransaction();
    try {
        transaction.begin();
        String sqlCreateFunction = "create or replace function employee_name_max_salary()\n" + "returns character varying(255) as\n" + "$$ select e.fullname from employee as e where e.salary in (select max(salary) from employee) $$\n" + "language 'sql' volatile;";
        em.createNativeQuery(sqlCreateFunction).executeUpdate();
        transaction.commit();
    } catch (Exception e) {
        transaction.rollback();
        throw new ServletException(e);
    } finally {
        em.close();
    }
}

######


private void removeEmployee(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String employeeIdParam = req.getParameter("employeeId");
    EntityManager em = JPASessionUtil.getEntityManager();
    EntityTransaction transaction = em.getTransaction();
    try {
        transaction.begin();
        Long employeeId = Long.parseLong(employeeIdParam);
        Query query = em.createQuery("delete from Employee as e where e.id=:employeeId");
        query.setParameter("employeeId", employeeId);
        query.executeUpdate();
        transaction.commit();
    } catch (Exception e) {
        transaction.rollback();
        throw new ServletException(e);
    } finally {
        em.close();
    }
    resp.sendRedirect("employees");
}

######


private void editEmployee(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String employeeIdParam = req.getParameter("employeeId");
    String employeeFullName = req.getParameter("employeeFullName");
    String positionParam = req.getParameter("employeePosition");
    EntityManager em = JPASessionUtil.getEntityManager();
    EntityTransaction transaction = em.getTransaction();
    try {
        transaction.begin();
        Long employeeId = Long.parseLong(employeeIdParam);
        TypedQuery<Employee> employeeQuery = em.createQuery("select e from Employee as e where e.id=:employeeId", Employee.class);
        employeeQuery.setParameter("employeeId", employeeId);
        Employee employee = employeeQuery.getSingleResult();
        TypedQuery<Position> positionQuery = em.createQuery("select p from Position as p where p.name=:positionName", Position.class);
        positionQuery.setParameter("positionName", positionParam);
        Position position = positionQuery.getSingleResult();
        employee.setFullName(employeeFullName);
        employee.setPosition(position);
        transaction.commit();
    } catch (Exception e) {
        transaction.rollback();
        throw new ServletException(e);
    } finally {
        em.close();
    }
    resp.sendRedirect("employees");
}

######


private void showEditEmployeeForm(HttpServletResponse resp) throws IOException {
    PrintWriter writer = writeHtmlHeader(resp);
    writer.append("<h2>Edit Employee</h2>\r\n");
    writer.append("<form method=\"POST\" action=\"employees\">\r\n");
    writer.append("    <input type=\"hidden\" name=\"action\" value=\"edit\"/>\r\n");
    writer.append("    Employee ID<br/>\r\n");
    writer.append("    <input type=\"text\" name=\"employeeId\"/><br/><br/>\r\n");
    writer.append("    Full name<br/>\r\n");
    writer.append("    <input type=\"text\" name=\"employeeFullName\"/><br/><br/>\r\n");
    writer.append("    Position<br/>\r\n");
    writer.append("    <input type=\"text\" name=\"employeePosition\"/><br/><br/>\r\n");
    writer.append("    <input type=\"submit\" value=\"Submit\"/>\r\n");
    writer.append("</form>\r\n");
    writeHtmlFooter(writer);
}

######


private void listEmployees(HttpServletResponse resp) throws ServletException {
    EntityManager em = JPASessionUtil.getEntityManager();
    EntityTransaction transaction = em.getTransaction();
    try {
        transaction.begin();
        TypedQuery<Employee> query = em.createQuery("select e from Employee as e order by e.id desc", Employee.class);
        List<Employee> employees = query.getResultList();
        PrintWriter writer = writeHtmlHeader(resp);
        writer.append("<table>\r\n");
        writeEmployeesHeader(writer);
        for (Employee emp : employees) {
            writeEmployee(writer, emp);
        }
        writer.append("</table>\r\n");
        writeHtmlFooter(writer);
        transaction.commit();
    } catch (Exception e) {
        transaction.rollback();
        throw new ServletException(e);
    } finally {
        em.close();
    }
}

######


private void writeEmployeesHeader(PrintWriter writer) {
    writer.append("<tr><th>Id</th><th>Full name</th><th>Login</th><th>Position</th><th>Salary</th></tr>\r\n");
}

######


private void writeEmployee(PrintWriter writer, Employee emp) {
    writer.append("<tr><td>");
    writer.append(emp.getId().toString());
    writer.append("</td><td>\r\n");
    writer.append(emp.getFullName());
    writer.append("</td><td>\r\n");
    writer.append(emp.getLogin());
    writer.append("</td><td>\r\n");
    writer.append(emp.getPosition().getName());
    writer.append("</td><td>\r\n");
    writer.append(emp.getSalary().toString());
    writer.append("</td><td>\r\n");
    writer.append(buildRemoveEmployeeForm(emp.getId()));
    writer.append("</td></tr>\r\n");
}

######


private PrintWriter writeHtmlHeader(HttpServletResponse resp) throws IOException {
    PrintWriter writer = resp.getWriter();
    writer.append("<html><head><title>Employee Servlet</title></head><body>\r\n");
    return writer;
}

######


private void writeHtmlFooter(PrintWriter writer) {
    writer.append("</body></html>");
}

######


private String buildRemoveEmployeeForm(Long id) {
    return "<form action=\"employees\" method=\"POST\">\n" + "        <input type=\"hidden\" name=\"action\" value=\"remove\">\n" + "        <input type=\"hidden\" name=\"employeeId\" value=\"" + id + "\">\n" + "        <input type=\"submit\" value=\"Remove\">\n" + "    </form>";
}

######


public Connection abreConexaoBD() {
    try {
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
        } catch (ClassNotFoundException ex) {
            return null;
        }
        try {
            this.conexao = (Connection) DriverManager.getConnection(url, login, senha);
        } catch (SQLException ex) {
            return null;
        }
        return this.conexao;
    } catch (Exception e) {
        return null;
    }
}

######


public Connection fechaConexaoBD() {
    this.conexao = null;
    return null;
}

######


public void deletaCliente(int id) {
    this.conexao = abreConexaoBD();
    String query;
    query = "DELETE FROM EMPRESTIMO WHERE ID = " + id + ";";
    try {
        this.conexao.createStatement().executeUpdate(query);
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public void atualizaCliente(Emprestimo emprestimo) {
    this.conexao = abreConexaoBD();
    String query, isString = "'", virgula = ",";
    ;
    query = "UPDATE EMPRESTIMO SET NOME = " + isString + emprestimo.getNome() + isString + virgula + "EMAIL = " + isString + emprestimo.getEmail() + isString + virgula + "CPF = " + isString + emprestimo.getCpf() + isString + virgula + "DT_NASCIMENTO = " + isString + emprestimo.getDataNascimento() + isString + virgula + "TELEFONE = " + isString + emprestimo.getTelefone() + isString + virgula + "SEXO = " + isString + emprestimo.getSexo() + isString + virgula + "SALARIO = " + emprestimo.getSalario() + virgula + "VALOR = " + emprestimo.getValor() + virgula + "ATRASO = " + emprestimo.getDiasAtraso() + " WHERE ID = " + emprestimo.getId();
    try {
        this.conexao.createStatement().executeUpdate(query);
    } catch (SQLException e) {
        e.printStackTrace();
    }
    this.conexao = fechaConexaoBD();
}

######


public void inserirCliente(Emprestimo emprestimo) {
    this.conexao = abreConexaoBD();
    String query, virgula = ",", isString = "'";
    query = "INSERT INTO EMPRESTIMO (NOME, CPF, SALARIO, EMAIL, DT_NASCIMENTO, VALOR, TELEFONE, SEXO, ATRASO) VALUES(" + isString + emprestimo.getNome() + isString + virgula + isString + emprestimo.getCpf() + isString + virgula + emprestimo.getSalario() + virgula + isString + emprestimo.getEmail() + isString + virgula + isString + emprestimo.getDataNascimento() + isString + virgula + emprestimo.getValor() + virgula + isString + emprestimo.getTelefone() + isString + virgula + isString + emprestimo.getSexo() + isString + virgula + emprestimo.getDiasAtraso() + ");";
    try {
        this.conexao.createStatement().executeUpdate(query);
    } catch (SQLException e) {
        e.printStackTrace();
    }
    this.conexao = fechaConexaoBD();
}

######


@Before
public void runBeforeEachTest() {
    executeDataSet(ENC_INITIAL_DATA_XML);
}

######


@Test
public void saveEncounter_shouldUpdateExistingEncounterWhenAChildObsIsEdited() {
    executeDataSet(ENC_OBS_HIERARCHY_DATA_XML);
    EncounterService es = Context.getEncounterService();
    ObsService os = Context.getObsService();
    Encounter enc = es.getEncounter(100);
    Obs o = os.getObs(101);
    o.setValueText("Obs value updated");
    es.saveEncounter(enc);
    Context.flushSession();
    Context.clearSession();
    updateSearchIndex();
    enc = es.getEncounter(100);
    Set<Obs> obsAtTopLevelUpdated = enc.getObsAtTopLevel(true);
    Obs oParent = os.getObs(100);
    final Obs editedObs = os.getObs(101);
    Obs o2 = os.getObs(102);
    Obs o3 = getNewVersionOfEditedObs(oParent, editedObs);
    assertEquals(1, obsAtTopLevelUpdated.size());
    assertEquals(3, oParent.getGroupMembers(true).size());
    assertTrue(editedObs.getVoided());
    assertFalse(oParent.getVoided());
    assertFalse(o2.getVoided());
    assertNotNull(o3);
    assertFalse(o3.getVoided());
    assertEquals("Obs value updated", o3.getValueText());
}

######


@Test
public void saveEncounter_shouldUpdateValueOfLeafObsAndNotDuplicateAtEncounterLevel() {
    executeDataSet(ENC_OBS_HIERARCHY_DATA_XML);
    Encounter encounter = Context.getEncounterService().getEncounter(100);
    assertEquals(1, encounter.getObsAtTopLevel(true).size());
    Obs topLevelObs = encounter.getObsAtTopLevel(true).iterator().next();
    topLevelObs.getGroupMembers().iterator().next().setValueText("editing first obs");
    encounter.addObs(topLevelObs);
    Encounter savedEncounter = Context.getEncounterService().saveEncounter(encounter);
    assertEquals(1, savedEncounter.getObsAtTopLevel(true).size());
}

######


@Test
public void saveEncounter_shouldUpdateExistingEncounterWhenNewObsIsAddedToParentObs() {
    executeDataSet(ENC_OBS_HIERARCHY_DATA_XML);
    ConceptService cs = Context.getConceptService();
    EncounterService es = Context.getEncounterService();
    ObsService os = Context.getObsService();
    Encounter enc = es.getEncounter(100);
    Obs o3 = new Obs();
    o3.setConcept(cs.getConcept(3));
    o3.setDateCreated(new Date());
    o3.setCreator(Context.getAuthenticatedUser());
    o3.setLocation(new Location(1));
    o3.setObsDatetime(new Date());
    o3.setPerson(Context.getPersonService().getPerson(3));
    o3.setValueText("third obs value text");
    o3.setEncounter(enc);
    Obs oParent = os.getObs(100);
    oParent.addGroupMember(o3);
    es.saveEncounter(enc);
    Context.flushSession();
    Context.clearSession();
    enc = es.getEncounter(100);
    Set<Obs> obsAtTopLevelUpdated = enc.getObsAtTopLevel(true);
    assertEquals(1, obsAtTopLevelUpdated.size());
    assertEquals(3, obsAtTopLevelUpdated.iterator().next().getGroupMembers(true).size());
    oParent = os.getObs(100);
    assertTrue(oParent.getGroupMembers(true).contains(os.getObs(101)));
    assertTrue(oParent.getGroupMembers(true).contains(os.getObs(102)));
    assertTrue(oParent.getGroupMembers(true).contains(os.getObs(o3.getObsId())));
}

######


@Test
public void saveEncounter_shouldSaveEncounterWhenTopLevelObsIsUpdatedByRemovingChildObs() {
    executeDataSet(ENC_OBS_HIERARCHY_DATA_XML);
    EncounterService es = Context.getEncounterService();
    ObsService os = Context.getObsService();
    Encounter enc = es.getEncounter(100);
    Obs oParent = os.getObs(100);
    Obs oChild = os.getObs(101);
    oParent.removeGroupMember(oChild);
    es.saveEncounter(enc);
    Context.flushSession();
    Context.clearSession();
    enc = es.getEncounter(100);
    Set<Obs> obsAtTopLevel = enc.getObsAtTopLevel(true);
    assertEquals(2, obsAtTopLevel.size());
    assertTrue(obsAtTopLevel.contains(os.getObs(100)));
    Obs newObs = obsAtTopLevel.stream().filter(obs -> obs.getObsId() != 100).findFirst().get();
    assertNotNull(newObs.getPreviousVersion());
    assertEquals(oChild.getObsId(), newObs.getPreviousVersion().getObsId());
    assertTrue(os.getObs(100).getGroupMembers(true).contains(os.getObs(102)));
    assertTrue(os.getObs(100).getGroupMembers(true).contains(os.getObs(101)));
}

######


private Obs getNewVersionOfEditedObs(Obs parentObs, Obs originalObs) {
    for (Obs childObs : parentObs.getGroupMembers()) {
        if (originalObs.equals(childObs.getPreviousVersion())) {
            return childObs;
        }
    }
    return null;
}

######


@Test
public void saveEncounter_shouldSaveEncounterWithBasicDetails() {
    Encounter encounter = buildEncounter();
    EncounterService es = Context.getEncounterService();
    es.saveEncounter(encounter);
    assertNotNull("The saved encounter should have an encounter id now", encounter.getEncounterId());
    Encounter newSavedEncounter = es.getEncounter(encounter.getEncounterId());
    assertNotNull("We should get back an encounter", newSavedEncounter);
    assertTrue("The created encounter needs to equal the pojo encounter", encounter.equals(newSavedEncounter));
}

######


@Test
public void saveEncounter_shouldUpdateEncounterSuccessfully() {
    EncounterService es = Context.getEncounterService();
    Encounter encounter = es.getEncounter(1);
    Patient origPatient = encounter.getPatient();
    Location origLocation = encounter.getLocation();
    Date origDate = encounter.getEncounterDatetime();
    EncounterType origEncType = encounter.getEncounterType();
    Location loc2 = new Location(2);
    EncounterType encType2 = new EncounterType(2);
    Date d2 = new Date();
    Patient pat2 = new Patient(2);
    encounter.setLocation(loc2);
    encounter.setEncounterType(encType2);
    encounter.setEncounterDatetime(d2);
    encounter.setPatient(pat2);
    es.saveEncounter(encounter);
    Encounter newestEnc = es.getEncounter(encounter.getEncounterId());
    assertFalse("The location should be different", origLocation.equals(loc2));
    assertTrue("The location should be different", newestEnc.getLocation().equals(loc2));
    assertFalse("The enc should have changed", origEncType.equals(encType2));
    assertTrue("The enc type needs to have been set", newestEnc.getEncounterType().equals(encType2));
    assertFalse("Make sure the dates changed slightly", origDate.equals(d2));
    assertTrue("The date needs to have been set", DateUtil.truncateToSeconds(newestEnc.getEncounterDatetime()).equals(DateUtil.truncateToSeconds(d2)));
    assertFalse("The patient should be different", origPatient.equals(pat2));
    assertTrue("The patient should have been set", newestEnc.getPatient().equals(pat2));
}

######


@Test
public void saveEncounter_shouldCascadeSaveToContainedObs() {
    EncounterService es = Context.getEncounterService();
    Encounter enc = buildEncounter();
    Obs groupObs = new Obs();
    Concept c = Context.getConceptService().getConcept(1);
    groupObs.setConcept(c);
    Obs childObs = new Obs();
    childObs.setConcept(c);
    childObs.setValueNumeric(50d);
    groupObs.addGroupMember(childObs);
    enc.addObs(groupObs);
    assertNotNull("save succeeds without error", es.saveEncounter(enc));
    assertTrue("enc save succeeds", enc.getId() > 0);
    assertNotNull("obs save succeeds", groupObs.getObsId());
    assertEquals("encounter id propogated", groupObs.getEncounter().getId(), enc.getId());
    assertEquals("encounter time propogated", groupObs.getObsDatetime(), enc.getEncounterDatetime());
    assertNotNull("obs save succeeds", childObs.getObsId());
    assertEquals("encounter id propogated", childObs.getEncounter().getId(), enc.getId());
    assertEquals("encounter time propogated", childObs.getObsDatetime(), enc.getEncounterDatetime());
}

######


@Test
public void saveEncounter_shouldCascadeChangeOfLocationInEncounterToContainedObs() {
    EncounterService es = Context.getEncounterService();
    Encounter enc = buildEncounter();
    es.saveEncounter(enc);
    Obs newObs = new Obs();
    newObs.setConcept(Context.getConceptService().getConcept(1));
    newObs.setValueNumeric(50d);
    Location location = new Location(1);
    newObs.setLocation(location);
    enc.addObs(newObs);
    es.saveEncounter(enc);
    enc.setLocation(location);
    es.saveEncounter(enc);
    assertEquals(enc.getLocation(), newObs.getLocation());
}

######


@Test
public void saveEncounter_shouldSaveEncounterWithComplexObs() {
    executeDataSet(ENC_OBS_HIERARCHY_DATA_XML);
    EncounterService es = Context.getEncounterService();
    Encounter encounter = es.getEncounter(101);
    Obs observation = buildObs();
    observation.setLocation(encounter.getLocation());
    observation.setPerson(encounter.getPatient());
    encounter.addObs(observation);
    es.saveEncounter(encounter);
    Context.flushSession();
    Context.clearSession();
    encounter = es.getEncounter(101);
    assertEquals(2, encounter.getObsAtTopLevel(true).size());
}

######


private Encounter buildEncounter() {
    Encounter enc = new Encounter();
    enc.setLocation(Context.getLocationService().getLocation(1));
    enc.setEncounterType(Context.getEncounterService().getEncounterType(1));
    enc.setEncounterDatetime(new Date());
    enc.setPatient(Context.getPatientService().getPatient(3));
    enc.addProvider(Context.getEncounterService().getEncounterRole(1), Context.getProviderService().getProvider(1));
    return enc;
}

######


@Test
public void saveEncounter_shouldNotCascadeLocationChangeForDifferentInitialLocations() {
    EncounterService es = Context.getEncounterService();
    Encounter enc = buildEncounter();
    es.saveEncounter(enc);
    Obs newObs = buildObs();
    enc.addObs(newObs);
    es.saveEncounter(enc);
    enc.setLocation(new Location(2));
    es.saveEncounter(enc);
    assertNotSame(enc.getLocation(), newObs.getLocation());
}

######


private Obs buildObs() {
    Obs newObs = new Obs();
    newObs.setConcept(Context.getConceptService().getConcept(1));
    newObs.setValueNumeric(50d);
    newObs.setLocation(new Location(2));
    return newObs;
}

######


@Test
public void saveEncounter_shouldSetDateStoppedOnTheOriginalAfterAddingReviseOrder() {
    EncounterService es = Context.getEncounterService();
    TestOrder order = (TestOrder) Context.getOrderService().getOrder(7);
    Assert.assertNull(order.getDateStopped());
    Encounter encounter = es.getEncounter(6);
    TestOrder reviseOrder = order.cloneForRevision();
    reviseOrder.setOrderer(Context.getProviderService().getProvider(1));
    encounter.addOrder(reviseOrder);
    es.saveEncounter(encounter);
    Context.flushSession();
    Context.clearSession();
    Date dateStopped = Context.getOrderService().getOrder(7).getDateStopped();
    Assert.assertNotNull(dateStopped);
}

######


@Test
public void saveEncounter_shouldNotCascadeToExistingOrder() {
    EncounterService es = Context.getEncounterService();
    TestOrder order = (TestOrder) Context.getOrderService().getOrder(7);
    order.setVoided(true);
    Encounter encounter = es.getEncounter(6);
    es.saveEncounter(encounter);
    String sql = "SELECT voided FROM orders WHERE order_id=7";
    Boolean voided = (Boolean) Context.getAdministrationService().executeSQL(sql, true).get(0).get(0);
    Assert.assertFalse(voided);
}

######


@Test
public void purgeEncounter_shouldPurgeEncounter() {
    EncounterService es = Context.getEncounterService();
    Encounter encounterToDelete = es.getEncounter(1);
    es.purgeEncounter(encounterToDelete);
    Encounter e = es.getEncounter(encounterToDelete.getEncounterId());
    assertNull("We shouldn't find the encounter after deletion", e);
}

######


@Test
public void purgeEncounter_shouldCascadePurgeToObsAndOrders() {
    EncounterService es = Context.getEncounterService();
    Encounter encounterToDelete = es.getEncounter(1);
    es.purgeEncounter(encounterToDelete, true);
    Encounter e = es.getEncounter(encounterToDelete.getEncounterId());
    assertNull("We shouldn't find the encounter after deletion", e);
    ObsService obsService = Context.getObsService();
    assertNull(obsService.getObs(1));
    assertNull(obsService.getObs(2));
    assertNull(obsService.getObs(3));
    assertNull(Context.getOrderService().getOrder(1));
}

######


@Test
public void saveEncounter_shouldCascadeSaveToContainedObsWhenEncounterAlreadyExists() {
    EncounterService es = Context.getEncounterService();
    Encounter encounter = es.getEncounter(1);
    assertNotNull(encounter.getEncounterDatetime());
    Obs obs = new Obs();
    obs.setConcept(Context.getConceptService().getConcept(1));
    obs.setValueNumeric(50d);
    obs.setObsDatetime(new Date());
    encounter.addObs(obs);
    assertNull(obs.getObsId());
    es.saveEncounter(encounter);
    assertNotNull(obs.getObsId());
}

######


@Test
public void saveEncounter_shouldCascadeEncounterDatetimeToObs() {
    EncounterService es = Context.getEncounterService();
    Encounter encounter = es.getEncounter(1);
    assertNotNull(encounter.getEncounterDatetime());
    Obs obs = new Obs();
    obs.setConcept(Context.getConceptService().getConcept(1));
    obs.setValueNumeric(50d);
    encounter.addObs(obs);
    es.saveEncounter(encounter);
    assertTrue(encounter.getEncounterDatetime().equals(obs.getObsDatetime()));
}

######


@Test
public void saveEncounter_shouldOnlyCascadeTheObsdatetimesToObsWithDifferentInitialObsdatetimes() {
    EncounterService es = Context.getEncounterService();
    Encounter enc = es.getEncounter(1);
    assertEquals(3, enc.getAllObs(false).size());
    List<Obs> obsWithSameDateBefore = new ArrayList<>();
    Obs obsWithDifferentDateBefore = null;
    for (Obs o : enc.getAllObs(false)) {
        if (enc.getEncounterDatetime().equals(o.getObsDatetime())) {
            obsWithSameDateBefore.add(o);
        } else if (obsWithDifferentDateBefore == null) {
            obsWithDifferentDateBefore = o;
        }
    }
    assertNotNull(obsWithDifferentDateBefore);
    assertEquals(2, obsWithSameDateBefore.size());
    Date newDate = new Date();
    enc.setEncounterDatetime(newDate);
    es.saveEncounter(enc);
    Context.flushSession();
    List<Obs> obsWithSameDateAfter = new ArrayList<>();
    Obs obsWithDifferentDateAfter = null;
    for (Obs o : enc.getAllObs(false)) {
        if (enc.getEncounterDatetime().equals(o.getObsDatetime())) {
            obsWithSameDateAfter.add(o);
            assertTrue(obsWithSameDateBefore.contains(o.getPreviousVersion()));
        } else if (obsWithDifferentDateAfter == null) {
            obsWithDifferentDateAfter = o;
        }
    }
    assertNotNull(obsWithDifferentDateAfter);
    assertEquals(2, obsWithSameDateAfter.size());
    assertNull(obsWithDifferentDateAfter.getPreviousVersion());
    assertSame(obsWithDifferentDateBefore, obsWithDifferentDateAfter);
}

######


@Test
public void saveEncounter_shouldNotOverwriteCreatorIfNonNull() {
    EncounterService encounterService = Context.getEncounterService();
    Encounter encounter = buildEncounter();
    encounter.setCreator(new User(4));
    assertNotSame(encounter.getCreator(), Context.getAuthenticatedUser());
    encounterService.saveEncounter(encounter);
    assertEquals(4, encounter.getCreator().getId().intValue());
    Encounter newEncounter = encounterService.getEncounter(encounter.getEncounterId());
    assertNotNull(newEncounter);
    assertEquals(4, encounter.getCreator().getId().intValue());
    assertNotSame(encounter.getCreator(), Context.getAuthenticatedUser());
}

######


@Test
public void saveEncounter_shouldNotOverwriteDateCreatedIfNonNull() {
    EncounterService encounterService = Context.getEncounterService();
    Encounter encounter = buildEncounter();
    encounter.setCreator(new User(4));
    Date date = new Date(System.currentTimeMillis() - 5000);
    encounter.setDateCreated(date);
    encounterService.saveEncounter(encounter);
    assertEquals(4, encounter.getCreator().getId().intValue());
    assertNotSame(encounter.getCreator(), Context.getAuthenticatedUser());
    assertEquals(DateUtil.truncateToSeconds(date), encounter.getDateCreated());
    Encounter newEncounter = encounterService.getEncounter(encounter.getEncounterId());
    assertNotNull(newEncounter);
    assertEquals(DateUtil.truncateToSeconds(date), encounter.getDateCreated());
}

######


@Test
public void saveEncounter_shouldNotOverwriteObsAndOrdersCreatorOrDateCreated() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {
    EncounterService encounterService = Context.getEncounterService();
    Encounter encounter = buildEncounter();
    Date date = new Date(System.currentTimeMillis() - 5000);
    encounter.setDateCreated(date);
    User creator = new User(1);
    encounter.setCreator(creator);
    ConceptService cs = Context.getConceptService();
    Obs obs = new Obs(new Patient(2), cs.getConcept(1), new Date(), new Location(1));
    obs.setDateCreated(date);
    obs.setCreator(creator);
    obs.setValueNumeric(50d);
    encounter.addObs(obs);
    OrderService os = Context.getOrderService();
    TestOrder order = new TestOrder();
    order.setConcept(Context.getConceptService().getConcept(5497));
    order.setPatient(new Patient(2));
    order.setDateActivated(new Date());
    order.setOrderType(os.getOrderType(2));
    order.setOrderer(Context.getProviderService().getProvider(1));
    Field field = Order.class.getDeclaredField("orderNumber");
    field.setAccessible(true);
    field.set(order, "ORD-1");
    order.setDateCreated(date);
    order.setCreator(creator);
    order.setCareSetting(os.getCareSetting(1));
    encounter.addOrder(order);
    assertNotSame(encounter.getCreator(), Context.getAuthenticatedUser());
    encounterService.saveEncounter(encounter);
    Obs createdObs = Context.getObsService().getObs(obs.getObsId());
    assertEquals(DateUtil.truncateToSeconds(date), createdObs.getDateCreated());
    assertEquals(creator, createdObs.getCreator());
    Order createdOrder = os.getOrder(order.getOrderId());
    assertEquals(DateUtil.truncateToSeconds(date), createdOrder.getDateCreated());
    assertEquals(creator, createdOrder.getCreator());
}

######


@Test
public void getEncountersByPatient_shouldNotGetVoidedEncounters() {
    EncounterService encounterService = Context.getEncounterService();
    List<Encounter> encounters = encounterService.getEncountersByPatient(new Patient(3));
    assertEquals(2, encounters.size());
}

######


@Test(expected = IllegalArgumentException.class)
public void getEncountersByPatient_shouldThrowErrorWhenGivenNullParameter() {
    Context.getEncounterService().getEncountersByPatient((Patient) null);
}

######


@Test
public void getEncountersByPatientId_shouldNotGetVoidedEncounters() {
    EncounterService encounterService = Context.getEncounterService();
    List<Encounter> encounters = encounterService.getEncountersByPatientId(3);
    assertEquals(2, encounters.size());
}

######


@Test(expected = IllegalArgumentException.class)
public void getEncountersByPatientId_shouldThrowErrorIfGivenANullParameter() {
    Context.getEncounterService().getEncountersByPatientId(null);
}

######


@Test
public void getEncountersByPatientIdentifier_shouldNotGetVoidedEncounters() {
    EncounterService encounterService = Context.getEncounterService();
    List<Encounter> encounters = encounterService.getEncountersByPatientIdentifier("12345");
    assertEquals(2, encounters.size());
}

######


@Test(expected = IllegalArgumentException.class)
public void getEncountersByPatientIdentifier_shouldThrowErrorIfGivenNullParameter() {
    Context.getEncounterService().getEncountersByPatientIdentifier(null);
}

######


@Test
public void voidEncounter_shouldVoidEncounterAndSetAttributes() {
    EncounterService encounterService = Context.getEncounterService();
    Encounter encounter = encounterService.getEncounter(1);
    assertFalse(encounter.getVoided());
    assertNull(encounter.getVoidedBy());
    assertNull(encounter.getVoidReason());
    assertNull(encounter.getDateVoided());
    Encounter voidedEnc = encounterService.voidEncounter(encounter, "Just Testing");
    assertEquals(voidedEnc, encounter);
    assertTrue(voidedEnc.getVoided());
    assertNotNull(voidedEnc.getDateVoided());
    assertEquals(Context.getAuthenticatedUser(), voidedEnc.getVoidedBy());
    assertEquals("Just Testing", voidedEnc.getVoidReason());
}

######


@Test
public void voidEncounter_shouldCascadeToObs() {
    EncounterService encounterService = Context.getEncounterService();
    Encounter encounter = encounterService.getEncounter(1);
    encounterService.voidEncounter(encounter, "Just Testing");
    Obs obs = Context.getObsService().getObs(1);
    assertTrue(obs.getVoided());
    assertEquals("Just Testing", obs.getVoidReason());
}

######


@Test
public void voidEncounter_shouldCascadeToOrders() {
    EncounterService encounterService = Context.getEncounterService();
    Encounter encounter = encounterService.getEncounter(1);
    encounterService.voidEncounter(encounter, "Just Testing");
    Order order = Context.getOrderService().getOrder(1);
    assertTrue(order.getVoided());
    assertEquals("Just Testing", order.getVoidReason());
}

######


@Test
public void unvoidEncounter_shouldCascadeUnvoidToObs() {
    EncounterService encounterService = Context.getEncounterService();
    Encounter encounter = encounterService.getEncounter(2);
    encounterService.unvoidEncounter(encounter);
    Obs obs = Context.getObsService().getObs(4);
    assertFalse(obs.getVoided());
    assertNull(obs.getVoidReason());
}

######


@Test
public void unvoidEncounter_shouldCascadeUnvoidToOrders() {
    EncounterService encounterService = Context.getEncounterService();
    Encounter encounter = encounterService.getEncounter(2);
    encounterService.unvoidEncounter(encounter);
    Order order = Context.getOrderService().getOrder(2);
    assertFalse(order.getVoided());
    assertNull(order.getVoidReason());
}

######


@Test(expected = IllegalArgumentException.class)
public void voidEncounter_shouldThrowErrorWithNullReasonParameter() {
    EncounterService encounterService = Context.getEncounterService();
    Encounter type = encounterService.getEncounter(1);
    encounterService.voidEncounter(type, null);
}

######


@Test
public void unvoidEncounter_shouldUnvoidAndUnmarkAllAttributes() {
    EncounterService encounterService = Context.getEncounterService();
    Encounter encounter = encounterService.getEncounter(2);
    assertTrue(encounter.getVoided());
    assertNotNull(encounter.getVoidedBy());
    assertNotNull(encounter.getVoidReason());
    assertNotNull(encounter.getDateVoided());
    Encounter unvoidedEnc = encounterService.unvoidEncounter(encounter);
    assertEquals(unvoidedEnc, encounter);
    assertFalse(unvoidedEnc.getVoided());
    assertNull(unvoidedEnc.getDateVoided());
    assertNull(unvoidedEnc.getVoidedBy());
    assertNull(unvoidedEnc.getVoidReason());
}

######


@Test
public void getEncounters_shouldGetEncountersByLocation() {
    EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setLocation(new Location(1)).setIncludeVoided(true).createEncounterSearchCriteria();
    List<Encounter> encounters = Context.getEncounterService().getEncounters(encounterSearchCriteria);
    assertEquals(6, encounters.size());
}

######


@Test
public void getEncounters_shouldGetEncountersOnOrAfterDate() throws ParseException {
    DateFormat ymd = new SimpleDateFormat("yyyy-MM-dd");
    EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setFromDate(ymd.parse("2004-12-31")).setIncludeVoided(false).createEncounterSearchCriteria();
    List<Encounter> encounters = Context.getEncounterService().getEncounters(encounterSearchCriteria);
    assertEquals(5, encounters.size());
    assertEquals(1, encounters.get(0).getEncounterId().intValue());
    encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setFromDate(ymd.parse("2005-01-01")).setIncludeVoided(false).createEncounterSearchCriteria();
    encounters = Context.getEncounterService().getEncounters(encounterSearchCriteria);
    assertEquals(5, encounters.size());
    encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setFromDate(ymd.parse("2005-01-02")).setIncludeVoided(false).createEncounterSearchCriteria();
    encounters = Context.getEncounterService().getEncounters(encounterSearchCriteria);
    assertEquals(4, encounters.size());
    assertEquals(3, encounters.get(0).getEncounterId().intValue());
    assertEquals(4, encounters.get(1).getEncounterId().intValue());
    assertEquals(5, encounters.get(2).getEncounterId().intValue());
}

######


@Test
public void getEncounters_shouldGetEncountersOnOrUpToADate() throws ParseException {
    Date toDate = new SimpleDateFormat("yyyy-dd-MM").parse("2006-01-01");
    EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setToDate(toDate).setIncludeVoided(true).createEncounterSearchCriteria();
    List<Encounter> encounters = Context.getEncounterService().getEncounters(encounterSearchCriteria);
    assertEquals(2, encounters.size());
    assertEquals(15, encounters.get(0).getEncounterId().intValue());
    assertEquals(1, encounters.get(1).getEncounterId().intValue());
}

######


@Test
public void getEncounters_shouldGetEncountersByForm() {
    List<Form> forms = new ArrayList<>();
    forms.add(new Form(1));
    EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setEnteredViaForms(forms).setIncludeVoided(true).createEncounterSearchCriteria();
    List<Encounter> encounters = Context.getEncounterService().getEncounters(encounterSearchCriteria);
    assertEquals(8, encounters.size());
}

######


@Test
public void getEncounters_shouldGetEncountersByType() {
    List<EncounterType> types = new ArrayList<>();
    types.add(new EncounterType(1));
    EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setEncounterTypes(types).setIncludeVoided(true).createEncounterSearchCriteria();
    List<Encounter> encounters = Context.getEncounterService().getEncounters(encounterSearchCriteria);
    assertEquals(7, encounters.size());
}

######


@Test
public void getEncounters_shouldExcludeVoidedEncounters() {
    EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setIncludeVoided(false).createEncounterSearchCriteria();
    assertEquals(6, Context.getEncounterService().getEncounters(encounterSearchCriteria).size());
}

######


@Test
public void getEncounters_shouldGetEncountersModifiedAfterSpecifiedDate() throws ParseException {
    EncounterService encounterService = Context.getEncounterService();
    Assert.assertEquals(7, encounterService.getEncounters(encounterSearchForVoidedWithDateChanged("2006-01-01")).size());
    Assert.assertEquals(5, encounterService.getEncounters(encounterSearchForVoidedWithDateChanged("2008-06-01")).size());
    Assert.assertEquals(1, encounterService.getEncounters(encounterSearchForVoidedWithDateChanged("2010-01-01")).size());
}

######


@Test
public void getEncounters_shouldIncludeVoidedEncounters() {
    EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setIncludeVoided(true).createEncounterSearchCriteria();
    assertEquals(8, Context.getEncounterService().getEncounters(encounterSearchCriteria).size());
}

######


@Test
public void saveEncounterType_shouldSaveEncounterType() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType encounterType = new EncounterType("testing", "desc");
    encounterService.saveEncounterType(encounterType);
    assertNotNull(encounterType.getEncounterTypeId());
    EncounterType newEncounterType = encounterService.getEncounterType(encounterType.getEncounterTypeId());
    assertNotNull(newEncounterType);
}

######


@Test
public void saveEncounterType_shouldNotOverwriteCreator() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType encounterType = new EncounterType("testing", "desc");
    encounterType.setCreator(new User(4));
    assertNotSame(encounterType.getCreator(), Context.getAuthenticatedUser());
    encounterService.saveEncounterType(encounterType);
    assertEquals(4, encounterType.getCreator().getId().intValue());
    assertNotSame(encounterType.getCreator(), Context.getAuthenticatedUser());
    EncounterType newEncounterType = encounterService.getEncounterType(encounterType.getEncounterTypeId());
    assertNotNull(newEncounterType);
    assertEquals(4, encounterType.getCreator().getId().intValue());
    assertNotSame(encounterType.getCreator(), Context.getAuthenticatedUser());
}

######


@Test
public void saveEncounterType_shouldNotOverwriteCreatorOrDateCreated() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType encounterType = new EncounterType("testing", "desc");
    encounterType.setCreator(new User(4));
    Date date = new Date(System.currentTimeMillis() - 5000);
    encounterType.setDateCreated(date);
    assertNotSame(encounterType.getCreator(), Context.getAuthenticatedUser());
    encounterService.saveEncounterType(encounterType);
    assertNotSame(encounterType.getCreator().getId(), Context.getAuthenticatedUser().getId());
    assertEquals(DateUtil.truncateToSeconds(date), encounterType.getDateCreated());
    EncounterType newEncounterType = encounterService.getEncounterType(encounterType.getEncounterTypeId());
    assertNotNull(newEncounterType);
    assertEquals(4, encounterType.getCreator().getId().intValue());
    assertNotSame(encounterType.getCreator(), Context.getAuthenticatedUser());
    assertEquals(DateUtil.truncateToSeconds(date), encounterType.getDateCreated());
}

######


@Test
public void saveEncounterType_shouldNotOverwriteDateCreated() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType encounterType = new EncounterType();
    encounterType.setName("testing");
    encounterType.setDescription("desc");
    Date date = new Date(System.currentTimeMillis() - 5000);
    encounterType.setDateCreated(date);
    encounterService.saveEncounterType(encounterType);
    assertEquals(DateUtil.truncateToSeconds(date), encounterType.getDateCreated());
    EncounterType newEncounterType = encounterService.getEncounterType(encounterType.getEncounterTypeId());
    assertNotNull(newEncounterType);
    assertEquals(DateUtil.truncateToSeconds(date), encounterType.getDateCreated());
}

######


@Test
public void saveEncounterType_shouldSetAuditInfoIfAnyItemInEncounterTypeIsEdited() {
    EncounterService es = Context.getEncounterService();
    EncounterType encounterType = es.saveEncounterType(new EncounterType("testing", "desc"));
    User creator = encounterType.getCreator();
    Date dateCreated = encounterType.getDateCreated();
    assertNotNull("creator should be set after saving", creator);
    assertNotNull("date creates should be set after saving", dateCreated);
    assertNull("changed by should not be set after creation", encounterType.getChangedBy());
    assertNull("date changed should not be set after creation", encounterType.getDateChanged());
    encounterType.setDescription("This has been a test!");
    EncounterType editedEt = es.saveEncounterType(encounterType);
    Context.flushSession();
    assertTrue("creator should not change during edit", creator.equals(editedEt.getCreator()));
    assertTrue("date created should not changed during edit", dateCreated.equals(editedEt.getDateCreated()));
    assertNotNull("changed by should be set after edit", editedEt.getChangedBy());
    assertNotNull("date changed should be set after edit", editedEt.getDateChanged());
}

######


@Test
public void getEncounterType_shouldNotGetRetiredTypes() {
    EncounterService encounterService = Context.getEncounterService();
    boolean foundRetired = false;
    for (EncounterType encType : encounterService.getAllEncounterTypes(true)) {
        if (encType.getName().equals("Test Enc Type C") && encType.getRetired()) {
            foundRetired = true;
        }
    }
    assertTrue(foundRetired);
    assertNull(encounterService.getEncounterType("Test Enc Type C"));
}

######


@Test
public void getEncounterType_shouldReturnNullIfOnlyRetiredTypeFound() {
    EncounterService encounterService = Context.getEncounterService();
    assertTrue(encounterService.getEncounterType(4).getRetired());
    assertEquals("Some Retired Type", encounterService.getEncounterType(4).getName());
    EncounterType type = encounterService.getEncounterType("Some Retired Type");
    assertNull(type);
}

######


@Test
public void getEncounterType_shouldNotGetByInexactName() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType type = encounterService.getEncounterType("Test Enc Type A");
    assertEquals(2, type.getEncounterTypeId().intValue());
    EncounterType typeByInExactName = encounterService.getEncounterType("Test Enc");
    assertNull(typeByInExactName);
}

######


@Test
public void getEncounterType_shouldReturnNullWithNullNameParameter() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType type = encounterService.getEncounterType((String) null);
    assertNull(type);
}

######


@Test
public void getAllEncounterTypes_shouldNotReturnRetiredTypes() {
    EncounterService encounterService = Context.getEncounterService();
    List<EncounterType> encounterTypes = encounterService.getAllEncounterTypes(false);
    assertNotNull(encounterTypes);
    assertEquals(2, encounterTypes.size());
}

######


@Test
public void getAllEncounterTypes_shouldIncludeRetiredTypesWithTrueIncludeRetiredParameter() {
    EncounterService encounterService = Context.getEncounterService();
    boolean foundRetired = false;
    List<EncounterType> types = encounterService.getAllEncounterTypes(true);
    assertEquals(5, types.size());
    for (EncounterType type : types) {
        if (type.getRetired())
            foundRetired = true;
    }
    assertTrue("Retired types should be returned as well", foundRetired);
}

######


@Test
public void findEncounterTypes_shouldReturnTypesByPartialNameMatch() {
    EncounterService encounterService = Context.getEncounterService();
    List<EncounterType> types = encounterService.findEncounterTypes("Test Enc");
    assertEquals(3, types.size());
}

######


@Test
public void findEncounterTypes_shouldReturnTypesByPartialCaseInsensitiveMatch() {
    EncounterService encounterService = Context.getEncounterService();
    List<EncounterType> types = encounterService.findEncounterTypes("Test ENC");
    assertEquals(3, types.size());
}

######


@Test
public void findEncounterTypes_shouldIncludeRetiredTypesInTheResults() {
    EncounterService encounterService = Context.getEncounterService();
    List<EncounterType> types = encounterService.findEncounterTypes("Test Enc");
    assertEquals(3, types.size());
    boolean foundRetired = false;
    for (EncounterType type : types) {
        if (type.getRetired())
            foundRetired = true;
    }
    assertTrue("Retired types should be returned as well", foundRetired);
}

######


@Test
public void findEncounterTypes_shouldNotPartialMatchNameOnInternalSubstrings() {
    EncounterService encounterService = Context.getEncounterService();
    List<EncounterType> types = encounterService.findEncounterTypes("Test Enc Type");
    assertEquals(3, types.size());
    types = encounterService.findEncounterTypes("Enc Type");
    assertEquals(0, types.size());
}

######


@Test
public void findEncounterTypes_shouldReturnTypesOrderedOnNameAndNonretiredFirst() {
    EncounterService encounterService = Context.getEncounterService();
    List<EncounterType> types = encounterService.findEncounterTypes("Test Enc");
    assertEquals(2, types.get(0).getEncounterTypeId().intValue());
    assertEquals(1, types.get(1).getEncounterTypeId().intValue());
    assertEquals(3, types.get(2).getEncounterTypeId().intValue());
}

######


@Test
public void retireEncounterType_shouldRetireTypeAndSetAttributes() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType type = encounterService.getEncounterType(1);
    assertFalse(type.getRetired());
    assertNull(type.getRetiredBy());
    assertNull(type.getRetireReason());
    assertNull(type.getDateRetired());
    EncounterType retiredEncType = encounterService.retireEncounterType(type, "Just Testing");
    assertEquals(retiredEncType, type);
    assertTrue(retiredEncType.getRetired());
    assertNotNull(retiredEncType.getDateRetired());
    assertEquals(Context.getAuthenticatedUser(), retiredEncType.getRetiredBy());
    assertEquals("Just Testing", retiredEncType.getRetireReason());
}

######


@Test(expected = IllegalArgumentException.class)
public void retireEncounterType_shouldThrowErrorIfGivenNullReasonParameter() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType type = encounterService.getEncounterType(1);
    encounterService.retireEncounterType(type, null);
}

######


@Test
public void unretireEncounterType_shouldUnretireTypeAndUnmarkAttributes() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType type = encounterService.getEncounterType(3);
    assertTrue(type.getRetired());
    assertNotNull(type.getRetiredBy());
    assertNotNull(type.getRetireReason());
    assertNotNull(type.getDateRetired());
    EncounterType unretiredEncType = encounterService.unretireEncounterType(type);
    assertEquals(unretiredEncType, type);
    assertFalse(unretiredEncType.getRetired());
    assertNull(unretiredEncType.getDateRetired());
    assertNull(unretiredEncType.getRetiredBy());
    assertNull(unretiredEncType.getRetireReason());
}

######


@Test
public void saveEncounterType_shouldUpdateAnExistingEncounterTypeName() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType encounterTypeToChange = encounterService.getEncounterType(1);
    encounterTypeToChange.setName("another test");
    encounterService.saveEncounterType(encounterTypeToChange);
    assertEquals(1, encounterTypeToChange.getEncounterTypeId().intValue());
    EncounterType fetchedEncounterType = encounterService.getEncounterType(1);
    assertTrue(fetchedEncounterType.getName().equals("another test"));
}

######


@Test
public void purgeEncounterType_shouldPurgeType() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType encounterTypeToPurge = encounterService.getEncounterType(4);
    assertNotNull(encounterTypeToPurge);
    encounterService.purgeEncounterType(encounterTypeToPurge);
    assertNull(encounterService.getEncounterType(4));
}

######


@Test(expected = IllegalArgumentException.class)
public void getEncounter_shouldThrowErrorIfGivenNullParameter() {
    Context.getEncounterService().getEncounter(null);
}

######


@Test(expected = IllegalArgumentException.class)
public void getEncounterType_shouldThrowErrorIfGivenNullParameter() {
    Context.getEncounterService().getEncounterType((Integer) null);
}

######


@Test
public void saveEncounter_shouldCascadePatientToOrdersInTheEncounter() {
    Encounter enc = Context.getEncounterService().getEncounter(15);
    Order existing = enc.getOrders().iterator().next();
    Assert.assertNotSame(enc.getPatient().getId(), existing.getPatient().getId());
    Context.getEncounterService().saveEncounter(enc);
    Assert.assertEquals(enc.getPatient().getId(), existing.getPatient().getId());
}

######


@Test
public void getEncounterByUuid_shouldFindObjectGivenValidUuid() {
    String uuid = "6519d653-393b-4118-9c83-a3715b82d4ac";
    Encounter encounter = Context.getEncounterService().getEncounterByUuid(uuid);
    Assert.assertEquals(3, (int) encounter.getEncounterId());
}

######


@Test
public void getEncounterByUuid_shouldReturnNullIfNoObjectFoundWithGivenUuid() {
    Assert.assertNull(Context.getEncounterService().getEncounterByUuid("some invalid uuid"));
}

######


@Test
public void getEncounterTypeByUuid_shouldFindObjectGivenValidUuid() {
    String uuid = "02c533ab-b74b-4ee4-b6e5-ffb6d09a0ac8";
    EncounterType encounterType = Context.getEncounterService().getEncounterTypeByUuid(uuid);
    Assert.assertEquals(6, (int) encounterType.getEncounterTypeId());
}

######


@Test
public void getEncounterTypeByUuid_shouldReturnNullIfNoObjectFoundWithGivenUuid() {
    Assert.assertNull(Context.getEncounterService().getEncounterTypeByUuid("some invalid uuid"));
}

######


@Test
public void getEncountersByPatient_shouldGetAllUnvoidedEncountersForTheGivenPatientIdentifier() {
    EncounterService encounterService = Context.getEncounterService();
    List<Encounter> encounters = encounterService.getEncountersByPatient("12345", false);
    assertEquals(2, encounters.size());
}

######


@Test
public void getEncountersByPatient_shouldGetAllUnvoidedEncountersForTheGivenPatientName() {
    EncounterService encounterService = Context.getEncounterService();
    List<Encounter> encounters = encounterService.getEncountersByPatient("John", false);
    assertEquals(3, encounters.size());
}

######


@Test
public void getEncountersByPatient_shouldIncludeVoidedEncountersInTheReturnedListIfIncludedVoidedIsTrue() {
    EncounterService encounterService = Context.getEncounterService();
    List<Encounter> encounters = encounterService.getEncountersByPatient("12345", true);
    assertEquals(4, encounters.size());
}

######


@Test(expected = IllegalArgumentException.class)
public void getEncountersByPatient_shouldThrowErrorIfGivenNullParameter() {
    Context.getEncounterService().getEncountersByPatient(null, false);
}

######


@Test
public void getAllEncounters_shouldGetAllEncountersForACohortOfPatients() {
    Cohort cohort = new Cohort();
    cohort.addMember(7);
    Map<Integer, List<Encounter>> allEncounters = Context.getEncounterService().getAllEncounters(cohort);
    Assert.assertEquals(1, allEncounters.size());
    Assert.assertEquals(3, allEncounters.get(7).size());
}

######


@Test
public void getEncounters_shouldGetEncountersByVisit() {
    List<Visit> visits = new ArrayList<>();
    visits.add(new Visit(1));
    EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setVisits(visits).setIncludeVoided(true).createEncounterSearchCriteria();
    List<Encounter> encounters = Context.getEncounterService().getEncounters(encounterSearchCriteria);
    assertEquals(2, encounters.size());
}

######


@Test
public void getEncounters_shouldGetEncountersByVisitType() {
    List<VisitType> visitTypes = new ArrayList<>();
    visitTypes.add(new VisitType(2));
    EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setVisitTypes(visitTypes).setIncludeVoided(true).createEncounterSearchCriteria();
    List<Encounter> encounters = Context.getEncounterService().getEncounters(encounterSearchCriteria);
    assertEquals(2, encounters.size());
}

######


@Test
public void getEncountersByVisit_shouldGetActiveEncountersByVisit() {
    List<Encounter> encounters = Context.getEncounterService().getEncountersByVisit(new Visit(1), false);
    assertEquals(1, encounters.size());
}

######


@Test
public void getEncountersByVisit_shouldIncludeVoidedEncountersWhenIncludeVoidedIsTrue() {
    List<Encounter> encounters = Context.getEncounterService().getEncountersByVisit(new Visit(1), true);
    assertEquals(2, encounters.size());
}

######


@Test
public void getCountOfEncounters_shouldGetTheCorrectCountOfUniqueEncounters() {
    executeDataSet(UNIQUE_ENC_WITH_PAGING_XML);
    Assert.assertEquals(4, Context.getEncounterService().getCountOfEncounters("qwerty", true).intValue());
}

######


@Test
@Ignore
public void getEncounters_shouldGetAllTheUniqueEncountersThatMatchTheSpecifiedParameterValues() {
    executeDataSet(UNIQUE_ENC_WITH_PAGING_XML);
    List<Encounter> encs = Context.getEncounterService().getEncounters("qwerty", 0, 4, true);
    Assert.assertEquals(4, encs.size());
}

######


@Test
@Ignore
public void getEncounters_shouldNotReturnVoidedEncountersIfIncludeVoidedIsSetToTrue() {
    executeDataSet(UNIQUE_ENC_WITH_PAGING_XML);
    List<Encounter> encs = Context.getEncounterService().getEncounters("qwerty", 0, 3, false);
    Assert.assertEquals(3, encs.size());
}

######


@Test
public void saveEncounterRole_shouldSaveEncounterRoleWithBasicDetails() {
    EncounterRole encounterRole = new EncounterRole();
    encounterRole.setName("Attending physician");
    encounterRole.setDescription("The person in charge");
    EncounterService encounterService = Context.getEncounterService();
    encounterService.saveEncounterRole(encounterRole);
    assertNotNull("The saved encounter role should have an encounter role id now", encounterRole.getEncounterRoleId());
    EncounterRole newSavedEncounterRole = encounterService.getEncounterRole(encounterRole.getEncounterRoleId());
    assertNotNull("We should get back an encounter role", newSavedEncounterRole);
    assertEquals(encounterRole, newSavedEncounterRole);
    assertTrue("The created encounter role needs to equal the pojo encounter role", encounterRole.equals(newSavedEncounterRole));
}

######


@Test
public void purgeEncounterRole_shouldPurgeEncounterRole() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterRole encounterRole = encounterService.getEncounterRole(1);
    encounterService.purgeEncounterRole(encounterRole);
    EncounterRole fetchedEncounterRole = encounterService.getEncounterRole(encounterRole.getEncounterRoleId());
    assertNull("We shouldn't find the encounter after deletion", fetchedEncounterRole);
}

######


@Test
public void getAllEncounterRoles_shouldGetAllEncounterRolesBasedOnIncludeRetiredFlag() {
    EncounterService encounterService = Context.getEncounterService();
    List<EncounterRole> encounterRoles = encounterService.getAllEncounterRoles(true);
    assertEquals("get all encounter roles including retired", 3, encounterRoles.size());
    encounterRoles = encounterService.getAllEncounterRoles(false);
    assertEquals("get all encounter roles excluding retired", 2, encounterRoles.size());
}

######


@Test
public void getEncounterRoleByUuid_shouldFindEncounterRoleBasedOnUuid() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterRole encounterRole = encounterService.getEncounterRoleByUuid("430bbb70-6a9c-4e1e-badb-9d1054b1b5e9");
    assertNotNull("valid uuid should be returned", encounterRole);
    encounterRole = encounterService.getEncounterRoleByUuid("invaid uuid");
    assertNull("returns null for invalid uuid", encounterRole);
}

######


@Test
public void getEncounterRoleByName_shouldFindEncounterRoleByName() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterRole encounterRole = new EncounterRole();
    String name = "surgeon role";
    encounterRole.setDescription("The surgeon");
    encounterRole.setName(name);
    encounterRole = encounterService.saveEncounterRole(encounterRole);
    EncounterRole retrievedEncounterRole = encounterService.getEncounterRoleByName(name);
    assertNotNull("valid EncounterRole object should be returned", retrievedEncounterRole);
    assertEquals(encounterRole.getUuid(), retrievedEncounterRole.getUuid());
}

######


@Test
public void retireEncounterRole_shouldRetireTypeAndSetAttributes() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterRole encounterRole = encounterService.getEncounterRole(1);
    assertFalse(encounterRole.getRetired());
    assertNull(encounterRole.getRetiredBy());
    assertNull(encounterRole.getRetireReason());
    assertNull(encounterRole.getDateRetired());
    EncounterRole retiredEncounterRole = encounterService.retireEncounterRole(encounterRole, "Just Testing");
    assertEquals(retiredEncounterRole, encounterRole);
    assertTrue(retiredEncounterRole.getRetired());
    assertNotNull(retiredEncounterRole.getDateRetired());
    assertEquals(Context.getAuthenticatedUser(), retiredEncounterRole.getRetiredBy());
    assertEquals("Just Testing", retiredEncounterRole.getRetireReason());
}

######


@Test(expected = IllegalArgumentException.class)
public void retireEncounterRole_shouldThrowErrorIfGivenNullReasonParameter() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterRole encounterRole = encounterService.getEncounterRole(1);
    encounterService.retireEncounterRole(encounterRole, null);
}

######


@Test
public void unretireEncounterRole_shouldUnretireTypeAndUnmarkAttributes() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterRole encounterRole = encounterService.getEncounterRole(2);
    assertTrue(encounterRole.getRetired());
    assertNotNull(encounterRole.getRetiredBy());
    assertNotNull(encounterRole.getRetireReason());
    assertNotNull(encounterRole.getDateRetired());
    EncounterRole unretiredEncounterRole = encounterService.unretireEncounterRole(encounterRole);
    assertEquals(unretiredEncounterRole, encounterRole);
    assertFalse(unretiredEncounterRole.getRetired());
    assertNull(unretiredEncounterRole.getDateRetired());
    assertNull(unretiredEncounterRole.getRetiredBy());
    assertNull(unretiredEncounterRole.getRetireReason());
}

######


@Test
public void saveEncounter_shouldCascadeDeleteEncounterProviders() {
    Encounter encounter = new Encounter();
    encounter.setLocation(new Location(1));
    encounter.setEncounterType(new EncounterType(1));
    encounter.setEncounterDatetime(new Date());
    encounter.setPatient(new Patient(3));
    EncounterRole role = new EncounterRole();
    role.setName("role");
    role = Context.getEncounterService().saveEncounterRole(role);
    Provider provider = new Provider();
    provider.setIdentifier("id1");
    provider.setPerson(newPerson("name"));
    provider = Context.getProviderService().saveProvider(provider);
    Provider provider2 = new Provider();
    provider2.setIdentifier("id2");
    provider2.setPerson(newPerson("name2"));
    provider2 = Context.getProviderService().saveProvider(provider2);
    encounter.addProvider(role, provider);
    encounter.addProvider(role, provider2);
    EncounterService es = Context.getEncounterService();
    es.saveEncounter(encounter);
    Context.flushSession();
    Context.clearSession();
    encounter = Context.getEncounterService().getEncounter(encounter.getEncounterId());
    encounter.setProvider(role, provider);
    es.saveEncounter(encounter);
    Context.flushSession();
    Context.clearSession();
    encounter = Context.getEncounterService().getEncounter(encounter.getEncounterId());
    Assert.assertEquals(1, encounter.getProvidersByRole(role).size());
    Assert.assertTrue("Role", encounter.getProvidersByRole(role).contains(provider));
}

######


@Test
public void saveEncounter_shouldCascadeSaveEncounterProviders() {
    Encounter encounter = new Encounter();
    encounter.setLocation(new Location(1));
    encounter.setEncounterType(new EncounterType(1));
    encounter.setEncounterDatetime(new Date());
    encounter.setPatient(new Patient(3));
    EncounterRole role = new EncounterRole();
    role.setName("role");
    role = Context.getEncounterService().saveEncounterRole(role);
    EncounterRole role2 = new EncounterRole();
    role2.setName("role2");
    role2 = Context.getEncounterService().saveEncounterRole(role2);
    Provider provider = new Provider();
    provider.setIdentifier("id1");
    provider.setPerson(newPerson("name1"));
    provider = Context.getProviderService().saveProvider(provider);
    Provider provider2 = new Provider();
    provider2.setIdentifier("id2");
    provider2.setPerson(newPerson("name2"));
    provider2 = Context.getProviderService().saveProvider(provider2);
    encounter.addProvider(role, provider);
    encounter.addProvider(role, provider2);
    encounter.addProvider(role2, provider2);
    EncounterService es = Context.getEncounterService();
    es.saveEncounter(encounter);
    Context.flushSession();
    Context.clearSession();
    encounter = Context.getEncounterService().getEncounter(encounter.getEncounterId());
    Assert.assertEquals(2, encounter.getProvidersByRole(role).size());
    Assert.assertTrue("Role", encounter.getProvidersByRole(role).containsAll(Arrays.asList(provider, provider2)));
    Assert.assertEquals(1, encounter.getProvidersByRole(role2).size());
    Assert.assertTrue("Role2", encounter.getProvidersByRole(role2).contains(provider2));
}

######


@Test
public void getEncounters_shouldReturnEmptyListForEmptyQuery() {
    List<Encounter> encounters = Context.getEncounterService().getEncounters("", null, null, true);
    Assert.assertTrue(encounters.isEmpty());
}

######


@Test
public void getVisitAssignmentHandlers_shouldReturnTheNoAssignmentHandler() {
    List<EncounterVisitHandler> handlers = Context.getEncounterService().getEncounterVisitHandlers();
    boolean found = false;
    for (EncounterVisitHandler handler : handlers) {
        if (handler instanceof NoVisitAssignmentHandler)
            found = true;
    }
    Assert.assertTrue("The basic 'no assignment' handler was not found", found);
}

######


@Test
public void getVisitAssignmentHandlers_shouldReturnTheExistingVisitOnlyAssignmentHandler() {
    List<EncounterVisitHandler> handlers = Context.getEncounterService().getEncounterVisitHandlers();
    boolean found = false;
    for (EncounterVisitHandler handler : handlers) {
        if (handler instanceof ExistingVisitAssignmentHandler) {
            found = true;
            break;
        }
    }
    Assert.assertTrue("The 'existing visit only assignment' handler was not found", found);
}

######


@Test
public void getVisitAssignmentHandlers_shouldReturnTheExistingOrNewVisitAssignmentHandler() {
    List<EncounterVisitHandler> handlers = Context.getEncounterService().getEncounterVisitHandlers();
    boolean found = false;
    for (EncounterVisitHandler handler : handlers) {
        if (handler instanceof ExistingOrNewVisitAssignmentHandler) {
            found = true;
            break;
        }
    }
    Assert.assertTrue("The 'existing or new visit only assignment' handler was not found", found);
}

######


@Test
public void saveEncounter_shouldNotAssignEncounterToVisitIfNoHandlerIsRegistered() {
    Encounter encounter = buildEncounter();
    assertNull(encounter.getVisit());
    Context.getEncounterService().saveEncounter(encounter);
    assertNull(encounter.getVisit());
}

######


@Test
public void saveEncounter_shouldNotAssignEncounterToVisitIfTheNoAssignHandlerIsRegistered() {
    Encounter encounter = buildEncounter();
    assertNull(encounter.getVisit());
    GlobalProperty gp = Context.getAdministrationService().getGlobalPropertyObject(OpenmrsConstants.GP_VISIT_ASSIGNMENT_HANDLER);
    gp.setPropertyValue("org.openmrs.api.handler.NoVisitAssignmentHandler");
    Context.getAdministrationService().saveGlobalProperty(gp);
    Context.getEncounterService().saveEncounter(encounter);
    assertNull(encounter.getVisit());
}

######


@Test
public void saveEncounter_shouldAssignEncounterToVisitIfTheAssignToExistingHandlerIsRegistered() {
    Encounter encounter = buildEncounter();
    assertNull(encounter.getVisit());
    GlobalProperty gp = Context.getAdministrationService().getGlobalPropertyObject(OpenmrsConstants.GP_VISIT_ASSIGNMENT_HANDLER);
    gp.setPropertyValue("org.openmrs.api.handler.ExistingVisitAssignmentHandler");
    Context.getAdministrationService().saveGlobalProperty(gp);
    Context.getEncounterService().saveEncounter(encounter);
    assertNotNull(encounter.getVisit());
    assertNotNull(encounter.getVisit().getVisitId());
}

######


@Test
public void saveEncounter_shouldAssignEncounterToVisitIfTheAssignToExistingOrNewHandlerIsRegistered() {
    Encounter encounter = new Encounter();
    encounter.setLocation(new Location(2));
    encounter.setEncounterType(new EncounterType(1));
    encounter.setEncounterDatetime(new Date());
    encounter.setPatient(new Patient(2));
    encounter.setCreator(new User(4));
    assertNull(encounter.getVisit());
    GlobalProperty gp = Context.getAdministrationService().getGlobalPropertyObject(OpenmrsConstants.GP_VISIT_ASSIGNMENT_HANDLER);
    gp.setPropertyValue("org.openmrs.api.handler.ExistingOrNewVisitAssignmentHandler");
    Context.getAdministrationService().saveGlobalProperty(gp);
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(encounter.getEncounterDatetime());
    calendar.set(Calendar.YEAR, 1900);
    encounter.setEncounterDatetime(calendar.getTime());
    Context.getEncounterService().saveEncounter(encounter);
    assertNotNull(encounter.getVisit());
    assertNotNull(encounter.getVisit().getVisitId());
}

######


@Test
public void getEncountersNotAssignedToAnyVisit_shouldReturnTheUnvoidedEncountersNotAssignedToAnyVisit() {
    executeDataSet(UNIQUE_ENC_WITH_PAGING_XML);
    List<Encounter> encs = Context.getEncounterService().getEncountersNotAssignedToAnyVisit(Context.getPatientService().getPatient(10));
    Assert.assertEquals(2, encs.size());
    Assert.assertNull(encs.get(0).getVisit());
    Assert.assertNull(encs.get(1).getVisit());
}

######


@Test
public void saveEncounter_shouldVoidAndCreateNewObsWhenSavingEncounter() {
    EncounterService es = Context.getEncounterService();
    Encounter encounter = new Encounter();
    encounter.setLocation(Context.getLocationService().getLocation(1));
    encounter.setEncounterType(es.getEncounterType(1));
    encounter.setEncounterDatetime(new Date());
    encounter.setPatient(Context.getPatientService().getPatient(3));
    Obs obs = new Obs();
    obs.setConcept(Context.getConceptService().getConcept(1));
    obs.setValueNumeric(50d);
    encounter.addObs(obs);
    es.saveEncounter(encounter);
    int oldObsId = obs.getObsId();
    obs.setValueNumeric(100d);
    encounter = es.saveEncounter(encounter);
    encounter = es.getEncounter(encounter.getEncounterId());
    int newObsId = encounter.getAllObs().iterator().next().getId();
    Assert.assertTrue(oldObsId != newObsId);
    Assert.assertEquals(2, encounter.getAllObs(true).size());
    Assert.assertEquals(1, encounter.getAllObs().size());
}

######


@Test
public void voidEncounter_shouldNotVoidProviders() {
    EncounterService encounterService = Context.getEncounterService();
    Encounter encounter = new Encounter();
    encounter.setLocation(new Location(1));
    encounter.setEncounterType(new EncounterType(1));
    encounter.setEncounterDatetime(new Date());
    encounter.setPatient(new Patient(3));
    EncounterRole role = new EncounterRole();
    role.setName("role");
    role = encounterService.saveEncounterRole(role);
    Provider provider = new Provider();
    provider.setIdentifier("id1");
    provider.setPerson(newPerson("name"));
    provider = Context.getProviderService().saveProvider(provider);
    encounter.addProvider(role, provider);
    encounterService.saveEncounter(encounter);
    assertEquals(1, encounter.getProvidersByRoles().size());
    encounterService.voidEncounter(encounter, "reason");
    encounter = encounterService.getEncounter(encounter.getEncounterId());
    assertEquals(1, encounter.getProvidersByRoles().size());
}

######


@Test
public void filterEncountersByViewPermissions_shouldFilterEncountersIfUserIsNotAllowedToSeeSomeEncounters() {
    EncounterService encounterService = Context.getEncounterService();
    int expectedSize = encounterService.getEncountersByPatientId(3).size();
    Encounter encounter = new Encounter();
    encounter.setLocation(new Location(1));
    encounter.setEncounterDatetime(new Date());
    encounter.setPatient(Context.getPatientService().getPatient(3));
    EncounterType encounterType = new EncounterType(1);
    encounterType.setViewPrivilege(Context.getUserService().getPrivilege("Some Privilege For View Encounter Types"));
    encounter.setEncounterType(encounterType);
    EncounterRole role = new EncounterRole();
    role.setName("role");
    role = encounterService.saveEncounterRole(role);
    Provider provider = new Provider();
    provider.setIdentifier("id1");
    provider.setPerson(newPerson("name"));
    provider = Context.getProviderService().saveProvider(provider);
    encounter.addProvider(role, provider);
    encounterService.saveEncounter(encounter);
    List<Encounter> patientEncounters = encounterService.getEncountersByPatientId(3);
    assertEquals(expectedSize + 1, patientEncounters.size());
    if (Context.isAuthenticated()) {
        Context.logout();
    }
    Context.authenticate("test_user", "test");
    Context.addProxyPrivilege(PrivilegeConstants.GET_ENCOUNTERS);
    patientEncounters = encounterService.getEncountersByPatientId(3);
    int actualSize = patientEncounters.size();
    Context.removeProxyPrivilege(PrivilegeConstants.GET_ENCOUNTERS);
    Context.logout();
    assertEquals(actualSize, expectedSize);
    assertTrue(!patientEncounters.contains(encounter));
}

######


@Test
public void filterEncountersByViewPermissions_shouldNotFilterAllEncountersWhenTheEncounterTypesViewPrivilegeColumnIsNull() {
    EncounterService encounterService = Context.getEncounterService();
    int beforeSize = encounterService.getEncountersByPatientId(3).size();
    Encounter encounter = new Encounter();
    encounter.setLocation(new Location(1));
    encounter.setEncounterDatetime(new Date());
    encounter.setPatient(Context.getPatientService().getPatient(3));
    EncounterType encounterType = new EncounterType(1);
    encounter.setEncounterType(encounterType);
    EncounterRole role = new EncounterRole();
    role.setName("role");
    role = encounterService.saveEncounterRole(role);
    Provider provider = new Provider();
    provider.setIdentifier("id1");
    provider.setPerson(newPerson("name"));
    provider = Context.getProviderService().saveProvider(provider);
    encounter.addProvider(role, provider);
    encounterService.saveEncounter(encounter);
    List<Encounter> patientEncounters = encounterService.getEncountersByPatientId(3);
    assertNotNull(patientEncounters);
    assertEquals(beforeSize + 1, patientEncounters.size());
}

######


@Test
public void canViewAllEncounterTypes_shouldReturnTrueIfUserIsGrantedToViewEncounters() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType encounterType = new EncounterType("testing", "desc");
    Privilege viewPrivilege = Context.getUserService().getPrivilege("Some Privilege For View Encounter Types");
    encounterType.setViewPrivilege(viewPrivilege);
    encounterService.saveEncounterType(encounterType);
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    assertFalse(encounterService.canViewAllEncounterTypes(user));
    Role role = Context.getUserService().getRole("Provider");
    role.addPrivilege(viewPrivilege);
    user.addRole(role);
    assertTrue(encounterService.canViewAllEncounterTypes(user));
}

######


@Test
public void canViewAllEncounterTypes_shouldReturnTrueWhenTheEncounterTypesViewPrivilegeColumnIsNull() {
    EncounterService encounterService = Context.getEncounterService();
    for (EncounterType encounterType : encounterService.getAllEncounterTypes()) {
        encounterType.setViewPrivilege(null);
        encounterService.saveEncounterType(encounterType);
    }
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    assertTrue(encounterService.canViewAllEncounterTypes(user));
}

######


@Test
public void canEditAllEncounterTypes_shouldReturnTrueIfUserIsGrantedToEditEncounters() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType encounterType = new EncounterType("testing", "desc");
    Privilege editPrivilege = Context.getUserService().getPrivilege("Some Privilege For Edit Encounter Types");
    encounterType.setEditPrivilege(editPrivilege);
    encounterService.saveEncounterType(encounterType);
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    assertFalse(encounterService.canEditAllEncounterTypes(user));
    Role role = Context.getUserService().getRole("Provider");
    role.addPrivilege(editPrivilege);
    user.addRole(role);
    assertTrue(encounterService.canEditAllEncounterTypes(user));
}

######


@Test
public void canViewAllEncounterTypes_shouldReturnTrueWhenTheEncounterTypesEditPrivilegeColumnIsNull() {
    EncounterService encounterService = Context.getEncounterService();
    for (EncounterType encounterType : encounterService.getAllEncounterTypes()) {
        encounterType.setEditPrivilege(null);
        encounterService.saveEncounterType(encounterType);
    }
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    assertTrue(encounterService.canEditAllEncounterTypes(user));
}

######


@Test
public void canEditEncounter_shouldReturnTrueIfUserCanEditEncounter() {
    Encounter encounter = getEncounterWithEditPrivilege();
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    Role role = Context.getUserService().getRole("Provider");
    role.addPrivilege(encounter.getEncounterType().getEditPrivilege());
    user.addRole(role);
    assertTrue(Context.getEncounterService().canEditEncounter(encounter, user));
}

######


@Test
public void canEditEncounter_shouldReturnFalseIfUserCanNotEditEncounter() {
    Encounter encounter = getEncounterWithEditPrivilege();
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    assertFalse(Context.getEncounterService().canEditEncounter(encounter, user));
}

######


@Test(expected = IllegalArgumentException.class)
public void canEditEncounter_shouldFailfIfEncounterIsNull() {
    Context.getEncounterService().canEditEncounter(null, null);
}

######


@Test
public void canViewEncounter_shouldReturnTrueIfUserCanViewEncounter() {
    Encounter encounter = getEncounterWithViewPrivilege();
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    Role role = Context.getUserService().getRole("Provider");
    role.addPrivilege(encounter.getEncounterType().getViewPrivilege());
    user.addRole(role);
    assertTrue(Context.getEncounterService().canViewEncounter(encounter, user));
}

######


@Test(expected = IllegalArgumentException.class)
public void canViewEncounter_shouldFailfIfEncounterIsNull() {
    Context.getEncounterService().canViewEncounter(null, null);
}

######


@Test
public void canViewEncounter_shouldReturnFalseIfUserCanNotViewEncounter() {
    Encounter encounter = getEncounterWithViewPrivilege();
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    assertFalse(Context.getEncounterService().canViewEncounter(encounter, user));
}

######


@Test(expected = APIException.class)
public void getEncounter_shouldFailIfUserIsNotAllowedToViewEncounterByGivenId() {
    Encounter encounter = getEncounterWithViewPrivilege();
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    Context.becomeUser(user.getSystemId());
    Context.addProxyPrivilege(PrivilegeConstants.GET_ENCOUNTERS);
    assertNull(Context.getEncounterService().getEncounter(encounter.getId()));
}

######


@Test
public void getEncounter_shouldReturnEncounterIfUserIsAllowedToViewIt() {
    Encounter encounter = getEncounterWithViewPrivilege();
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    Role role = Context.getUserService().getRole("Provider");
    role.addPrivilege(encounter.getEncounterType().getViewPrivilege());
    user.addRole(role);
    Context.becomeUser(user.getSystemId());
    Context.addProxyPrivilege(PrivilegeConstants.GET_ENCOUNTERS);
    assertNotNull(Context.getEncounterService().getEncounter(encounter.getId()));
}

######


@Test(expected = APIException.class)
public void saveEncounter_shouldFailfIfUserIsNotSupposedToEditEncountersOfTypeOfGivenEncounter() {
    Encounter encounter = getEncounterWithEditPrivilege();
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    Context.becomeUser(user.getSystemId());
    Context.addProxyPrivilege(PrivilegeConstants.EDIT_ENCOUNTERS);
    Context.getEncounterService().saveEncounter(encounter);
}

######


@Test(expected = APIException.class)
public void voidEncounter_shouldFailfIfUserIsNotSupposedToEditEncountersOfTypeOfGivenEncounter() {
    Encounter encounter = getEncounterWithEditPrivilege();
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    Context.becomeUser(user.getSystemId());
    Context.addProxyPrivilege(PrivilegeConstants.EDIT_ENCOUNTERS);
    Context.getEncounterService().voidEncounter(encounter, "test");
}

######


@Test(expected = APIException.class)
public void unvoidEncounter_shouldFailfIfUserIsNotSupposedToEditEncountersOfTypeOfGivenEncounter() {
    Encounter encounter = getEncounterWithEditPrivilege();
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    Context.becomeUser(user.getSystemId());
    Context.addProxyPrivilege(PrivilegeConstants.EDIT_ENCOUNTERS);
    Context.getEncounterService().unvoidEncounter(encounter);
}

######


@Test(expected = APIException.class)
public void purgeEncounter_shouldFailfIfUserIsNotSupposedToEditEncountersOfTypeOfGivenEncounter() {
    Encounter encounter = getEncounterWithEditPrivilege();
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    Context.becomeUser(user.getSystemId());
    Context.addProxyPrivilege(PrivilegeConstants.PURGE_ENCOUNTERS);
    Context.getEncounterService().purgeEncounter(encounter);
}

######


@Test(expected = APIException.class)
public void purgeEncounterCascade_shouldFailfIfUserIsNotSupposedToEditEncountersOfTypeOfGivenEncounter() {
    Encounter encounter = getEncounterWithEditPrivilege();
    User user = Context.getUserService().getUserByUsername("test_user");
    assertNotNull(user);
    Context.becomeUser(user.getSystemId());
    Context.addProxyPrivilege(PrivilegeConstants.PURGE_ENCOUNTERS);
    Context.getEncounterService().purgeEncounter(encounter, Boolean.TRUE);
}

######


@Test(expected = APIException.class)
public void getActiveEncounterVisitHandler_shouldThrowIfBeanWithGivenTypeAndNameNotFound() {
    String incorrectBeanName = OpenmrsConstants.REGISTERED_COMPONENT_NAME_PREFIX + "invalidName";
    GlobalProperty visitHandlerProperty = new GlobalProperty(OpenmrsConstants.GP_VISIT_ASSIGNMENT_HANDLER, incorrectBeanName);
    Context.getAdministrationService().saveGlobalProperty(visitHandlerProperty);
    Context.getEncounterService().getActiveEncounterVisitHandler();
}

######


@Test
public void getActiveEncounterVisitHandler_shouldReturnBeanHaveBeenRegisteredWithGivenName() {
    String correctBeanName = OpenmrsConstants.REGISTERED_COMPONENT_NAME_PREFIX + "existingOrNewVisitAssignmentHandler";
    GlobalProperty visitHandlerProperty = new GlobalProperty(OpenmrsConstants.GP_VISIT_ASSIGNMENT_HANDLER, correctBeanName);
    Context.getAdministrationService().saveGlobalProperty(visitHandlerProperty);
    EncounterVisitHandler activeEncounterVisitHandler = Context.getEncounterService().getActiveEncounterVisitHandler();
    Assert.assertNotNull(activeEncounterVisitHandler);
}

######


private Encounter getEncounterWithEditPrivilege() {
    EncounterService encounterService = Context.getEncounterService();
    Encounter encounter = encounterService.getEncounter(1);
    EncounterType encounterType = encounter.getEncounterType();
    assertNotNull(encounterType);
    Privilege editPrivilege = Context.getUserService().getPrivilege("Some Privilege For Edit Encounter Types");
    encounterType.setEditPrivilege(editPrivilege);
    encounter.setEncounterType(encounterType);
    encounter = encounterService.saveEncounter(encounter);
    assertNotNull(encounter);
    return encounter;
}

######


private Encounter getEncounterWithViewPrivilege() {
    EncounterService encounterService = Context.getEncounterService();
    Encounter encounter = encounterService.getEncounter(1);
    EncounterType encounterType = encounter.getEncounterType();
    assertNotNull(encounterType);
    Privilege viewPrivilege = Context.getUserService().getPrivilege("Some Privilege For View Encounter Types");
    encounterType.setViewPrivilege(viewPrivilege);
    encounter.setEncounterType(encounterType);
    encounter = encounterService.saveEncounter(encounter);
    assertNotNull(encounter);
    return encounter;
}

######


@Test
public void getEncounters_shouldFetchEncountersByPatientId() {
    Assert.assertEquals(2, Context.getEncounterService().getEncounters(null, 3, null, null, false).size());
    Assert.assertEquals(4, Context.getEncounterService().getEncounters(null, 3, null, null, true).size());
}

######


@Test
public void getEncounters_shouldMatchOnTheLocationName() {
    Assert.assertEquals(2, Context.getEncounterService().getEncounters("Test Location", 3, null, null, false).size());
    Assert.assertEquals(4, Context.getEncounterService().getEncounters("Test Location", 3, null, null, true).size());
}

######


@Test
public void getEncounters_shouldMatchOnTheProviderName() {
    Assert.assertEquals(1, Context.getEncounterService().getEncounters("phys", 3, null, null, false).size());
}

######


@Test
public void getEncounters_shouldShouldMatchOnProviderIdentifier() {
    Assert.assertEquals(1, Context.getEncounterService().getEncounters("2", 3, null, null, false).size());
    Assert.assertEquals(2, Context.getEncounterService().getEncounters("2", 3, null, null, true).size());
}

######


@Test
public void getEncounters_shouldMatchOnTheProviderPersonName() {
    Assert.assertEquals(1, Context.getEncounterService().getEncounters("er jo", 3, null, null, false).size());
    Assert.assertEquals(2, Context.getEncounterService().getEncounters("er jo", 3, null, null, true).size());
    Assert.assertEquals(0, Context.getEncounterService().getEncounters("none", 3, null, null, true).size());
}

######


@Test
public void getEncounters_shouldIncludeVoidedEncountersIfIncludeVoidedIsSetToTrue() {
    Assert.assertEquals(2, Context.getEncounterService().getEncounters("2", 3, null, null, true).size());
}

######


@Test
public void getEncounters_shouldMatchOnTheEncounterTypeName() {
    Assert.assertEquals(2, Context.getEncounterService().getEncounters("Type B", 3, null, null, false).size());
}

######


@Test
public void getEncounters_shouldMatchOnTheFormName() {
    Assert.assertEquals(2, Context.getEncounterService().getEncounters("Basic", 3, null, null, false).size());
}

######


@Test(expected = EncounterTypeLockedException.class)
public void saveEncounterType_shouldThrowErrorWhenTryingToSaveEncounterTypeWhenEncounterTypesAreLocked() {
    GlobalProperty gp = new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_ENCOUNTER_TYPES_LOCKED);
    gp.setPropertyValue("true");
    Context.getAdministrationService().saveGlobalProperty(gp);
    EncounterService encounterService = Context.getEncounterService();
    EncounterType encounterType = Context.getEncounterService().getEncounterType(1);
    Assert.assertNotNull(encounterType);
    encounterService.saveEncounterType(encounterType);
}

######


@Test(expected = EncounterTypeLockedException.class)
public void retireEncounterType_shouldThrowErrorWhenTryingToRetireEncounterTypeWhenEncounterTypesAreLocked() {
    GlobalProperty gp = new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_ENCOUNTER_TYPES_LOCKED);
    gp.setPropertyValue("true");
    Context.getAdministrationService().saveGlobalProperty(gp);
    EncounterService encounterService = Context.getEncounterService();
    EncounterType encounterType = Context.getEncounterService().getEncounterType(1);
    Assert.assertNotNull(encounterType);
    encounterService.retireEncounterType(encounterType, "reason");
}

######


@Test(expected = EncounterTypeLockedException.class)
public void unretireEncounterType_shouldThrowErrorWhenTryingToUnretireEncounterTypeWhenEncounterTypesAreLocked() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType encounterType = Context.getEncounterService().getEncounterType(2);
    GlobalProperty gp = new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_ENCOUNTER_TYPES_LOCKED);
    gp.setPropertyValue("true");
    Context.getAdministrationService().saveGlobalProperty(gp);
    encounterService.unretireEncounterType(encounterType);
}

######


@Test(expected = EncounterTypeLockedException.class)
public void purgeEncounterType_shouldThrowErrorWhenTryingToDeleteEncounterTypeWhenEncounterTypesAreLocked() {
    EncounterService encounterService = Context.getEncounterService();
    EncounterType encounterType = Context.getEncounterService().getEncounterType(1);
    Assert.assertNotNull(encounterType);
    GlobalProperty gp = new GlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_ENCOUNTER_TYPES_LOCKED);
    gp.setPropertyValue("true");
    Context.getAdministrationService().saveGlobalProperty(gp);
    encounterService.purgeEncounterType(encounterType);
}

######


@Test
public void getEncounterRolesByName_shouldFindEncounterRolesByName() {
    EncounterService encounterService = Context.getEncounterService();
    String name = "surgeon";
    List<EncounterRole> encounterRoles = encounterService.getEncounterRolesByName(name);
    assertNotNull("valid EncounterROle object should be returned", encounterRoles);
    assertEquals(encounterRoles.size(), 1);
    assertEquals(encounterRoles.get(0).getName(), name);
}

######


@Test
public void transferEncounter_shouldTransferAnEncounterWithObservationsButNotOrdersToGivenPatient() {
    executeDataSet(TRANSFER_ENC_DATA_XML);
    Patient targetPatient = Context.getPatientService().getPatient(201);
    Encounter sourceEncounter = Context.getEncounterService().getEncounter(201);
    Assert.assertEquals(2, sourceEncounter.getOrders().size());
    Assert.assertEquals(2, sourceEncounter.getObs().size());
    Encounter transferredEncounter = Context.getEncounterService().transferEncounter(sourceEncounter, targetPatient);
    List<Order> transferredOrders = new ArrayList<>(transferredEncounter.getOrders());
    List<Obs> transferredObservations = new ArrayList<>(transferredEncounter.getObs());
    Assert.assertNotEquals(sourceEncounter.getId(), transferredEncounter.getId());
    Assert.assertEquals(targetPatient, transferredEncounter.getPatient());
    Assert.assertEquals(0, transferredOrders.size());
    Assert.assertEquals(2, transferredObservations.size());
    Assert.assertEquals(targetPatient, transferredObservations.get(0).getPerson());
    Assert.assertEquals(targetPatient, transferredObservations.get(1).getPerson());
    Assert.assertNull(transferredObservations.get(0).getOrder());
    Assert.assertNull(transferredObservations.get(1).getOrder());
    Assert.assertNotNull(transferredEncounter.getForm());
}

######


@Test
public void transferEncounter_shouldVoidGivenEncounter() {
    executeDataSet(TRANSFER_ENC_DATA_XML);
    Patient anyPatient = new Patient(2);
    Encounter sourceEncounter = Context.getEncounterService().getEncounter(200);
    Context.getEncounterService().transferEncounter(sourceEncounter, anyPatient);
    Encounter sourceEncounterAfterTransfer = Context.getEncounterService().getEncounter(sourceEncounter.getId());
    Assert.assertTrue(sourceEncounterAfterTransfer.getVoided());
}

######


@Test
public void transferEncounter_shouldVoidGivenEncounterVisitIfGivenEncounterIsTheOnlyEncounter() {
    executeDataSet(TRANSFER_ENC_DATA_XML);
    Patient anyPatient = new Patient(2);
    Encounter sourceEncounter = Context.getEncounterService().getEncounter(200);
    Context.getEncounterService().transferEncounter(sourceEncounter, anyPatient);
    Visit visit = Context.getVisitService().getVisit(200);
    Assert.assertTrue(visit.getVoided());
}

######


private EncounterSearchCriteria encounterSearchForVoidedWithDateChanged(String dateChanged) throws ParseException {
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
    return new EncounterSearchCriteriaBuilder().setIncludeVoided(true).setDateChanged(sdf.parse(dateChanged)).createEncounterSearchCriteria();
}

######


private Person newPerson(String name) {
    Person person = new Person();
    Set<PersonName> personNames = new TreeSet<>();
    PersonName personName = new PersonName();
    personName.setFamilyName(name);
    personNames.add(personName);
    person.setNames(personNames);
    return person;
}

######


@Test
public void shouldSaveOrderGroupAlongWithOrders() {
    executeDataSet(ORDER_SET);
    Encounter encounter = new Encounter();
    encounter.setPatient(Context.getPatientService().getPatient(3));
    encounter.setEncounterType(Context.getEncounterService().getEncounterType(1));
    encounter.setEncounterDatetime(new Date());
    Context.getEncounterService().saveEncounter(encounter);
    Integer encounterId = Context.getEncounterService().getEncounterByUuid(encounter.getUuid()).getId();
    OrderSet orderSet = Context.getOrderSetService().getOrderSet(2000);
    OrderGroup orderGroup = new OrderGroup();
    orderGroup.setOrderSet(orderSet);
    orderGroup.setPatient(encounter.getPatient());
    orderGroup.setEncounter(Context.getEncounterService().getEncounter(encounterId));
    Order firstOrderWithOrderGroup = new OrderBuilder().withAction(Order.Action.NEW).withPatient(3).withConcept(1000).withCareSetting(1).withOrderer(1).withEncounter(encounterId).withDateActivated(new Date()).withOrderType(17).withUrgency(Order.Urgency.ON_SCHEDULED_DATE).withScheduledDate(new Date()).withOrderGroup(orderGroup).build();
    Order secondOrderWithOrderGroup = new OrderBuilder().withAction(Order.Action.NEW).withPatient(3).withConcept(1001).withCareSetting(1).withOrderer(1).withEncounter(encounterId).withDateActivated(new Date()).withOrderType(17).withUrgency(Order.Urgency.ON_SCHEDULED_DATE).withScheduledDate(new Date()).withOrderGroup(orderGroup).build();
    encounter.addOrder(firstOrderWithOrderGroup);
    encounter.addOrder(secondOrderWithOrderGroup);
    Context.getEncounterService().saveEncounter(encounter);
    Context.flushSession();
    List<Order> orders = new ArrayList<>(Context.getEncounterService().getEncounterByUuid(encounter.getUuid()).getOrders());
    assertNotNull("OrderGroup is saved", orders.get(0).getOrderGroup());
    assertEquals("OrderGroup isa same for both the orders ", true, orders.get(0).getOrderGroup().equals(orders.get(1).getOrderGroup()));
}

######


@Test
public void shouldSaveMultipleOrderGroupsIfDifferentOrdersHaveDifferentOrderGroups() {
    executeDataSet(ORDER_SET);
    Encounter encounter = new Encounter();
    encounter.setPatient(Context.getPatientService().getPatient(3));
    encounter.setEncounterType(Context.getEncounterService().getEncounterType(1));
    encounter.setEncounterDatetime(new Date());
    Context.getEncounterService().saveEncounter(encounter);
    Integer encounterId = Context.getEncounterService().getEncounterByUuid(encounter.getUuid()).getId();
    OrderSet orderSet = Context.getOrderSetService().getOrderSet(2000);
    OrderGroup orderGroup = new OrderGroup();
    orderGroup.setOrderSet(orderSet);
    orderGroup.setPatient(encounter.getPatient());
    orderGroup.setEncounter(Context.getEncounterService().getEncounter(encounterId));
    OrderGroup orderGroup2 = new OrderGroup();
    orderGroup2.setEncounter(Context.getEncounterService().getEncounter(encounterId));
    orderGroup2.setPatient(encounter.getPatient());
    Order newOrder1 = new OrderBuilder().withAction(Order.Action.NEW).withPatient(3).withConcept(1000).withCareSetting(1).withOrderer(1).withEncounter(encounterId).withDateActivated(new Date()).withOrderType(17).withUrgency(Order.Urgency.ON_SCHEDULED_DATE).withScheduledDate(new Date()).withOrderGroup(orderGroup).build();
    Order newOrder2 = new OrderBuilder().withAction(Order.Action.NEW).withPatient(3).withConcept(1001).withCareSetting(1).withOrderer(1).withEncounter(encounterId).withDateActivated(new Date()).withOrderType(17).withUrgency(Order.Urgency.ON_SCHEDULED_DATE).withScheduledDate(new Date()).withOrderGroup(orderGroup).build();
    Order newOrder3 = new OrderBuilder().withAction(Order.Action.NEW).withPatient(3).withConcept(1002).withCareSetting(1).withOrderer(1).withEncounter(encounterId).withDateActivated(new Date()).withOrderType(17).withUrgency(Order.Urgency.ON_SCHEDULED_DATE).withScheduledDate(new Date()).withOrderGroup(orderGroup2).build();
    Order newOrder4 = new OrderBuilder().withAction(Order.Action.NEW).withPatient(3).withConcept(1000).withCareSetting(1).withOrderer(1).withEncounter(encounterId).withDateActivated(new Date()).withOrderType(17).withUrgency(Order.Urgency.ON_SCHEDULED_DATE).withScheduledDate(new Date()).build();
    Order newOrder5 = new OrderBuilder().withAction(Order.Action.NEW).withPatient(3).withConcept(1001).withCareSetting(1).withOrderer(1).withEncounter(encounterId).withDateActivated(new Date()).withOrderType(17).withUrgency(Order.Urgency.ON_SCHEDULED_DATE).withScheduledDate(new Date()).withOrderGroup(orderGroup2).build();
    encounter.addOrder(newOrder1);
    encounter.addOrder(newOrder2);
    encounter.addOrder(newOrder3);
    encounter.addOrder(newOrder4);
    encounter.addOrder(newOrder5);
    Context.getEncounterService().saveEncounter(encounter);
    Context.flushSession();
    List<Order> orders = new ArrayList<>(Context.getEncounterService().getEncounterByUuid(encounter.getUuid()).getOrders());
    HashMap<Integer, OrderGroup> orderGroups = new HashMap<>();
    for (Order order : orders) {
        if (order.getOrderGroup() != null) {
            orderGroups.put(order.getOrderGroup().getId(), order.getOrderGroup());
        }
    }
    assertEquals("Two New Order Groups Get Saved", 2, orderGroups.size());
}

######


public void setEquipmentDao(IEquipmentDAO equipmentDao) {
    this.equipmentDao = equipmentDao;
}

######


public Long addEquipment(Equipment equipment) {
    this.equipmentDao.save(equipment);
    if (equipment != null && equipment.getId() != null) {
        return equipment.getId();
    }
    return null;
}

######


public Equipment getEquipment(Long id) {
    Equipment equipment = this.equipmentDao.get(id);
    return equipment;
}

######


public Equipment getEquipment(String name) {
    List list = equipmentDao.query("select e from Equipment e where e.name=?1", new Object[] { name }, 0, 1);
    if (list.isEmpty())
        return null;
    else
        return (Equipment) list.get(0);
}

######


public boolean delEquipment(Long id) {
    Equipment equipment = this.getEquipment(id);
    if (equipment != null) {
        this.equipmentDao.remove(id);
        return true;
    }
    return false;
}

######


public boolean batchDelEquipments(List<Serializable> equipmentIds) {
    for (Serializable id : equipmentIds) {
        delEquipment((Long) id);
    }
    return true;
}

######


public IPageList getEquipmentBy(IQueryObject queryObject) {
    return QueryUtil.query(queryObject, Equipment.class, this.equipmentDao);
}

######


public boolean updateEquipment(Long id, Equipment equipment) {
    if (id != null) {
        equipment.setId(id);
    } else {
        return false;
    }
    this.equipmentDao.update(equipment);
    return true;
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("testErrorMessage", "id int not null primary key auto_increment, test varchar(10), test2 int");
}

######


@Test
public void testSmallRewriteErrorMessage() {
    try (Connection connection = setBlankConnection("&rewriteBatchedStatements=true" + "&dumpQueriesOnException")) {
        executeBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?)"));
    }
}

######


@Test
public void testSmallMultiBatchErrorMessage() throws SQLException {
    try (Connection connection = setConnection("&allowMultiQueries=true&useServerPrepStmts=false&dumpQueriesOnException")) {
        executeBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        if ((isMariadbServer() && minVersion(10, 2) && sharedOptions().useBulkStmts) || sharedOptions().useServerPrepStmts || sharedOptions().rewriteBatchedStatements) {
            assertTrue("message : " + sqle.getCause().getCause().getMessage(), sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?)"));
        } else {
            if (!sharedOptions().useBatchMultiSend) {
                assertTrue("message : " + sqle.getCause().getCause().getMessage(), sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?), " + "parameters ['more than 10 characters to provoc error',10]"));
            } else {
                assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values " + "('more than 10 characters to provoc error', 10)"));
            }
        }
    }
}

######


@Test
public void testSmallPrepareErrorMessage() {
    try (Connection connection = setBlankConnection("&useBatchMultiSend=false" + "&dumpQueriesOnException")) {
        executeBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?)"));
    }
}

######


@Test
public void testSmallBulkErrorMessage() throws SQLException {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection connection = setConnection("&useBatchMultiSend=true&dumpQueriesOnException")) {
        executeBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        if ((isMariadbServer() && minVersion(10, 2) && sharedOptions().useBulkStmts) || sharedOptions().useServerPrepStmts || sharedOptions().rewriteBatchedStatements) {
            assertTrue("message : " + sqle.getCause().getCause().getMessage(), sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?)"));
        } else {
            assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values " + "('more than 10 characters to provoc error', 10)"));
        }
    }
}

######


@Test
public void testSmallPrepareBulkErrorMessage() {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection connection = setBlankConnection("&useBatchMultiSend=true&useServerPrepStmts=true&dumpQueriesOnException")) {
        executeBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values " + "(?, ?)"));
    }
}

######


@Test
public void testBigRewriteErrorMessage() {
    try (Connection connection = setBlankConnection("&rewriteBatchedStatements=true" + "&dumpQueriesOnException")) {
        executeBigBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?)"));
    }
}

######


@Test
public void testBigMultiErrorMessage() throws SQLException {
    try (Connection connection = setConnection("&allowMultiQueries=true&useServerPrepStmts=false&dumpQueriesOnException")) {
        executeBigBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        if ((isMariadbServer() && minVersion(10, 2) && sharedOptions().useBulkStmts) || sharedOptions().useServerPrepStmts || sharedOptions().rewriteBatchedStatements) {
            assertTrue("message : " + sqle.getCause().getCause().getMessage(), sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?)"));
        } else {
            if (!sharedOptions().useBatchMultiSend) {
                assertTrue("message : " + sqle.getCause().getCause().getMessage(), sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) " + "values (?, ?), parameters ['more than 10 characters to provoc error',200]"));
            } else {
                assertTrue("message : " + sqle.getCause().getCause().getMessage(), sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values " + "('more than 10 characters to provoc error', 200)"));
            }
        }
    }
}

######


@Test
public void testBigPrepareErrorMessage() throws SQLException {
    try (Connection connection = setBlankConnection("&useBatchMultiSend=false" + "&dumpQueriesOnException")) {
        executeBigBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        sqle.printStackTrace();
        if (isMariadbServer() && minVersion(10, 2)) {
            assertTrue("message : " + sqle.getCause().getCause().getMessage(), sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?)"));
        } else {
            assertTrue("message : " + sqle.getCause().getCause().getMessage(), sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?), " + "parameters ['more than 10 characters to provoc error',200]"));
        }
    }
}

######


@Test
public void testBigBulkErrorMessage() throws SQLException {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection connection = setConnection("&useBatchMultiSend=true" + "&dumpQueriesOnException")) {
        executeBigBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        if ((isMariadbServer() && minVersion(10, 2) && sharedOptions().useBulkStmts || sharedOptions().useServerPrepStmts || sharedOptions().rewriteBatchedStatements)) {
            assertTrue("message : " + sqle.getCause().getCause().getMessage(), sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?)"));
        } else {
            assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values " + "('more than 10 characters to provoc error', 200)"));
        }
    }
}

######


@Test
public void testBigBulkErrorPrepareMessage() {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection connection = setBlankConnection("&useBatchMultiSend=true&useServerPrepStmts=true&dumpQueriesOnException")) {
        executeBigBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?)"));
    }
}

######


private void executeBatchWithException(Connection connection) throws SQLException {
    connection.createStatement().execute("TRUNCATE testErrorMessage");
    try (PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO testErrorMessage(test, test2) values (?, ?)")) {
        for (int i = 0; i < 10; i++) {
            preparedStatement.setString(1, "whoua" + i);
            preparedStatement.setInt(2, i);
            preparedStatement.addBatch();
        }
        preparedStatement.setString(1, "more than 10 characters to provoc error");
        preparedStatement.setInt(2, 10);
        preparedStatement.addBatch();
        preparedStatement.executeBatch();
    } catch (SQLException e) {
        connection.createStatement().execute("SELECT 1");
        throw e;
    }
}

######


private void executeBigBatchWithException(Connection connection) throws SQLException {
    connection.createStatement().execute("TRUNCATE testErrorMessage");
    try (PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO testErrorMessage(test, test2) values (?, ?)")) {
        for (int i = 0; i < 200; i++) {
            preparedStatement.setString(1, "whoua" + i);
            preparedStatement.setInt(2, i);
            preparedStatement.addBatch();
        }
        preparedStatement.setString(1, "more than 10 characters to provoc error");
        preparedStatement.setInt(2, 200);
        preparedStatement.addBatch();
        preparedStatement.executeBatch();
    } catch (SQLException e) {
        connection.createStatement().execute("SELECT 1");
        throw e;
    }
}

######


@Test
public void testFailOverKillCmd() throws Throwable {
    Assume.assumeTrue(System.getenv("MAXSCALE_VERSION") == null);
    Assume.assumeTrue(isMariadbServer());
    DataSource ds = new MariaDbDataSource("jdbc:mariadb:failover//" + ((hostname != null) ? hostname : "localhost") + ":" + port + "," + ((hostname != null) ? hostname : "localhost") + ":" + port + "/" + database + "?user=" + username + (password != null ? "&password=" + password : ""));
    try (Connection connection = ds.getConnection()) {
        Protocol protocol = getProtocolFromConnection(connection);
        Statement stmt = connection.createStatement();
        long threadId = protocol.getServerThreadId();
        try {
            stmt.executeQuery("KILL " + threadId);
            stmt.executeQuery("SELECT 1");
            long newThreadId = protocol.getServerThreadId();
            assertNotEquals(threadId, newThreadId);
            PreparedStatement preparedStatement = connection.prepareStatement("KILL ?");
            preparedStatement.setLong(1, newThreadId);
            preparedStatement.execute();
            stmt.executeQuery("SELECT 1");
            long anotherNewThreadId = protocol.getServerThreadId();
            assertNotEquals(anotherNewThreadId, newThreadId);
        } catch (SQLException sqle) {
        }
    }
}

######


@Test
public void testSmallRewriteErrorMessageNoBulk() {
    try (Connection connection = setBlankConnection("&rewriteBatchedStatements=true&useBulkStmts=false&dumpQueriesOnException")) {
        executeBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?)"));
    }
}

######


@Test
public void testSmallMultiBatchErrorMessageNoBulk() {
    try (Connection connection = setBlankConnection("&allowMultiQueries=true&useServerPrepStmts=false&useBulkStmts=false" + "&dumpQueriesOnException")) {
        executeBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        if (sharedIsAurora()) {
            assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?), " + "parameters ['more than 10 characters to provoc error',10]"));
        } else {
            assertTrue("message : " + sqle.getCause().getCause().getMessage(), sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values " + "('more than 10 characters to provoc error', 10)"));
        }
    }
}

######


@Test
public void testSmallPrepareErrorMessageNoBulk() {
    try (Connection connection = setBlankConnection("&useBatchMultiSend=false&useBulkStmts=false&dumpQueriesOnException")) {
        executeBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?), " + "parameters ['more than 10 characters to provoc error',10]"));
    }
}

######


@Test
public void testSmallBulkErrorMessageNoBulk() {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection connection = setBlankConnection("&useBatchMultiSend=true&useBulkStmts=false" + "&dumpQueriesOnException")) {
        executeBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values " + "('more than 10 characters to provoc error', 10)"));
    }
}

######


@Test
public void testSmallPrepareBulkErrorMessageNoBulk() {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection connection = setBlankConnection("&useBatchMultiSend=true&useServerPrepStmts=true&useBulkStmts=false" + "&dumpQueriesOnException")) {
        executeBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values " + "(?, ?)"));
    }
}

######


@Test
public void testBigRewriteErrorMessageNoBulk() {
    try (Connection connection = setBlankConnection("&rewriteBatchedStatements=true&useBulkStmts=false&dumpQueriesOnException")) {
        executeBigBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?)"));
    }
}

######


@Test
public void testBigMultiErrorMessageNoBulk() {
    try (Connection connection = setBlankConnection("&allowMultiQueries=true&useServerPrepStmts=false&useBulkStmts=false" + "&dumpQueriesOnException")) {
        executeBigBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        if (!sharedIsAurora()) {
            assertTrue("message : " + sqle.getCause().getCause().getMessage(), sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values " + "('more than 10 characters to provoc error', 200)"));
        } else {
            assertTrue("message : " + sqle.getCause().getCause().getMessage(), sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?), parameters " + "['more than 10 characters to provoc error',200]"));
        }
    }
}

######


@Test
public void testBigPrepareErrorMessageNoBulk() {
    try (Connection connection = setBlankConnection("&useBatchMultiSend=false&useBulkStmts=false&dumpQueriesOnException")) {
        executeBigBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        assertTrue("message : " + sqle.getCause().getCause().getMessage(), sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?), parameters " + "['more than 10 characters to provoc error',200]"));
    }
}

######


@Test
public void testBigBulkErrorMessageNoBulk() {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection connection = setBlankConnection("&useBatchMultiSend=true&useBulkStmts=false" + "&dumpQueriesOnException")) {
        executeBigBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (" + "'more than 10 characters to provoc error', 200)"));
    }
}

######


@Test
public void testBigBulkErrorPrepareMessageNoBulk() {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection connection = setBlankConnection("&useBatchMultiSend=true&useServerPrepStmts=true&useBulkStmts=false" + "&dumpQueriesOnException")) {
        executeBigBatchWithException(connection);
        fail("Must Have thrown error");
    } catch (SQLException sqle) {
        assertTrue(sqle.getCause().getCause().getMessage().contains("INSERT INTO testErrorMessage(test, test2) values (?, ?)"));
    }
}

######


@Query("SELECT * FROM event")
List<Event> getAll();

######


@Insert
long insert(Event event);

######


@Query("SELECT * FROM event WHERE id = (:eventId)")
Event getEventById(long eventId);

######


@Query("SELECT * FROM event WHERE raceLength = (:raceLength)")
List<Event> getAllEventsByRaceLength(long raceLength);

######


@Query("DELETE FROM Event")
void deleteAllEvents();

######


@Delete
void delete(Event event);

######


@RequestMapping("/")
public String hello() {
    return jdbcTemplate.queryForObject("select model from car where id = 1", String.class);
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("ExecuteBatchTest", "id int not null primary key auto_increment, test varchar(100) , test2 int");
    createTable("ExecuteBatchUseBatchMultiSend", "test varchar(100)");
}

######


@Test
public void interruptExecuteBatch() throws Exception {
    Assume.assumeTrue(sharedOptions().useBatchMultiSend && !(sharedOptions().useBulkStmts && isMariadbServer() && minVersion(10, 2)));
    ExecutorService service = Executors.newFixedThreadPool(1);
    final CyclicBarrier barrier = new CyclicBarrier(2);
    final AtomicBoolean wasInterrupted = new AtomicBoolean(false);
    final AtomicReference<Exception> exceptionRef = new AtomicReference<>();
    service.submit(() -> {
        try {
            PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO ExecuteBatchTest(test, test2) values (?, ?)");
            for (int i = 0; i < 1_000_000; i++) {
                preparedStatement.setString(1, String.valueOf(System.nanoTime()));
                preparedStatement.setInt(2, i);
                preparedStatement.addBatch();
            }
            barrier.await();
            preparedStatement.executeBatch();
        } catch (InterruptedException ex) {
            exceptionRef.set(ex);
            Thread.currentThread().interrupt();
        } catch (BrokenBarrierException ex) {
            exceptionRef.set(ex);
        } catch (SQLException ex) {
            exceptionRef.set(ex);
            wasInterrupted.set(Thread.currentThread().isInterrupted());
        } catch (Exception ex) {
            exceptionRef.set(ex);
        }
    });
    barrier.await();
    Thread.sleep(TimeUnit.SECONDS.toMillis(1));
    service.shutdownNow();
    assertTrue(service.awaitTermination(1, TimeUnit.MINUTES));
    assertNotNull(exceptionRef.get());
    ResultSet rs = sharedConnection.createStatement().executeQuery("SELECT 123456");
    assertTrue(rs.next());
    assertEquals(123456, rs.getInt(1));
    StringWriter writer = new StringWriter();
    exceptionRef.get().printStackTrace(new PrintWriter(writer));
    assertTrue("Exception should be a SQLException: \n" + writer.toString(), exceptionRef.get() instanceof SQLException);
    assertTrue(wasInterrupted.get());
}

######


@Test
public void serverBulk8mTest() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore8m("serverBulk8mTest"));
    Assume.assumeTrue(runLongTest);
    Assume.assumeFalse(sharedIsAurora());
    sharedConnection.createStatement().execute("TRUNCATE TABLE ExecuteBatchTest");
    try (Connection connection = setConnection("&useComMulti=false&useBatchMultiSend=true&profileSql=" + profileSql)) {
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO ExecuteBatchTest(test, test2) values (?, ?)");
        addBatchData(preparedStatement, 60000, connection);
    }
}

######


@Test
public void serverBulk20mTest() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore20m("serverBulk20mTest"));
    Assume.assumeTrue(runLongTest);
    Assume.assumeFalse(sharedIsAurora());
    sharedConnection.createStatement().execute("TRUNCATE TABLE ExecuteBatchTest");
    try (Connection connection = setConnection("&useComMulti=false&useBatchMultiSend=true&profileSql=" + profileSql)) {
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO ExecuteBatchTest(test, test2) values (?, ?)");
        addBatchData(preparedStatement, 160000, connection);
    }
}

######


@Test
public void serverStd8mTest() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore8m("serverStd8mTest"));
    Assume.assumeTrue(runLongTest);
    sharedConnection.createStatement().execute("TRUNCATE TABLE ExecuteBatchTest");
    try (Connection connection = setConnection("&useComMulti=false&useBatchMultiSend=false&profileSql=" + profileSql)) {
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO ExecuteBatchTest(test, test2) values (?, ?)");
        addBatchData(preparedStatement, 60000, connection);
    }
}

######


@Test
public void clientBulkTest() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore8m("serverStd8mTest"));
    Assume.assumeTrue(runLongTest);
    Assume.assumeFalse(sharedIsAurora());
    sharedConnection.createStatement().execute("TRUNCATE TABLE ExecuteBatchTest");
    try (Connection connection = setConnection("&useComMulti=false&useBatchMultiSend=true&useServerPrepStmts=false&profileSql=" + profileSql)) {
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO ExecuteBatchTest(test, test2) values (?, ?)");
        addBatchData(preparedStatement, 60000, connection);
    }
}

######


@Test
public void clientRewriteValuesNotPossible8mTest() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore8m("clientRewriteValuesNotPossibleTest"));
    Assume.assumeTrue(runLongTest);
    sharedConnection.createStatement().execute("TRUNCATE TABLE ExecuteBatchTest");
    try (Connection connection = setConnection("&rewriteBatchedStatements=true&profileSql=" + profileSql)) {
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO ExecuteBatchTest(test, test2) values (?, ?) ON DUPLICATE KEY UPDATE id=?");
        addBatchData(preparedStatement, 60000, connection, true, true);
    }
}

######


@Test
public void clientRewriteValuesNotPossible20mTest() throws SQLException {
    Assume.assumeTrue(checkMaxAllowedPacketMore8m("clientRewriteValuesNotPossibleTest"));
    Assume.assumeTrue(runLongTest);
    sharedConnection.createStatement().execute("TRUNCATE TABLE ExecuteBatchTest");
    try (Connection connection = setConnection("&rewriteBatchedStatements=true&profileSql=" + profileSql)) {
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO ExecuteBatchTest(test, test2) values (?, ?) ON DUPLICATE KEY UPDATE id=?");
        addBatchData(preparedStatement, 160000, connection, true, true);
    }
}

######


private void addBatchData(PreparedStatement preparedStatement, int batchNumber, Connection connection) throws SQLException {
    addBatchData(preparedStatement, batchNumber, connection, false, false);
}

######


private void addBatchData(PreparedStatement preparedStatement, int batchNumber, Connection connection, boolean additionnalParameter, boolean sendUnique) throws SQLException {
    for (int i = 0; i < batchNumber; i++) {
        preparedStatement.setString(1, oneHundredLengthString);
        preparedStatement.setInt(2, i);
        if (additionnalParameter) {
            preparedStatement.setInt(3, i);
        }
        preparedStatement.addBatch();
    }
    int[] resultInsert = preparedStatement.executeBatch();
    assertEquals(batchNumber, resultInsert.length);
    for (int i = 0; i < batchNumber; i++) {
        if ((!sendUnique && sharedIsRewrite()) || (sharedOptions().useBulkStmts && isMariadbServer() && minVersion(10, 2))) {
            assertEquals(Statement.SUCCESS_NO_INFO, resultInsert[i]);
        } else {
            assertEquals(1, resultInsert[i]);
        }
    }
    ResultSet resultSet = connection.createStatement().executeQuery("SELECT * FROM ExecuteBatchTest");
    for (int i = 0; i < batchNumber; i++) {
        assertTrue(resultSet.next());
        if (!sharedOptions().useBulkStmts)
            assertEquals(i + 1, resultSet.getInt(1));
        assertEquals(oneHundredLengthString, resultSet.getString(2));
        assertEquals(i, resultSet.getInt(3));
    }
    assertFalse(resultSet.next());
}

######


@Test
public void useBatchMultiSend() throws Exception {
    Assume.assumeFalse(sharedIsAurora());
    try (Connection connection = setConnection("&useBatchMultiSend=true")) {
        String sql = "insert into ExecuteBatchUseBatchMultiSend (test) values (?)";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            for (int i = 0; i < 10; i++) {
                pstmt.setInt(1, i);
                pstmt.addBatch();
            }
            int[] updateCounts = pstmt.executeBatch();
            assertEquals(10, updateCounts.length);
            for (int updateCount : updateCounts) {
                if ((sharedIsRewrite() || (sharedOptions().useBulkStmts && isMariadbServer() && minVersion(10, 2)))) {
                    assertEquals(Statement.SUCCESS_NO_INFO, updateCount);
                } else {
                    assertEquals(1, updateCount);
                }
            }
        }
    }
}

######


@Test
public void ensureBulkSchedulerMaxPoolSizeRejection() throws Throwable {
    Assume.assumeFalse(sharedIsAurora() || sharedOptions().profileSql);
    System.out.println(getProtocolFromConnection(sharedConnection).getHostAddress());
    Statement statement = sharedConnection.createStatement();
    ResultSet resultSet = statement.executeQuery("SELECT @@max_connections");
    assertTrue(resultSet.next());
    int maxConnection = resultSet.getInt(1);
    int limit = Math.min(1, Math.min(200, maxConnection - 10));
    System.out.println("limit:" + limit);
    for (int i = 0; i < limit; i++) {
        createTable("multipleSimultaneousBatch_" + i, "a INT NOT NULL");
    }
    AtomicInteger counter = new AtomicInteger();
    ExecutorService exec = Executors.newFixedThreadPool(limit + 50);
    for (int i = 0; i < limit; i++) {
        exec.execute(() -> {
            try (Connection connection = setConnection()) {
                connection.setAutoCommit(false);
                Statement stmt = connection.createStatement();
                int connectionCounter = counter.getAndIncrement();
                for (int j = 0; j < 1024; j++) {
                    stmt.addBatch("INSERT INTO multipleSimultaneousBatch_" + connectionCounter + "(a) VALUES (" + j + ")");
                }
                stmt.executeBatch();
                connection.commit();
            } catch (Throwable e) {
                e.printStackTrace();
            }
        });
    }
    exec.shutdown();
    exec.awaitTermination(150, TimeUnit.SECONDS);
    Statement stmt = sharedConnection.createStatement();
    for (int i = 0; i < limit; i++) {
        ResultSet rs = stmt.executeQuery("SELECT count(*) from multipleSimultaneousBatch_" + i);
        assertTrue(rs.next());
        assertEquals(1024, rs.getInt(1));
    }
}

######


@Test
public void useBatchMultiSendWithError() throws Exception {
    Assume.assumeFalse(sharedIsAurora());
    Iterator<Thread> it = Thread.getAllStackTraces().keySet().iterator();
    Thread thread;
    while (it.hasNext()) {
        thread = it.next();
        if (thread.getName().contains("MariaDb-bulk-")) {
            assertEquals(State.WAITING, thread.getState());
        }
    }
    Properties properties = new Properties();
    properties.setProperty("useBatchMultiSend", "true");
    try (Connection connection = createProxyConnection(properties)) {
        Statement stmt = connection.createStatement();
        stmt.execute("CREATE TEMPORARY TABLE useBatchMultiSendWithError (id INT NOT NULL," + "UNIQUE INDEX `index1` (id))");
        String sql = "insert into useBatchMultiSendWithError (id) values (?)";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            for (int i = 0; i < 200000; i++) {
                pstmt.setInt(1, i);
                pstmt.addBatch();
            }
            final ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1);
            executor.schedule(() -> {
                stopProxy();
            }, 10, TimeUnit.MILLISECONDS);
            try {
                pstmt.executeBatch();
                fail();
            } catch (SQLException e) {
                Iterator<Thread> it2 = Thread.getAllStackTraces().keySet().iterator();
                Thread.sleep(500);
                Thread thread2;
                while (it2.hasNext()) {
                    thread2 = it2.next();
                    if (thread2.getName().contains("MariaDb-bulk-")) {
                        assertEquals(State.WAITING, thread2.getState());
                    }
                }
                restartProxy();
            }
        }
    }
}

######


public static MappedStatement prepareInsertAuthorMappedStatement(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    MappedStatement ms = new MappedStatement.Builder(config, "insertAuthor", new StaticSqlSource(config, "INSERT INTO author (id,username,password,email,bio,favourite_section) values(?,?,?,?,?,?)"), SqlCommandType.INSERT).parameterMap(new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "id", registry.getTypeHandler(int.class)).build());
            add(new ParameterMapping.Builder(config, "username", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "password", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "email", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "bio", registry.getTypeHandler(String.class)).jdbcType(JdbcType.VARCHAR).build());
            add(new ParameterMapping.Builder(config, "favouriteSection", registry.getTypeHandler(Section.class)).jdbcType(JdbcType.VARCHAR).build());
        }
    }).build()).cache(authorCache).build();
    return ms;
}

######


public static MappedStatement prepareInsertAuthorMappedStatementWithAutoKey(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    MappedStatement ms = new MappedStatement.Builder(config, "insertAuthor", new StaticSqlSource(config, "INSERT INTO author (username,password,email,bio,favourite_section) values(?,?,?,?,?)"), SqlCommandType.INSERT).parameterMap(new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "username", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "password", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "email", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "bio", registry.getTypeHandler(String.class)).jdbcType(JdbcType.VARCHAR).build());
            add(new ParameterMapping.Builder(config, "favouriteSection", registry.getTypeHandler(Section.class)).jdbcType(JdbcType.VARCHAR).build());
        }
    }).build()).cache(authorCache).keyGenerator(Jdbc3KeyGenerator.INSTANCE).keyProperty("id").build();
    return ms;
}

######


public static MappedStatement prepareInsertAuthorProc(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    MappedStatement ms = new MappedStatement.Builder(config, "insertAuthorProc", new StaticSqlSource(config, "{call insertAuthor(?,?,?,?)}"), SqlCommandType.INSERT).parameterMap(new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "id", registry.getTypeHandler(int.class)).build());
            add(new ParameterMapping.Builder(config, "username", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "password", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "email", registry.getTypeHandler(String.class)).build());
        }
    }).build()).cache(authorCache).build();
    return ms;
}

######


public static MappedStatement prepareUpdateAuthorMappedStatement(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    MappedStatement ms = new MappedStatement.Builder(config, "updateAuthor", new StaticSqlSource(config, "UPDATE author SET username = ?, password = ?, email = ?, bio = ? WHERE id = ?"), SqlCommandType.UPDATE).parameterMap(new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "username", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "password", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "email", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "bio", registry.getTypeHandler(String.class)).jdbcType(JdbcType.VARCHAR).build());
            add(new ParameterMapping.Builder(config, "id", registry.getTypeHandler(int.class)).build());
        }
    }).build()).cache(authorCache).build();
    return ms;
}

######


public static MappedStatement prepareDeleteAuthorMappedStatement(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    MappedStatement ms = new MappedStatement.Builder(config, "deleteAuthor", new StaticSqlSource(config, "DELETE FROM author WHERE id = ?"), SqlCommandType.DELETE).parameterMap(new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "id", registry.getTypeHandler(int.class)).build());
        }
    }).build()).cache(authorCache).build();
    return ms;
}

######


public static MappedStatement prepareSelectOneAuthorMappedStatement(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    final ResultMap rm = new ResultMap.Builder(config, "defaultResultMap", Author.class, new ArrayList<ResultMapping>() {

        {
            add(new ResultMapping.Builder(config, "id", "id", registry.getTypeHandler(int.class)).build());
            add(new ResultMapping.Builder(config, "username", "username", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "password", "password", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "email", "email", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "bio", "bio", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "favouriteSection", "favourite_section", registry.getTypeHandler(Section.class)).build());
        }
    }).build();
    MappedStatement ms = new MappedStatement.Builder(config, "selectAuthor", new StaticSqlSource(config, "SELECT * FROM author WHERE id = ?"), SqlCommandType.SELECT).parameterMap(new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "id", registry.getTypeHandler(int.class)).build());
        }
    }).build()).resultMaps(new ArrayList<ResultMap>() {

        {
            add(rm);
        }
    }).cache(authorCache).build();
    return ms;
}

######


public static MappedStatement prepareSelectAllAuthorsAutoMappedStatement(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    return new MappedStatement.Builder(config, "selectAuthorAutoMap", new StaticSqlSource(config, "SELECT * FROM author ORDER BY id"), SqlCommandType.SELECT).resultMaps(new ArrayList<ResultMap>() {

        {
            add(new ResultMap.Builder(config, "defaultResultMap", Author.class, new ArrayList<ResultMapping>() {

                {
                    add(new ResultMapping.Builder(config, "favouriteSection", "favourite_section", registry.getTypeHandler(Section.class)).build());
                    add(new ResultMapping.Builder(config, null, "not_exists", Object.class).build());
                }
            }).build());
        }
    }).fetchSize(1000).timeout(2000).build();
}

######


public static MappedStatement prepareSelectOneAuthorMappedStatementWithConstructorResults(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    MappedStatement ms = new MappedStatement.Builder(config, "selectAuthor", new StaticSqlSource(config, "SELECT * FROM author WHERE id = ?"), SqlCommandType.SELECT).parameterMap(new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "id", registry.getTypeHandler(int.class)).build());
        }
    }).build()).resultMaps(new ArrayList<ResultMap>() {

        {
            add(new ResultMap.Builder(config, "defaultResultMap", Author.class, new ArrayList<ResultMapping>() {

                {
                    add(new ResultMapping.Builder(config, null, "id", registry.getTypeHandler(Integer.class)).javaType(int.class).flags(new ArrayList<ResultFlag>() {

                        {
                            add(ResultFlag.CONSTRUCTOR);
                        }
                    }).build());
                    add(new ResultMapping.Builder(config, "username", "username", registry.getTypeHandler(String.class)).build());
                    add(new ResultMapping.Builder(config, "password", "password", registry.getTypeHandler(String.class)).build());
                    add(new ResultMapping.Builder(config, "email", "email", registry.getTypeHandler(String.class)).build());
                    add(new ResultMapping.Builder(config, "bio", "bio", registry.getTypeHandler(String.class)).build());
                    add(new ResultMapping.Builder(config, "favouriteSection", "favourite_section", registry.getTypeHandler(Section.class)).build());
                }
            }).build());
        }
    }).cache(authorCache).build();
    return ms;
}

######


public static MappedStatement prepareSelectTwoSetsOfAuthorsProc(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    MappedStatement ms = new MappedStatement.Builder(config, "selectTwoSetsOfAuthors", new StaticSqlSource(config, "{call selectTwoSetsOfAuthors(?,?)}"), SqlCommandType.SELECT).statementType(StatementType.CALLABLE).parameterMap(new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "id1", registry.getTypeHandler(int.class)).build());
            add(new ParameterMapping.Builder(config, "id2", registry.getTypeHandler(int.class)).build());
        }
    }).build()).resultMaps(new ArrayList<ResultMap>() {

        {
            ResultMap map = new ResultMap.Builder(config, "defaultResultMap", Author.class, new ArrayList<ResultMapping>() {

                {
                    add(new ResultMapping.Builder(config, "id", "id", registry.getTypeHandler(int.class)).build());
                    add(new ResultMapping.Builder(config, "username", "username", registry.getTypeHandler(String.class)).build());
                    add(new ResultMapping.Builder(config, "password", "password", registry.getTypeHandler(String.class)).build());
                    add(new ResultMapping.Builder(config, "email", "email", registry.getTypeHandler(String.class)).build());
                    add(new ResultMapping.Builder(config, "bio", "bio", registry.getTypeHandler(String.class)).build());
                }
            }).build();
            add(map);
            add(map);
        }
    }).build();
    return ms;
}

######


public static MappedStatement prepareSelectAuthorViaOutParams(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    MappedStatement ms = new MappedStatement.Builder(config, "selectAuthorViaOutParams", new StaticSqlSource(config, "{call selectAuthorViaOutParams(?,?,?,?,?)}"), SqlCommandType.SELECT).statementType(StatementType.CALLABLE).parameterMap(new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "id", registry.getTypeHandler(int.class)).build());
            add(new ParameterMapping.Builder(config, "username", registry.getTypeHandler(String.class)).jdbcType(JdbcType.VARCHAR).mode(ParameterMode.OUT).build());
            add(new ParameterMapping.Builder(config, "password", registry.getTypeHandler(String.class)).jdbcType(JdbcType.VARCHAR).mode(ParameterMode.OUT).build());
            add(new ParameterMapping.Builder(config, "email", registry.getTypeHandler(String.class)).jdbcType(JdbcType.VARCHAR).mode(ParameterMode.OUT).build());
            add(new ParameterMapping.Builder(config, "bio", registry.getTypeHandler(String.class)).jdbcType(JdbcType.VARCHAR).mode(ParameterMode.OUT).build());
        }
    }).build()).resultMaps(new ArrayList<ResultMap>()).cache(authorCache).build();
    return ms;
}

######


public static MappedStatement prepareSelectDiscriminatedPost(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    final ResultMap discriminatorResultMap = new ResultMap.Builder(config, "postResultMap", HashMap.class, new ArrayList<ResultMapping>() {

        {
            add(new ResultMapping.Builder(config, "subject", "subject", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "body", "body", registry.getTypeHandler(String.class)).build());
        }
    }).build();
    config.addResultMap(discriminatorResultMap);
    MappedStatement ms = new MappedStatement.Builder(config, "selectPosts", new StaticSqlSource(config, "SELECT * FROM post"), SqlCommandType.SELECT).resultMaps(new ArrayList<ResultMap>() {

        {
            add(new ResultMap.Builder(config, "defaultResultMap", HashMap.class, new ArrayList<ResultMapping>() {

                {
                    add(new ResultMapping.Builder(config, "id", "id", registry.getTypeHandler(int.class)).build());
                    add(new ResultMapping.Builder(config, "blog_id", "blog_id", registry.getTypeHandler(int.class)).build());
                }
            }).discriminator(new Discriminator.Builder(config, new ResultMapping.Builder(config, "section", "section", registry.getTypeHandler(String.class)).build(), new HashMap<String, String>() {

                {
                    put("NEWS", discriminatorResultMap.getId());
                    put("VIDEOS", discriminatorResultMap.getId());
                    put("PODCASTS", discriminatorResultMap.getId());
                }
            }).build()).build());
        }
    }).build();
    return ms;
}

######


public static MappedStatement createInsertAuthorWithIDof99MappedStatement(final Configuration config) {
    MappedStatement ms = new MappedStatement.Builder(config, "insertAuthor", new StaticSqlSource(config, "INSERT INTO author (id,username,password,email,bio) values(99,'someone','******','someone@apache.org',null)"), SqlCommandType.INSERT).statementType(StatementType.STATEMENT).parameterMap(new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>()).build()).cache(authorCache).build();
    return ms;
}

######


public static MappedStatement createSelectAuthorWithIDof99MappedStatement(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    MappedStatement ms = new MappedStatement.Builder(config, "selectAuthor", new StaticSqlSource(config, "SELECT * FROM author WHERE id = 99"), SqlCommandType.SELECT).statementType(StatementType.STATEMENT).parameterMap(new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>()).build()).resultMaps(new ArrayList<ResultMap>() {

        {
            add(new ResultMap.Builder(config, "defaultResultMap", Author.class, new ArrayList<ResultMapping>() {

                {
                    add(new ResultMapping.Builder(config, "id", "id", registry.getTypeHandler(int.class)).build());
                    add(new ResultMapping.Builder(config, "username", "username", registry.getTypeHandler(String.class)).build());
                    add(new ResultMapping.Builder(config, "password", "password", registry.getTypeHandler(String.class)).build());
                    add(new ResultMapping.Builder(config, "email", "email", registry.getTypeHandler(String.class)).build());
                    add(new ResultMapping.Builder(config, "bio", "bio", registry.getTypeHandler(String.class)).build());
                }
            }).build());
        }
    }).build();
    return ms;
}

######


public static MappedStatement prepareComplexSelectBlogMappedStatement(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    final SqlSource sqlSource = new StaticSqlSource(config, "SELECT b.id, b.author_id, b.title, a.username, a.password, a.email, a.bio" + " FROM blog b" + " INNER JOIN author a ON b.author_id = a.id" + " WHERE b.id = ?");
    final ParameterMap parameterMap = new ParameterMap.Builder(config, "defaultParameterMap", int.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "id", registry.getTypeHandler(int.class)).build());
        }
    }).build();
    final ResultMap resultMap = new ResultMap.Builder(config, "defaultResultMap", Blog.class, new ArrayList<ResultMapping>() {

        {
            add(new ResultMapping.Builder(config, "id", "id", registry.getTypeHandler(int.class)).flags(new ArrayList<ResultFlag>() {

                {
                    add(ResultFlag.ID);
                }
            }).build());
            add(new ResultMapping.Builder(config, "title", "title", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "author.id", "author_id", registry.getTypeHandler(int.class)).build());
            add(new ResultMapping.Builder(config, "author.username", "username", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "author.password", "password", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "author.email", "email", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "author.bio", "bio", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "posts", "id", registry.getTypeHandler(int.class)).javaType(List.class).nestedQueryId("selectPostsForBlog").build());
        }
    }).build();
    return new MappedStatement.Builder(config, "selectBlogById", sqlSource, SqlCommandType.SELECT).parameterMap(parameterMap).resultMaps(new ArrayList<ResultMap>() {

        {
            add(resultMap);
        }
    }).build();
}

######


public static MappedStatement prepareSelectBlogByIdAndAuthor(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    final SqlSource sqlSource = new StaticSqlSource(config, "SELECT b.id, b.author_id, b.title, a.username, a.password, a.email, a.bio" + " FROM blog b" + " INNER JOIN author a ON b.author_id = a.id" + " WHERE b.id = ? and a.id = ?");
    final ParameterMap parameterMap = new ParameterMap.Builder(config, "defaultParameterMap", Map.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "blogId", registry.getTypeHandler(int.class)).build());
            add(new ParameterMapping.Builder(config, "authorId", registry.getTypeHandler(int.class)).build());
        }
    }).build();
    final ResultMap resultMap = new ResultMap.Builder(config, "defaultResultMap", Blog.class, new ArrayList<ResultMapping>() {

        {
            add(new ResultMapping.Builder(config, "id", "id", registry.getTypeHandler(int.class)).flags(new ArrayList<ResultFlag>() {

                {
                    add(ResultFlag.ID);
                }
            }).build());
            add(new ResultMapping.Builder(config, "title", "title", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "author.id", "author_id", registry.getTypeHandler(int.class)).build());
            add(new ResultMapping.Builder(config, "author.username", "username", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "author.password", "password", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "author.email", "email", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "author.bio", "bio", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "posts", "id", registry.getTypeHandler(int.class)).javaType(List.class).nestedQueryId("selectPostsForBlog").build());
        }
    }).build();
    return new MappedStatement.Builder(config, "selectBlogByIdAndAuthor", sqlSource, SqlCommandType.SELECT).parameterMap(parameterMap).resultMaps(new ArrayList<ResultMap>() {

        {
            add(resultMap);
        }
    }).build();
}

######


public static MappedStatement prepareSelectPostsForBlogMappedStatement(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    final SqlSource sqlSource = new StaticSqlSource(config, "SELECT p.id, p.created_on, p.blog_id, p.section, p.subject, p.body, pt.tag_id," + " t.name as tag_name, c.id as comment_id, c.name as comment_name, c.comment" + " FROM post p" + " INNER JOIN post_tag pt ON pt.post_id = p.id" + " INNER JOIN tag t ON pt.tag_id = t.id" + " LEFT OUTER JOIN comment c ON c.post_id = p.id" + " WHERE p.blog_id = ?");
    final ParameterMap parameterMap = new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "id", registry.getTypeHandler(int.class)).build());
        }
    }).build();
    final ResultMap tagResultMap = new ResultMap.Builder(config, "tagResultMap", Tag.class, new ArrayList<ResultMapping>() {

        {
            add(new ResultMapping.Builder(config, "id", "tag_id", registry.getTypeHandler(int.class)).flags(new ArrayList<ResultFlag>() {

                {
                    add(ResultFlag.ID);
                }
            }).build());
            add(new ResultMapping.Builder(config, "name", "tag_name", registry.getTypeHandler(String.class)).build());
        }
    }).build();
    final ResultMap commentResultMap = new ResultMap.Builder(config, "commentResultMap", Comment.class, new ArrayList<ResultMapping>() {

        {
            add(new ResultMapping.Builder(config, "id", "comment_id", registry.getTypeHandler(int.class)).flags(new ArrayList<ResultFlag>() {

                {
                    add(ResultFlag.ID);
                }
            }).build());
            add(new ResultMapping.Builder(config, "name", "comment_name", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "comment", "comment", registry.getTypeHandler(String.class)).build());
        }
    }).build();
    config.addResultMap(tagResultMap);
    config.addResultMap(commentResultMap);
    final ResultMap postResultMap = new ResultMap.Builder(config, "defaultResultMap", Post.class, new ArrayList<ResultMapping>() {

        {
            add(new ResultMapping.Builder(config, "id", "id", registry.getTypeHandler(int.class)).flags(new ArrayList<ResultFlag>() {

                {
                    add(ResultFlag.ID);
                }
            }).build());
            add(new ResultMapping.Builder(config, "blog", "blog_id", registry.getTypeHandler(int.class)).javaType(Blog.class).nestedQueryId("selectBlogById").build());
            add(new ResultMapping.Builder(config, "createdOn", "created_on", registry.getTypeHandler(Date.class)).build());
            add(new ResultMapping.Builder(config, "section", "section", registry.getTypeHandler(Section.class)).build());
            add(new ResultMapping.Builder(config, "subject", "subject", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "body", "body", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "tags").nestedResultMapId(tagResultMap.getId()).build());
            add(new ResultMapping.Builder(config, "comments").nestedResultMapId(commentResultMap.getId()).build());
        }
    }).build();
    return new MappedStatement.Builder(config, "selectPostsForBlog", sqlSource, SqlCommandType.SELECT).parameterMap(parameterMap).resultMaps(new ArrayList<ResultMap>() {

        {
            add(postResultMap);
        }
    }).build();
}

######


public static MappedStatement prepareSelectPostMappedStatement(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    final SqlSource sqlSource = new StaticSqlSource(config, "SELECT p.id, p.created_on, p.blog_id, p.section, p.subject, p.body, pt.tag_id," + " t.name as tag_name, c.id as comment_id, c.name as comment_name, c.comment" + " FROM post p" + " LEFT OUTER JOIN post_tag pt ON pt.post_id = p.id" + " LEFT OUTER JOIN tag t ON pt.tag_id = t.id" + " LEFT OUTER JOIN comment c ON c.post_id = p.id" + " WHERE p.id = ?");
    final ParameterMap parameterMap = new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "id", registry.getTypeHandler(int.class)).build());
        }
    }).build();
    final ResultMap tagResultMap = new ResultMap.Builder(config, "tagResultMap", Tag.class, new ArrayList<ResultMapping>() {

        {
            add(new ResultMapping.Builder(config, "id", "tag_id", registry.getTypeHandler(int.class)).flags(new ArrayList<ResultFlag>() {

                {
                    add(ResultFlag.ID);
                }
            }).build());
            add(new ResultMapping.Builder(config, "name", "tag_name", registry.getTypeHandler(String.class)).build());
        }
    }).build();
    final ResultMap commentResultMap = new ResultMap.Builder(config, "commentResultMap", Comment.class, new ArrayList<ResultMapping>() {

        {
            add(new ResultMapping.Builder(config, "id", "comment_id", registry.getTypeHandler(int.class)).flags(new ArrayList<ResultFlag>() {

                {
                    add(ResultFlag.ID);
                }
            }).build());
            add(new ResultMapping.Builder(config, "name", "comment_name", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "comment", "comment", registry.getTypeHandler(String.class)).build());
        }
    }).build();
    config.addResultMap(tagResultMap);
    config.addResultMap(commentResultMap);
    final ResultMap postResultMap = new ResultMap.Builder(config, "", Post.class, new ArrayList<ResultMapping>() {

        {
            add(new ResultMapping.Builder(config, "id", "id", registry.getTypeHandler(int.class)).flags(new ArrayList<ResultFlag>() {

                {
                    add(ResultFlag.ID);
                }
            }).build());
            add(new ResultMapping.Builder(config, "blog", "blog_id", registry.getTypeHandler(int.class)).javaType(Blog.class).nestedQueryId("selectBlogById").build());
            add(new ResultMapping.Builder(config, "createdOn", "created_on", registry.getTypeHandler(Date.class)).build());
            add(new ResultMapping.Builder(config, "section", "section", registry.getTypeHandler(Section.class)).build());
            add(new ResultMapping.Builder(config, "subject", "subject", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "body", "body", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "tags").nestedResultMapId(tagResultMap.getId()).build());
            add(new ResultMapping.Builder(config, "comments").nestedResultMapId(commentResultMap.getId()).build());
        }
    }).build();
    return new MappedStatement.Builder(config, "selectPostsForBlog", sqlSource, SqlCommandType.SELECT).parameterMap(parameterMap).resultMaps(new ArrayList<ResultMap>() {

        {
            add(postResultMap);
        }
    }).build();
}

######


public static MappedStatement prepareSelectPostWithBlogByAuthorMappedStatement(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    final SqlSource sqlSource = new StaticSqlSource(config, "SELECT p.id, p.created_on, p.blog_id, p.author_id, p.section, p.subject, p.body, pt.tag_id," + " t.name as tag_name, c.id as comment_id, c.name as comment_name, c.comment" + " FROM post p" + " LEFT OUTER JOIN post_tag pt ON pt.post_id = p.id" + " LEFT OUTER JOIN tag t ON pt.tag_id = t.id" + " LEFT OUTER JOIN comment c ON c.post_id = p.id" + " WHERE p.id = ?");
    final ParameterMap parameterMap = new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "id", registry.getTypeHandler(int.class)).build());
        }
    }).build();
    final ResultMap tagResultMap = new ResultMap.Builder(config, "tagResultMap", Tag.class, new ArrayList<ResultMapping>() {

        {
            add(new ResultMapping.Builder(config, "id", "tag_id", registry.getTypeHandler(int.class)).flags(new ArrayList<ResultFlag>() {

                {
                    add(ResultFlag.ID);
                }
            }).build());
            add(new ResultMapping.Builder(config, "name", "tag_name", registry.getTypeHandler(String.class)).build());
        }
    }).build();
    final ResultMap commentResultMap = new ResultMap.Builder(config, "commentResultMap", Comment.class, new ArrayList<ResultMapping>() {

        {
            add(new ResultMapping.Builder(config, "id", "comment_id", registry.getTypeHandler(int.class)).flags(new ArrayList<ResultFlag>() {

                {
                    add(ResultFlag.ID);
                }
            }).build());
            add(new ResultMapping.Builder(config, "name", "comment_name", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "comment", "comment", registry.getTypeHandler(String.class)).build());
        }
    }).build();
    config.addResultMap(tagResultMap);
    config.addResultMap(commentResultMap);
    final ResultMap postResultMap = new ResultMap.Builder(config, "postResultMap", Post.class, new ArrayList<ResultMapping>() {

        {
            add(new ResultMapping.Builder(config, "id", "id", registry.getTypeHandler(int.class)).flags(new ArrayList<ResultFlag>() {

                {
                    add(ResultFlag.ID);
                }
            }).build());
            add(new ResultMapping.Builder(config, "blog").nestedQueryId("selectBlogByIdAndAuthor").composites(new ArrayList<ResultMapping>() {

                {
                    add(new ResultMapping.Builder(config, "authorId", "author_id", registry.getTypeHandler(int.class)).build());
                    add(new ResultMapping.Builder(config, "blogId", "blog_id", registry.getTypeHandler(int.class)).build());
                }
            }).build());
            add(new ResultMapping.Builder(config, "createdOn", "created_on", registry.getTypeHandler(Date.class)).build());
            add(new ResultMapping.Builder(config, "section", "section", registry.getTypeHandler(Section.class)).build());
            add(new ResultMapping.Builder(config, "subject", "subject", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "body", "body", registry.getTypeHandler(String.class)).build());
            add(new ResultMapping.Builder(config, "tags").nestedResultMapId(tagResultMap.getId()).build());
            add(new ResultMapping.Builder(config, "comments").nestedResultMapId(commentResultMap.getId()).build());
        }
    }).build();
    return new MappedStatement.Builder(config, "selectPostsForBlog", sqlSource, SqlCommandType.SELECT).parameterMap(parameterMap).resultMaps(new ArrayList<ResultMap>() {

        {
            add(postResultMap);
        }
    }).build();
}

######


public static MappedStatement prepareInsertAuthorMappedStatementWithBeforeAutoKey(final Configuration config) {
    final TypeHandlerRegistry registry = config.getTypeHandlerRegistry();
    final ResultMap rm = new ResultMap.Builder(config, "keyResultMap", Integer.class, new ArrayList<ResultMapping>()).build();
    MappedStatement kms = new MappedStatement.Builder(config, "insertAuthor!selectKey", new StaticSqlSource(config, "SELECT 123456 as id FROM SYSIBM.SYSDUMMY1"), SqlCommandType.SELECT).keyProperty("id").resultMaps(new ArrayList<ResultMap>() {

        {
            add(rm);
        }
    }).build();
    config.addMappedStatement(kms);
    MappedStatement ms = new MappedStatement.Builder(config, "insertAuthor", new DynamicSqlSource(config, new TextSqlNode("INSERT INTO author (id,username,password,email,bio,favourite_section) values(#{id},#{username},#{password},#{email},#{bio:VARCHAR},#{favouriteSection})")), SqlCommandType.INSERT).parameterMap(new ParameterMap.Builder(config, "defaultParameterMap", Author.class, new ArrayList<ParameterMapping>() {

        {
            add(new ParameterMapping.Builder(config, "id", registry.getTypeHandler(Integer.class)).build());
            add(new ParameterMapping.Builder(config, "username", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "password", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "email", registry.getTypeHandler(String.class)).build());
            add(new ParameterMapping.Builder(config, "bio", registry.getTypeHandler(String.class)).jdbcType(JdbcType.VARCHAR).build());
            add(new ParameterMapping.Builder(config, "favouriteSection", registry.getTypeHandler(Section.class)).jdbcType(JdbcType.VARCHAR).build());
        }
    }).build()).cache(authorCache).keyGenerator(new SelectKeyGenerator(kms, true)).keyProperty("id").build();
    return ms;
}

######


public void insertar(Factura vo) throws SQLException {
    PreparedStatement sentencia = cnn.prepareStatement("INSERT INTO factura ( fechafactura , tipofactura, valorunitario, valortotal, descuento, detalles, idempleado, devolucion) " + "VALUES(?,?,?,?,?,?,?,?)");
    sentencia.setDate(1, new java.sql.Date(vo.getFechafactura().getTime()));
    sentencia.setString(2, vo.getTipofactura());
    sentencia.setInt(3, vo.getValorunitario());
    sentencia.setInt(4, vo.getValortotal());
    sentencia.setDouble(5, vo.getDescuento());
    sentencia.setString(6, vo.getDetalles());
    sentencia.setInt(7, vo.getIdempleado());
    sentencia.setDouble(8, vo.getDevolucion());
    sentencia.executeUpdate();
}

######


public void borrar(Factura vo) throws SQLException {
    PreparedStatement sentencia = cnn.prepareStatement("DELETE factura " + "WHERE idcontacto = ?");
    sentencia.setInt(1, vo.getCodfactura());
    sentencia.executeUpdate();
}

######


public void modificar(Factura vo) throws SQLException {
    PreparedStatement sentencia = cnn.prepareStatement("UPDATE factura SET fechafactura= ?,tipofactura= ?,valorunitario= ?,valortotal=?,descuento= ?,detalles= ?,idempleado=?,devolucion=? " + "WHERE codfactura = ?");
    sentencia.setDate(1, new java.sql.Date(vo.getFechafactura().getTime()));
    sentencia.setString(2, vo.getTipofactura());
    sentencia.setInt(3, vo.getValorunitario());
    sentencia.setInt(4, vo.getValortotal());
    sentencia.setDouble(5, vo.getDescuento());
    sentencia.setString(6, vo.getDetalles());
    sentencia.setInt(7, vo.getIdempleado());
    sentencia.setDouble(8, vo.getDevolucion());
    sentencia.setInt(9, vo.getCodfactura());
    sentencia.executeUpdate();
}

######


public List<Factura> consultar() throws SQLException {
    List<Factura> listaFactura = new ArrayList<>();
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM factura");
    ResultSet resultado = sentencia.executeQuery();
    while (resultado.next()) {
        Factura voTemp = new Factura();
        voTemp.setFechafactura(resultado.getDate("fechafactura"));
        voTemp.setTipofactura(resultado.getString("tipofactura"));
        voTemp.setValorunitario(resultado.getInt("valorunitario"));
        voTemp.setValortotal(resultado.getInt("valortotal"));
        voTemp.setDescuento(resultado.getDouble("descuento"));
        voTemp.setDetalles(resultado.getString("detalles"));
        voTemp.setDevolucion(resultado.getDouble("devolucion"));
        listaFactura.add(voTemp);
    }
    if (listaFactura.size() > 0) {
        return listaFactura;
    } else {
        return null;
    }
}

######


public List<Factura> consultarf() throws SQLException {
    List<Factura> listaFactura = new ArrayList<>();
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM factura");
    ResultSet resultado = sentencia.executeQuery();
    while (resultado.next()) {
        Factura voTemp = new Factura();
        voTemp.setCodfactura(resultado.getInt("codfactura"));
        voTemp.setFechafactura(resultado.getDate("fechafactura"));
        listaFactura.add(voTemp);
    }
    if (listaFactura.size() > 0) {
        return listaFactura;
    } else {
        return null;
    }
}

######


public List<Factura> consultarnombre(String nombre) throws SQLException {
    List<Factura> listaEmpleado = new ArrayList<>();
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM factura");
    ResultSet resultado = sentencia.executeQuery();
    while (resultado.next()) {
        Factura voTemp = new Factura();
        voTemp.setFechafactura(resultado.getDate("fechafactura"));
        voTemp.setTipofactura(resultado.getString("tipofactura"));
        voTemp.setValorunitario(resultado.getInt("valorunitario"));
        voTemp.setValortotal(resultado.getInt("valortotal"));
        voTemp.setDescuento(resultado.getDouble("descuento"));
        voTemp.setDetalles(resultado.getString("detalles"));
        voTemp.setDevolucion(resultado.getDouble("devolucion"));
        listaEmpleado.add(voTemp);
    }
    if (listaEmpleado.size() > 0) {
        return listaEmpleado;
    } else {
        return null;
    }
}

######


public Factura queryNombre(String tipofactura) throws SQLException, ParseException {
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM factura WHERE tipofactura=?");
    sentencia.setString(1, tipofactura);
    ResultSet resultado = sentencia.executeQuery();
    if (resultado.next()) {
        return getVo(resultado);
    }
    return null;
}

######


public Factura getVo(ResultSet resultado) throws SQLException, ParseException {
    Factura vot = new Factura();
    SimpleDateFormat formato = new SimpleDateFormat("yyyy-MM-dd");
    vot.setFechafactura(formato.parse(resultado.getString("fechafactura")));
    vot.setTipofactura(resultado.getString("tipofactura"));
    vot.setValorunitario(resultado.getInt("valorunitario"));
    vot.setValortotal(resultado.getInt("valortotal"));
    vot.setDescuento(resultado.getDouble("descuento"));
    vot.setDetalles(resultado.getString("detalles"));
    vot.setDevolucion(resultado.getDouble("devolucion"));
    return vot;
}

######


public void insertar(FacturaProducto vo) throws SQLException {
    PreparedStatement sentencia = cnn.prepareStatement("INSERT INTO factura_producto (idproducto,codfactura,cantidatotal,subtotal)" + "VALUES(?,?,?,?)");
    sentencia.setInt(1, vo.getIdproducto());
    sentencia.setInt(2, vo.getCodfactura());
    sentencia.setInt(3, vo.getCantidadtotal());
    sentencia.setDouble(4, vo.getSubtotal());
    sentencia.executeUpdate();
}

######


public List<FacturaProducto> consultar() throws SQLException {
    List<FacturaProducto> listaFacturaproducto = new ArrayList<>();
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM factura_producto");
    ResultSet resultado = sentencia.executeQuery();
    while (resultado.next()) {
        FacturaProducto voTemp = new FacturaProducto();
        voTemp.setIdproducto(resultado.getInt("idproducto"));
        voTemp.setCodfactura(resultado.getInt("codfactura"));
        voTemp.setCantidadtotal(resultado.getInt("cantidatotal"));
        voTemp.setSubtotal(resultado.getDouble("subtotal"));
        voTemp.setIdfacturaproducto(resultado.getInt("idfacturaproducto"));
        listaFacturaproducto.add(voTemp);
    }
    if (listaFacturaproducto.size() > 0) {
        return listaFacturaproducto;
    } else {
        return null;
    }
}

######


public void modificar(FacturaProducto vo) throws SQLException {
    PreparedStatement sentencia = cnn.prepareStatement("UPDATE factura_producto SET idproducto= ?,codfactura= ?,cantidatotal= ?,subtotal=?" + "WHERE idfacturaproducto = ?");
    sentencia.setInt(1, vo.getIdproducto());
    sentencia.setInt(2, vo.getCodfactura());
    sentencia.setInt(3, vo.getCantidadtotal());
    sentencia.setDouble(4, vo.getSubtotal());
    sentencia.setDouble(5, vo.getIdfacturaproducto());
    sentencia.executeUpdate();
}

######


public List<FacturaProducto> consultarnombre(String nombre) throws SQLException {
    List<FacturaProducto> listaEmpleado = new ArrayList<>();
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM factura_producto");
    ResultSet resultado = sentencia.executeQuery();
    while (resultado.next()) {
        FacturaProducto voTemp = new FacturaProducto();
        voTemp.setCantidadtotal(resultado.getInt("cantidatotal"));
        voTemp.setSubtotal(resultado.getDouble("subtotal"));
        listaEmpleado.add(voTemp);
    }
    if (listaEmpleado.size() > 0) {
        return listaEmpleado;
    } else {
        return null;
    }
}

######


public FacturaProducto queryNombre(int cantidadtotal) throws SQLException, ParseException {
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM factura_producto WHERE cantidatotal=?");
    sentencia.setString(1, Integer.toString(cantidadtotal));
    ResultSet resultado = sentencia.executeQuery();
    if (resultado.next()) {
        return getVo(resultado);
    }
    return null;
}

######


public FacturaProducto consultaridFacturaProducto(int idfacturaproducto) throws SQLException, ParseException {
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM factura_producto WHERE idfacturaproducto=?");
    sentencia.setInt(1, idfacturaproducto);
    ResultSet resultado = sentencia.executeQuery();
    if (resultado.next()) {
        return getVo(resultado);
    }
    return null;
}

######


public FacturaProducto getVo(ResultSet resultado) throws SQLException, ParseException {
    FacturaProducto vot = new FacturaProducto();
    vot.setCantidadtotal(resultado.getInt("cantidadtotal"));
    vot.setSubtotal(resultado.getDouble("subtotal"));
    return vot;
}

######


public static synchronized FavoritePlayTableHelper getInstance(Context context) {
    if (mInstance == null) {
        mInstance = new FavoritePlayTableHelper(context);
    }
    return mInstance;
}

######


public void inserSong(SongDetail songDetail, int isFav) {
    try {
        sampleDB = dbHelper.getDB();
        sampleDB.beginTransaction();
        String sql = "Insert or Replace into " + TABLENAME + " values(?,?,?,?,?,?,?,?,?,?,?);";
        SQLiteStatement insert = sampleDB.compileStatement(sql);
        try {
            if (songDetail != null) {
                insert.clearBindings();
                insert.bindLong(1, songDetail.getId());
                insert.bindLong(2, songDetail.getAlbum_id());
                insert.bindString(3, songDetail.getArtist());
                insert.bindString(4, songDetail.getTitle());
                insert.bindString(5, songDetail.getDisplay_name());
                insert.bindString(6, songDetail.getDuration());
                insert.bindString(7, songDetail.getPath());
                insert.bindString(8, songDetail.audioProgress + "");
                insert.bindString(9, songDetail.audioProgressSec + "");
                insert.bindString(10, System.currentTimeMillis() + "");
                insert.bindLong(11, isFav);
                insert.execute();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        sampleDB.setTransactionSuccessful();
    } catch (Exception e) {
        Log.e("XML:", e.toString());
    } finally {
        sampleDB.endTransaction();
    }
}

######


private void closeCurcor(Cursor cursor) {
    if (cursor != null) {
        cursor.close();
        cursor = null;
    }
}

######


public Cursor getFavoriteSongList() {
    Cursor mCursor = null;
    try {
        String sqlQuery = "Select * from " + TABLENAME + " where " + ISFAVORITE + "=1";
        sampleDB = dbHelper.getDB();
        mCursor = sampleDB.rawQuery(sqlQuery, null);
    } catch (Exception e) {
        closeCurcor(mCursor);
        e.printStackTrace();
    }
    return mCursor;
}

######


public boolean getIsFavorite(SongDetail mDetail) {
    Cursor mCursor = null;
    try {
        String sqlQuery = "Select * from " + TABLENAME + " where " + ID + "=" + mDetail.getId() + " and " + ISFAVORITE + "=1";
        sampleDB = dbHelper.getDB();
        mCursor = sampleDB.rawQuery(sqlQuery, null);
        if (mCursor != null && mCursor.getCount() >= 1) {
            closeCurcor(mCursor);
            return true;
        }
    } catch (Exception e) {
        closeCurcor(mCursor);
        e.printStackTrace();
    }
    return false;
}

######


private boolean between(int begin, int end, int pos) {
    return pos >= begin && pos <= end;
}

######


private boolean hasNegation(int pos, List<Word> negs) {
    int trg_pos = WPos2Chunk(pos);
    for (Word w : negs) {
        int c_pos = WPos2Chunk(w.pos);
        if (c_pos == trg_pos && pos > w.pos) {
            return true;
        }
    }
    return false;
}

######


private FeatureData getPhraseFeatures(SenData sen, int pos1, int pos2, boolean train, String f_name, DDIPair pair) {
    FeatureData vector = new FeatureData();
    Set<String> features = new HashSet<>();
    int begin = sen.chunks.get(pos1).begin;
    int end = sen.chunks.get(pos2).end;
    FeatureIndex fdx = featureMap.get(f_name);
    if (fdx == null && train) {
        fdx = new FeatureIndex();
        featureMap.put(f_name, fdx);
    }
    List<Word> trgs = getTriggers(sen, begin, end);
    if (trgs.isEmpty()) {
        return null;
    }
    if (fdx == null) {
        System.out.println("BUG ----> ");
        return null;
    }
    int cpos1 = WPos2Chunk(pair.arg1.pos);
    int cpos2 = WPos2Chunk(pair.arg2.pos);
    if (cpos1 == cpos2) {
        features.add("same_chunk");
    } else {
        features.add("not_same_chunk");
    }
    String[] tk = sen.tokens;
    if (!trgs.isEmpty()) {
        Set<String> flist = formNPData(pair, trgs);
        features.addAll(flist);
    }
    for (int i = pair.arg1.pos + 1; i <= pair.arg2.pos; i++) {
        String txt = tk[i].toLowerCase();
        if (!txt.startsWith("drug") && (vocSet.contains(txt))) {
            features.add(txt);
        }
        if (txt.equals(":") && !tk[i - 1].equals("following")) {
            features.add("has_separator");
        } else if (tk[i].equals(":") && tk[i - 1].equals("following")) {
            features.add("following:");
        }
    }
    if (pair.arg1.pos - 1 >= begin) {
        String val = tk[pair.arg1.pos - 1].toLowerCase();
        if (val.equals("(") || val.equals(",")) {
            features.add(val + "_drug1");
        }
    }
    if (tk[pair.arg1.pos + 1].equals(",") || tk[pair.arg1.pos + 1].equals(")")) {
        features.add("drug1_" + tk[pair.arg1.pos + 1]);
    }
    if (pair.arg1.pos + 2 == pair.arg2.pos) {
        features.add("drug1_" + tk[pair.arg1.pos + 1] + "_drug2");
    }
    if (pair.arg2.pos - 1 >= begin) {
        String val = tk[pair.arg2.pos - 1].toLowerCase();
        if (!val.startsWith("drug")) {
            features.add(val + "_drug2");
        }
    }
    if (pair.arg2.pos + 1 <= end) {
        String val = tk[pair.arg2.pos + 1].toLowerCase();
        if (!val.startsWith("drug")) {
            features.add("drug2_" + val);
        }
    }
    List<Word> wlist;
    wlist = getWords(sen.prepList, pair.arg1.pos, pair.arg2.pos);
    if (!wlist.isEmpty()) {
        Word prev = null;
        for (Word w : wlist) {
            features.add(w.word);
            if (prev != null) {
                features.add(prev.word + "_" + w.word);
            }
            prev = w;
        }
    } else {
        features.add("no_preposition_between");
    }
    wlist = getWords(sen.negList, begin, pair.arg2.pos);
    if (!wlist.isEmpty()) {
        for (Word w : wlist) {
            features.add(w.word + "_" + tk[w.pos + 1]);
        }
    } else {
        features.add("no_negation");
    }
    wlist = getWords(sen.relList, begin, pair.arg2.pos);
    if (!wlist.isEmpty()) {
        for (Word w : wlist) {
            if (hasNegation(w.pos, sen.negList)) {
                features.add("no_" + w.word.toLowerCase());
            } else {
                features.add(w.word.toLowerCase());
            }
        }
    } else {
        features.add("no_trigger_word");
    }
    if (train) {
        for (String s : features) {
            int idx = fdx.add(s);
            vector.add(idx, 1);
        }
    } else {
        for (String s : features) {
            int idx = fdx.getIndex(s);
            if (idx >= 0) {
                vector.add(idx, 1);
            }
        }
    }
    return vector;
}

######


boolean hasCommaBetween(int pos1, int pos2) {
    Chunk c;
    for (int i = pos1 + 1; i < pos2; i++) {
        c = chunkList.get(i);
        if (c.txt.equals(",")) {
            return true;
        }
    }
    return false;
}

######


private Set<String> formNPData(DDIPair r, List<Word> trgs) {
    Set<String> flist = new HashSet<>();
    Word trg;
    int pos1 = WPos2Chunk(r.arg1.pos);
    int pos2 = WPos2Chunk(r.arg2.pos);
    int type;
    for (int i = 0; i < trgs.size(); i++) {
        trg = trgs.get(i);
        type = Integer.parseInt(trg.type);
        int tg_pos = WPos2Chunk(trg.pos);
        if (hasNegation(trg.pos, currSen.negList)) {
            flist.add("neg_" + trg.word);
        }
        if (type >= 5 || type < 2) {
            continue;
        }
        String trg_word = trg.word.toLowerCase();
        if (trg.posTag.startsWith("NN")) {
            if (tg_pos < pos1) {
                String prep1, prep2;
                int count = countPreps(tg_pos, pos1);
                if (count == 0 || count >= 2) {
                    continue;
                }
                count = countPreps(pos1, pos2);
                if (count == 0 || count > 2) {
                    continue;
                }
                prep2 = findPrep(pos1, pos2);
                prep1 = findPrep(tg_pos, pos1);
                flist.add(trg_word + "_on_left");
                if (prep1 != null) {
                    flist.add(trg_word + "_" + prep1 + "_drug1");
                } else {
                    flist.add(trg_word + "_no_prep_drug1");
                }
                if (prep2 != null) {
                    if (prep1 != null) {
                        flist.add(trg_word + "_" + prep1 + "_" + prep2);
                    }
                    flist.add(trg_word + "_" + prep1 + "_drug1_" + prep2 + "_drug2");
                }
            } else if (pos1 < tg_pos && tg_pos < pos2) {
                String prep1, prep2;
                prep1 = findPrep(pos1, tg_pos);
                prep2 = findPrep(tg_pos, pos2);
                if (prep1 != null) {
                    flist.add("drug1_" + prep1 + "_" + trg_word);
                } else {
                    flist.add("drug1_no_prep_" + trg_word);
                }
                if (prep1 != null && prep2 != null) {
                    flist.add("drug1_" + prep1 + "_" + trg.word + "_" + prep2 + "_drug2");
                } else {
                    flist.add("between_drug_" + trg_word);
                }
                if (prep2 != null) {
                    flist.add(trg.word + "_" + prep2 + "_drug2");
                }
            }
        } else if (trg.posTag.startsWith("VB")) {
            if (pos1 < tg_pos && pos2 > tg_pos) {
                String prep = findPrep(pos1, tg_pos);
                if (prep != null) {
                    flist.add("drug1_" + prep + "_" + trg_word);
                } else {
                    flist.add("drug1_no_prep_" + trg_word);
                }
                prep = findPrep(tg_pos, pos2);
                if (prep != null) {
                    flist.add(trg_word + "_" + prep + "_drug2");
                } else {
                    flist.add(trg_word + "_no_prep_drug2");
                }
                flist.add("between_pos_" + trg_word);
            } else if (tg_pos <= pos1 && tg_pos < pos2) {
                flist.add(trg_word + "_on_left");
                String prep = findPrep(tg_pos, pos1);
                if (prep != null) {
                    flist.add(trg_word + "_" + prep + "_drug1");
                } else {
                    flist.add(trg_word + "_no_prep_drug1");
                }
                prep = findPrep(pos1, pos2);
                if (prep != null) {
                    flist.add("drug1_" + prep + "_drug2");
                } else {
                    flist.add("drug1_no_prep_drug2");
                }
            } else if (tg_pos > pos1 && tg_pos > pos2) {
                flist.add(trg_word + "_on_right");
                String prep = findPrep(pos2, tg_pos);
                if (prep != null) {
                    flist.add("drug2_" + prep + "_" + trg_word);
                } else {
                    flist.add("drug2_no_prep_" + trg_word);
                }
                prep = findPrep(pos1, pos2);
                if (prep != null) {
                    flist.add("drug1_" + prep + "_drug2");
                } else {
                    flist.add("drug1_no_prep_drug2");
                }
            }
        }
    }
    return flist;
}

######


private int countPreps(int pos1, int pos2) {
    if ((pos1 == pos2)) {
        Chunk c = chunkList.get(pos1);
        if (c.txt.contains(" and ")) {
            return 1;
        }
    } else {
        int count = 0;
        for (int i = pos1 + 1; i < pos2; i++) {
            Chunk c = chunkList.get(i);
            if (c.type.equals("PP") && Data.prepSet.contains(c.txt)) {
                count++;
            }
        }
        return count;
    }
    return 0;
}

######


private FeatureData getLexicalFeatures(SenData sen, int begin, int end, int pos, String f_name, boolean train, int len, boolean subject) {
    FeatureData vector = new FeatureData();
    Set<String> features = new HashSet<>();
    FeatureIndex fdx = featureMap.get(f_name);
    int pos1 = chunkList.get(begin).begin;
    int pos2 = chunkList.get(end).end;
    if (fdx == null && train) {
        fdx = new FeatureIndex();
        featureMap.put(f_name, fdx);
    }
    if (fdx == null) {
        return null;
    }
    if (begin > end) {
        return null;
    }
    String[] tk = sen.tokens;
    int start, stop;
    if (subject) {
        start = Math.max(pos1, pos - 3);
        for (int i = start; i < pos; i++) {
            String txt = tk[i].toLowerCase();
            if (!txt.startsWith("drug")) {
                features.add(tk[i].toLowerCase() + "_left");
            }
        }
        stop = Math.min(pos2, pos + 3);
        for (int i = pos + 1; i < stop; i++) {
            String txt = tk[i].toLowerCase();
            if (!txt.startsWith("drug")) {
                features.add(tk[i].toLowerCase() + "_right");
            } else {
            }
        }
    } else {
        String[] POS = sen.POS;
        int c_pos = WPos2Chunk(pos);
        start = Math.max(begin, c_pos - 3);
        pos1 = chunkList.get(start).begin;
        for (int i = pos1; i < pos; i++) {
            String txt = lemma.lemmatize(tk[i], POS[i]);
            features.add(txt + "_left");
        }
        stop = Math.min(end, c_pos + len);
        pos2 = chunkList.get(stop).end;
        for (int i = pos + 1; i < pos2; i++) {
            String txt = lemma.lemmatize(tk[i], POS[i]);
            features.add(txt + "_right");
        }
    }
    if (train) {
        for (String s : features) {
            int idx = fdx.add(s);
            vector.add(idx, 1);
        }
    } else {
        for (String s : features) {
            int idx = fdx.getIndex(s);
            if (idx >= 0) {
                vector.add(idx, 1);
            }
        }
    }
    return vector;
}

######


private List<String> getPrepFeatures(String pre, int pos1, int pos2, List<Chunk> ls) {
    List<String> list = new ArrayList<>();
    String txt2 = pre + "_";
    int idx = 0, np = 0;
    Chunk c;
    if (pos1 == pos2) {
        txt2 += "no_prep_";
        list.add(txt2);
        return list;
    }
    for (int i = pos1; i < pos2; i++) {
        c = ls.get(i);
        if (Data.prepSet.contains(c.txt)) {
            txt2 = txt2 + c.txt + "_" + idx;
            idx++;
        }
    }
    c = ls.get(pos2);
    if (Data.prepSet.contains(c.txt)) {
        txt2 = txt2 + c.txt;
    }
    list.add(txt2);
    return list;
}

######


private FeatureData getSyntaticFeatures(SenData sen, int begin, int end, int pos, String f_name, boolean train) {
    FeatureData vector = new FeatureData();
    Set<String> features = new HashSet<>();
    FeatureIndex fdx = featureMap.get(f_name);
    int pos1 = chunkList.get(begin).begin;
    int pos2 = chunkList.get(end).end;
    int arg_pos = WPos2Chunk(pos);
    if (fdx == null && train) {
        fdx = new FeatureIndex();
        featureMap.put(f_name, fdx);
    }
    if (fdx == null) {
        return null;
    }
    int prep_count = 0, noun_count = 0;
    for (int i = begin; i <= arg_pos; i++) {
        Chunk c = chunkList.get(i);
        if (c.type.equals("PP")) {
            features.add(c.txt + "_" + prep_count);
            prep_count++;
        } else if (c.type.equals("NP")) {
            features.add(c.type + noun_count);
            noun_count++;
        }
    }
    features.add("Prep_count_" + prep_count);
    features.add("Noun_count_" + noun_count);
    List<Word> ls = getWords(sen.relList, pos1, pos2);
    if (ls != null && !ls.isEmpty()) {
        for (Word w : ls) {
            int tg_pos = WPos2Chunk(w.pos);
            int type = Integer.parseInt(w.type);
            String pre = w.pos < pos ? "l_" : "r_";
            String tg_word = pre + w.word.toLowerCase();
            if (hasNegation(w.pos, sen.negList)) {
                tg_word = "neg_" + w.word.toLowerCase();
            }
            if (type >= 2 && type < 5) {
                List<String> ft = getPrepFeatures(tg_word, tg_pos, arg_pos, chunkList);
                features.addAll(ft);
            } else {
                features.add(tg_word);
            }
        }
    } else {
        features.add("no_rel_word");
    }
    List<Word> drLs = getWords(sen.drugList, pos, pos2);
    if (drLs.isEmpty()) {
        features.add("_no_other_argument");
    } else {
        features.add("_has_other_arguments");
        int j = 0;
        int arg_count = 1;
        while (j < drLs.size()) {
            Word dr = drLs.get(j);
            int dr_pos = WPos2Chunk(dr.pos);
            if (dr_pos == arg_pos) {
                String[] tk = sen.tokens;
                for (int i = pos + 1; i < dr.pos; i++) {
                    if (tk[i].equals("and") || tk[i].equals(",")) {
                        features.add(tk[i] + "_arg");
                        break;
                    }
                }
            } else {
                List<Word> preps = getPrep(pos, dr.pos, sen.prepList);
                if (!preps.isEmpty()) {
                    String v = "";
                    for (Word p : preps) {
                        int p_pos = WPos2Chunk(p.pos);
                        if (p_pos + 1 == dr_pos) {
                            features.add(p.word + "_arg");
                        } else {
                            features.add("_no_link_with_arg");
                        }
                        break;
                    }
                    features.add(v + "_arg");
                    break;
                } else {
                    features.add("arg_" + arg_count);
                    arg_count++;
                }
            }
            j++;
        }
    }
    if (train) {
        for (String s : features) {
            int idx = fdx.add(s);
            vector.add(idx, 1);
        }
    } else {
        for (String s : features) {
            int idx = fdx.getIndex(s);
            if (idx >= 0) {
                vector.add(idx, 1);
            }
        }
    }
    return vector;
}

######


private FeatureData getVBPhraseFeatures(SenData sen, Chunk vb_chunk, String f_name, boolean train) {
    FeatureData vector = new FeatureData();
    FeatureIndex fdx = featureMap.get(f_name);
    if (fdx == null && train) {
        fdx = new FeatureIndex();
        featureMap.put(f_name, fdx);
    }
    if (fdx == null) {
        return null;
    }
    Set<String> features = new HashSet<>();
    int pos1 = vb_chunk.begin;
    int pos2 = vb_chunk.end;
    String[] tk = sen.tokens;
    List<Word> ls = getWords(sen.relList, pos1, pos2);
    if (ls.isEmpty()) {
        features.add("no_trigger_word");
    } else {
        features.add("has_trigger_word");
        for (Word w : ls) {
            if (hasNegation(w.pos, sen.negList)) {
                features.add("neg_" + w.word.toLowerCase());
            } else {
                features.add(w.word.toLowerCase() + "_" + w.posTag);
            }
        }
    }
    ls = getWords(sen.negList, pos1, pos2);
    if (ls != null && !ls.isEmpty()) {
        for (Word w : ls) {
            features.add(w.word.toLowerCase());
        }
    } else {
        features.add("no_negation_word");
    }
    String txt = null;
    for (int i = pos1; i <= pos2; i++) {
        String token = tk[i].toLowerCase();
        features.add(token);
        if (txt != null) {
            features.add(txt + "_" + token);
        }
        txt = tk[i].toLowerCase();
    }
    int c_pos = sen.chunks.indexOf(vb_chunk);
    if (c_pos < sen.chunks.size() - 1) {
        Chunk c = sen.chunks.get(c_pos + 1);
        if (c.type.equals("ADVP")) {
            features.add(c.txt + "_right_pos");
        }
    }
    if (pos1 > 0 && Data.connnectSet.contains(tk[pos1 - 1].toLowerCase())) {
        features.add(tk[pos1 - 1] + "_left_pos");
    }
    if (pos1 == pos2 && Data.beSet.contains(tk[pos1])) {
        if (c_pos < sen.chunks.size() - 1) {
            Chunk c = sen.chunks.get(c_pos + 1);
            if (c.type.equals("NP") || c.type.equals("ADJP")) {
                features.add(c.txt + "_right_pos");
            }
        }
    }
    if (train) {
        for (String s : features) {
            int idx = fdx.add(s);
            vector.add(idx, 1);
        }
    } else {
        for (String s : features) {
            int idx = fdx.getIndex(s);
            if (idx >= 0) {
                vector.add(idx, 1);
            }
        }
    }
    return vector;
}

######


public FeatureData getAuxiliaryFeatures(SenData sen, DDIPair pair, int pos1, int pos2, String f_name, boolean train) {
    FeatureData vector = new FeatureData();
    Set<String> features = new HashSet<>();
    FeatureIndex fdx = featureMap.get(f_name);
    int begin = sen.chunks.get(pos1).begin;
    int end = sen.chunks.get(pos2).end;
    if (fdx == null && train) {
        fdx = new FeatureIndex();
        featureMap.put(f_name, fdx);
    }
    if (fdx == null) {
        return null;
    }
    int cpos1 = WPos2Chunk(pair.arg1.pos);
    int cpos2 = WPos2Chunk(pair.arg2.pos);
    if (cpos1 == cpos2) {
        features.add("same_chunk");
    } else {
        features.add("not_same_chunk");
    }
    if (pair.arg1.word.toLowerCase().startsWith("drug") || pair.arg2.word.toLowerCase().startsWith("drug")) {
        features.add("arg_has_drug_word");
    }
    String[] tk = sen.tokens;
    for (int i = pair.arg1.pos + 1; i <= pair.arg2.pos; i++) {
        String txt = tk[i].toLowerCase();
        if (txt.equals(":") && !tk[i - 1].equals("following")) {
            features.add("has_separator");
        } else if (tk[i].equals(":") && tk[i - 1].equals("following")) {
            features.add("following:");
        }
        if (Data.connnectSet.contains(txt)) {
            features.add("betw_con_" + txt);
        }
    }
    if (left_con != null) {
        int con_pos = WPos2Chunk(left_con.pos);
        if (con_pos >= pos1 && con_pos < pos2) {
            String txt = left_con.word.toLowerCase();
            if (Data.connnectSet.contains(txt)) {
                features.add("left_con_" + txt);
            }
        }
    }
    if (pair.arg1.pos - 1 >= begin) {
        String val = tk[pair.arg1.pos - 1].toLowerCase();
        features.add(val + "_drug1");
    }
    features.add("drug1_" + tk[pair.arg1.pos + 1]);
    if (pair.arg1.pos + 2 == pair.arg2.pos) {
        features.add("drug1_" + tk[pair.arg1.pos + 1] + "_drug2");
    }
    if (pair.arg2.pos - 1 >= begin) {
        String val = tk[pair.arg2.pos - 1].toLowerCase();
        features.add(val + "_drug2");
    }
    if (pair.arg2.pos + 1 <= end) {
        String val = tk[pair.arg2.pos + 1].toLowerCase();
        features.add("drug2_" + val);
    }
    if (train) {
        for (String s : features) {
            int idx = fdx.add(s);
            vector.add(idx, 1);
        }
    } else {
        for (String s : features) {
            int idx = fdx.getIndex(s);
            if (idx >= 0) {
                vector.add(idx, 1);
            }
        }
    }
    return vector;
}

######


private List<Word> getTriggers(SenData sen, int begin, int end) {
    List<Word> ls = new ArrayList<>();
    for (Word w : sen.relList) {
        if (w.pos >= begin && w.pos <= end) {
            int vb_type = Integer.parseInt(w.type);
            if (vb_type >= 2 && vb_type < 5) {
                ls.add(w);
            }
        }
    }
    return ls;
}

######


private boolean hasTrigger(List<Word> ls) {
    for (Word w : ls) {
        int value = Integer.parseInt(w.type);
        if (value > 1 && value < 5) {
            return true;
        }
    }
    return false;
}

######


public void featureGenerator(String db_path, boolean train, boolean useToken, String out_path) {
    boolean checkForKnownPDDIs = false;
    Map<String, SenData> senMap = readData(db_path);
    outputMap.clear();
    fdataMap.clear();
    for (String s : out_type) {
        outputMap.put(s, new ArrayList<DDIPair>());
    }
    int chunk_len = 4;
    if (useToken) {
        chunk_len = 3;
    }
    int total = 0;
    int all = 0;
    int skip_count = 0;
    int unknown = 0;
    int unknown_true = 0;
    int false_ls_all = 0, false_ls_true = 0;
    int sen_count = 0, sen_skip_count = 0;
    skip_true_pairs = 0;
    Set<DDIPair> check = new HashSet<>();
    try {
        conn = DriverManager.getConnection("jdbc:mysql://localhost/merged_DDIs?user=mergedPddi&password=pddi");
    } catch (SQLException ex) {
        System.out.println("SQLException: " + ex.getMessage());
        System.out.println("SQLState: " + ex.getSQLState());
        System.out.println("VendorError: " + ex.getErrorCode());
        System.exit(1);
    }
    if (!train && featureMap.isEmpty()) {
        try {
            System.out.println("");
            System.out.println("Loading feature indexes .....");
            featureMap = (Map<String, FeatureIndex>) Data.read(Data.FeatureMaps);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        if (featureMap == null) {
            System.out.println("Failed to read feature index data");
            System.exit(1);
        }
    }
    for (Map.Entry<String, SenData> entry : senMap.entrySet()) {
        senID = entry.getKey();
        currSen = entry.getValue();
        chunkList = currSen.chunks;
        sen_count++;
        int count = countTruePairs(currSen.ddiList);
        if (currSen.ddiList != null) {
            all += currSen.ddiList.size();
        }
        total += count;
        if (!hasTrigger(currSen.relList)) {
            if (!checkForKnownPDDIs) {
                System.out.println("Skipping sentence because no trigger found:\n\t" + currSen.long_text);
                skip_true_pairs += count;
                skip_count += currSen.ddiList.size();
                sen_skip_count++;
                check.addAll(currSen.ddiList);
                continue;
            } else {
                if (!testForKnownPDDI(currSen.ddiList)) {
                    System.out.println("Skipping sentence because no trigger found and no pair not present in a PDDI within the merged database:\n\t" + currSen.long_text);
                    skip_true_pairs += count;
                    skip_count += currSen.ddiList.size();
                    sen_skip_count++;
                    check.addAll(currSen.ddiList);
                    continue;
                } else {
                    System.out.println("Processing sentences - No trigger found but data for at least one drug pair mentioned is present in the merged PDDI dataset:\n\t" + currSen.long_text);
                }
            }
        }
        List<Chunk> verbs = findVerbChunk(currSen);
        FeatureData[] vectors;
        for (DDIPair pair : currSen.ddiList) {
            if (pair.arg1.word.toLowerCase().equals(pair.arg2.word.toLowerCase())) {
                if (pair.ddi) {
                    skip_true_pairs++;
                }
                skip_count++;
                check.add(pair);
                continue;
            }
            int pos1 = WPos2Chunk(pair.arg1.pos);
            int pos2 = WPos2Chunk(pair.arg2.pos);
            int start = 0;
            boolean has_break = false;
            share_subject = false;
            if (verbs.size() > 0) {
                int idx = 0;
                int vb_pos;
                int last_stop = chunkList.size() - 1;
                int next_stop;
                int vb_pos2 = 0;
                while (idx < verbs.size()) {
                    left_con = checkConnector(start, -1);
                    Chunk vb = verbs.get(idx);
                    vb_pos = chunkList.indexOf(vb);
                    if (idx < verbs.size() - 1) {
                        Chunk vb2 = verbs.get(idx + 1);
                        vb_pos2 = chunkList.indexOf(vb2);
                        right_con = checkConnector(vb_pos, vb_pos2);
                        next_stop = findBreak(vb_pos, vb_pos2, chunkList);
                        has_break = false;
                        share_subject = false;
                        if (next_stop != -1) {
                            has_break = true;
                        } else {
                            next_stop = findStop(vb_pos, vb_pos2);
                        }
                    } else {
                        next_stop = last_stop;
                    }
                    if (between(start, next_stop, pos1) && between(start, next_stop, pos2)) {
                        if (between(start, vb_pos, pos1) && between(start, vb_pos, pos2)) {
                            vectors = new FeatureData[sub_vector.length];
                            vectors[0] = getPhraseFeatures(currSen, start, vb_pos, train, sub_vector[0], pair);
                            vectors[1] = getVBPhraseFeatures(currSen, vb, sub_vector[1], train);
                            vectors[2] = getAuxiliaryFeatures(currSen, pair, pos1, pos2, sub_vector[2], train);
                            vectors[3] = getLexicalFeatures(currSen, start, vb_pos - 1, pair.arg1.pos, sub_vector[3], train, 3, useToken);
                            vectors[4] = getLexicalFeatures(currSen, start, vb_pos - 1, pair.arg2.pos, sub_vector[4], train, 3, useToken);
                            vectors[5] = getSyntaticFeatures(currSen, start, vb_pos - 1, pair.arg1.pos, sub_vector[5], train);
                            vectors[6] = getSyntaticFeatures(currSen, start, vb_pos - 1, pair.arg2.pos, sub_vector[6], train);
                            if (vectors[0] != null) {
                                fdataMap.put(pair.id, vectors);
                                List<DDIPair> ids = outputMap.get("subject");
                                ids.add(pair);
                            } else {
                                skip_count++;
                                if (pair.ddi) {
                                    skip_true_pairs++;
                                }
                            }
                            check.add(pair);
                            break;
                        } else if (between(vb_pos, next_stop, pos1) && between(vb_pos, next_stop, pos2)) {
                            vectors = new FeatureData[obj_vector.length];
                            vectors[0] = getPhraseFeatures(currSen, vb_pos + 1, next_stop, train, obj_vector[0], pair);
                            vectors[1] = getVBPhraseFeatures(currSen, vb, obj_vector[1], train);
                            vectors[2] = getAuxiliaryFeatures(currSen, pair, pos1, pos2, obj_vector[2], train);
                            vectors[3] = getLexicalFeatures(currSen, vb_pos, next_stop, pair.arg1.pos, obj_vector[3], train, 2, false);
                            vectors[4] = getLexicalFeatures(currSen, vb_pos, next_stop, pair.arg2.pos, obj_vector[4], train, 2, false);
                            if (vectors[0] != null) {
                                fdataMap.put(pair.id, vectors);
                                List<DDIPair> ids = outputMap.get("object");
                                ids.add(pair);
                            } else {
                                skip_count++;
                                if (pair.ddi) {
                                    skip_true_pairs++;
                                }
                            }
                            check.add(pair);
                            break;
                        } else {
                            vectors = new FeatureData[clause_vector.length];
                            vectors[0] = getVBPhraseFeatures(currSen, vb, clause_vector[0], train);
                            vectors[1] = getLexicalFeatures(currSen, start, vb_pos - 1, pair.arg1.pos, clause_vector[4], train, chunk_len, false);
                            vectors[2] = getLexicalFeatures(currSen, vb_pos + 1, next_stop, pair.arg2.pos, clause_vector[5], train, chunk_len, false);
                            vectors[3] = getAuxiliaryFeatures(currSen, pair, pos1, pos2, clause_vector[3], train);
                            vectors[4] = getSyntaticFeatures(currSen, start, vb_pos - 1, pair.arg1.pos, clause_vector[1], train);
                            vectors[5] = getSyntaticFeatures(currSen, vb_pos, next_stop, pair.arg2.pos, clause_vector[2], train);
                            fdataMap.put(pair.id, vectors);
                            List<DDIPair> ids = outputMap.get("clause");
                            if (vectors[0] != null) {
                                ids.add(pair);
                            } else {
                                skip_count++;
                                if (pair.ddi) {
                                    skip_true_pairs++;
                                }
                            }
                            check.add(pair);
                            break;
                        }
                    } else if (pos1 >= start && pos1 < next_stop && pos2 > next_stop) {
                        if (has_break) {
                            if (pair.ddi) {
                                skip_true_pairs++;
                            }
                            skip_count++;
                            check.add(pair);
                            break;
                        }
                        int next2stop;
                        if (idx + 2 == verbs.size()) {
                            next2stop = last_stop;
                        } else if (idx + 2 < verbs.size()) {
                            Chunk next2vb = verbs.get(idx + 2);
                            int next2vb_pos = chunkList.indexOf(next2vb);
                            right_con = checkConnector(vb_pos2, next2vb_pos);
                            next2stop = findStop(vb_pos2, next2vb_pos);
                        } else {
                            next2stop = -1;
                            System.out.println("---------> cannot be here !!!!!!!");
                        }
                        if (pos2 > next_stop && pos2 < next2stop) {
                            Chunk vb2 = verbs.get(idx + 1);
                            if (share_subject) {
                                if (pos1 < vb_pos && pos2 > vb_pos2) {
                                    vectors = new FeatureData[clause_vector.length];
                                    vectors[0] = getVBPhraseFeatures(currSen, vb2, clause_vector[0], train);
                                    vectors[1] = getLexicalFeatures(currSen, start, vb_pos - 1, pair.arg1.pos, clause_vector[4], train, chunk_len, false);
                                    vectors[2] = getLexicalFeatures(currSen, vb_pos2 + 1, next_stop, pair.arg2.pos, clause_vector[5], train, chunk_len, false);
                                    vectors[3] = getAuxiliaryFeatures(currSen, pair, pos1, pos2, clause_vector[3], train);
                                    vectors[4] = getSyntaticFeatures(currSen, start, vb_pos - 1, pair.arg1.pos, clause_vector[1], train);
                                    vectors[5] = getSyntaticFeatures(currSen, vb_pos2, next2stop, pair.arg2.pos, clause_vector[2], train);
                                    fdataMap.put(pair.id, vectors);
                                    List<DDIPair> ids = outputMap.get("clause");
                                    if (vectors[0] != null) {
                                        ids.add(pair);
                                    } else {
                                        skip_count++;
                                        if (pair.ddi) {
                                            skip_true_pairs++;
                                        }
                                    }
                                    check.add(pair);
                                    break;
                                }
                            }
                            vectors = new FeatureData[clause2_vector.length];
                            if (pos1 < vb_pos) {
                                vectors[0] = getLexicalFeatures(currSen, start, vb_pos - 1, pair.arg1.pos, clause2_vector[5], train, 3, false);
                                vectors[5] = getSyntaticFeatures(currSen, start, vb_pos - 1, pair.arg1.pos, clause2_vector[0], train);
                            } else {
                                vectors[0] = getLexicalFeatures(currSen, vb_pos + 1, next_stop - 1, pair.arg1.pos, clause2_vector[5], train, 3, false);
                                vectors[5] = getSyntaticFeatures(currSen, vb_pos + 1, next_stop - 1, pair.arg1.pos, clause2_vector[0], train);
                            }
                            vectors[1] = getVBPhraseFeatures(currSen, vb, clause2_vector[1], train);
                            if (pos2 < vb_pos2) {
                                vectors[2] = getLexicalFeatures(currSen, next_stop + 1, vb_pos2 - 1, pair.arg2.pos, clause2_vector[6], train, 3, false);
                                vectors[6] = getSyntaticFeatures(currSen, next_stop + 1, vb_pos2 - 1, pair.arg2.pos, clause2_vector[2], train);
                            } else {
                                vectors[2] = getLexicalFeatures(currSen, vb_pos2 + 1, next2stop, pair.arg2.pos, clause2_vector[6], train, 3, false);
                                vectors[6] = getSyntaticFeatures(currSen, vb_pos2 + 1, next2stop, pair.arg2.pos, clause2_vector[2], train);
                            }
                            vectors[3] = getVBPhraseFeatures(currSen, vb2, clause2_vector[3], train);
                            vectors[4] = getAuxiliaryFeatures(currSen, pair, start, next2stop, clause2_vector[4], train);
                            fdataMap.put(pair.id, vectors);
                            List<DDIPair> ids = outputMap.get("clause2");
                            ids.add(pair);
                            check.add(pair);
                            break;
                        } else {
                            unknown++;
                            if (pair.ddi) {
                                unknown_true++;
                            }
                            check.add(pair);
                        }
                    }
                    idx++;
                    if (has_break) {
                        start = next_stop + 1;
                    } else {
                        start = next_stop + 1;
                    }
                }
            } else {
                int end = chunkList.size() - 1;
                if (pos1 >= start && pos1 <= end && pos2 >= start && pos2 <= end) {
                    vectors = new FeatureData[np_vector.length];
                    vectors[0] = getPhraseFeatures(currSen, 0, end, train, np_vector[0], pair);
                    vectors[1] = getLexicalFeatures(currSen, 0, end, pair.arg1.pos, np_vector[1], train, 3, false);
                    vectors[2] = getLexicalFeatures(currSen, 0, end, pair.arg2.pos, np_vector[2], train, 3, false);
                    vectors[3] = getAuxiliaryFeatures(currSen, pair, 0, end, np_vector[3], train);
                    if (vectors[0] != null) {
                        fdataMap.put(pair.id, vectors);
                        List<DDIPair> ids = outputMap.get("np");
                        ids.add(pair);
                    } else {
                        skip_count++;
                    }
                    check.add(pair);
                }
            }
        }
    }
    for (Map.Entry<String, SenData> entry : senMap.entrySet()) {
        currSen = entry.getValue();
        for (DDIPair pair : currSen.ddiList) {
            if (!check.contains(pair)) {
                unknown++;
                if (pair.ddi) {
                    unknown_true++;
                }
            }
        }
    }
    System.out.println("\n\n");
    System.out.println("All pairs:\t" + all);
    System.out.println("True pairs:\t" + total);
    System.out.println("Negative pairs:\t" + (all - total));
    System.out.println("Skip true pairs:\t" + skip_true_pairs);
    System.out.println("Skip (all) count:\t" + skip_count + " Skip neg:" + (skip_count - skip_true_pairs));
    System.out.println("Unknown cases:\t" + unknown + "\ttrue pairs:\t" + unknown_true + "\t" + "true negatives:\t" + (unknown - unknown_true));
    System.out.println("Sen_count:\t" + sen_count);
    System.out.println("Sen_skip:\t" + sen_skip_count);
    System.out.println("\n");
    Map<String, FeatureData[]> out_map = new HashMap<>();
    int true_count;
    for (String s : out_type) {
        true_count = 0;
        List<DDIPair> data = outputMap.get(s);
        FeatureData[] ls = new FeatureData[data.size()];
        out_map.put(s, ls);
        String[] flist = nameMaps.get(s);
        int[] size = new int[flist.length];
        for (int i = 0; i < size.length; i++) {
            FeatureIndex fdx = featureMap.get(flist[i]);
            if (fdx != null) {
                size[i] = fdx.getSize();
            } else {
                size[i] = 0;
            }
        }
        int idx = 0;
        for (DDIPair pair : data) {
            if (pair.ddi) {
                true_count++;
            }
            FeatureData[] fdt = fdataMap.get(pair.id);
            FeatureData v = FeatureData.mergeVector(fdt, size);
            v.setLabel(pair.ddi ? 1 : 0);
            v.id = pair.id;
            ls[idx] = v;
            idx++;
        }
        if (!train) {
            typeCounter.put(s, true_count);
        }
        System.out.println("Type:\t" + s + "\t\ttrue pairs:\t" + true_count + "\tNeg count:\t" + (ls.length - true_count));
    }
    System.out.println("");
    if (train) {
        try {
            System.out.println("Storing training data");
            Data.write(out_path, out_map);
            System.out.println("Storing feature vectors...");
            System.out.println("");
            for (String s1 : featureMap.keySet()) {
                System.out.println("Feature type:\t" + s1 + "\t -> number of featues:\t" + featureMap.get(s1).getSize());
            }
            Data.write(Data.FeatureMaps, featureMap);
            System.out.println("");
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    } else {
        try {
            Data.write(out_path, out_map);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}

######


public static void main(String[] args) {
    FeatureGenerator fg = new FeatureGenerator();
}

######


public Map<String, SenData> readData(String path) {
    try {
        Map<String, SenData> senMap = (Map<String, SenData>) Data.read(path);
        return senMap;
    } catch (Exception ex) {
        ex.printStackTrace();
    }
    return null;
}

######


private void loadTriggers(String path) {
    vocSet = new HashSet<>();
    try {
        FileReader fr = new FileReader(path);
        BufferedReader reader = new BufferedReader(fr);
        String txt;
        String[] st;
        while ((txt = reader.readLine()) != null) {
            st = txt.split("\t");
            vocSet.add(st[1]);
        }
        reader.close();
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


private Word checkConnector(int begin, int end) {
    if (end == -1) {
        if (!currSen.connector.isEmpty()) {
            for (Word w : currSen.connector) {
                int pos = WPos2Chunk(w.pos);
                if (pos == begin || pos - 1 == begin) {
                    return w;
                }
            }
        }
    } else {
        for (Word w : currSen.connector) {
            int pos = WPos2Chunk(w.pos);
            if (between(begin + 1, end, pos)) {
                return w;
            }
        }
    }
    return null;
}

######


private int countTruePairs(List<DDIPair> ls) {
    int count = 0;
    for (DDIPair pair : ls) {
        if (pair.ddi) {
            count++;
        }
    }
    return count;
}

######


private List<Word> getWords(List<Word> trigger, int pos1, int pos2) {
    List<Word> list = new ArrayList<>();
    for (int i = 0; i < trigger.size(); i++) {
        Word tg = trigger.get(i);
        if (tg.pos >= pos1 && tg.pos <= pos2) {
            list.add(tg);
        }
    }
    return list;
}

######


private String findPrep(int pos1, int pos2) {
    String txt = "";
    if ((pos1 == pos2)) {
        Chunk c = chunkList.get(pos1);
        if (c.txt.contains(" and ")) {
            return "and";
        }
    } else {
        for (int i = pos1 + 1; i < pos2; i++) {
            Chunk c = chunkList.get(i);
            if (Data.prepSet.contains(c.txt)) {
                if (txt.isEmpty()) {
                    txt = c.txt;
                } else {
                    txt = txt + "_" + c.txt;
                }
            }
        }
    }
    if (txt.isEmpty()) {
        return null;
    } else {
        return txt;
    }
}

######


private boolean hasNounChunk(int start, List<Chunk> ls, int stop) {
    Chunk c;
    for (int i = start; i <= stop; i++) {
        c = ls.get(i);
        if (c.type.equals("NP") && !subclauseSet.contains(c.txt)) {
            return true;
        }
    }
    return false;
}

######


private int getVerbChunkType(Chunk vb, SenData sen) {
    boolean has_be = false;
    boolean VBN = false;
    String[] tokens = sen.tokens;
    String[] POS = sen.POS;
    if (vb.txt.toLowerCase().startsWith("to ") && vb.end > vb.begin) {
        return 4;
    }
    for (int i = vb.begin; i <= vb.end; i++) {
        if (beSet.contains(tokens[i])) {
            has_be = true;
        }
        if (POS[i].equals("VBN")) {
            VBN = true;
        }
    }
    if (POS[vb.end].equals("VBG") && !has_be) {
        return 3;
    }
    if ((vb.end > vb.begin && has_be) && VBN) {
        return 1;
    }
    if (VBN) {
        return 2;
    }
    return 0;
}

######


public void printChunk(List<Chunk> chunk) {
    for (Chunk c : chunk) {
        System.out.print("[" + c.type + " " + c.txt + "]");
    }
    System.out.println("");
}

######


public void printChunk(int start, List<Chunk> chunk, int stop) {
    for (int t = start; t <= stop; t++) {
        System.out.print("[" + chunk.get(t).type + " " + chunk.get(t).txt + "] ");
    }
    System.out.println("");
}

######


private List<Chunk> getConjList(int start, int end, List<Chunk> ls) {
    List<Chunk> comma = new ArrayList<>();
    Chunk c;
    for (int i = start + 1; i <= end; i++) {
        c = ls.get(i);
        if (c.type.equals("O") && ccSet.contains(c.txt)) {
            comma.add(c);
        }
    }
    return comma;
}

######


public List<Chunk> findVerbChunk(SenData sen) {
    List<Chunk> ls = new ArrayList<>();
    int i = 0;
    Chunk c, prev = null;
    while (i < sen.chunks.size()) {
        c = sen.chunks.get(i);
        if (c.type.equals("VP") && !appoSet.contains(c.txt) && !(prev != null && subclauseSet.contains(prev.txt) && prev.type.equals("NP"))) {
            if (getVerbChunkType(c, sen) < 2 && !c.txt.startsWith("as ")) {
                ls.add(c);
            }
        }
        prev = c;
        i++;
    }
    return ls;
}

######


private int findStop(int start, int end) {
    List<Chunk> ls = chunkList;
    if (end - start > 2) {
        Chunk pp = ls.get(start + 1);
        if ((pp.type.equals("SBAR") || pp.type.equals("PP")) && subclauseSet.contains(pp.txt)) {
            return start + 1;
        }
        pp = ls.get(start + 2);
        if ((pp.type.equals("SBAR") || pp.type.equals("PP")) && subclauseSet.contains(pp.txt)) {
            return start + 2;
        }
    }
    if (end - start > 2) {
        Chunk c1 = chunkList.get(end - 1);
        Chunk c2 = chunkList.get(end - 2);
        if (c1.type.equals("O") && (c1.txt.equals("and") || c1.txt.equals("or"))) {
            share_subject = true;
            if (c2.txt.equals(",")) {
                return end - 3;
            } else {
                return end - 2;
            }
        }
    }
    if (right_con != null) {
        return WPos2Chunk(right_con.pos);
    }
    List<Chunk> comma = getCommaList(start, end, ls);
    List<Chunk> conj = getConjList(start, end, ls);
    if (comma.size() == 1) {
        if (conj.size() > 0) {
            Chunk and = conj.get(conj.size() - 1);
            int conj_pos = ls.indexOf(and);
            if (hasNounChunk(conj_pos, ls, end)) {
                Chunk com = comma.get(0);
                int com_pos = ls.indexOf(com);
                if (com.end < and.end && conj_pos - com_pos == 1) {
                    end = com_pos - 1;
                } else {
                    if (!hasNounChunk(com_pos, ls, end)) {
                    } else {
                        end = com_pos - 1;
                    }
                }
            }
        } else {
            Chunk com = comma.get(0);
            int com_pos = ls.indexOf(com);
            if (!hasNounChunk(com_pos, ls, end)) {
            } else {
                end = com_pos - 1;
            }
        }
    } else if (comma.isEmpty()) {
        if (conj.size() > 0) {
            Chunk and = conj.get(conj.size() - 1);
            int conj_pos = ls.indexOf(and);
            end = conj_pos - 1;
        }
    } else {
        Chunk com = comma.get(0);
        int com_pos = ls.indexOf(com);
        int pos = find_coord(com_pos, ls, end);
        if (pos == com_pos) {
            end = pos--;
        } else {
            if (hasNounChunk(pos + 1, ls, end)) {
                end = pos;
            }
        }
    }
    end = Math.min(end, ls.size() - 1);
    return end;
}

######


private int findBreak(int start, int end, List<Chunk> ls) {
    for (int i = start + 1; i < end; i++) {
        Chunk c = ls.get(i);
        if (c.type.equals("O") && c.txt.equals(".")) {
            if (i < end - 1) {
                Chunk c1 = ls.get(i + 1);
                if (Character.isUpperCase(c1.txt.charAt(0))) {
                    return i - 1;
                }
            }
        } else if (c.type.equals("NP") && c.txt.startsWith(".")) {
            if (c.txt.length() >= 4 && (Character.isUpperCase(c.txt.charAt(2)) || Character.isUpperCase(c.txt.charAt(1)))) {
                return i - 1;
            }
        }
    }
    return -1;
}

######


public boolean is_passive(Chunk verb, SenData sen) {
    boolean has_be = false;
    int count = 0;
    String[] tokens = sen.tokens;
    String[] POS = sen.POS;
    for (int i = verb.begin; i <= verb.end; i++) {
        if (beSet.contains(tokens[i])) {
            has_be = true;
        }
        if (POS[i].equals("VBN")) {
            count++;
        }
    }
    if (has_be && count >= 1) {
        return true;
    }
    return false;
}

######


private List<Chunk> getCommaList(int start, int end, List<Chunk> ls) {
    List<Chunk> comma = new ArrayList<>();
    Chunk c;
    for (int i = start + 1; i <= end; i++) {
        c = ls.get(i);
        if (c.type.equals("O") && c.txt.equals(",")) {
            comma.add(c);
        }
    }
    return comma;
}

######


private List<Word> getPrep(int pos1, int pos2, List<Word> prepList) {
    List<Word> list = new ArrayList<>();
    for (Word w : prepList) {
        if (w.pos >= pos1 && w.pos <= pos2) {
            list.add(w);
        }
    }
    return list;
}

######


public int WPos2Chunk(int pos) {
    Chunk c;
    for (int i = 0; i < chunkList.size(); i++) {
        c = chunkList.get(i);
        if (pos >= c.begin && pos <= c.end) {
            return i;
        }
    }
    return -1;
}

######


private int find_coord(int start, List<Chunk> ls, int end) {
    int count = 0;
    int conj = 0;
    int list = 0;
    int last_pos = 0;
    Chunk c, prev = null;
    if (start > 0) {
        Chunk np = ls.get(start - 1);
        if (np.type.equals("NP")) {
            for (int i = start + 1; i <= end; i++) {
                c = ls.get(i);
                if (c.txt.equals(",")) {
                    continue;
                } else if (c.type.equals("NP")) {
                    count++;
                    if (conj > 0 && count > 0) {
                        return i;
                    }
                    if (list > 0) {
                        last_pos = i;
                    }
                } else if (ccSet.contains(c.txt) || c.type.equals("CONJ")) {
                    conj++;
                } else if (c.type.equals("PP") && appoSet.contains(c.txt)) {
                    list++;
                } else {
                    break;
                }
                prev = c;
            }
        }
    }
    if (list > 0) {
        return last_pos;
    }
    return start;
}

######


public void toLibSVM(FeatureData[] data, String sub_type, String path) {
    try {
        FileWriter wr = new FileWriter(path + "/" + sub_type + ".libsvm");
        BufferedWriter writer = new BufferedWriter(wr);
        for (FeatureData dt : data) {
            writer.append(dt.toString());
        }
        writer.flush();
        writer.close();
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void crossValidation(FeatureData[] data, int n_fold, String output) {
    Map<String, List<FeatureData>> docMap = new HashMap<>();
    List<String> idList = new ArrayList<>();
    for (FeatureData dt : data) {
        String docid = getDocID(dt.id);
        List<FeatureData> ldt = docMap.get(docid);
        if (ldt == null) {
            ldt = new ArrayList<>();
            docMap.put(docid, ldt);
            idList.add(docid);
        }
        ldt.add(dt);
    }
    int size = 0;
    for (String s : idList) {
        size += docMap.get(s).size();
    }
    int begin = 0;
    size = idList.size() / n_fold;
    int end = size;
    List<FeatureData>[] split = new List[n_fold];
    for (int i = 0; i < n_fold; i++) {
        split[i] = new ArrayList<>();
        for (int j = begin; j < end; j++) {
            String id = idList.get(j);
            List<FeatureData> ls = docMap.get(id);
            split[i].addAll(ls);
        }
        begin += size;
        if (i == n_fold - 2) {
            end = idList.size();
        } else {
            end += size;
        }
    }
    size = 0;
    for (List<FeatureData> split1 : split) {
        size += split1.size();
    }
    System.out.println("Check sum, split n_fold:\t" + size + "\t input:\t" + data.length);
    if (size != data.length) {
        System.out.println("Problem with splitting, exit now");
        System.exit(1);
    }
    SVMTrain trainer = new SVMTrain();
    svm_parameter para = trainer.getPara();
    para.kernel_type = svm_parameter.RBF;
    para.nr_weight = 1;
    double[] ww = { 2 };
    para.weight = ww;
    int[] lb = { 1 };
    para.weight_label = lb;
    double[] v = { 0.05, 0.1, 0.15, 0.2, 0.25, 0.3 };
    try {
        FileWriter writer = new FileWriter(output);
        writer.append("C,G,TP,FP,Pre,Recall,Fscore");
        writer.append("\n");
        for (int i = 1; i <= 6; i++) {
            for (int j = 0; j < v.length; j++) {
                para.C = i;
                para.gamma = v[j];
                int tp = 0;
                int fp = 0;
                int total = 0;
                for (int t = 0; t < n_fold; t++) {
                    List<FeatureData> trainData = new ArrayList<>();
                    List<FeatureData> testData = split[t];
                    for (int k = 0; k < n_fold; k++) {
                        if (k != t) {
                            trainData.addAll(split[k]);
                        }
                    }
                    svm_model model = trainer.train(trainData, para);
                    for (FeatureData dt : testData) {
                        double val = trainer.predict(dt, model);
                        if (dt.getLabel() == 1) {
                            total++;
                            if (val == 1) {
                                tp++;
                            }
                        } else {
                            if (val == 1) {
                                fp++;
                            }
                        }
                    }
                }
                double precision = (double) tp / (double) (tp + fp);
                double recall = (double) tp / (double) total;
                double f_score = (2 * precision * recall) / (precision + recall);
                writer.append(i + "," + v[j] + "," + tp + "," + fp + "," + precision + "," + recall + "," + f_score);
                writer.append("\n");
            }
            writer.flush();
        }
        writer.close();
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


private String getDocID(String id) {
    return id.substring(0, id.indexOf(".s"));
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("fetchSizeTest1", "id int, test varchar(100)");
    createTable("fetchSizeTest2", "id int, test varchar(100)");
    createTable("fetchSizeTest3", "id int, test varchar(100)");
    createTable("fetchSizeTest4", "id int, test varchar(100)");
    createTable("fetchSizeTest5", "id int, test varchar(100)");
}

######


@Test
public void batchFetchSizeTest() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    PreparedStatement pstmt = sharedConnection.prepareStatement("INSERT INTO fetchSizeTest1 (test) values (?)");
    stmt.setFetchSize(1);
    pstmt.setFetchSize(1);
    for (int i = 0; i < 10; i++) {
        pstmt.setString(1, "" + i);
        pstmt.addBatch();
        stmt.addBatch("INSERT INTO fetchSizeTest1 (test) values ('aaa" + i + "')");
    }
    pstmt.executeBatch();
    stmt.executeBatch();
    ResultSet resultSet = stmt.executeQuery("SELECT count(*) from fetchSizeTest1");
    if (resultSet.next()) {
        assertEquals(20, resultSet.getLong(1));
    } else {
        fail("must have resultset");
    }
}

######


@Test
public void fetchSizeNormalTest() throws SQLException {
    prepareRecords(100, "fetchSizeTest4");
    Statement stmt = sharedConnection.createStatement();
    stmt.setFetchSize(1);
    ResultSet resultSet = stmt.executeQuery("SELECT test FROM fetchSizeTest4");
    for (int counter = 0; counter < 100; counter++) {
        assertTrue(resultSet.next());
        assertEquals("" + counter, resultSet.getString(1));
    }
    assertFalse(resultSet.next());
}

######


@Test
public void fetchSizeErrorWhileFetchTest() throws SQLException {
    prepareRecords(100, "fetchSizeTest3");
    Statement stmt = sharedConnection.createStatement();
    stmt.setFetchSize(1);
    ResultSet resultSet = stmt.executeQuery("SELECT test FROM fetchSizeTest3");
    for (int counter = 0; counter < 50; counter++) {
        assertTrue(resultSet.next());
        assertEquals("" + counter, resultSet.getString(1));
    }
    assertFalse(resultSet.isClosed());
    try {
        ResultSet rs2 = stmt.executeQuery("SELECT 1");
        if (rs2.next()) {
            assertEquals(1, rs2.getInt(1));
        } else {
            fail("resultset must have been active");
        }
    } catch (SQLException e) {
        fail("Must have worked");
    }
    try {
        assertFalse(resultSet.isClosed());
        for (int counter = 50; counter < 100; counter++) {
            assertTrue(resultSet.next());
            assertEquals("" + counter, resultSet.getString(1));
        }
        resultSet.close();
        assertTrue(resultSet.isClosed());
    } catch (SQLException sqlexception) {
        fail("must have throw an exception, since resulset must have been closed.");
    }
}

######


@Test
public void fetchSizeBigSkipTest() throws SQLException {
    prepareRecords(300, "fetchSizeTest5");
    Statement stmt = sharedConnection.createStatement();
    stmt.setFetchSize(1);
    ResultSet resultSet = stmt.executeQuery("SELECT test FROM fetchSizeTest5");
    for (int counter = 0; counter < 100; counter++) {
        assertTrue(resultSet.next());
        assertEquals("" + counter, resultSet.getString(1));
    }
    resultSet.close();
    try {
        resultSet.next();
        fail("Must have thrown exception");
    } catch (SQLException sqle) {
        assertTrue(sqle.getMessage().contains("Operation not permit on a closed resultSet"));
    }
    resultSet = stmt.executeQuery("SELECT test FROM fetchSizeTest5");
    for (int counter = 0; counter < 100; counter++) {
        assertTrue(resultSet.next());
        assertEquals("" + counter, resultSet.getString(1));
    }
    stmt.execute("Select 1");
    for (int counter = 100; counter < 200; counter++) {
        assertTrue(resultSet.next());
        assertEquals("" + counter, resultSet.getString(1));
    }
    stmt.close();
    resultSet.last();
    assertEquals("299", resultSet.getString(1));
}

######


private void prepareRecords(int recordNumber, String tableName) throws SQLException {
    PreparedStatement pstmt = sharedConnection.prepareStatement("INSERT INTO " + tableName + " (test) values (?)");
    for (int i = 0; i < recordNumber; i++) {
        pstmt.setString(1, "" + i);
        pstmt.addBatch();
    }
    pstmt.executeBatch();
}

######


@Test
public void fetchSizeCancel() throws SQLException {
    ifMaxscaleRequireMinimumVersion(2, 2);
    Assume.assumeTrue(!sharedOptions().profileSql);
    long start = System.currentTimeMillis();
    try (Statement stmt = sharedConnection.createStatement()) {
        stmt.executeQuery("select * from information_schema.columns as c1,  information_schema.tables LIMIT 200000");
    }
    final long normalExecutionTime = System.currentTimeMillis() - start;
    start = System.currentTimeMillis();
    try (Statement stmt = sharedConnection.createStatement()) {
        stmt.setFetchSize(1);
        stmt.executeQuery("select * from information_schema.columns as c1,  information_schema.tables LIMIT 200000");
        stmt.cancel();
    }
    long interruptedExecutionTime = System.currentTimeMillis() - start;
    Assume.assumeTrue(minVersion(10, 1));
    String maxscaleVersion = System.getenv("MAXSCALE_VERSION");
    if (maxscaleVersion == null && normalExecutionTime > 500) {
        assertTrue("interruptedExecutionTime:" + interruptedExecutionTime + " normalExecutionTime:" + normalExecutionTime, interruptedExecutionTime < normalExecutionTime);
    }
}

######


@Test
public void fetchSizePrepareCancel() throws SQLException {
    ifMaxscaleRequireMinimumVersion(2, 2);
    Assume.assumeTrue(!sharedOptions().profileSql && !sharedOptions().pool);
    long start;
    long normalExecutionTime;
    try (PreparedStatement stmt = sharedConnection.prepareStatement("select * from information_schema.columns as c1,  information_schema.tables, mysql.user LIMIT 50000")) {
        start = System.currentTimeMillis();
        stmt.executeQuery();
        normalExecutionTime = System.currentTimeMillis() - start;
        start = System.currentTimeMillis();
        stmt.setFetchSize(1);
        stmt.executeQuery();
        stmt.cancel();
    }
    long interruptedExecutionTime = System.currentTimeMillis() - start;
    System.out.println(normalExecutionTime);
    System.out.println(interruptedExecutionTime);
    assertTrue("interruptedExecutionTime:" + interruptedExecutionTime + " normalExecutionTime:" + normalExecutionTime, interruptedExecutionTime < normalExecutionTime);
}

######


@Override
public void apply(Connection connection) throws IOException, SQLException {
    try (PreparedStatement ps = connection.prepareStatement("SELECT DISTINCT " + field + " FROM " + table + ";")) {
        try (ResultSet rs = ps.executeQuery()) {
            try (PreparedStatement ps2 = connection.prepareStatement("UPDATE workspaceaccesses SET " + field + " = ? WHERE " + field + " = ?;")) {
                while (rs.next()) {
                    String value = rs.getString(1);
                    ps2.setString(1, f.apply(value));
                    ps2.setString(2, value);
                    ps2.executeUpdate();
                }
            }
        }
    }
}

######


public void setFileClassDao(IFileClassDAO fileClassDao) {
    this.fileClassDao = fileClassDao;
}

######


public Long addFileClass(FileClass fileClass) {
    updateLevel(fileClass);
    this.fileClassDao.save(fileClass);
    if (fileClass != null && fileClass.getId() != null) {
        return fileClass.getId();
    }
    return null;
}

######


public FileClass getFileClass(Long id) {
    FileClass fileClass = this.fileClassDao.get(id);
    return fileClass;
}

######


public boolean delFileClass(Long id) {
    FileClass fileClass = this.getFileClass(id);
    if (fileClass != null) {
        this.fileClassDao.remove(id);
        return true;
    }
    return false;
}

######


public boolean batchDelFileClasss(List<Serializable> fileClassIds) {
    for (Serializable id : fileClassIds) {
        delFileClass((Long) id);
    }
    return true;
}

######


public IPageList getFileClassBy(IQueryObject queryObject) {
    return QueryUtil.query(queryObject, FileClass.class, this.fileClassDao);
}

######


public boolean updateFileClass(Long id, FileClass fileClass) {
    if (id != null) {
        fileClass.setId(id);
    } else {
        return false;
    }
    updateLevel(fileClass);
    this.fileClassDao.update(fileClass);
    return true;
}

######


public String loadTree(Integer currentNodeId) {
    String result = "[";
    String sql;
    if (new Integer(0).equals(currentNodeId))
        sql = "select o from FileClass o where o.parent is null and o.disabled=0";
    else
        sql = "select o from FileClass o where o.parent.id=" + currentNodeId + " and o.disabled=0";
    List list = fileClassDao.query(sql, null, 0, AppContext.RESULTSIZE);
    for (int i = 0; i < list.size(); i++) {
        FileClass fileClass = (FileClass) list.get(i);
        Long id = fileClass.getId();
        result += "{id:" + id + ",text:'" + fileClass.getName() + "(" + fileClass.getCode() + ")',";
        if (isLeaf(id))
            result += "leaf:true}";
        else
            result += "leaf:false}";
        if (i < list.size() - 1)
            result += ",";
    }
    return result + "]";
}

######


private boolean isLeaf(Long nodeId) {
    String sql = "select o from FileClass o where o.parent.id=" + nodeId + " and o.disabled=false";
    List list = fileClassDao.query(sql, null, 0, 1);
    return list.isEmpty();
}

######


private void updateLevel(FileClass fileClass) {
    FileClass parent = fileClass.getParent();
    if (null != parent)
        fileClass.setLevel(parent.getLevel() + "-" + fileClass.getCode());
    else
        fileClass.setLevel(fileClass.getCode());
}

######


@ResponseBody
@RequestMapping(value = "/exportraw", method = RequestMethod.GET)
public String getExperimentalData(@RequestParam(value = "phenotyping_center", required = true) String phenotypingCenterParameter, @RequestParam(value = "pipeline_stable_id", required = true) String pipelineStableId, @RequestParam(value = "procedure_stable_id", required = true) String procedureStableId, @RequestParam(value = "parameter_stable_id", required = true) String parameterStableId, @RequestParam(value = "allele_accession", required = true) String alleleAccession, @RequestParam(value = "sex", required = false) String[] sexesParameter, @RequestParam(value = "zygosity", required = false) String[] zygositiesParameter, @RequestParam(value = "strain", required = false) String strainParameter) throws SolrServerException, IOException, URISyntaxException {
    Organisation phenotypingCenter = organisationDao.getOrganisationByName(phenotypingCenterParameter);
    Pipeline pipeline = ppDAO.getPhenotypePipelineByStableId(pipelineStableId);
    Parameter parameter = ppDAO.getParameterByStableId(parameterStableId);
    Allele allele = alleleDAO.getAlleleByAccession(alleleAccession);
    SexType sex = (sexesParameter != null && sexesParameter.length > 1) ? SexType.valueOf(sexesParameter[0]) : null;
    List<String> zygosities = (zygositiesParameter == null) ? null : Arrays.asList(zygositiesParameter);
    String center = phenotypingCenter.getName();
    Integer centerId = phenotypingCenter.getId();
    String geneAcc = allele.getGene().getId().getAccession();
    String alleleAcc = allele.getId().getAccession();
    String strainAccession = null;
    if (strainParameter != null) {
        Strain s = strainDAO.getStrainByName(strainParameter);
        if (s != null) {
            strainAccession = s.getId().getAccession();
        }
    }
    List<ExperimentDTO> experiments = experimentService.getExperimentDTO(parameter.getId(), pipeline.getId(), geneAcc, sex, centerId, zygosities, strainAccession, null, Boolean.FALSE, alleleAcc);
    List<String> rows = new ArrayList<>();
    rows.add(StringUtils.join(new String[] { "Experiment", "Center", "Pipeline", "Procedure", "Parameter", "Strain", "Colony", "Gene", "Allele", "MetadataGroup", "Zygosity", "Sex", "AssayDate", "Value", "Metadata" }, ", "));
    Integer i = 1;
    for (ExperimentDTO experiment : experiments) {
        Set<ObservationDTO> observations = experiment.getControls();
        observations.addAll(experiment.getMutants());
        for (ObservationDTO observation : observations) {
            List<String> row = new ArrayList<>();
            row.add("Exp" + i.toString());
            row.add(center);
            row.add(pipelineStableId);
            row.add(procedureStableId);
            row.add(parameterStableId);
            row.add(observation.getStrain());
            row.add((observation.getGroup().equals("control")) ? "+/+" : observation.getColonyId());
            row.add((observation.getGroup().equals("control")) ? "\"\"" : geneAcc);
            row.add((observation.getGroup().equals("control")) ? "\"\"" : alleleAcc);
            row.add((observation.getMetadataGroup() != null && !observation.getMetadataGroup().isEmpty()) ? observation.getMetadataGroup() : "\"\"");
            row.add((observation.getZygosity() != null && !observation.getZygosity().isEmpty()) ? observation.getZygosity() : "\"\"");
            row.add(observation.getSex());
            row.add(observation.getDateOfExperimentString());
            String dataValue = observation.getCategory();
            if (dataValue == null) {
                dataValue = observation.getDataPoint().toString();
            }
            row.add(dataValue);
            row.add("\"" + StringUtils.join(observation.getMetadata(), "::") + "\"");
            rows.add(StringUtils.join(row, ", "));
        }
        i++;
    }
    return StringUtils.join(rows, "\n");
}

######


public int inserirFilme(Filme filme) throws IOException {
    int id = -1;
    String sql = "insert into Filme (titulo, descricao, diretor, posterpath, " + "popularidade, data_lancamento, id_genero) values (?,?,?,?,?,?,?)";
    try (Connection conn = ConnectionFactory.getConnection();
        PreparedStatement pst = conn.prepareStatement(sql)) {
        pst.setString(1, filme.getTitulo());
        pst.setString(2, filme.getDescricao());
        pst.setString(3, filme.getDiretor());
        pst.setString(4, filme.getPosterPath());
        pst.setDouble(5, filme.getPopularidade());
        if (filme.getDataLancamento() != null) {
            pst.setDate(6, new java.sql.Date(filme.getDataLancamento().getTime()));
        } else {
            pst.setDate(6, null);
        }
        pst.setInt(7, filme.getGenero().getId());
        pst.execute();
        String query = "select LAST_INSERT_ID()";
        try (PreparedStatement pst1 = conn.prepareStatement(query);
            ResultSet rs = pst1.executeQuery()) {
            if (rs.next()) {
                id = rs.getInt(1);
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
        throw new IOException(e);
    }
    return id;
}

######


public Filme buscarFilme(int id) throws IOException {
    Filme filme = null;
    String sql = "select f.id as id_filme, f.titulo, f.descricao, f.diretor, f.posterpath, f.popularidade, f.data_lancamento, g.id as id_genero, g.nome from Filme f inner join Genero g on f.id_genero = g.id where f.id = ?";
    try (Connection conn = ConnectionFactory.getConnection();
        PreparedStatement stm = conn.prepareStatement(sql)) {
        stm.setInt(1, id);
        try (ResultSet rs = stm.executeQuery()) {
            if (rs.next()) {
                Genero genero = new Genero();
                genero.setId(rs.getInt("id_genero"));
                genero.setNome(rs.getString("nome"));
                filme = new Filme();
                filme.setId(rs.getInt("id_filme"));
                filme.setTitulo(rs.getString("titulo"));
                filme.setDescricao(rs.getString("descricao"));
                filme.setDiretor(rs.getString("diretor"));
                filme.setPosterPath(rs.getString("posterpath"));
                filme.setPopularidade(rs.getInt("popularidade"));
                filme.setDataLancamento(rs.getDate("data_lancamento"));
                filme.setGenero(genero);
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
        throw new IOException(e);
    }
    return filme;
}

######


public ArrayList<Filme> listarFilmes() throws IOException {
    ArrayList<Filme> filmes = new ArrayList<>();
    String sql = "select f.id as id_filme, f.titulo, f.descricao, f.diretor, f.posterpath, f.popularidade, f.data_lancamento, g.id as id_genero, g.nome from Filme f inner join Genero g on f.id_genero = g.id order by f.titulo";
    try (Connection conn = ConnectionFactory.getConnection();
        PreparedStatement stm = conn.prepareStatement(sql);
        ResultSet rs = stm.executeQuery()) {
        while (rs.next()) {
            Genero genero = new Genero();
            genero.setId(rs.getInt("id_genero"));
            genero.setNome(rs.getString("nome"));
            Filme filme = new Filme();
            filme.setId(rs.getInt("id_filme"));
            filme.setTitulo(rs.getString("titulo"));
            filme.setDescricao(rs.getString("descricao"));
            filme.setDiretor(rs.getString("diretor"));
            filme.setPosterPath(rs.getString("posterpath"));
            filme.setPopularidade(rs.getInt("popularidade"));
            filme.setDataLancamento(rs.getDate("data_lancamento"));
            filme.setGenero(genero);
            filmes.add(filme);
        }
    } catch (SQLException e) {
        e.printStackTrace();
        throw new IOException(e);
    }
    return filmes;
}

######


public int atualizarFilme(Filme filme) throws IOException {
    int id = -1;
    String sql = "update Filme set titulo=?, descricao=?, diretor=?, posterpath=?, popularidade=?, data_lancamento=?, id_genero=? where id= ?";
    try (Connection conn = ConnectionFactory.getConnection();
        PreparedStatement stm = conn.prepareStatement(sql)) {
        stm.setString(1, filme.getTitulo());
        stm.setString(2, filme.getDescricao());
        stm.setString(3, filme.getDiretor());
        stm.setString(4, filme.getPosterPath());
        stm.setDouble(5, filme.getPopularidade());
        if (filme.getDataLancamento() != null) {
            stm.setDate(6, new java.sql.Date(filme.getDataLancamento().getTime()));
        } else {
            stm.setDate(6, null);
        }
        stm.setInt(7, filme.getGenero().getId());
        stm.setInt(8, filme.getId());
        stm.execute();
        String query = "select LAST_INSERT_ID()";
        try (PreparedStatement pst1 = conn.prepareStatement(query);
            ResultSet rs = pst1.executeQuery()) {
            if (rs.next()) {
                id = rs.getInt(1);
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
        throw new IOException(e);
    }
    return id;
}

######


public int excluir(int id) throws IOException {
    String sql = "delete from Filme where id = ?";
    try (Connection conn = ConnectionFactory.getConnection();
        PreparedStatement stm = conn.prepareStatement(sql)) {
        stm.setInt(1, id);
        stm.execute();
    } catch (SQLException e) {
        e.printStackTrace();
        throw new IOException(e);
    }
    return id;
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
}

######


public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


@Test
public void testFindWithChildren() throws Exception {
    Connection conn = DriverManager.getConnection("jdbc:hsqldb:mem:association_nested", "SA", "");
    Statement stmt = conn.createStatement();
    stmt.execute("create table folder (id int, name varchar(100), parent_id int)");
    stmt.execute("insert into folder (id, name) values(1, 'Root')");
    stmt.execute("insert into folder values(2, 'Folder 1', 1)");
    stmt.execute("insert into folder values(3, 'Folder 2', 1)");
    stmt.execute("insert into folder values(4, 'Folder 2_1', 3)");
    stmt.execute("insert into folder values(5, 'Folder 2_2', 3)");
    stmt.close();
    conn.close();
    String resource = "org/apache/ibatis/submitted/association_nested/mybatis-config.xml";
    InputStream inputStream = Resources.getResourceAsStream(resource);
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    SqlSession session = sqlSessionFactory.openSession();
    FolderMapper postMapper = session.getMapper(FolderMapper.class);
    List<FolderFlatTree> folders = postMapper.findWithSubFolders("Root");
    Assert.assertEquals(3, folders.size());
    inputStream.close();
    session.close();
}

######


public static boolean verifIdNotNull() {
    try {
        connect = ConnexionBD.getConnexion();
        String req = "select count(id_user) from utilisateur";
        Statement s = connect.createStatement();
        ResultSet resultats = s.executeQuery(req);
        resultats.next();
        if (resultats.getInt(1) != 0) {
            return true;
        }
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
    return false;
}

######


public static int getIdClient(String pseudo) {
    int id = -1;
    try {
        connect = ConnexionBD.getConnexion();
        String req = "select id_user from utilisateur where pseudo='" + pseudo + "'";
        if (verifIdNotNull()) {
            Statement s = connect.createStatement();
            ResultSet resultats = s.executeQuery(req);
            resultats.next();
            id = resultats.getInt(1);
        }
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
    return id;
}

######


public static int getIdContact(String pseudo, int id_user) {
    int id = -1;
    try {
        connect = ConnexionBD.getConnexion();
        String req = "select id_contact from contact,utilisateur where utilisateur.pseudo='" + pseudo + "' and contact.id_user='" + id_user + "'";
        Statement s = connect.createStatement();
        ResultSet resultats = s.executeQuery(req);
        resultats.next();
        if (resultats.getInt(1) != 0)
            id = resultats.getInt(1);
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
    return id;
}

######


public static int getIdRoom(String room, int id_user) {
    int id = -1;
    try {
        connect = ConnexionBD.getConnexion();
        String req = "select id_room from room,utilisateur where room.nom_room='" + room + "' and room.id_user='" + id_user + "'";
        Statement s = connect.createStatement();
        ResultSet resultats = s.executeQuery(req);
        resultats.next();
        if (resultats.getInt(1) != 0)
            id = resultats.getInt(1);
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
    return id;
}

######


public static String sha1(String input) {
    MessageDigest mDigest;
    StringBuffer sb = new StringBuffer();
    try {
        mDigest = MessageDigest.getInstance("SHA1");
        byte[] result = mDigest.digest(input.getBytes());
        for (int i = 0; i < result.length; i++) {
            sb.append(Integer.toString((result[i] & 0xff) + 0x100, 16).substring(1));
        }
    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Fonctions.class.getName()).log(Level.SEVERE, null, ex);
    }
    return sb.toString();
}

######


public static void ajouterUser(String nom, String prenom, String pseudo, String mdp, String ip, int port) {
    try {
        String pwd = sha1(mdp);
        connect = ConnexionBD.getConnexion();
        String req = "insert into utilisateur(pseudo,nom,prenom,password, adresse_ip,port,date_connexion) values ('" + pseudo + "','" + nom + "','" + prenom + "','" + pwd + "','" + ip + "','" + port + "','" + LocalDate.now() + "')";
        PreparedStatement ps = connect.prepareStatement(req);
        ps.execute();
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
}

######


public static void ajouterContact(int id_contact, int id_user) {
    try {
        connect = ConnexionBD.getConnexion();
        String req = "insert into contact(id_contact, id_user) values ('" + id_contact + "','" + id_user + "')";
        PreparedStatement ps = connect.prepareStatement(req);
        ps.execute();
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
}

######


public static void ajouterRoom(String nom_room, int id_user, int id_contact) {
    try {
        connect = ConnexionBD.getConnexion();
        String req = "insert into room(nom_room,id_user,id_contact) values ('" + nom_room + "','" + id_user + "','" + id_contact + "')";
        PreparedStatement ps = connect.prepareStatement(req);
        ps.execute();
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
}

######


public static String[] connexionUser(String pseudo, String mdp) {
    String[] tab = new String[8];
    try {
        connect = ConnexionBD.getConnexion();
        if (verifIdNotNull()) {
            String req = "select * from utilisateur where pseudo='" + pseudo + "' and password='" + sha1(mdp) + "'";
            Statement s = connect.createStatement();
            ResultSet resultats = s.executeQuery(req);
            while (resultats.next()) {
                for (int i = 1; i <= 8; i++) tab[i - 1] = resultats.getString(i);
            }
        } else {
            tab = null;
            System.out.println("database is empty");
        }
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
    return tab;
}

######


public static void SupprimerContact(int id_contact) {
    try {
        connect = ConnexionBD.getConnexion();
        String req = "delete from contact where id_contact='" + id_contact + "'";
        PreparedStatement ps = connect.prepareStatement(req);
        ps.execute();
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
}

######


public static void SupprimerRoom(int id_room) {
    try {
        connect = ConnexionBD.getConnexion();
        String req = "delete from room where id_room = '" + id_room + "'";
        PreparedStatement ps = connect.prepareStatement(req);
        ps.execute();
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
}

######


public Object[] listUsers() {
    ArrayList<String> list = new ArrayList<String>();
    try {
        connect = ConnexionBD.getConnexion();
        String req = "select pseudo,nom,prenom from utilisateur";
        Statement s = connect.createStatement();
        ResultSet resultats = s.executeQuery(req);
        while (resultats.next()) {
            String user;
            user = resultats.getString(1) + "(" + resultats.getString(2) + " " + resultats.getString(3) + ")";
            list.add(user);
        }
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
    return list.toArray();
}

######


public Object[] listRooms(int id_user) {
    ArrayList<String> list = new ArrayList<String>();
    try {
        connect = ConnexionBD.getConnexion();
        String req = "select nom_room from room where id_user='" + id_user + "'";
        Statement s = connect.createStatement();
        ResultSet resultats = s.executeQuery(req);
        while (resultats.next()) {
            String room;
            room = resultats.getString(1);
            list.add(room);
        }
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
    return list.toArray();
}

######


public String getUserById(int id) {
    String user = "";
    try {
        connect = ConnexionBD.getConnexion();
        String req = "select pseudo,nom,prenom from utilisateur where id_user='" + id + "'";
        Statement s = connect.createStatement();
        ResultSet resultats = s.executeQuery(req);
        resultats.next();
        user = resultats.getString(1) + "(" + resultats.getString(2) + " " + resultats.getString(2) + ")";
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
    return user;
}

######


public Object[] listContacts(int id_user) {
    ArrayList<String> list = new ArrayList<String>();
    try {
        connect = ConnexionBD.getConnexion();
        String req = "select id_contact from contact where id_user='" + id_user + "'";
        Statement s = connect.createStatement();
        ResultSet resultats = s.executeQuery(req);
        while (resultats.next()) {
            int id;
            id = resultats.getInt(1);
            list.add(getUserById(id));
        }
        connect.close();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    }
    return list.toArray();
}

######


@Before
public void initDatabase() throws Exception {
    Connection conn = null;
    try {
        Class.forName("org.hsqldb.jdbcDriver");
        conn = DriverManager.getConnection("jdbc:hsqldb:mem:force_flush_on_select", "sa", "");
        Reader reader = Resources.getResourceAsReader("org/apache/ibatis/submitted/force_flush_on_select/CreateDB.sql");
        ScriptRunner runner = new ScriptRunner(conn);
        runner.setLogWriter(null);
        runner.setErrorLogWriter(null);
        runner.runScript(reader);
        conn.commit();
        reader.close();
        reader = Resources.getResourceAsReader("org/apache/ibatis/submitted/force_flush_on_select/ibatisConfig.xml");
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
        reader.close();
    } finally {
        if (conn != null) {
            conn.close();
        }
    }
}

######


@Test
public void testShouldFlushLocalSessionCacheOnQuery() throws SQLException {
    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE);
    try {
        PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);
        personMapper.selectByIdFlush(1);
        updateDatabase(sqlSession.getConnection());
        Person updatedPerson = personMapper.selectByIdFlush(1);
        assertEquals("Simone", updatedPerson.getFirstName());
        sqlSession.commit();
    } finally {
        sqlSession.close();
    }
}

######


@Test
public void testShouldNotFlushLocalSessionCacheOnQuery() throws SQLException {
    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE);
    try {
        PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);
        personMapper.selectByIdNoFlush(1);
        updateDatabase(sqlSession.getConnection());
        Person updatedPerson = personMapper.selectByIdNoFlush(1);
        assertEquals("John", updatedPerson.getFirstName());
        sqlSession.commit();
    } finally {
        sqlSession.close();
    }
}

######


@Test
public void testShouldFlushLocalSessionCacheOnQueryForList() throws SQLException {
    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE);
    try {
        PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);
        List<Person> people = personMapper.selectAllFlush();
        updateDatabase(sqlSession.getConnection());
        people = personMapper.selectAllFlush();
        assertEquals("Simone", people.get(0).getFirstName());
        sqlSession.commit();
    } finally {
        sqlSession.close();
    }
}

######


@Test
public void testShouldNotFlushLocalSessionCacheOnQueryForList() throws SQLException {
    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE);
    try {
        PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);
        List<Person> people = personMapper.selectAllNoFlush();
        updateDatabase(sqlSession.getConnection());
        people = personMapper.selectAllNoFlush();
        assertEquals("John", people.get(0).getFirstName());
        sqlSession.commit();
    } finally {
        sqlSession.close();
    }
}

######


private void updateDatabase(Connection conn) throws SQLException {
    Statement stmt = conn.createStatement();
    stmt.executeUpdate("UPDATE person SET firstName = 'Simone' WHERE id = 1");
    stmt.close();
}

######


@Test
public void testUpdateShouldFlushLocalCache() throws SQLException {
    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE);
    try {
        PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);
        Person person = personMapper.selectByIdNoFlush(1);
        person.setLastName("Perez");
        personMapper.update(person);
        Person updatedPerson = personMapper.selectByIdNoFlush(1);
        assertEquals("Smith", updatedPerson.getLastName());
        assertNotSame(person, updatedPerson);
        sqlSession.commit();
    } finally {
        sqlSession.close();
    }
}

######


@Test
public void testSelectShouldFlushLocalCacheIfFlushLocalCacheAtferEachStatementIsTrue() throws SQLException {
    sqlSessionFactory.getConfiguration().setLocalCacheScope(LocalCacheScope.STATEMENT);
    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE);
    try {
        PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);
        List<Person> people = personMapper.selectAllNoFlush();
        updateDatabase(sqlSession.getConnection());
        people = personMapper.selectAllFlush();
        assertEquals("Simone", people.get(0).getFirstName());
        sqlSession.commit();
    } finally {
        sqlSession.close();
    }
}

######


public void mouseClicked(java.awt.event.MouseEvent evt) {
    tableMhsMouseClicked(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnRefreshActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnSimpanActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnUbahActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnHapusActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnBatalActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    cmbJenisActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jScrollPane2 = new javax.swing.JScrollPane();
    jTable1 = new javax.swing.JTable();
    jScrollPane3 = new javax.swing.JScrollPane();
    tableMhs = new javax.swing.JTable();
    btnRefresh = new javax.swing.JButton();
    btnSimpan = new javax.swing.JButton();
    btnUbah = new javax.swing.JButton();
    btnHapus = new javax.swing.JButton();
    btnBatal = new javax.swing.JButton();
    jLabel6 = new javax.swing.JLabel();
    txtAlamat = new javax.swing.JTextField();
    cmbJurusan = new javax.swing.JComboBox();
    jLabel7 = new javax.swing.JLabel();
    cmbFakultas = new javax.swing.JComboBox();
    jLabel8 = new javax.swing.JLabel();
    cmbAngkatan = new javax.swing.JComboBox();
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    txtNim = new javax.swing.JTextField();
    jLabel3 = new javax.swing.JLabel();
    txtNama = new javax.swing.JTextField();
    jLabel4 = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    txtTanggal = new javax.swing.JFormattedTextField();
    cmbJenis = new javax.swing.JComboBox();
    jTable1.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane2.setViewportView(jTable1);
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    setTitle("Aplikasi Sekolah");
    tableMhs.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    tableMhs.addMouseListener(new java.awt.event.MouseAdapter() {

        public void mouseClicked(java.awt.event.MouseEvent evt) {
            tableMhsMouseClicked(evt);
        }
    });
    jScrollPane3.setViewportView(tableMhs);
    btnRefresh.setText("Refresh");
    btnRefresh.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnRefreshActionPerformed(evt);
        }
    });
    btnSimpan.setText("Simpan");
    btnSimpan.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnSimpanActionPerformed(evt);
        }
    });
    btnUbah.setText("Ubah");
    btnUbah.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnUbahActionPerformed(evt);
        }
    });
    btnHapus.setText("Hapus");
    btnHapus.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnHapusActionPerformed(evt);
        }
    });
    btnBatal.setText("Batal");
    btnBatal.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnBatalActionPerformed(evt);
        }
    });
    jLabel6.setFont(new java.awt.Font("Sylfaen", 1, 10));
    jLabel6.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel6.setText("Alamat");
    cmbJurusan.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Akuntansi", "Teknik Informatika", "Manajemen", "Teknik Arsitektur", "Matematika" }));
    jLabel7.setFont(new java.awt.Font("Sylfaen", 1, 10));
    jLabel7.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel7.setText("Angkatan");
    cmbFakultas.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Ekonomi", "Syariah", "Teknik", "Pendidikan" }));
    jLabel8.setFont(new java.awt.Font("Sylfaen", 1, 10));
    jLabel8.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel8.setText("Jurusan");
    cmbAngkatan.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "2010", "2011", "2012", "2013" }));
    jLabel1.setFont(new java.awt.Font("Sylfaen", 1, 10));
    jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel1.setText("Fakultas");
    jLabel2.setFont(new java.awt.Font("Sylfaen", 1, 10));
    jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel2.setText("NIM");
    jLabel3.setFont(new java.awt.Font("Sylfaen", 1, 10));
    jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel3.setText("Nama");
    jLabel4.setFont(new java.awt.Font("Sylfaen", 1, 10));
    jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel4.setText("Jenis Kelamin");
    jLabel5.setFont(new java.awt.Font("Sylfaen", 1, 10));
    jLabel5.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel5.setText("Tanggal Lahir");
    txtTanggal.setFormatterFactory(new javax.swing.text.DefaultFormatterFactory(new javax.swing.text.DateFormatter(java.text.DateFormat.getDateInstance(java.text.DateFormat.SHORT))));
    cmbJenis.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Laki-Laki", "Perempuan" }));
    cmbJenis.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            cmbJenisActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(30, 30, 30).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 521, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(btnRefresh).addComponent(btnUbah)).addGap(141, 141, 141).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(btnBatal).addComponent(btnHapus))).addGroup(layout.createSequentialGroup().addGap(115, 115, 115).addComponent(btnSimpan))).addGap(0, 421, Short.MAX_VALUE)).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel8, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 89, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false).addGroup(layout.createSequentialGroup().addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(cmbAngkatan, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)).addComponent(cmbJurusan, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup().addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(cmbFakultas, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)).addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(178, 178, 178)).addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(jLabel6, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED))).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(cmbJenis, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(txtNim, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(txtNama, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(txtTanggal, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(txtAlamat, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE))))).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))));
    layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] { btnBatal, btnHapus, btnRefresh, btnSimpan, btnUbah });
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(txtNim, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(txtNama, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(cmbJenis, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(txtTanggal, javax.swing.GroupLayout.DEFAULT_SIZE, 38, Short.MAX_VALUE).addComponent(jLabel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(txtAlamat, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(cmbFakultas, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel8, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(cmbJurusan, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(cmbAngkatan, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 191, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(btnRefresh).addComponent(btnHapus)).addGap(18, 18, 18).addComponent(btnSimpan).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(btnUbah).addComponent(btnBatal)))).addGap(68, 68, 68)));
    pack();
}

######


private void btnSimpanActionPerformed(java.awt.event.ActionEvent evt) {
    String nim = txtNim.getText();
    String nama = txtNama.getText();
    String jenis_kelamin = "";
    Date Tanggal = (Date) txtTanggal.getValue();
    String alamat = txtAlamat.getText();
    String fakultas = cmbFakultas.getSelectedItem().toString();
    String jurusan = cmbJurusan.getSelectedItem().toString();
    String angkatan = cmbAngkatan.getSelectedItem().toString();
    connection = TesKoneksi.getConnection();
    String query = "INSERT INTO biodata_mhs" + "(nim,nama,jenis_kelamin,tanggal_lahir,alamat,fakultas,jurusan,angkatan)" + "VALUES (?,?,?,?,?,?,?,?)";
    try {
        PreparedStatement statement = (PreparedStatement) connection.prepareStatement(query);
        statement.setString(1, nim);
        statement.setString(2, nama);
        statement.setString(3, jenis_kelamin);
        statement.setDate(4, new java.sql.Date(Tanggal.getTime()));
        statement.setString(5, alamat);
        statement.setString(6, fakultas);
        statement.setString(7, jurusan);
        statement.setString(8, angkatan);
        statement.executeUpdate();
    } catch (SQLException ex) {
        JOptionPane.showMessageDialog(this, "Terjadi error pada saat input data");
    } finally {
        loadData();
        reset();
    }
}

######


private void btnUbahActionPerformed(java.awt.event.ActionEvent evt) {
    int row = tableMhs.getSelectedRow();
    if (row == -1) {
        return;
    }
    String nim = (String) tableModel.getValueAt(row, 0);
    String nama = txtNama.getText();
    String jenis_kelamin = cmbJenis.getSelectedItem().toString();
    Date Tanggal = (Date) txtTanggal.getValue();
    String alamat = txtAlamat.getText();
    String fakultas = cmbFakultas.getSelectedItem().toString();
    String jurusan = cmbJurusan.getSelectedItem().toString();
    String angkatan = cmbAngkatan.getSelectedItem().toString();
    connection = TesKoneksi.getConnection();
    String query = "UPDATE biodata_mhs SET " + "nama=?,jenis_kelamin=?,tanggal_lahir=?,alamat=?,fakultas=?,jurusan=?,angkatan=?" + "WHERE nim=?";
    try {
        PreparedStatement statement = (PreparedStatement) connection.prepareStatement(query);
        statement.setString(1, nama);
        statement.setString(2, jenis_kelamin);
        statement.setDate(3, new java.sql.Date(Tanggal.getTime()));
        statement.setString(4, alamat);
        statement.setString(5, fakultas);
        statement.setString(6, jurusan);
        statement.setString(7, angkatan);
        statement.setString(8, nim);
        statement.executeUpdate();
        JOptionPane.showMessageDialog(this, "Data Berhasil di Ubah");
    } catch (SQLException ex) {
        JOptionPane.showMessageDialog(this, "Terjadi error pada saat update data");
    } finally {
        loadData();
        reset();
    }
}

######


private void btnHapusActionPerformed(java.awt.event.ActionEvent evt) {
    int row = tableMhs.getSelectedRow();
    if (row == -1) {
        return;
    }
    String nim = (String) tableModel.getValueAt(row, 0);
    connection = TesKoneksi.getConnection();
    String query = "DELETE FROM biodata_mhs WHERE nim=?";
    try {
        PreparedStatement statement = (PreparedStatement) connection.prepareStatement(query);
        statement.setString(1, nim);
        statement.executeUpdate();
    } catch (SQLException ex) {
        JOptionPane.showMessageDialog(this, "Terjadi error pada saat delete data");
    } finally {
        loadData();
        reset();
    }
}

######


private void btnRefreshActionPerformed(java.awt.event.ActionEvent evt) {
    loadData();
}

######


private void btnBatalActionPerformed(java.awt.event.ActionEvent evt) {
    reset();
}

######


private void tableMhsMouseClicked(java.awt.event.MouseEvent evt) {
    try {
        int row = tableMhs.getSelectedRow();
        if (row == -1) {
            return;
        }
        String nim = (String) tableModel.getValueAt(row, 0);
        String nama = (String) tableModel.getValueAt(row, 1);
        String jenis_kelamin = (String) tableModel.getValueAt(row, 2);
        String tanggal_lahir = (String) tableModel.getValueAt(row, 3);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        Date date = sdf.parse(tanggal_lahir);
        String alamat = (String) tableModel.getValueAt(row, 4);
        String fakultas = (String) tableModel.getValueAt(row, 5);
        String jurusan = (String) tableModel.getValueAt(row, 6);
        String angkatan = (String) tableModel.getValueAt(row, 7);
        txtNim.setText(nim);
        txtNama.setText(nama);
        cmbJenis.getSelectedObjects();
        txtTanggal.setValue(date);
        txtAlamat.setText(alamat);
        cmbFakultas.getSelectedObjects();
        cmbJurusan.getSelectedObjects();
        cmbAngkatan.getSelectedObjects();
    } catch (ParseException ex) {
        Logger.getLogger(FormUtama.class.getName()).log(Level.SEVERE, null, ex);
    }
}

######


private void cmbJenisActionPerformed(java.awt.event.ActionEvent evt) {
}

######


public void run() {
    new FormUtama().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(FormUtama.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(FormUtama.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(FormUtama.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(FormUtama.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new FormUtama().setVisible(true);
        }
    });
}

######


private void initTable() {
    tableModel = new DefaultTableModel();
    tableMhs.setModel(tableModel);
    tableModel.addColumn("nim");
    tableModel.addColumn("nama");
    tableModel.addColumn("jenis_kelamin");
    tableModel.addColumn("tanggal_lahir");
    tableModel.addColumn("Alamat");
    tableModel.addColumn("fakultas");
    tableModel.addColumn("jurusan");
    tableModel.addColumn("angkatan");
}

######


private void loadData() {
    tableModel.getDataVector().removeAllElements();
    tableModel.fireTableDataChanged();
    try {
        connection = TesKoneksi.getConnection();
        String query = "SELECT * FROM biodata_mhs";
        Statement statement = (Statement) connection.createStatement();
        ResultSet resultSet = statement.executeQuery(query);
        while (resultSet.next()) {
            Object[] biodata_mhs = new Object[8];
            biodata_mhs[0] = resultSet.getString("nim");
            biodata_mhs[1] = resultSet.getString("nama");
            biodata_mhs[2] = resultSet.getString("jenis_kelamin");
            biodata_mhs[3] = resultSet.getString("tanggal_lahir");
            biodata_mhs[4] = resultSet.getString("alamat");
            biodata_mhs[5] = resultSet.getString("fakultas");
            biodata_mhs[6] = resultSet.getString("jurusan");
            biodata_mhs[7] = resultSet.getString("angkatan");
            tableModel.addRow(biodata_mhs);
        }
        resultSet.close();
        statement.close();
    } catch (SQLException ex) {
        System.out.println(ex.getMessage());
    }
}

######


private void reset() {
    txtNim.setText("");
    txtNama.setText("");
    txtTanggal.setValue(new java.util.Date());
    cmbJenis.getSelectedIndex();
    txtTanggal.setValue("");
    txtAlamat.setText("");
    cmbFakultas.getSelectedIndex();
    cmbJurusan.getSelectedIndex();
    cmbAngkatan.getSelectedIndex();
}

######


public void addProduct(Fridge fridge) {
    try {
        PreparedStatement preparedStatement = connection.prepareStatement("insert into fridge(ProductName,ProductAmount, UserID) values (?, ?, ? )");
        preparedStatement.setString(1, fridge.getName());
        preparedStatement.setInt(2, fridge.getAmount());
        preparedStatement.setInt(3, fridge.getUserID());
        preparedStatement.executeUpdate();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public void deleteProduct(int productID) {
    try {
        PreparedStatement preparedStatement = connection.prepareStatement("delete from fridge where ProductID=?");
        preparedStatement.setInt(1, productID);
        preparedStatement.executeUpdate();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public void updateFridge(Fridge fridge) {
    try {
        PreparedStatement preparedStatement = connection.prepareStatement("update fridge set ProductName=?, ProductAmount=?" + " where ProductID=?");
        preparedStatement.setString(1, fridge.getName());
        preparedStatement.setInt(2, fridge.getAmount());
        preparedStatement.setInt(3, fridge.getProductID());
        preparedStatement.executeUpdate();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public List<Fridge> getAllProducts() {
    List<Fridge> products = new ArrayList<Fridge>();
    try {
        Statement statement = connection.createStatement();
        ResultSet rs = statement.executeQuery("select * from fridge");
        while (rs.next()) {
            Fridge product = new Fridge();
            product.setProductID(rs.getInt("ProductID"));
            product.setName(rs.getString("ProductName"));
            product.setAmount(rs.getInt("ProductAmount"));
            product.setUserID(rs.getInt("UserID"));
            products.add(product);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return products;
}

######


public Fridge getProductById(int ProductID) {
    Fridge product = new Fridge();
    try {
        PreparedStatement preparedStatement = connection.prepareStatement("select * from fridge where ProductID=?");
        preparedStatement.setInt(1, ProductID);
        ResultSet rs = preparedStatement.executeQuery();
        if (rs.next()) {
            product.setProductID(rs.getInt("ProductID"));
            product.setName(rs.getString("ProductName"));
            product.setAmount(rs.getInt("ProductAmount"));
            product.setUserID(rs.getInt("UserID"));
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return product;
}

######


List<FriendEvent> getAllByReceiverAndReaded(Long receiver, boolean readed);

######


List<FriendEvent> getAllByReceiverOrSenderOrderBySendTimeDesc(Long receiver, Long sender);

######


List<FriendEvent> getByTypeAndSenderAndReceiverAndDone(String type, Long sender, Long receiver, boolean done);

######


@Modifying
@Query("update FriendEvent e set e.type = ?1,e.done=1,e.responseTime=?2 where e.sender = ?3 and e.receiver=?4 and e.type=?5")
void friendReject(String toType, LocalDateTime now, Long sender, Long toWho, String fromType);

######


public FriendsDetails sendrequest(FriendsDetails pair) {
    sessionFactory.getCurrentSession().save(pair);
    return pair;
}

######


public ArrayList<FriendsDetails> myFriends(String userid) {
    String qu1 = "from FriendsDetails where userid='" + userid + "'";
    String qu2 = "from FriendsDetails where friendid='" + userid + "'";
    Query query1 = sessionFactory.getCurrentSession().createQuery(qu1);
    Query query2 = sessionFactory.getCurrentSession().createQuery(qu2);
    @SuppressWarnings("unchecked") ArrayList<FriendsDetails> list1 = (ArrayList<FriendsDetails>) query1.list();
    @SuppressWarnings("unchecked") ArrayList<FriendsDetails> list2 = (ArrayList<FriendsDetails>) query2.list();
    list1.addAll(list2);
    return list1;
}

######


public ArrayList<String> myFriendsString(String userid) {
    String qu1 = "select friendid from FriendsDetails where userid='" + userid + "'";
    String qu2 = "select userid from FriendsDetails where friendid='" + userid + "'";
    Query query1 = sessionFactory.getCurrentSession().createQuery(qu1);
    Query query2 = sessionFactory.getCurrentSession().createQuery(qu2);
    @SuppressWarnings("unchecked") ArrayList<String> list1 = (ArrayList<String>) query1.list();
    @SuppressWarnings("unchecked") ArrayList<String> list2 = (ArrayList<String>) query2.list();
    list1.addAll(list2);
    return list1;
}

######


public ArrayList<String> getnew(String id) {
    String allq = "select id from UserDetails";
    Query query = sessionFactory.getCurrentSession().createQuery(allq);
    @SuppressWarnings("unchecked") ArrayList<String> all = (ArrayList<String>) query.list();
    ArrayList<String> friendlist = myFriendsString(id);
    friendlist.add(id);
    all.removeAll(friendlist);
    return all;
}

######


public ArrayList<String> myFriendRequest(String userid) {
    String hql = "select userid from FriendsDetails where friendid='" + userid + "' and status='New'";
    Query que = sessionFactory.getCurrentSession().createQuery(hql);
    @SuppressWarnings("unchecked") ArrayList<String> list = (ArrayList<String>) que.list();
    return list;
}

######


public ArrayList<String> mySentRequest(String userid) {
    String hql = "select friendid from FriendsDetails where userid='" + userid + "' and status='New'";
    Query que = sessionFactory.getCurrentSession().createQuery(hql);
    @SuppressWarnings("unchecked") ArrayList<String> list = (ArrayList<String>) que.list();
    return list;
}

######


public boolean changeStatus(FriendsDetails pair) {
    try {
        sessionFactory.getCurrentSession().update(pair);
        return true;
    } catch (HibernateException e) {
        e.printStackTrace();
        return false;
    }
}

######


public FriendsDetails cancelRequest(FriendsDetails pair) {
    sessionFactory.getCurrentSession().delete(pair);
    return pair;
}

######


public void inicializaBaseDeDatos() {
    try {
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        conexion = DriverManager.getConnection("jdbc:mysql://" + "localhost/farmacia", "root", "");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void llenaTablaClientes() {
    try {
        DefaultTableModel model = new DefaultTableModel();
        tablaClientes.setModel(model);
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT id_cliente, CONCAT(nombre,' ',apellido_paterno,' ',apellido_materno) " + "AS nombre FROM clientes WHERE status=1");
        ResultSet rs = consulta.executeQuery();
        ResultSetMetaData rsMd = rs.getMetaData();
        int cantidadColumnas = rsMd.getColumnCount();
        for (int i = 1; i <= cantidadColumnas; i++) {
            model.addColumn(rsMd.getColumnLabel(i));
        }
        while (rs.next()) {
            Object[] fila = new Object[cantidadColumnas];
            for (int j = 1; j <= cantidadColumnas; j++) {
                fila[j - 1] = rs.getObject(j);
            }
            model.addRow(fila);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    txtBuscarActionPerformed(evt);
}

######


public void keyReleased(java.awt.event.KeyEvent evt) {
    txtBuscarKeyReleased(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnSeleccionarActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel1 = new javax.swing.JLabel();
    txtBuscar = new javax.swing.JTextField();
    btnSeleccionar = new javax.swing.JButton();
    jScrollPane1 = new javax.swing.JScrollPane();
    tablaClientes = new javax.swing.JTable();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18));
    jLabel1.setText("Tabla de Clientes");
    txtBuscar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            txtBuscarActionPerformed(evt);
        }
    });
    txtBuscar.addKeyListener(new java.awt.event.KeyAdapter() {

        public void keyReleased(java.awt.event.KeyEvent evt) {
            txtBuscarKeyReleased(evt);
        }
    });
    btnSeleccionar.setText("Seleccionar");
    btnSeleccionar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnSeleccionarActionPerformed(evt);
        }
    });
    tablaClientes.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane1.setViewportView(tablaClientes);
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 662, Short.MAX_VALUE).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel1).addGroup(layout.createSequentialGroup().addComponent(txtBuscar, javax.swing.GroupLayout.PREFERRED_SIZE, 219, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18, 18, 18).addComponent(btnSeleccionar))).addGap(0, 0, Short.MAX_VALUE))).addContainerGap()));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(jLabel1).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(txtBuscar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(btnSeleccionar)).addGap(18, 18, 18).addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 257, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(181, Short.MAX_VALUE)));
    pack();
}

######


private void txtBuscarActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void btnSeleccionarActionPerformed(java.awt.event.ActionEvent evt) {
    int id = (int) tablaClientes.getValueAt(tablaClientes.getSelectedRow(), 0);
    txtIdCliente.setText("" + id);
    this.dispose();
}

######


private void txtBuscarKeyReleased(java.awt.event.KeyEvent evt) {
    try {
        DefaultTableModel model = new DefaultTableModel();
        tablaClientes.setModel(model);
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT id_cliente, nombre, apellido_paterno, apellido_materno FROM clientes WHERE status=1 AND " + "MATCH(nombre,apellido_paterno,apellido_materno) AGAINST (?)");
        consulta.setString(1, txtBuscar.getText());
        ResultSet rs = consulta.executeQuery();
        ResultSetMetaData rsMd = rs.getMetaData();
        int cantidadColumnas = rsMd.getColumnCount();
        for (int i = 1; i <= cantidadColumnas; i++) {
            model.addColumn(rsMd.getColumnLabel(i));
        }
        while (rs.next()) {
            Object[] fila = new Object[cantidadColumnas];
            for (int j = 1; j <= cantidadColumnas; j++) {
                fila[j - 1] = rs.getObject(j);
            }
            model.addRow(fila);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void run() {
    new frmBuscarCliente().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(frmBuscarCliente.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(frmBuscarCliente.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(frmBuscarCliente.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(frmBuscarCliente.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new frmBuscarCliente().setVisible(true);
        }
    });
}

######


public void inicializaBaseDeDatos() {
    try {
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        conexion = DriverManager.getConnection("jdbc:mysql://" + "localhost/farmacia", "root", "");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void llenaTablaProductos() {
    try {
        DefaultTableModel model = new DefaultTableModel();
        tablaProductos.setModel(model);
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT id_medicamento, nombre " + " FROM medicamento WHERE status=1");
        ResultSet rs = consulta.executeQuery();
        ResultSetMetaData rsMd = rs.getMetaData();
        int cantidadColumnas = rsMd.getColumnCount();
        for (int i = 1; i <= cantidadColumnas; i++) {
            model.addColumn(rsMd.getColumnLabel(i));
        }
        while (rs.next()) {
            Object[] fila = new Object[cantidadColumnas];
            for (int j = 1; j <= cantidadColumnas; j++) {
                fila[j - 1] = rs.getObject(j);
            }
            model.addRow(fila);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    txtBuscarActionPerformed(evt);
}

######


public void keyReleased(java.awt.event.KeyEvent evt) {
    txtBuscarKeyReleased(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnSeleccionarActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel1 = new javax.swing.JLabel();
    txtBuscar = new javax.swing.JTextField();
    btnSeleccionar = new javax.swing.JButton();
    jScrollPane1 = new javax.swing.JScrollPane();
    tablaProductos = new javax.swing.JTable();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18));
    jLabel1.setText("Tabla de Medicamentos");
    txtBuscar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            txtBuscarActionPerformed(evt);
        }
    });
    txtBuscar.addKeyListener(new java.awt.event.KeyAdapter() {

        public void keyReleased(java.awt.event.KeyEvent evt) {
            txtBuscarKeyReleased(evt);
        }
    });
    btnSeleccionar.setText("Seleccionar");
    btnSeleccionar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnSeleccionarActionPerformed(evt);
        }
    });
    tablaProductos.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane1.setViewportView(tablaProductos);
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 633, Short.MAX_VALUE).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel1).addGroup(layout.createSequentialGroup().addComponent(txtBuscar, javax.swing.GroupLayout.PREFERRED_SIZE, 232, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18, 18, 18).addComponent(btnSeleccionar))).addGap(0, 0, Short.MAX_VALUE))).addContainerGap()));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(19, 19, 19).addComponent(jLabel1).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(txtBuscar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(btnSeleccionar)).addGap(18, 18, 18).addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 254, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(177, Short.MAX_VALUE)));
    pack();
}

######


private void btnSeleccionarActionPerformed(java.awt.event.ActionEvent evt) {
    int id = (int) tablaProductos.getValueAt(tablaProductos.getSelectedRow(), 0);
    txtIdProducto.setText("" + id);
    this.dispose();
}

######


private void txtBuscarActionPerformed(java.awt.event.ActionEvent evt) {
}

######


public void inicializaBaseDeDatos() {
    try {
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        conexion = DriverManager.getConnection("jdbc:mysql://" + "localhost/farmacia", "root", "");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void llenaTablaProveedor() {
    try {
        DefaultTableModel model = new DefaultTableModel();
        tablaProveedor.setModel(model);
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT id_proveedor, nombre_proveedor " + " FROM proveedor WHERE status=1");
        ResultSet rs = consulta.executeQuery();
        ResultSetMetaData rsMd = rs.getMetaData();
        int cantidadColumnas = rsMd.getColumnCount();
        for (int i = 1; i <= cantidadColumnas; i++) {
            model.addColumn(rsMd.getColumnLabel(i));
        }
        while (rs.next()) {
            Object[] fila = new Object[cantidadColumnas];
            for (int j = 1; j <= cantidadColumnas; j++) {
                fila[j - 1] = rs.getObject(j);
            }
            model.addRow(fila);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void keyReleased(java.awt.event.KeyEvent evt) {
    txtBuscarKeyReleased(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButton1ActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel1 = new javax.swing.JLabel();
    txtBuscar = new javax.swing.JTextField();
    jButton1 = new javax.swing.JButton();
    jScrollPane1 = new javax.swing.JScrollPane();
    tablaProveedor = new javax.swing.JTable();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18));
    jLabel1.setText("Tabla de Proveedores");
    txtBuscar.addKeyListener(new java.awt.event.KeyAdapter() {

        public void keyReleased(java.awt.event.KeyEvent evt) {
            txtBuscarKeyReleased(evt);
        }
    });
    jButton1.setText("Seleccionar");
    jButton1.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButton1ActionPerformed(evt);
        }
    });
    tablaProveedor.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane1.setViewportView(tablaProveedor);
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(27, 27, 27).addComponent(jLabel1)).addGroup(layout.createSequentialGroup().addGap(52, 52, 52).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 577, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(layout.createSequentialGroup().addComponent(txtBuscar, javax.swing.GroupLayout.PREFERRED_SIZE, 211, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(27, 27, 27).addComponent(jButton1))))).addContainerGap(43, Short.MAX_VALUE)));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(jLabel1).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(txtBuscar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jButton1)).addGap(18, 18, 18).addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 274, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(183, Short.MAX_VALUE)));
    pack();
}

######


private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {
    int id = (int) tablaProveedor.getValueAt(tablaProveedor.getSelectedRow(), 0);
    txtIdProveedor.setText("" + id);
    this.dispose();
}

######


private void txtBuscarKeyReleased(java.awt.event.KeyEvent evt) {
    try {
        DefaultTableModel model = new DefaultTableModel();
        tablaProveedor.setModel(model);
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT id_proveedor, nombre_proveedor FROM proveedor WHERE status=1 AND nombre_proveedor LIKE ?");
        consulta.setString(1, "'" + txtBuscar.getText() + "'");
        ResultSet rs = consulta.executeQuery();
        ResultSetMetaData rsMd = rs.getMetaData();
        int cantidadColumnas = rsMd.getColumnCount();
        for (int i = 1; i <= cantidadColumnas; i++) {
            model.addColumn(rsMd.getColumnLabel(i));
        }
        while (rs.next()) {
            Object[] fila = new Object[cantidadColumnas];
            for (int j = 1; j <= cantidadColumnas; j++) {
                fila[j - 1] = rs.getObject(j);
            }
            model.addRow(fila);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void run() {
    new frmBuscarProveedor().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(frmBuscarProveedor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(frmBuscarProveedor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(frmBuscarProveedor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(frmBuscarProveedor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new frmBuscarProveedor().setVisible(true);
        }
    });
}

######


public void inicializaBaseDeDatos() {
    try {
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        conexion = DriverManager.getConnection("jdbc:mysql://" + "localhost/farmacia", "root", "");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void llenaTablaUsuarios() {
    try {
        DefaultTableModel model = new DefaultTableModel();
        tablaUsuarios.setModel(model);
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT id_usuario, CONCAT(nombre,' ',apellido_paterno,' ',apellido_materno) " + "AS nombre FROM usuarios WHERE status=1");
        ResultSet rs = consulta.executeQuery();
        ResultSetMetaData rsMd = rs.getMetaData();
        int cantidadColumnas = rsMd.getColumnCount();
        for (int i = 1; i <= cantidadColumnas; i++) {
            model.addColumn(rsMd.getColumnLabel(i));
        }
        while (rs.next()) {
            Object[] fila = new Object[cantidadColumnas];
            for (int j = 1; j <= cantidadColumnas; j++) {
                fila[j - 1] = rs.getObject(j);
            }
            model.addRow(fila);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    txtBuscarActionPerformed(evt);
}

######


public void keyReleased(java.awt.event.KeyEvent evt) {
    txtBuscarKeyReleased(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    txtSeleccionarActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel1 = new javax.swing.JLabel();
    txtBuscar = new javax.swing.JTextField();
    txtSeleccionar = new javax.swing.JButton();
    jScrollPane1 = new javax.swing.JScrollPane();
    tablaUsuarios = new javax.swing.JTable();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18));
    jLabel1.setText("Tabla de usuarios");
    txtBuscar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            txtBuscarActionPerformed(evt);
        }
    });
    txtBuscar.addKeyListener(new java.awt.event.KeyAdapter() {

        public void keyReleased(java.awt.event.KeyEvent evt) {
            txtBuscarKeyReleased(evt);
        }
    });
    txtSeleccionar.setText("Seleccionar");
    txtSeleccionar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            txtSeleccionarActionPerformed(evt);
        }
    });
    tablaUsuarios.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane1.setViewportView(tablaUsuarios);
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(37, 37, 37).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(txtBuscar, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18, 18, 18).addComponent(txtSeleccionar)).addComponent(jLabel1).addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 507, javax.swing.GroupLayout.PREFERRED_SIZE)).addContainerGap(69, Short.MAX_VALUE)));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(30, 30, 30).addComponent(jLabel1).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(txtBuscar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(txtSeleccionar)).addGap(18, 18, 18).addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 266, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(170, Short.MAX_VALUE)));
    pack();
}

######


private void txtBuscarActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void txtSeleccionarActionPerformed(java.awt.event.ActionEvent evt) {
    int id = (int) tablaUsuarios.getValueAt(tablaUsuarios.getSelectedRow(), 0);
    txtIdUsuario.setText("" + id);
    this.dispose();
}

######


private void txtBuscarKeyReleased(java.awt.event.KeyEvent evt) {
    try {
        DefaultTableModel model = new DefaultTableModel();
        tablaUsuarios.setModel(model);
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT id_usuario, nombre, apellido_paterno, apellido_materno FROM usuarios WHERE status=1 AND " + "MATCH(nombre,apellido_paterno,apellido_materno) AGAINST (?)");
        consulta.setString(1, txtBuscar.getText());
        ResultSet rs = consulta.executeQuery();
        ResultSetMetaData rsMd = rs.getMetaData();
        int cantidadColumnas = rsMd.getColumnCount();
        for (int i = 1; i <= cantidadColumnas; i++) {
            model.addColumn(rsMd.getColumnLabel(i));
        }
        while (rs.next()) {
            Object[] fila = new Object[cantidadColumnas];
            for (int j = 1; j <= cantidadColumnas; j++) {
                fila[j - 1] = rs.getObject(j);
            }
            model.addRow(fila);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void run() {
    new frmBuscarUsuario().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(frmBuscarUsuario.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(frmBuscarUsuario.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(frmBuscarUsuario.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(frmBuscarUsuario.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new frmBuscarUsuario().setVisible(true);
        }
    });
}

######


public void inicializaBaseDeDatos() {
    try {
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        conexion = DriverManager.getConnection("jdbc:mysql://" + "localhost/farmacia", "root", "");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void llenaTablaClientes() {
    try {
        DefaultTableModel model = new DefaultTableModel();
        tablaClientes.setModel(model);
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT * FROM clientes WHERE status=1");
        ResultSet rs = consulta.executeQuery();
        ResultSetMetaData rsMd = rs.getMetaData();
        int cantidadColumnas = rsMd.getColumnCount();
        for (int i = 1; i <= cantidadColumnas; i++) {
            model.addColumn(rsMd.getColumnLabel(i));
        }
        while (rs.next()) {
            Object[] fila = new Object[cantidadColumnas];
            for (int j = 1; j <= cantidadColumnas; j++) {
                fila[j - 1] = rs.getObject(j);
            }
            model.addRow(fila);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnGuardarActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnModificarActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnEliminarActionPerformed(evt);
}

######


public void keyReleased(java.awt.event.KeyEvent evt) {
    txtBuscarKeyReleased(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jScrollPane1 = new javax.swing.JScrollPane();
    jTable1 = new javax.swing.JTable();
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    jLabel4 = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    jLabel6 = new javax.swing.JLabel();
    jLabel7 = new javax.swing.JLabel();
    txtNombre = new javax.swing.JTextField();
    txtApellido_paterno = new javax.swing.JTextField();
    txtApellido_materno = new javax.swing.JTextField();
    txtTelefono = new javax.swing.JTextField();
    txtEmail = new javax.swing.JTextField();
    txtDireccion = new javax.swing.JTextField();
    jLabel8 = new javax.swing.JLabel();
    txtId = new javax.swing.JTextField();
    btnGuardar = new javax.swing.JButton();
    btnModificar = new javax.swing.JButton();
    btnEliminar = new javax.swing.JButton();
    jSeparator1 = new javax.swing.JSeparator();
    jLabel9 = new javax.swing.JLabel();
    txtBuscar = new javax.swing.JTextField();
    jScrollPane2 = new javax.swing.JScrollPane();
    tablaClientes = new javax.swing.JTable();
    jLabel10 = new javax.swing.JLabel();
    jTable1.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane1.setViewportView(jTable1);
    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
    jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18));
    jLabel1.setForeground(new java.awt.Color(255, 255, 0));
    jLabel1.setText("Registro Clientes");
    getContentPane().add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(31, 19, -1, -1));
    jLabel2.setForeground(new java.awt.Color(255, 255, 0));
    jLabel2.setText("Nombre:");
    getContentPane().add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(56, 85, -1, -1));
    jLabel3.setForeground(new java.awt.Color(255, 255, 0));
    jLabel3.setText("Apellido paterno:");
    getContentPane().add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(56, 126, -1, -1));
    jLabel4.setForeground(new java.awt.Color(255, 255, 0));
    jLabel4.setText("Apellido materno:");
    getContentPane().add(jLabel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(56, 158, -1, -1));
    jLabel5.setForeground(new java.awt.Color(255, 255, 0));
    jLabel5.setText("Telefono:");
    getContentPane().add(jLabel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(56, 192, -1, -1));
    jLabel6.setForeground(new java.awt.Color(255, 255, 0));
    jLabel6.setText("Email:");
    getContentPane().add(jLabel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(56, 230, -1, -1));
    jLabel7.setForeground(new java.awt.Color(255, 255, 0));
    jLabel7.setText("Direccion:");
    getContentPane().add(jLabel7, new org.netbeans.lib.awtextra.AbsoluteConstraints(56, 268, -1, -1));
    getContentPane().add(txtNombre, new org.netbeans.lib.awtextra.AbsoluteConstraints(150, 90, 142, -1));
    getContentPane().add(txtApellido_paterno, new org.netbeans.lib.awtextra.AbsoluteConstraints(150, 120, 144, -1));
    getContentPane().add(txtApellido_materno, new org.netbeans.lib.awtextra.AbsoluteConstraints(150, 158, 142, -1));
    getContentPane().add(txtTelefono, new org.netbeans.lib.awtextra.AbsoluteConstraints(150, 189, 142, -1));
    getContentPane().add(txtEmail, new org.netbeans.lib.awtextra.AbsoluteConstraints(150, 227, 142, -1));
    getContentPane().add(txtDireccion, new org.netbeans.lib.awtextra.AbsoluteConstraints(150, 265, 142, -1));
    jLabel8.setForeground(new java.awt.Color(255, 255, 0));
    jLabel8.setText("ID:");
    getContentPane().add(jLabel8, new org.netbeans.lib.awtextra.AbsoluteConstraints(56, 55, -1, -1));
    txtId.setText("Nuevo");
    getContentPane().add(txtId, new org.netbeans.lib.awtextra.AbsoluteConstraints(150, 52, 80, -1));
    btnGuardar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/guardar.png")));
    btnGuardar.setToolTipText("Guardar");
    btnGuardar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnGuardarActionPerformed(evt);
        }
    });
    getContentPane().add(btnGuardar, new org.netbeans.lib.awtextra.AbsoluteConstraints(343, 19, 66, -1));
    btnModificar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/modificar.png")));
    btnModificar.setToolTipText("Modificar");
    btnModificar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnModificarActionPerformed(evt);
        }
    });
    getContentPane().add(btnModificar, new org.netbeans.lib.awtextra.AbsoluteConstraints(419, 19, -1, 57));
    btnEliminar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/eliminar.png")));
    btnEliminar.setToolTipText("Eliminar");
    btnEliminar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnEliminarActionPerformed(evt);
        }
    });
    getContentPane().add(btnEliminar, new org.netbeans.lib.awtextra.AbsoluteConstraints(494, 19, -1, 57));
    getContentPane().add(jSeparator1, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 303, 799, 10));
    jLabel9.setFont(new java.awt.Font("Tahoma", 1, 11));
    jLabel9.setForeground(new java.awt.Color(255, 255, 0));
    jLabel9.setText("Buscar cliente:");
    getContentPane().add(jLabel9, new org.netbeans.lib.awtextra.AbsoluteConstraints(51, 343, -1, -1));
    txtBuscar.addKeyListener(new java.awt.event.KeyAdapter() {

        public void keyReleased(java.awt.event.KeyEvent evt) {
            txtBuscarKeyReleased(evt);
        }
    });
    getContentPane().add(txtBuscar, new org.netbeans.lib.awtextra.AbsoluteConstraints(149, 340, 182, -1));
    tablaClientes.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane2.setViewportView(tablaClientes);
    getContentPane().add(jScrollPane2, new org.netbeans.lib.awtextra.AbsoluteConstraints(51, 378, 712, 174));
    jLabel10.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/Fondo-color-verde-688051.jpeg")));
    getContentPane().add(jLabel10, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, -1, -1));
    pack();
}

######


private void btnGuardarActionPerformed(java.awt.event.ActionEvent evt) {
    String nombre = txtNombre.getText();
    String apellido_paterno = txtApellido_paterno.getText();
    String apellido_materno = txtApellido_materno.getText();
    String email = txtEmail.getText();
    String telefono = txtTelefono.getText();
    String direccion = txtDireccion.getText();
    int id = 0;
    if (modifica) {
        id = Integer.parseInt(txtId.getText());
    }
    if (nombre.length() == 0 || apellido_paterno.length() == 0 || apellido_materno.length() == 0 || email.length() == 0 || telefono.length() == 0 || direccion.length() == 0) {
        JOptionPane.showMessageDialog(null, "Debes llenar todos los campos para registrar.");
        return;
    }
    try {
        PreparedStatement consulta;
        if (modifica) {
            consulta = conexion.prepareStatement("" + "UPDATE  clientes SET nombre=?,apellido_paterno=?,apellido_materno=?,email=?,telefono=?,direccion=? WHERE id_cliente=?");
            consulta.setString(1, nombre);
            consulta.setString(2, apellido_paterno);
            consulta.setString(3, apellido_materno);
            consulta.setString(4, email);
            consulta.setString(5, telefono);
            consulta.setString(6, direccion);
            consulta.setInt(7, id);
        } else {
            consulta = conexion.prepareStatement("" + "INSERT INTO clientes(nombre,apellido_paterno,apellido_materno" + ",email,telefono,direccion) VALUES (?,?,?,?,?,?)");
            consulta.setString(1, nombre);
            consulta.setString(2, apellido_paterno);
            consulta.setString(3, apellido_materno);
            consulta.setString(4, email);
            consulta.setString(5, telefono);
            consulta.setString(6, direccion);
        }
        consulta.executeUpdate();
        llenaTablaClientes();
        limpiaCampos();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


private void btnModificarActionPerformed(java.awt.event.ActionEvent evt) {
    int id = (int) tablaClientes.getValueAt(tablaClientes.getSelectedRow(), 0);
    String nombre = (String) tablaClientes.getValueAt(tablaClientes.getSelectedRow(), 1);
    String apellido_paterno = (String) tablaClientes.getValueAt(tablaClientes.getSelectedRow(), 2);
    String apellido_materno = (String) tablaClientes.getValueAt(tablaClientes.getSelectedRow(), 3);
    String email = (String) tablaClientes.getValueAt(tablaClientes.getSelectedRow(), 4);
    String telefono = (String) tablaClientes.getValueAt(tablaClientes.getSelectedRow(), 5);
    String direccion = (String) tablaClientes.getValueAt(tablaClientes.getSelectedRow(), 6);
    txtId.setText("" + id);
    txtNombre.setText(nombre);
    txtApellido_paterno.setText(apellido_paterno);
    txtApellido_materno.setText(apellido_materno);
    txtEmail.setText(email);
    txtTelefono.setText(telefono);
    txtDireccion.setText(direccion);
    modifica = true;
}

######


private void btnEliminarActionPerformed(java.awt.event.ActionEvent evt) {
    int id = (int) tablaClientes.getValueAt(tablaClientes.getSelectedRow(), 0);
    try {
        PreparedStatement consulta = conexion.prepareStatement("" + "UPDATE clientes SET status=2 WHERE id_cliente=?");
        consulta.setInt(1, id);
        consulta.executeUpdate();
        llenaTablaClientes();
        limpiaCampos();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void inicializaBaseDeDatos() {
    try {
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        conexion = DriverManager.getConnection("jdbc:mysql://" + "localhost/farmacia", "root", "");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButton1ActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnGuardarActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButton3ActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnAgregarActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jScrollPane1 = new javax.swing.JScrollPane();
    tablaEntrada = new javax.swing.JTable();
    jLabel3 = new javax.swing.JLabel();
    jLabel4 = new javax.swing.JLabel();
    txtProveedor = new javax.swing.JTextField();
    txtCantidad = new javax.swing.JTextField();
    jButton1 = new javax.swing.JButton();
    btnGuardar = new javax.swing.JButton();
    jLabel1 = new javax.swing.JLabel();
    txtProducto = new javax.swing.JTextField();
    jButton3 = new javax.swing.JButton();
    btnAgregar = new javax.swing.JButton();
    jLabel5 = new javax.swing.JLabel();
    txtTotal = new javax.swing.JTextField();
    jLabel6 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    tablaEntrada.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane1.setViewportView(tablaEntrada);
    jLabel3.setText("Proveedor:");
    jLabel3.setToolTipText("");
    jLabel4.setText("Cantidad:");
    jButton1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/buscar (2).png")));
    jButton1.setToolTipText("Buscar proveedor");
    jButton1.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButton1ActionPerformed(evt);
        }
    });
    btnGuardar.setText("Guardar entrada");
    btnGuardar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnGuardarActionPerformed(evt);
        }
    });
    jLabel1.setText("Producto:");
    jButton3.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/medicamento.png")));
    jButton3.setToolTipText("Buscar Producto");
    jButton3.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButton3ActionPerformed(evt);
        }
    });
    btnAgregar.setText("Agregar Venta");
    btnAgregar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnAgregarActionPerformed(evt);
        }
    });
    jLabel5.setText("Total a pagar:");
    jLabel6.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/icon-farm.png")));
    jLabel2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/sistem.png")));
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(32, 32, 32).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel4).addComponent(jLabel1)).addGap(38, 38, 38).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false).addComponent(txtCantidad, javax.swing.GroupLayout.Alignment.LEADING).addComponent(txtProveedor, javax.swing.GroupLayout.Alignment.LEADING).addComponent(txtProducto, javax.swing.GroupLayout.PREFERRED_SIZE, 159, javax.swing.GroupLayout.PREFERRED_SIZE))).addComponent(jLabel3)).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(18, 18, 18).addComponent(btnAgregar).addGap(18, 18, 18).addComponent(btnGuardar)).addGroup(layout.createSequentialGroup().addGap(35, 35, 35).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 66, javax.swing.GroupLayout.PREFERRED_SIZE))))).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addGroup(layout.createSequentialGroup().addComponent(jLabel5).addGap(18, 18, 18).addComponent(txtTotal, javax.swing.GroupLayout.PREFERRED_SIZE, 91, javax.swing.GroupLayout.PREFERRED_SIZE)).addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 626, javax.swing.GroupLayout.PREFERRED_SIZE)))).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 76, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jLabel2))).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(6, 6, 6).addComponent(jLabel6)).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(jLabel2))).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel3).addComponent(txtProveedor, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel1).addComponent(txtProducto, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel4).addComponent(txtCantidad, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(btnGuardar).addComponent(btnAgregar)).addGap(27, 27, 27).addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 272, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel5).addComponent(txtTotal, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(34, 34, 34)));
    pack();
}

######


private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {
    frmBuscarProveedor BuscarProveedor = new frmBuscarProveedor(txtProveedor);
    BuscarProveedor.setVisible(true);
}

######


private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {
    frmBuscarProducto BuscarProducto = new frmBuscarProducto(txtProducto);
    BuscarProducto.setVisible(true);
}

######


private void btnAgregarActionPerformed(java.awt.event.ActionEvent evt) {
    try {
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT * FROM medicamento WHERE status=1 AND id_medicamento=?");
        consulta.setString(1, txtProducto.getText());
        ResultSet rs = consulta.executeQuery();
        rs.next();
        Object[] fila = new Object[5];
        fila[0] = txtProducto.getText();
        fila[1] = rs.getString("nombre");
        fila[2] = rs.getString("precio");
        fila[3] = txtCantidad.getText();
        double precio = Double.parseDouble(rs.getString("precio"));
        int cantidad = Integer.parseInt(txtCantidad.getText());
        double total = precio * cantidad;
        fila[4] = "" + total;
        model.addRow(fila);
        limpiaCampos();
        sumarventa();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


private void btnGuardarActionPerformed(java.awt.event.ActionEvent evt) {
    try {
        PreparedStatement consulta = conexion.prepareStatement("" + "INSERT INTO entrada (fecha_alta, id_usuario, id_proveedor,total) VALUES(NOW(),?,?,?)");
        consulta.setInt(1, config.id_usuario);
        consulta.setString(2, txtProveedor.getText());
        consulta.setString(3, "0");
        consulta.executeUpdate();
        consulta = conexion.prepareStatement("SELECT last_insert_id() as id FROM entrada");
        ResultSet rs = consulta.executeQuery();
        if (rs.next()) {
            int id_entrada = rs.getInt("id");
            for (int i = 0; i < tablaEntrada.getRowCount(); i++) {
                int id_producto = Integer.parseInt(tablaEntrada.getValueAt(i, 0).toString());
                int cantidad = Integer.parseInt(tablaEntrada.getValueAt(i, 3).toString());
                double precio = Double.parseDouble(tablaEntrada.getValueAt(i, 2).toString());
                double total = Double.parseDouble(tablaEntrada.getValueAt(i, 4).toString());
                consulta = conexion.prepareStatement("" + "INSERT INTO detalle_entrada(id_entrada,id_producto,cantidad,precio,total) VALUES (?,?,?,?,?)");
                consulta.setInt(1, id_entrada);
                consulta.setInt(2, id_producto);
                consulta.setInt(3, cantidad);
                consulta.setDouble(4, precio);
                consulta.setDouble(5, total);
                consulta.executeUpdate();
                consulta = conexion.prepareStatement("SELECT * FROM bodega WHERE id_medicamento=?");
                consulta.setInt(1, id_producto);
                ResultSet rs2 = consulta.executeQuery();
                if (rs2.next()) {
                    int cantidad_bodega = rs2.getInt("cantidad");
                    cantidad_bodega = cantidad_bodega + cantidad;
                    consulta = conexion.prepareStatement("UPDATE bodega SET cantidad=? WHERE id_medicamento = ?");
                    consulta.setInt(1, cantidad_bodega);
                    consulta.setInt(2, id_producto);
                    consulta.executeUpdate();
                } else {
                    consulta = conexion.prepareStatement("INSERT INTO bodega (id_medicamento, cantidad) VALUES (?,?)");
                    consulta.setInt(1, id_producto);
                    consulta.setInt(2, cantidad);
                    consulta.executeUpdate();
                }
            }
            JOptionPane.showMessageDialog(null, "Se guardo la venta");
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void limpiaCampos() {
    txtProducto.setText("");
    txtCantidad.setText("");
}

######


public void sumarventa() {
    double suma = 0;
    for (int i = 0; i < tablaEntrada.getRowCount(); i++) {
        suma += Double.parseDouble(tablaEntrada.getValueAt(i, 4).toString());
    }
    txtTotal.setText("" + suma);
}

######


public void run() {
    new frmCatalogoEntrada().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(frmCatalogoEntrada.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(frmCatalogoEntrada.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(frmCatalogoEntrada.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(frmCatalogoEntrada.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new frmCatalogoEntrada().setVisible(true);
        }
    });
}

######


public void inicializaBasedeDatos() {
    try {
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        conexion = DriverManager.getConnection("jdbc:mysql://localhost/farmacia", "root", "");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void llenaTablaMedicamentos() {
    try {
        DefaultTableModel model = new DefaultTableModel();
        tablaMedicamentos.setModel(model);
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT * FROM medicamento WHERE status=1");
        ResultSet rs = consulta.executeQuery();
        ResultSetMetaData rsMd = rs.getMetaData();
        int cantidadColumnas = rsMd.getColumnCount();
        for (int i = 1; i <= cantidadColumnas; i++) {
            model.addColumn(rsMd.getColumnLabel(i));
        }
        while (rs.next()) {
            Object[] fila = new Object[cantidadColumnas];
            for (int j = 1; j <= cantidadColumnas; j++) {
                fila[j - 1] = rs.getObject(j);
            }
            model.addRow(fila);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnGuardarActionPerformed(evt);
}

######


public void keyReleased(java.awt.event.KeyEvent evt) {
    txtBuscarKeyReleased(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    jLabel4 = new javax.swing.JLabel();
    txtId = new javax.swing.JTextField();
    txtNombre_medicamento = new javax.swing.JTextField();
    txtPrecio = new javax.swing.JTextField();
    btnGuardar = new javax.swing.JButton();
    jSeparator1 = new javax.swing.JSeparator();
    jLabel5 = new javax.swing.JLabel();
    txtBuscar = new javax.swing.JTextField();
    jScrollPane1 = new javax.swing.JScrollPane();
    tablaMedicamentos = new javax.swing.JTable();
    jLabel6 = new javax.swing.JLabel();
    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
    jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18));
    jLabel1.setForeground(new java.awt.Color(255, 255, 0));
    jLabel1.setText("Ingreso de Productos");
    getContentPane().add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(26, 22, -1, -1));
    jLabel2.setForeground(new java.awt.Color(255, 255, 0));
    jLabel2.setText("ID:");
    getContentPane().add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(66, 65, -1, -1));
    jLabel3.setForeground(new java.awt.Color(255, 255, 0));
    jLabel3.setText("Medicamento:");
    getContentPane().add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(66, 103, -1, -1));
    jLabel4.setForeground(new java.awt.Color(255, 255, 0));
    jLabel4.setText("Precio:");
    getContentPane().add(jLabel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(66, 138, -1, -1));
    txtId.setText("Nuevo");
    getContentPane().add(txtId, new org.netbeans.lib.awtextra.AbsoluteConstraints(143, 62, 76, -1));
    getContentPane().add(txtNombre_medicamento, new org.netbeans.lib.awtextra.AbsoluteConstraints(143, 100, 208, -1));
    getContentPane().add(txtPrecio, new org.netbeans.lib.awtextra.AbsoluteConstraints(143, 138, 123, -1));
    btnGuardar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/agregar-nuevo.png")));
    btnGuardar.setToolTipText("insertar nuevo");
    btnGuardar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnGuardarActionPerformed(evt);
        }
    });
    getContentPane().add(btnGuardar, new org.netbeans.lib.awtextra.AbsoluteConstraints(367, 53, -1, -1));
    getContentPane().add(jSeparator1, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 202, 778, 12));
    jLabel5.setForeground(new java.awt.Color(255, 255, 0));
    jLabel5.setText("Buscar Medicamento:");
    getContentPane().add(jLabel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(52, 228, -1, -1));
    txtBuscar.addKeyListener(new java.awt.event.KeyAdapter() {

        public void keyReleased(java.awt.event.KeyEvent evt) {
            txtBuscarKeyReleased(evt);
        }
    });
    getContentPane().add(txtBuscar, new org.netbeans.lib.awtextra.AbsoluteConstraints(172, 225, 251, -1));
    tablaMedicamentos.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane1.setViewportView(tablaMedicamentos);
    getContentPane().add(jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 267, 758, 278));
    jLabel6.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/Fondo-color-verde-688051.jpeg")));
    getContentPane().add(jLabel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, -1, -1));
    pack();
}

######


private void btnGuardarActionPerformed(java.awt.event.ActionEvent evt) {
    String nombre = txtNombre_medicamento.getText();
    String precio = txtPrecio.getText();
    if (nombre.length() == 0 || precio.length() == 0) {
        JOptionPane.showMessageDialog(null, "Debes llenar todos los campos para registrar.");
        return;
    }
    try {
        PreparedStatement consulta = conexion.prepareStatement("" + "INSERT INTO medicamento(nombre,precio) VALUES (?,?)");
        consulta.setString(1, nombre);
        consulta.setString(2, precio);
        consulta.executeUpdate();
        consulta = conexion.prepareStatement("SELECT last_insert_id() as id FROM medicamento");
        ResultSet rs = consulta.executeQuery();
        rs.next();
        int id_medicamento = rs.getInt("id");
        consulta = conexion.prepareStatement("" + "INSERT INTO bodega(id_medicamento,cantidad) VALUES (?,0)");
        consulta.setInt(1, id_medicamento);
        consulta.executeUpdate();
        llenaTablaMedicamentos();
        limpiaCampos();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void inicializaBaseDeDatos() {
    try {
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        conexion = DriverManager.getConnection("jdbc:mysql://" + "localhost/farmacia", "root", "");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void llenaTablaProveedor() {
    try {
        DefaultTableModel model = new DefaultTableModel();
        tablaProveedor.setModel(model);
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT * FROM proveedor WHERE status=1");
        ResultSet rs = consulta.executeQuery();
        ResultSetMetaData rsMd = rs.getMetaData();
        int cantidadColumnas = rsMd.getColumnCount();
        for (int i = 1; i <= cantidadColumnas; i++) {
            model.addColumn(rsMd.getColumnLabel(i));
        }
        while (rs.next()) {
            Object[] fila = new Object[cantidadColumnas];
            for (int j = 1; j <= cantidadColumnas; j++) {
                fila[j - 1] = rs.getObject(j);
            }
            model.addRow(fila);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnGuardarActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnEliminarActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnModificarActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    txtBuscarActionPerformed(evt);
}

######


public void keyReleased(java.awt.event.KeyEvent evt) {
    txtBuscarKeyReleased(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    txtEmpresaActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    txtId = new javax.swing.JTextField();
    txtProveedor = new javax.swing.JTextField();
    btnGuardar = new javax.swing.JButton();
    btnEliminar = new javax.swing.JButton();
    btnModificar = new javax.swing.JButton();
    jSeparator1 = new javax.swing.JSeparator();
    jLabel7 = new javax.swing.JLabel();
    txtBuscar = new javax.swing.JTextField();
    jScrollPane1 = new javax.swing.JScrollPane();
    tablaProveedor = new javax.swing.JTable();
    jLabel9 = new javax.swing.JLabel();
    txtEmpresa = new javax.swing.JTextField();
    jLabel4 = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    txtApellido_paterno = new javax.swing.JTextField();
    txtApellido_materno = new javax.swing.JTextField();
    jLabel6 = new javax.swing.JLabel();
    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
    jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18));
    jLabel1.setForeground(new java.awt.Color(255, 255, 0));
    jLabel1.setText("Sistema de proveedores");
    getContentPane().add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(39, 27, -1, -1));
    jLabel2.setForeground(new java.awt.Color(255, 255, 0));
    jLabel2.setText("ID:");
    getContentPane().add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(71, 70, -1, -1));
    jLabel3.setForeground(new java.awt.Color(255, 255, 0));
    jLabel3.setText("Proveedor:");
    getContentPane().add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(71, 107, -1, -1));
    txtId.setText("Nuevo");
    getContentPane().add(txtId, new org.netbeans.lib.awtextra.AbsoluteConstraints(157, 67, 74, -1));
    getContentPane().add(txtProveedor, new org.netbeans.lib.awtextra.AbsoluteConstraints(157, 104, 204, -1));
    btnGuardar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/guardar.png")));
    btnGuardar.setToolTipText("Guardar");
    btnGuardar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnGuardarActionPerformed(evt);
        }
    });
    getContentPane().add(btnGuardar, new org.netbeans.lib.awtextra.AbsoluteConstraints(387, 67, 65, -1));
    btnEliminar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/eliminar.png")));
    btnEliminar.setToolTipText("Eliminar");
    btnEliminar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnEliminarActionPerformed(evt);
        }
    });
    getContentPane().add(btnEliminar, new org.netbeans.lib.awtextra.AbsoluteConstraints(470, 67, -1, 57));
    btnModificar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/modificar.png")));
    btnModificar.setToolTipText("Modificar");
    btnModificar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnModificarActionPerformed(evt);
        }
    });
    getContentPane().add(btnModificar, new org.netbeans.lib.awtextra.AbsoluteConstraints(553, 67, -1, 57));
    getContentPane().add(jSeparator1, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 330, 786, 10));
    jLabel7.setForeground(new java.awt.Color(255, 255, 0));
    jLabel7.setText("Buscar proveedor");
    getContentPane().add(jLabel7, new org.netbeans.lib.awtextra.AbsoluteConstraints(38, 373, -1, -1));
    txtBuscar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            txtBuscarActionPerformed(evt);
        }
    });
    txtBuscar.addKeyListener(new java.awt.event.KeyAdapter() {

        public void keyReleased(java.awt.event.KeyEvent evt) {
            txtBuscarKeyReleased(evt);
        }
    });
    getContentPane().add(txtBuscar, new org.netbeans.lib.awtextra.AbsoluteConstraints(141, 370, 190, -1));
    tablaProveedor.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane1.setViewportView(tablaProveedor);
    getContentPane().add(jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 424, 766, 215));
    jLabel9.setForeground(new java.awt.Color(255, 255, 0));
    jLabel9.setText("Empresa:");
    getContentPane().add(jLabel9, new org.netbeans.lib.awtextra.AbsoluteConstraints(71, 240, -1, -1));
    txtEmpresa.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            txtEmpresaActionPerformed(evt);
        }
    });
    getContentPane().add(txtEmpresa, new org.netbeans.lib.awtextra.AbsoluteConstraints(157, 237, 204, -1));
    jLabel4.setForeground(new java.awt.Color(255, 255, 0));
    jLabel4.setText("Apellido paterno:");
    getContentPane().add(jLabel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(71, 153, -1, -1));
    jLabel5.setForeground(new java.awt.Color(255, 255, 0));
    jLabel5.setText("Apellido materno:");
    getContentPane().add(jLabel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(71, 202, -1, -1));
    getContentPane().add(txtApellido_paterno, new org.netbeans.lib.awtextra.AbsoluteConstraints(157, 150, 204, -1));
    getContentPane().add(txtApellido_materno, new org.netbeans.lib.awtextra.AbsoluteConstraints(159, 199, 202, -1));
    jLabel6.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/Fondo-color-verde-688051.jpeg")));
    getContentPane().add(jLabel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, -1, -1));
    pack();
}

######


private void btnGuardarActionPerformed(java.awt.event.ActionEvent evt) {
    String nombre_proveedor = txtProveedor.getText();
    String empresa = txtEmpresa.getText();
    String apellido_paterno = txtApellido_paterno.getText();
    String apellido_materno = txtApellido_materno.getText();
    int id = 0;
    if (modifica) {
        id = Integer.parseInt(txtId.getText());
    }
    if (nombre_proveedor.length() == 0 || empresa.length() == 0 || apellido_paterno.length() == 0 || apellido_materno.length() == 0) {
        JOptionPane.showMessageDialog(null, "Debes llenar todos los campos para registrar.");
        return;
    }
    try {
        PreparedStatement consulta;
        if (modifica) {
            consulta = conexion.prepareStatement("" + "UPDATE  proveedor SET nombre_proveedor=?,apellido_paterno=?,apellido_materno=?,empresa=? WHERE id_proveedor=?");
            consulta.setString(1, nombre_proveedor);
            consulta.setString(2, apellido_paterno);
            consulta.setString(3, apellido_materno);
            consulta.setString(4, empresa);
            consulta.setInt(5, id);
        } else {
            consulta = conexion.prepareStatement("" + "INSERT INTO proveedor(nombre_proveedor, apellido_paterno,apellido_materno, empresa) VALUES (?,?,?,?)");
            consulta.setString(1, nombre_proveedor);
            consulta.setString(2, apellido_paterno);
            consulta.setString(3, apellido_materno);
            consulta.setString(4, empresa);
            JOptionPane.showMessageDialog(null, "ahora registre los productos en Catalogo-->Medicamentos");
        }
        consulta.executeUpdate();
        llenaTablaProveedor();
        limpiaCampos();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


private void btnModificarActionPerformed(java.awt.event.ActionEvent evt) {
    int id = (int) tablaProveedor.getValueAt(tablaProveedor.getSelectedRow(), 0);
    String nombre_proveedor = (String) tablaProveedor.getValueAt(tablaProveedor.getSelectedRow(), 1);
    String apellido_paterno = (String) tablaProveedor.getValueAt(tablaProveedor.getSelectedRow(), 2);
    String apellido_materno = (String) tablaProveedor.getValueAt(tablaProveedor.getSelectedRow(), 3);
    String empresa = (String) tablaProveedor.getValueAt(tablaProveedor.getSelectedRow(), 4);
    txtId.setText("" + id);
    txtProveedor.setText(nombre_proveedor);
    txtApellido_paterno.setText(apellido_paterno);
    txtApellido_materno.setText(apellido_materno);
    txtEmpresa.setText(empresa);
    modifica = true;
}

######


private void btnEliminarActionPerformed(java.awt.event.ActionEvent evt) {
    int id = (int) tablaProveedor.getValueAt(tablaProveedor.getSelectedRow(), 0);
    try {
        PreparedStatement consulta = conexion.prepareStatement("" + "UPDATE proveedor SET status=2 WHERE id_proveedor=?");
        consulta.setInt(1, id);
        consulta.executeUpdate();
        llenaTablaProveedor();
        limpiaCampos();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void inicializaBaseDeDatos() {
    try {
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        conexion = DriverManager.getConnection("jdbc:mysql://" + "localhost/farmacia", "root", "");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    txtProductoActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnBuscarProductoActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnAgregarActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnGuardarActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jScrollPane1 = new javax.swing.JScrollPane();
    tablaSalida = new javax.swing.JTable();
    jLabel1 = new javax.swing.JLabel();
    txtProducto = new javax.swing.JTextField();
    jLabel4 = new javax.swing.JLabel();
    txtCantidad = new javax.swing.JTextField();
    btnBuscarProducto = new javax.swing.JButton();
    btnAgregar = new javax.swing.JButton();
    btnGuardar = new javax.swing.JButton();
    jLabel5 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    tablaSalida.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane1.setViewportView(tablaSalida);
    jLabel1.setText("Producto:");
    txtProducto.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            txtProductoActionPerformed(evt);
        }
    });
    jLabel4.setText("Cantidad:");
    btnBuscarProducto.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/medicamento.png")));
    btnBuscarProducto.setToolTipText("Buscar producto");
    btnBuscarProducto.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnBuscarProductoActionPerformed(evt);
        }
    });
    btnAgregar.setText("Agregar Salida");
    btnAgregar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnAgregarActionPerformed(evt);
        }
    });
    btnGuardar.setText("Guardar salida");
    btnGuardar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnGuardarActionPerformed(evt);
        }
    });
    jLabel5.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/icon-farm.png")));
    jLabel2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/sistem.png")));
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(23, 23, 23).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(jLabel1).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(txtProducto, javax.swing.GroupLayout.PREFERRED_SIZE, 164, javax.swing.GroupLayout.PREFERRED_SIZE)).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addComponent(jLabel4).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(txtCantidad, javax.swing.GroupLayout.PREFERRED_SIZE, 164, javax.swing.GroupLayout.PREFERRED_SIZE))).addGap(27, 27, 27).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(btnBuscarProducto, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(layout.createSequentialGroup().addComponent(btnAgregar).addGap(18, 18, 18).addComponent(btnGuardar)))).addGroup(layout.createSequentialGroup().addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jLabel2))).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 640, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap()));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel5).addComponent(jLabel2)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(btnBuscarProducto, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(layout.createSequentialGroup().addGap(14, 14, 14).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel1).addComponent(txtProducto, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(37, 37, 37).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel4).addComponent(txtCantidad, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(btnAgregar).addComponent(btnGuardar)))).addGap(34, 34, 34).addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 266, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(161, Short.MAX_VALUE)));
    pack();
}

######


private void txtProductoActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void btnGuardarActionPerformed(java.awt.event.ActionEvent evt) {
    try {
        PreparedStatement consulta = conexion.prepareStatement("" + "INSERT INTO salida (fecha_alta, id_usuario,cantidad) VALUES(NOW(),?,?)");
        consulta.setInt(1, config.id_usuario);
        consulta.setString(2, txtCantidad.getText());
        consulta.executeUpdate();
        consulta = conexion.prepareStatement("SELECT last_insert_id() as id FROM salida");
        ResultSet rs = consulta.executeQuery();
        if (rs.next()) {
            int id_salida = rs.getInt("id");
            String productoserror = "";
            boolean error = false;
            for (int i = 0; i < tablaSalida.getRowCount(); i++) {
                int id_producto = Integer.parseInt(tablaSalida.getValueAt(i, 0).toString());
                int cantidad = Integer.parseInt(tablaSalida.getValueAt(i, 2).toString());
                consulta = conexion.prepareStatement("" + "INSERT INTO detalle_salida (id_salida,id_producto,cantidad) VALUES (?,?,?)");
                consulta.setInt(1, id_salida);
                consulta.setInt(2, id_producto);
                consulta.setInt(3, cantidad);
                consulta.executeUpdate();
                consulta = conexion.prepareStatement("SELECT * FROM bodega WHERE id_medicamento=?");
                consulta.setInt(1, id_producto);
                ResultSet rs3 = consulta.executeQuery();
                if (rs3.next()) {
                    int cantidad_bodega = rs3.getInt("cantidad");
                    if (cantidad_bodega - cantidad > 0) {
                        cantidad_bodega = cantidad_bodega - cantidad;
                        consulta = conexion.prepareStatement("UPDATE bodega SET cantidad=? WHERE id_medicamento = ?");
                        consulta.setInt(1, cantidad_bodega);
                        consulta.setInt(2, id_producto);
                        consulta.executeUpdate();
                        consulta = conexion.prepareStatement("SELECT * FROM medicamento WHERE id_medicamento=?");
                        consulta.setInt(1, id_producto);
                        ResultSet rs2 = consulta.executeQuery();
                        if (rs2.next()) {
                            int cantidad_medicamentos = rs2.getInt("cantidad");
                            cantidad_medicamentos = cantidad_medicamentos + cantidad;
                            consulta = conexion.prepareStatement("UPDATE medicamento SET cantidad=? WHERE id_medicamento = ?");
                            consulta.setInt(1, cantidad_medicamentos);
                            consulta.setInt(2, id_producto);
                            consulta.executeUpdate();
                        }
                    } else {
                        error = true;
                        productoserror += "producto:" + rs3.getInt("id_medicamento") + "\n";
                    }
                }
            }
            if (error) {
                JOptionPane.showMessageDialog(null, "Se guardo la venta con los siguientes errores\n" + productoserror);
            } else {
                JOptionPane.showMessageDialog(null, "Se guardo la venta correctamente");
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void limpiaCampos() {
    txtProducto.setText("");
    txtCantidad.setText("");
}

######


private void btnBuscarProductoActionPerformed(java.awt.event.ActionEvent evt) {
    frmBuscarProducto BuscarProducto = new frmBuscarProducto(txtProducto);
    BuscarProducto.setVisible(true);
}

######


private void btnAgregarActionPerformed(java.awt.event.ActionEvent evt) {
    try {
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT * FROM medicamento WHERE status=1 AND id_medicamento=?");
        consulta.setString(1, txtProducto.getText());
        ResultSet rs = consulta.executeQuery();
        rs.next();
        Object[] fila = new Object[5];
        fila[0] = txtProducto.getText();
        fila[1] = rs.getString("nombre");
        fila[2] = txtCantidad.getText();
        model.addRow(fila);
        limpiaCampos();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void run() {
    new frmCatalogoSalida().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(frmCatalogoSalida.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(frmCatalogoSalida.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(frmCatalogoSalida.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(frmCatalogoSalida.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new frmCatalogoSalida().setVisible(true);
        }
    });
}

######


public void inicializaBaseDeDatos() {
    try {
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        conexion = DriverManager.getConnection("jdbc:mysql://" + "localhost/farmacia", "root", "");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void llenaTablaUsuarios() {
    try {
        DefaultTableModel model = new DefaultTableModel();
        tablaUsuario.setModel(model);
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT * FROM usuarios WHERE status=1");
        ResultSet rs = consulta.executeQuery();
        ResultSetMetaData rsMd = rs.getMetaData();
        int cantidadColumnas = rsMd.getColumnCount();
        for (int i = 1; i <= cantidadColumnas; i++) {
            model.addColumn(rsMd.getColumnLabel(i));
        }
        while (rs.next()) {
            Object[] fila = new Object[cantidadColumnas];
            for (int j = 1; j <= cantidadColumnas; j++) {
                fila[j - 1] = rs.getObject(j);
            }
            model.addRow(fila);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnGuardarActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnModificarActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnElimminarActionPerformed(evt);
}

######


public void keyReleased(java.awt.event.KeyEvent evt) {
    txtBuscarKeyReleased(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    jLabel4 = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    jLabel6 = new javax.swing.JLabel();
    jLabel7 = new javax.swing.JLabel();
    jLabel8 = new javax.swing.JLabel();
    txtId = new javax.swing.JTextField();
    txtNombre = new javax.swing.JTextField();
    txtApellido_paterno = new javax.swing.JTextField();
    txtApellido_materno = new javax.swing.JTextField();
    txtEmail = new javax.swing.JTextField();
    txtUsuario = new javax.swing.JTextField();
    txtPassword = new javax.swing.JTextField();
    btnGuardar = new javax.swing.JButton();
    btnModificar = new javax.swing.JButton();
    btnElimminar = new javax.swing.JButton();
    jLabel9 = new javax.swing.JLabel();
    txtBuscar = new javax.swing.JTextField();
    jScrollPane1 = new javax.swing.JScrollPane();
    tablaUsuario = new javax.swing.JTable();
    jSeparator1 = new javax.swing.JSeparator();
    jLabel10 = new javax.swing.JLabel();
    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
    jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18));
    jLabel1.setForeground(new java.awt.Color(255, 255, 0));
    jLabel1.setText("Sistema de Usuarios");
    getContentPane().add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(38, 28, -1, -1));
    jLabel2.setForeground(new java.awt.Color(255, 255, 0));
    jLabel2.setText("ID:");
    getContentPane().add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(60, 71, -1, -1));
    jLabel3.setForeground(new java.awt.Color(255, 255, 0));
    jLabel3.setText("Nombre:");
    getContentPane().add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(60, 117, -1, -1));
    jLabel4.setForeground(new java.awt.Color(255, 255, 0));
    jLabel4.setText("Apellido paterno:");
    getContentPane().add(jLabel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(60, 155, -1, -1));
    jLabel5.setForeground(new java.awt.Color(255, 255, 0));
    jLabel5.setText("Apellido materno:");
    getContentPane().add(jLabel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(60, 193, -1, -1));
    jLabel6.setForeground(new java.awt.Color(255, 255, 0));
    jLabel6.setText("Email:");
    getContentPane().add(jLabel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(60, 231, -1, -1));
    jLabel7.setForeground(new java.awt.Color(255, 255, 0));
    jLabel7.setText("Usuario:");
    getContentPane().add(jLabel7, new org.netbeans.lib.awtextra.AbsoluteConstraints(60, 266, -1, -1));
    jLabel8.setForeground(new java.awt.Color(255, 255, 0));
    jLabel8.setText("Contraseña:");
    getContentPane().add(jLabel8, new org.netbeans.lib.awtextra.AbsoluteConstraints(60, 304, -1, -1));
    txtId.setText("Nuevo");
    getContentPane().add(txtId, new org.netbeans.lib.awtextra.AbsoluteConstraints(165, 68, 94, -1));
    getContentPane().add(txtNombre, new org.netbeans.lib.awtextra.AbsoluteConstraints(165, 114, 162, -1));
    getContentPane().add(txtApellido_paterno, new org.netbeans.lib.awtextra.AbsoluteConstraints(165, 152, 162, -1));
    getContentPane().add(txtApellido_materno, new org.netbeans.lib.awtextra.AbsoluteConstraints(165, 190, 162, -1));
    getContentPane().add(txtEmail, new org.netbeans.lib.awtextra.AbsoluteConstraints(165, 228, 162, -1));
    getContentPane().add(txtUsuario, new org.netbeans.lib.awtextra.AbsoluteConstraints(165, 266, 162, -1));
    getContentPane().add(txtPassword, new org.netbeans.lib.awtextra.AbsoluteConstraints(165, 304, 162, -1));
    btnGuardar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/guardar.png")));
    btnGuardar.setToolTipText("Guardar");
    btnGuardar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnGuardarActionPerformed(evt);
        }
    });
    getContentPane().add(btnGuardar, new org.netbeans.lib.awtextra.AbsoluteConstraints(359, 46, 67, -1));
    btnModificar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/modificar.png")));
    btnModificar.setToolTipText("Modificar");
    btnModificar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnModificarActionPerformed(evt);
        }
    });
    getContentPane().add(btnModificar, new org.netbeans.lib.awtextra.AbsoluteConstraints(432, 46, -1, 57));
    btnElimminar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/eliminar.png")));
    btnElimminar.setToolTipText("Eliminar");
    btnElimminar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnElimminarActionPerformed(evt);
        }
    });
    getContentPane().add(btnElimminar, new org.netbeans.lib.awtextra.AbsoluteConstraints(503, 46, -1, 57));
    jLabel9.setForeground(new java.awt.Color(255, 255, 0));
    jLabel9.setText("Buscar usuario:");
    getContentPane().add(jLabel9, new org.netbeans.lib.awtextra.AbsoluteConstraints(60, 374, -1, -1));
    txtBuscar.addKeyListener(new java.awt.event.KeyAdapter() {

        public void keyReleased(java.awt.event.KeyEvent evt) {
            txtBuscarKeyReleased(evt);
        }
    });
    getContentPane().add(txtBuscar, new org.netbeans.lib.awtextra.AbsoluteConstraints(165, 371, 195, -1));
    tablaUsuario.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane1.setViewportView(tablaUsuario);
    getContentPane().add(jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(60, 424, 701, 166));
    getContentPane().add(jSeparator1, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 350, 778, 10));
    jLabel10.setForeground(new java.awt.Color(255, 255, 0));
    jLabel10.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/Fondo-color-verde-688051.jpeg")));
    getContentPane().add(jLabel10, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, -1, -1));
    pack();
}

######


private void btnGuardarActionPerformed(java.awt.event.ActionEvent evt) {
    String nombre = txtNombre.getText();
    String apellido_paterno = txtApellido_paterno.getText();
    String apellido_materno = txtApellido_materno.getText();
    String email = txtEmail.getText();
    String usuario = txtUsuario.getText();
    String password = txtPassword.getText();
    int id = 0;
    if (modifica) {
        id = Integer.parseInt(txtId.getText());
    }
    if (nombre.length() == 0 || apellido_paterno.length() == 0 || apellido_materno.length() == 0 || email.length() == 0 || usuario.length() == 0 || password.length() == 0) {
        JOptionPane.showMessageDialog(null, "Debes llenar todos los campos para registrar.");
        return;
    }
    try {
        PreparedStatement consulta;
        if (modifica) {
            consulta = conexion.prepareStatement("" + "UPDATE  usuarios SET nombre=?,apellido_paterno=?,apellido_materno=?,email=?,usuario=?,password=? WHERE id_usuario=?");
            consulta.setString(1, nombre);
            consulta.setString(2, apellido_paterno);
            consulta.setString(3, apellido_materno);
            consulta.setString(4, email);
            consulta.setString(5, usuario);
            consulta.setString(6, password);
            consulta.setInt(7, id);
        } else {
            consulta = conexion.prepareStatement("" + "INSERT INTO usuarios(nombre,apellido_paterno,apellido_materno" + ",email,usuario,password) VALUES (?,?,?,?,?,?)");
            consulta.setString(1, nombre);
            consulta.setString(2, apellido_paterno);
            consulta.setString(3, apellido_materno);
            consulta.setString(4, email);
            consulta.setString(5, usuario);
            consulta.setString(6, password);
        }
        consulta.executeUpdate();
        llenaTablaUsuarios();
        limpiaCampos();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


private void btnElimminarActionPerformed(java.awt.event.ActionEvent evt) {
    int id = (int) tablaUsuario.getValueAt(tablaUsuario.getSelectedRow(), 0);
    try {
        PreparedStatement consulta = conexion.prepareStatement("" + "UPDATE usuarios SET status=2 WHERE id_usuario=?");
        consulta.setInt(1, id);
        consulta.executeUpdate();
        llenaTablaUsuarios();
        limpiaCampos();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


private void btnModificarActionPerformed(java.awt.event.ActionEvent evt) {
    int id = (int) tablaUsuario.getValueAt(tablaUsuario.getSelectedRow(), 0);
    String nombre = (String) tablaUsuario.getValueAt(tablaUsuario.getSelectedRow(), 1);
    String apellido_paterno = (String) tablaUsuario.getValueAt(tablaUsuario.getSelectedRow(), 2);
    String apellido_materno = (String) tablaUsuario.getValueAt(tablaUsuario.getSelectedRow(), 3);
    String email = (String) tablaUsuario.getValueAt(tablaUsuario.getSelectedRow(), 4);
    String usuario = (String) tablaUsuario.getValueAt(tablaUsuario.getSelectedRow(), 5);
    String password = (String) tablaUsuario.getValueAt(tablaUsuario.getSelectedRow(), 6);
    txtId.setText("" + id);
    txtNombre.setText(nombre);
    txtApellido_paterno.setText(apellido_paterno);
    txtApellido_materno.setText(apellido_materno);
    txtEmail.setText(email);
    txtUsuario.setText(usuario);
    txtPassword.setText(password);
    modifica = true;
}

######


public void inicializaBaseDeDatos() {
    try {
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        conexion = DriverManager.getConnection("jdbc:mysql://" + "localhost/farmacia", "root", "");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnEntrarActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    txtUsuario = new javax.swing.JTextField();
    btnEntrar = new javax.swing.JButton();
    txtPassword = new javax.swing.JPasswordField();
    jLabel5 = new javax.swing.JLabel();
    jLabel4 = new javax.swing.JLabel();
    jLabel6 = new javax.swing.JLabel();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
    jLabel1.setFont(new java.awt.Font("Tahoma", 1, 14));
    jLabel1.setText("Inicio de sesion");
    getContentPane().add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(27, 21, -1, -1));
    jLabel2.setFont(new java.awt.Font("Tahoma", 1, 11));
    jLabel2.setText("Usuario:");
    getContentPane().add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(56, 56, -1, -1));
    jLabel3.setFont(new java.awt.Font("Tahoma", 1, 11));
    jLabel3.setText("Contraseña:");
    getContentPane().add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(56, 94, -1, -1));
    getContentPane().add(txtUsuario, new org.netbeans.lib.awtextra.AbsoluteConstraints(130, 50, 133, -1));
    btnEntrar.setText("Entrar");
    btnEntrar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnEntrarActionPerformed(evt);
        }
    });
    getContentPane().add(btnEntrar, new org.netbeans.lib.awtextra.AbsoluteConstraints(190, 138, -1, -1));
    getContentPane().add(txtPassword, new org.netbeans.lib.awtextra.AbsoluteConstraints(130, 90, 133, -1));
    jLabel5.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/cruz-verde.png")));
    getContentPane().add(jLabel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 170, -1, -1));
    jLabel4.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/sistem.png")));
    getContentPane().add(jLabel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(110, 190, 460, -1));
    jLabel6.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/Fondo-color-verde-688051.jpeg")));
    getContentPane().add(jLabel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, 700, 330));
    pack();
}

######


private void btnEntrarActionPerformed(java.awt.event.ActionEvent evt) {
    try {
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT * FROM usuarios WHERE usuario=? AND password=?" + " AND status=1");
        consulta.setString(1, txtUsuario.getText());
        consulta.setString(2, txtPassword.getText());
        ResultSet rs = consulta.executeQuery();
        if (rs.next()) {
            JOptionPane.showMessageDialog(null, "Bienvenido al Sistema");
            config.id_usuario = rs.getInt("id_usuario");
            MDIPrincipal mdiPrincipal = new MDIPrincipal();
            mdiPrincipal.setExtendedState(JFrame.MAXIMIZED_BOTH);
            mdiPrincipal.setVisible(true);
            frmLogin.this.dispose();
        } else {
            JOptionPane.showMessageDialog(null, "Usuario no Existe");
        }
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void run() {
    new frmLogin().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(frmLogin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(frmLogin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(frmLogin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(frmLogin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new frmLogin().setVisible(true);
        }
    });
}

######


public void inicializaBaseDeDatos() {
    try {
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        conexion = DriverManager.getConnection("jdbc:mysql://" + "localhost/farmacia", "root", "");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnBuscarClienteActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnAgregarActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnBuscarProductoActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    btnGuardarActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    txtCliente = new javax.swing.JTextField();
    txtProducto = new javax.swing.JTextField();
    txtTotal = new javax.swing.JTextField();
    jScrollPane1 = new javax.swing.JScrollPane();
    tablaVentas = new javax.swing.JTable();
    btnBuscarCliente = new javax.swing.JButton();
    btnAgregar = new javax.swing.JButton();
    btnBuscarProducto = new javax.swing.JButton();
    jLabel4 = new javax.swing.JLabel();
    txtCantidad = new javax.swing.JTextField();
    btnGuardar = new javax.swing.JButton();
    jLabel6 = new javax.swing.JLabel();
    jLabel1 = new javax.swing.JLabel();
    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    jLabel2.setText("Cliente:");
    jLabel3.setText("Producto:");
    jLabel5.setText("Total a pagar:");
    tablaVentas.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane1.setViewportView(tablaVentas);
    btnBuscarCliente.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/buscar (2).png")));
    btnBuscarCliente.setToolTipText("Buscar cliente");
    btnBuscarCliente.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnBuscarClienteActionPerformed(evt);
        }
    });
    btnAgregar.setText("Realizar venta");
    btnAgregar.setToolTipText("agregar nuevo");
    btnAgregar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnAgregarActionPerformed(evt);
        }
    });
    btnBuscarProducto.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/medicamento.png")));
    btnBuscarProducto.setToolTipText("Buscar producto");
    btnBuscarProducto.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnBuscarProductoActionPerformed(evt);
        }
    });
    jLabel4.setText("Cantidad");
    btnGuardar.setText("guardar venta");
    btnGuardar.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            btnGuardarActionPerformed(evt);
        }
    });
    jLabel6.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/icon-farm.png")));
    jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/iconos/sistem.png")));
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addGap(517, 517, 517).addComponent(jLabel5).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(txtTotal, javax.swing.GroupLayout.PREFERRED_SIZE, 105, javax.swing.GroupLayout.PREFERRED_SIZE)).addComponent(jScrollPane1).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jLabel1)).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel2).addComponent(jLabel3)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(txtCliente).addComponent(txtProducto, javax.swing.GroupLayout.PREFERRED_SIZE, 160, javax.swing.GroupLayout.PREFERRED_SIZE))).addGroup(layout.createSequentialGroup().addComponent(jLabel4).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(txtCantidad, javax.swing.GroupLayout.PREFERRED_SIZE, 159, javax.swing.GroupLayout.PREFERRED_SIZE))).addGap(26, 26, 26).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(btnBuscarProducto, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE).addComponent(btnBuscarCliente, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE))).addGroup(layout.createSequentialGroup().addGap(220, 220, 220).addComponent(btnAgregar).addGap(27, 27, 27).addComponent(btnGuardar))).addGap(0, 0, Short.MAX_VALUE))).addContainerGap()));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel6).addComponent(jLabel1)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(7, 7, 7).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel2).addComponent(txtCliente, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))).addComponent(btnBuscarCliente, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel3).addComponent(txtProducto, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel4).addComponent(txtCantidad, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))).addComponent(btnBuscarProducto, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(4, 4, 4).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(btnAgregar).addComponent(btnGuardar)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 215, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel5).addComponent(txtTotal, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)).addContainerGap(215, Short.MAX_VALUE)));
    pack();
}

######


private void btnBuscarClienteActionPerformed(java.awt.event.ActionEvent evt) {
    frmBuscarCliente BuscarCliente = new frmBuscarCliente(txtCliente);
    BuscarCliente.setVisible(true);
}

######


private void btnAgregarActionPerformed(java.awt.event.ActionEvent evt) {
    try {
        PreparedStatement consulta = conexion.prepareStatement("" + "SELECT * FROM medicamento WHERE status=1 AND id_medicamento=?");
        consulta.setString(1, txtProducto.getText());
        ResultSet rs = consulta.executeQuery();
        rs.next();
        Object[] fila = new Object[5];
        fila[0] = txtProducto.getText();
        fila[1] = rs.getString("nombre");
        fila[2] = rs.getString("precio");
        fila[3] = txtCantidad.getText();
        double precio = Double.parseDouble(rs.getString("precio"));
        int cantidad = Integer.parseInt(txtCantidad.getText());
        double total = precio * cantidad;
        fila[4] = "" + total;
        model.addRow(fila);
        limpiaCampos();
        sumarventa();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


private void btnBuscarProductoActionPerformed(java.awt.event.ActionEvent evt) {
    frmBuscarProducto BuscarProducto = new frmBuscarProducto(txtProducto);
    BuscarProducto.setVisible(true);
}

######


private void btnGuardarActionPerformed(java.awt.event.ActionEvent evt) {
    try {
        PreparedStatement consulta = conexion.prepareStatement("" + "INSERT INTO ventas(fecha_alta, id_usuario, id_cliente,total) VALUES(NOW(),?,?,?)");
        consulta.setInt(1, config.id_usuario);
        consulta.setString(2, txtCliente.getText());
        consulta.setString(3, "0");
        consulta.executeUpdate();
        consulta = conexion.prepareStatement("SELECT last_insert_id() as id FROM ventas");
        ResultSet rs = consulta.executeQuery();
        if (rs.next()) {
            int id_venta = rs.getInt("id");
            String productoserror = "";
            boolean error = false;
            for (int i = 0; i < tablaVentas.getRowCount(); i++) {
                int id_producto = Integer.parseInt(tablaVentas.getValueAt(i, 0).toString());
                int cantidad = Integer.parseInt(tablaVentas.getValueAt(i, 3).toString());
                double precio = Double.parseDouble(tablaVentas.getValueAt(i, 2).toString());
                double total = Double.parseDouble(tablaVentas.getValueAt(i, 4).toString());
                consulta = conexion.prepareStatement("" + "INSERT INTO detalle_venta(id_venta,id_producto,cantidad,precio,total) VALUES (?,?,?,?,?)");
                consulta.setInt(1, id_venta);
                consulta.setInt(2, id_producto);
                consulta.setInt(3, cantidad);
                consulta.setDouble(4, precio);
                consulta.setDouble(5, total);
                consulta.executeUpdate();
                consulta = conexion.prepareStatement("SELECT * FROM medicamento WHERE id_medicamento=?");
                consulta.setInt(1, id_producto);
                ResultSet rs2 = consulta.executeQuery();
                if (rs2.next()) {
                    int cantidad_medicamentos = rs2.getInt("cantidad");
                    if (cantidad_medicamentos - cantidad > 0) {
                        cantidad_medicamentos = cantidad_medicamentos - cantidad;
                        consulta = conexion.prepareStatement("UPDATE medicamento SET cantidad=? WHERE id_medicamento = ?");
                        consulta.setInt(1, cantidad_medicamentos);
                        consulta.setInt(2, id_producto);
                        consulta.executeUpdate();
                    } else {
                        error = true;
                        productoserror += "producto:" + rs2.getInt("id_medicamento") + "\n";
                    }
                }
            }
            if (error) {
                JOptionPane.showMessageDialog(null, "Se guardo la venta con los siguientes errores\n" + productoserror);
            } else {
                JOptionPane.showMessageDialog(null, "Se guardo la venta correctamente");
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void limpiaCampos() {
    txtProducto.setText("");
    txtCantidad.setText("");
}

######


public void sumarventa() {
    double suma = 0;
    for (int i = 0; i < tablaVentas.getRowCount(); i++) {
        suma += Double.parseDouble(tablaVentas.getValueAt(i, 4).toString());
    }
    txtTotal.setText("" + suma);
}

######


public void run() {
    new frmRealizarVenta().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(frmRealizarVenta.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(frmRealizarVenta.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(frmRealizarVenta.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(frmRealizarVenta.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new frmRealizarVenta().setVisible(true);
        }
    });
}

######


public void salvar(Funcionario funcionario) throws Exception {
    if (funcionario.getIdFuncionario() == 0) {
        inserir(funcionario);
    } else {
        alterar(funcionario);
    }
}

######


private void alterar(Funcionario funcionario) throws Exception {
    try {
        PreparedStatement ps = getConnection().prepareStatement(UPDATE);
        parseFuncionario(funcionario, ps);
        ps.setLong(4, funcionario.getIdFuncionario());
        ps.executeUpdate();
    } catch (Exception e) {
        e.printStackTrace();
        throw new Exception("Erro ao tentar salvar o usuario");
    }
}

######


private void inserir(Funcionario funcionario) throws Exception {
    try {
        PreparedStatement ps = getConnection().prepareStatement(INSERT);
        parseFuncionario(funcionario, ps);
        ps.executeUpdate();
    } catch (Exception e) {
        e.printStackTrace();
        throw new Exception("Erro ao tentar salvar o usuario");
    }
}

######


public void excluir(Long idFuncionario) throws Exception {
    try {
        PreparedStatement ps = getConnection().prepareStatement(DELETE);
        ps.setLong(1, idFuncionario);
        ps.executeUpdate();
    } catch (SQLException e) {
        e.printStackTrace();
        System.out.println("Erro a executar o delete: " + e);
        throw new Exception("Erro ao tentar excluir");
    }
}

######


public Funcionario buscarPorId(Long idFuncionario) throws Exception {
    try {
        PreparedStatement ps = getConnection().prepareStatement(SELECT_ID);
        ps.setLong(1, idFuncionario);
        ResultSet rs = ps.executeQuery();
        if (rs.next()) {
            Funcionario funcionario = parseFuncionario(rs);
            return funcionario;
        }
    } catch (SQLException e) {
        e.printStackTrace();
        System.out.println("Erro ao executar o select de user: " + e);
    }
    return null;
}

######


public List<Funcionario> listarTodos() throws Exception {
    List<Funcionario> funcionarios = new ArrayList<Funcionario>();
    try {
        PreparedStatement ps = getConnection().prepareStatement(SELECT);
        ResultSet rs = ps.executeQuery();
        while (rs.next()) {
            Funcionario funcionario = parseFuncionario(rs);
            funcionarios.add(funcionario);
        }
    } catch (SQLException e) {
        e.printStackTrace();
        System.out.println("Erro ao executar o select de user: " + e);
    }
    return funcionarios;
}

######


private Funcionario parseFuncionario(ResultSet rs) throws SQLException {
    Funcionario funcionario = new Funcionario();
    funcionario.setIdFuncionario(rs.getLong("idFuncionario"));
    funcionario.setNome(rs.getString("nome"));
    funcionario.setFuncao(rs.getString("funcao"));
    funcionario.setEmail(rs.getString("email"));
    return funcionario;
}

######


private void parseFuncionario(Funcionario funcionario, PreparedStatement ps) throws SQLException {
    ps.setString(1, funcionario.getNome());
    ps.setString(2, funcionario.getFuncao());
    ps.setString(3, funcionario.getEmail());
}

######


@Modifying
@Query("update Gallery g set g.entityId = ?2 where g.entityId = ?1")
int updateEntityId(String uuid, String newProductId);

######


Gallery findByEntityId(String id);

######


public static synchronized GCmLicenseManager getInstance() {
    if (m_instance == null) {
        m_instance = new GCmLicenseManager();
    }
    m_clients += 1;
    return m_instance;
}

######


public static Properties getLicenseProp() {
    if (m_licenseProp == null) {
        try {
            m_instance.parseLicenseString();
        } catch (Exception localException) {
        }
    }
    return m_licenseProp;
}

######


public static void init(String eknowareDir) throws GCmGplusException {
    if (m_instance == null) {
        EKNOWAREDIR = eknowareDir;
        SYS_PROPERTY_FILE = eknowareDir + File.separator + "eknoware.properties";
        GCmDebugLog log = null;
        try {
            log = new GCmDebugLog(eknowareDir + File.separator + "logs" + File.separator + "eknoware.log");
        } catch (Exception e) {
            log = new GCmDebugLog(new PrintWriter(System.err));
        }
        m_instance = new GCmLicenseManager();
        m_instance.loadSystemProperties();
        m_instance.loadCurrentStatusProperties();
        m_instance.parseLicenseString();
        m_instance.checkLegalUsing();
    }
}

######


private void loadSystemProperties() {
    try {
        FileInputStream fin = new FileInputStream(SYS_PROPERTY_FILE);
        m_sysProp.load(fin);
        fin.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

######


private void loadCurrentStatusProperties() throws GCmGplusException {
    Connection conn = null;
    Statement stmt = null;
    ResultSet userCnt = null;
    try {
        Class.forName(m_sysProp.getProperty("eknoware.db.jdbcDriver"));
        String strUrl = m_sysProp.getProperty("eknoware.db.jdbcUrl");
        String strUser = m_sysProp.getProperty("eknoware.db.user");
        String strPasswd = m_sysProp.getProperty("eknoware.db.password");
        conn = DriverManager.getConnection(strUrl, strUser, strPasswd);
        stmt = conn.createStatement();
        String strQuery = "SELECT COUNT(USERID) FROM TB_COMM_Z20  WHERE USECHECK='Y' AND SECLVL NOT IN('9')";
        userCnt = stmt.executeQuery(strQuery);
        if (userCnt.next()) {
            m_currentProp.put("UL", userCnt.getString(1));
        } else {
            throw new GCmGplusException();
        }
        m_currentProp.put("ED", GCmDateFcts.dateToStr(new Date(), 1));
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


private void parseLicenseString() throws GCmGplusException {
    String strLicenseKey = getLicenseString();
    StringTokenizer st = new StringTokenizer(strLicenseKey, "-");
    while (st.hasMoreTokens()) {
        String strItem = st.nextToken();
        StringTokenizer stItem = new StringTokenizer(strItem, ":");
        String strKey = null;
        String strValue = null;
        if (stItem.countTokens() == 2) {
            strKey = stItem.nextToken().toUpperCase();
            strValue = stItem.nextToken().toUpperCase();
            m_licenseProp.put(strKey, strValue);
        } else {
            throw new GCmGplusException();
        }
    }
}

######


private String getLicenseString() {
    Properties licenseKeyProp = null;
    try {
        Class cLicense = Class.forName("eknoware.commlib.GPlusLicense");
        Constructor ct = cLicense.getConstructor(null);
        Object objLicense = ct.newInstance(null);
        Method getLicenseKey = cLicense.getMethod("getLicenseKey", null);
        licenseKeyProp = (Properties) getLicenseKey.invoke(objLicense, null);
        return decryptString(licenseKeyProp.getProperty("KEY"));
    } catch (ClassNotFoundException e) {
        System.err.println("License file does not exist or CLASSPATH is not correct");
        return null;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}

######


private void checkLegalUsing() throws GCmGplusException {
    if (!(m_licenseProp.getProperty("SN").toUpperCase().trim().equals("G+20011202001"))) {
        throw new GCmGplusException();
    }
    if (!(m_licenseProp.getProperty("ED").toUpperCase().equals("U"))) {
        int nCurrentDate = Integer.parseInt(m_currentProp.getProperty("ED"));
        int nLicenseDate = Integer.parseInt(m_licenseProp.getProperty("ED"));
        if (nCurrentDate > nLicenseDate) {
            throw new GCmGplusException();
        }
    }
    if (!(m_licenseProp.getProperty("UL").toUpperCase().equals("U"))) {
        int nCurrentUser = Integer.parseInt(m_currentProp.getProperty("UL"));
        int nLicenseUser = Integer.parseInt(m_licenseProp.getProperty("UL"));
        if (nCurrentUser > nLicenseUser) {
            throw new GCmGplusException();
        }
    }
}

######


private void checkHost() throws GCmGplusException {
    String strHostName = "";
    String strSysName = "";
    GCmDebugLog log = null;
    try {
        strHostName = m_sysProp.getProperty("eknoware.system.HostName");
        strSysName = InetAddress.getLocalHost().getHostName();
    } catch (Exception e) {
        System.out.println("���� :: checkHost()=" + e.getMessage());
    }
    if (!(strHostName.toUpperCase().trim().equals(strSysName.toUpperCase().trim()))) {
        throw new GCmGplusException();
    }
}

######


private void checkHostIP() throws GCmGplusException {
    String strHostIP = "";
    String strSysIP = "";
    GCmDebugLog log = null;
    try {
        strHostIP = m_sysProp.getProperty("eknoware.system.hostip2");
        InetAddress MyHost = InetAddress.getLocalHost();
        strSysIP = MyHost.getHostAddress();
    } catch (Exception e) {
        System.out.println("���� :: checkHost()=" + e.getMessage());
    }
    if (!(strHostIP.toUpperCase().trim().equals(strSysIP.toUpperCase().trim()))) {
        throw new GCmGplusException();
    }
}

######


public static void checkLegalDate() throws GCmGplusException {
    if (!(m_licenseProp.getProperty("ED").toUpperCase().equals("U"))) {
        GCmDebugLog log = null;
        int nCurrentDate = 0;
        int nLicenseDate = 0;
        try {
            nCurrentDate = Integer.parseInt(GCmDateFcts.dateToStr(new Date(), 1));
            nLicenseDate = Integer.parseInt(m_licenseProp.getProperty("ED"));
            log = new GCmDebugLog(EKNOWAREDIR + File.separator + "log" + File.separator + "eknoware.log");
        } catch (Exception e) {
            log = new GCmDebugLog(new PrintWriter(System.err));
        }
        if (nCurrentDate > nLicenseDate) {
            log.println("Your license Date is expired...");
            System.runFinalization();
            System.exit(0);
            throw new GCmGplusException();
        }
    }
}

######


public static Properties getlicenseprop() {
    return m_licenseProp;
}

######


public static Properties getcurrentprop() {
    return m_currentProp;
}

######


private static long computeModExp(long n, long e, long m) {
    long residue = 1L;
    int i = 0;
    while (e > 0L) {
        if (e % 2L == 1L) {
            residue = residue * n % m;
        }
        if (residue < 0L) {
            break;
        }
        n = n * n % m;
        e /= 2L;
        ++i;
    }
    return residue;
}

######


private static long computeEuclid(long a, long b) {
    long d = a;
    long d2 = b;
    long u = 1L;
    long u2 = 0L;
    long v = 0L;
    long v2 = 1L;
    while (d2 != 0L) {
        long q = d / d2;
        long tmp = d;
        d = d2;
        d2 = tmp - (d2 * q);
        tmp = u;
        u = u2;
        u2 = tmp - (u2 * q);
        tmp = v;
        v = v2;
        v2 = tmp - (v2 * q);
    }
    if (u < 0L) {
        u += b;
    }
    return u;
}

######


private static String decryptString(String strEncrypted) {
    StringTokenizer st = new StringTokenizer(strEncrypted, "-");
    StringBuffer szBuff = new StringBuffer();
    for (int i = 0; st.hasMoreTokens(); ++i) {
        String strCode = st.nextToken();
        szBuff.append((char) (int) computeModExp(Long.parseLong(strCode), d, n));
    }
    return szBuff.toString();
}

######


public int updateNoti(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String TITLE = dmProp.getString("Title");
    String ATTNUM = dmProp.getString("Attnum");
    String NOTINO = dmProp.getString("Notino");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" UPDATE TB_" + COMCODE + "_A01 SET TITLE = " + genQuote(TITLE)).append(" , ATTNUM =" + genQuote(ATTNUM) + " WHERE NOTINO = " + genQuote(NOTINO));
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoBoBoardTran::updateNoti : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoBoBoardTran::updateNoti : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoBoBoardTran::updateNoti : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int updateNom(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String NOTINO = dmProp.getString("NOTINO");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" UPDATE TB_" + COMCODE + "_A01 SET NOMNUM = NOMNUM+1  ").append(" WHERE NOTINO =" + genQuote(NOTINO));
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoBoBoardTran::getUpdNom : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoBoBoardTran::getUpdNom : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoBoBoardTran::getUpdNom : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int insertBoxRight(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Boxno = dmProp.getString("Boxno");
    String Userno = dmProp.getString("Userno");
    String Docread = dmProp.getString("Docread");
    String Docwrite = dmProp.getString("Docwrite");
    String Docdel = dmProp.getString("Docdel");
    String Docdeladm = dmProp.getString("Docdeladm");
    String Fldmake = dmProp.getString("Fldmake");
    String Flddel = dmProp.getString("Flddel");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_M20 (BOXNO,USERID,DOCREAD,DOCWRITE,DOCDEL,DOCDELADM,FLDMAKE,FLDDEL) ").append(" VALUES (" + genQuote(Boxno) + "," + genQuote(Userno) + "," + genQuote(Docread) + "," + genQuote(Docwrite) + "," + genQuote(Docdel) + ",").append("         " + genQuote(Docdeladm) + "," + genQuote(Fldmake) + "," + genQuote(Flddel) + ") ");
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoBoBoardTran::insertBoxRight : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoBoBoardTran::insertBoxRight : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoBoBoardTran::insertBoxRight : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int deleteNoti(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String NOTINO = dmProp.getString("NOTINO");
    String PPATH = dmProp.getString("PPATH");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    GCmResultSet rs = null;
    GCoDoDocTran docTran = new GCoDoDocTran();
    GCoBoBoard board = new GCoBoBoard();
    try {
        StringBuffer SqlQuery = null;
        conn = GCmDbManager.getInstance().getConnection();
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        GCmResultSet rsDelList = board.getDelList(cp, dmProp, msgInfo);
        for (int j = 1; j <= rsDelList.getRowCount() && rsDelList.next(); j++) {
            dmProp.setProperty("DOCNO", rsDelList.getString("DOCNO"));
            dmProp.setProperty("SEQ", rsDelList.getString("SEQ"));
            dmProp.setProperty("FILENAME", rsDelList.getString("FILENAME"));
            dmProp.setProperty("FILEEXT", rsDelList.getString("FILEEXT"));
            dmProp.setProperty("VPATH", rsDelList.getString("VPATH"));
            java.io.File srcFile = new java.io.File(PPATH + rsDelList.getString("VPATH") + rsDelList.getString("FILENAME"));
            int cnt = 0;
            int bCnt = 0;
            int aCnt = 0;
            SqlQuery = new StringBuffer().append(" SELECT COUNT(*) bCnt FROM TB_eknow_B10  ").append(" WHERE DOCNO=" + genQuote(rsDelList.getString("DOCNO")));
            rs = conn.executeQuery(SqlQuery.toString());
            if (rs.next()) {
                bCnt = rs.getInt("bCnt");
            }
            SqlQuery = new StringBuffer().append(" SELECT COUNT(*) aCnt FROM TB_eknow_A01  ").append(" WHERE DOCNO=" + genQuote(rsDelList.getString("DOCNO")));
            rs = conn.executeQuery(SqlQuery.toString());
            if (rs.next()) {
                aCnt = rs.getInt("aCnt");
            }
            cnt = aCnt + bCnt;
            if (cnt == 1) {
                rv = docTran.deleteFile(cp, dmProp, msgInfo);
                if (srcFile.isFile())
                    srcFile.delete();
                dmProp.setProperty("DOCNO", rsDelList.getString("DOCNO"));
                rv = docTran.deleteDoc(cp, dmProp, msgInfo);
            }
        }
        SqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(COMCODE).append("_A01 ").append(" WHERE NOTINO = " + genQuote(NOTINO));
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoBoBoardTran::deleteNoti : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoBoBoardTran::deleteNoti : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoBoBoardTran::deleteNoti : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int insertNotify(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Notino = dmProp.getString("Notino");
    String Boxno = dmProp.getString("Boxno");
    String Docno = dmProp.getString("Docno");
    String Parentno = dmProp.getString("Parentno");
    String Title = dmProp.getString("Title");
    String Attnum = dmProp.getString("Attnum");
    String Refnum = dmProp.getString("Refnum");
    String Nomnum = dmProp.getString("Nomnum");
    String Childnum = dmProp.getString("Childnum");
    String Reguser = dmProp.getString("Reguser");
    String Regdate = dmProp.getString("Regdate");
    String Regname = dmProp.getString("Regname");
    String REF = dmProp.getString("REF");
    String STEPNUM = dmProp.getString("STEPNUM");
    String RELEVEL = dmProp.getString("RELEVEL");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_A01 (NOTINO,BOXNO,DOCNO,PARENTNO,TITLE,ATTNUM,REFNUM,NOMNUM,CHILDNUM,REGUSER,REGDATE,REGNAME,REF,SORTSTEP,RELEVEL) ").append(" VALUES(" + genQuote(Notino) + "," + genQuote(Boxno) + "," + genQuote(Docno) + "," + genQuote(Parentno) + "," + genQuote(Title) + ",").append("       " + Attnum + "," + Refnum + "," + Nomnum + "," + Childnum + "," + genQuote(Reguser) + "," + genQuote(Regdate) + "," + genQuote(Regname) + "," + genQuote(REF) + "," + genQuote(STEPNUM) + "," + genQuote(RELEVEL) + ")");
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoBoBoardTran::insertNotify : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoBoBoardTran::insertNotify : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoBoBoardTran::insertNotify : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int updateNotiOrder(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String REF = dmProp.getString("REF");
    int STEPNUM = dmProp.getInt("STEPNUM");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" UPDATE TB_" + COMCODE + "_A01 SET SORTSTEP = SORTSTEP + 1  ").append(" WHERE REF = " + genQuote(REF)).append(" AND SORTSTEP > " + STEPNUM);
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoBoBoardTran::updateNotiOrder : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoBoBoardTran::updateNotiOrder : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoBoBoardTran::updateNotiOrder : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int updateRefCnt(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String NOTINO = dmProp.getString("NOTINO");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" UPDATE TB_" + COMCODE + "_A01 SET REFNUM = REFNUM+1  ").append(" WHERE NOTINO =" + genQuote(NOTINO));
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoBoBoardTran::updateRefcnt : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoBoBoardTran::updateRefcnt : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoBoBoardTran::updateRefcnt : " + e.getMessage());
        }
        conn.close();
    }
}

######


public boolean setCopyFld(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    String COMCODE = dmProp.getString("COMCODE");
    String BOXNO = dmProp.getString("BOXNO");
    String REFNO = dmProp.getString("NOTINO");
    String USERID = dmProp.getString("USERID");
    String DOCNO = null;
    String FLDNO = null;
    GCmResultSet rs = null;
    int intRet = 0;
    GCoDoDoc doc = new GCoDoDoc();
    GCoDoDocTran docTran = new GCoDoDocTran();
    GCoDoDocFolder docFolder = new GCoDoDocFolder();
    GCoDoDocFolderTran docFolderTran = new GCoDoDocFolderTran();
    try {
        String strRegDate = GCmDateFcts.dateToStr(new java.util.Date(), 2);
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append("SELECT DOCNO from TB_").append(COMCODE).append("_A01 WHERE NOTINO=").append(genQuote(REFNO));
        rs = conn.executeQuery(sqlQuery.toString());
        if (REFNO != null && REFNO.length() > 0) {
            REFNO = "A" + REFNO;
        }
        if (rs.next()) {
            DOCNO = rs.getString("DOCNO");
            FLDNO = getMaxNoB10(COMCODE, strDbType);
            sqlQuery = new StringBuffer();
            sqlQuery.append("INSERT INTO TB_").append(COMCODE).append("_B10 (FLDNO,BOXNO,DOCNO,REFNO,USERID) VALUES(").append(genQuote(FLDNO)).append(",").append(genQuote(BOXNO)).append(",").append(genQuote(DOCNO)).append(",").append(genQuote(REFNO)).append(",").append(genQuote(USERID)).append(")");
            conn.executeUpdate(sqlQuery.toString());
        } else {
            return false;
        }
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("GCoDfDraftTran ::  setCopyFld() " + e.getMessage());
        }
        return false;
    } finally {
        conn.close();
    }
}

######


private String getMaxNoB10(String comcode, String strDbType) {
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(true);
        String strRegdate = GCmFcts.dateToStr(new java.util.Date(), 1);
        String strRet = "";
        StringBuffer sqlQuery = new StringBuffer();
        if ("oracle".equals(strDbType)) {
            sqlQuery.append(" SELECT SQ_").append(comcode).append("_B10.NEXTVAL RETCNT FROM DUAL ");
            GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
            while (rs.next()) {
                strRet = GCmFcts.numToStr(rs.getString("RETCNT"), 4);
                strRet = strRegdate + strRet;
            }
        } else if ("mssql".equals(strDbType)) {
            strRegdate = GCmFcts.dateToStr(new java.util.Date(), 3);
            sqlQuery.append(" INSERT INTO SQ_").append(comcode).append("_B10 VALUES ('A') ");
            conn.executeUpdate(sqlQuery.toString());
            sqlQuery = new StringBuffer().append(" SELECT MAX(RETCNT) FROM SQ_").append(comcode).append("_B10 ");
            GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
            while (rs.next()) {
                if (rs.getString("RETCNT").equals("1000000")) {
                    sqlQuery = new StringBuffer().append(" drop table SQ_").append(comcode).append("_B10 ");
                    conn.executeUpdate(sqlQuery.toString());
                    sqlQuery = new StringBuffer().append(" create  table SQ_").append(comcode).append("_B10 ( ").append("  RETCNT int IDENTITY(1,1) NOT NULL, ").append("   TMP char(1) not null ); ");
                    conn.executeUpdate(sqlQuery.toString());
                    strRet = strRegdate + "000001";
                } else {
                    strRet = GCmFcts.numToStr(rs.getString("RETCNT"), 6);
                    strRet = strRegdate + strRet;
                }
            }
        }
        return strRet;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDoDocTran::getMaxNoB10 " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public int insertCard(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String LIST = dmProp.getString("LIST");
    GEmTB_F10 tbf10 = (GEmTB_F10) dmProp.getObject("tbf10");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    java.util.Vector vList = new java.util.Vector();
    try {
        String cardNo = getMaxCardNo(COMCODE, cp.getProperty("eknoware.db.type"));
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_F10 (CARDNO, USERID, GRPNO, NAMEK, NAMEE, NAMEC,SEX, COMNAME, DEPTNAME,BIRTHDAY,ZIPCODE,ADDR,POSNAME, LUNARFLAG,TELHOME,TELOFFICE,TELWORK,MOBILE,PAGER,HOMEPAGE,TELFAX, ").append("         EMAIL, COMMENTS, EMAIL1, EMAIL2,  PUBFLAG, REGDATE ) ").append(" VALUES(" + genQuote(cardNo) + "," + genQuote(USERID) + "," + genQuote(tbf10.getStrGrpNo()) + "," + genQuote(tbf10.getStrNameK()) + "," + genQuote(tbf10.getStrNameE()) + "," + genQuote(tbf10.getStrNameC()) + ",").append("        " + genQuote(tbf10.getStrSex()) + "," + genQuote(tbf10.getStrComName()) + "," + genQuote(tbf10.getStrDeptName()) + "," + genQuote(tbf10.getStrBirthDay()) + "," + genQuote(tbf10.getStrZipCode()) + "," + genQuote(tbf10.getStrAddr()) + ",").append("        " + genQuote(tbf10.getStrPosName()) + "," + genQuote(tbf10.getStrLunarFlag()) + "," + genQuote(tbf10.getStrTelHome()) + "," + genQuote(tbf10.getStrTelOffice()) + "," + genQuote(tbf10.getStrTelWork()) + "," + genQuote(tbf10.getStrMobile()) + ",").append("        " + genQuote(tbf10.getStrPager()) + "," + genQuote(tbf10.getStrHomePage()) + "," + genQuote(tbf10.getStrTelFax()) + "," + genQuote(tbf10.getStrEmail()) + "," + genQuote(tbf10.getStrComments()) + "," + genQuote(tbf10.getStrEmail1()) + ",").append("        " + genQuote(tbf10.getStrEmail2()) + "," + genQuote(tbf10.getStrPubFlag()) + "," + genQuote(tbf10.getStrRegDate()) + " )");
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(sqlQuery.toString());
        try {
            vList = eknoware.commlib.util.GCmFcts.getSplit(LIST, ",");
            StringBuffer sqlQuery1 = null;
            if (tbf10.getStrPubFlag().equals("0")) {
                sqlQuery1 = new StringBuffer().append("insert into tb_" + COMCODE + "_f50 (CARDNO, USERID) ").append(" VALUES(" + genQuote(cardNo) + "," + genQuote(USERID) + ")");
                stmt = conn.createStatement();
                conn.setAutoCommit(false);
                rv = stmt.executeUpdate(sqlQuery1.toString());
            }
            for (int i = 0; i < vList.size(); i++) {
                String sList = (String) vList.elementAt(i);
                sqlQuery1 = new StringBuffer().append("insert into tb_" + COMCODE + "_f50 (CARDNO, USERID) ").append(" VALUES(" + genQuote(cardNo) + "," + genQuote(sList) + ")");
                stmt = conn.createStatement();
                conn.setAutoCommit(false);
                rv = stmt.executeUpdate(sqlQuery1.toString());
            }
        } catch (SQLException e) {
            GCmLog.writeLog("insertCard public list : " + e.getMessage());
        }
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoCaCardTran::insertCard : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoCaCardTran::insertCard : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoCaCardTran::insertCard : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int insertCopyCard(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    GEmTB_F10 tbf10 = (GEmTB_F10) dmProp.getObject("tbf10");
    String NameList = dmProp.getString("NameList");
    String CardList = dmProp.getString("CardList");
    int rv = 0;
    GCmConnection conn = null;
    Statement stmt = null;
    GCmResultSet rs = null;
    java.util.Vector vCardList = new java.util.Vector();
    java.util.Vector vNameList = new java.util.Vector();
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(true);
        stmt = conn.createStatement();
        vCardList = eknoware.commlib.util.GCmFcts.getSplit(CardList, ",");
        vNameList = eknoware.commlib.util.GCmFcts.getSplit(NameList, ",");
        StringBuffer sqlQuery = null;
        int count = 0;
        for (int i = 0; i < vCardList.size(); i++) {
            String sCardList = (String) vCardList.elementAt(i);
            sqlQuery = new StringBuffer().append("SELECT GRPNO, NAMEK, NAMEE, NAMEC, COMNAME, DEPTNAME, POSNAME, SEX, BIRTHDAY, LUNARFLAG, ZIPCODE, ADDR, MOBILE, PAGER, TELOFFICE, TELWORK, TELHOME, TELFAX, HOMEPAGE, EMAIL, EMAIL1, EMAIL2, COMMENTS, PUBFLAG, REGDATE ").append("FROM TB_" + COMCODE + "_F10 ").append("WHERE CARDNO =" + genQuote(sCardList));
            rs = conn.executeQuery(sqlQuery.toString());
            rs.next();
            tbf10.setStrGrpNo(rs.getString("GRPNO"));
            tbf10.setStrNameK(rs.getString("NAMEK"));
            tbf10.setStrNameE(rs.getString("NAMEE"));
            tbf10.setStrNameC(rs.getString("NAMEC"));
            tbf10.setStrComName(rs.getString("COMNAME"));
            tbf10.setStrDeptName(rs.getString("DEPTNAME"));
            tbf10.setStrPosName(rs.getString("POSNAME"));
            tbf10.setStrSex(rs.getString("SEX"));
            tbf10.setStrBirthDay(rs.getString("BIRTHDAY"));
            tbf10.setStrLunarFlag(rs.getString("LUNARFLAG"));
            tbf10.setStrZipCode(rs.getString("ZIPCODE"));
            tbf10.setStrAddr(rs.getString("ADDR"));
            tbf10.setStrMobile(rs.getString("MOBILE"));
            tbf10.setStrPager(rs.getString("PAGER"));
            tbf10.setStrTelOffice(rs.getString("TELOFFICE"));
            tbf10.setStrTelWork(rs.getString("TELWORK"));
            tbf10.setStrTelHome(rs.getString("TELHOME"));
            tbf10.setStrTelFax(rs.getString("TELFAX"));
            tbf10.setStrHomePage(rs.getString("HOMEPAGE"));
            tbf10.setStrEmail(rs.getString("EMAIL"));
            tbf10.setStrEmail1(rs.getString("EMAIL1"));
            tbf10.setStrEmail2(rs.getString("EMAIL2"));
            tbf10.setStrComments(rs.getString("COMMENTS"));
            tbf10.setStrPubFlag(rs.getString("PUBFLAG"));
            tbf10.setStrRegDate(rs.getString("REGDATE"));
            for (int k = 0; k < vNameList.size(); k++) {
                String cardNo = getMaxCardNo(COMCODE, cp.getProperty("eknoware.db.type"));
                String sNameList = (String) vNameList.elementAt(k);
                sqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_F10 (CARDNO, USERID, GRPNO, NAMEK, NAMEE, NAMEC, COMNAME, DEPTNAME, POSNAME, SEX, BIRTHDAY, LUNARFLAG, ZIPCODE, ADDR, MOBILE, PAGER, TELOFFICE, TELWORK, TELHOME, TELFAX, HOMEPAGE, ").append("         EMAIL, EMAIL1, EMAIL2, COMMENTS, PUBFLAG, REGDATE, COPIERID, COPYDATE ) ").append(" VALUES(" + genQuote(cardNo) + "," + genQuote(sNameList) + ",'000000000000'," + genQuote(tbf10.getStrNameK()) + "," + genQuote(tbf10.getStrNameE()) + "," + genQuote(tbf10.getStrNameC()) + ",").append("        " + genQuote(tbf10.getStrComName()) + "," + genQuote(tbf10.getStrDeptName()) + "," + genQuote(tbf10.getStrPosName()) + "," + genQuote(tbf10.getStrSex()) + "," + genQuote(tbf10.getStrBirthDay()) + "," + genQuote(tbf10.getStrLunarFlag()) + ",").append("        " + genQuote(tbf10.getStrZipCode()) + "," + genQuote(tbf10.getStrAddr()) + "," + genQuote(tbf10.getStrMobile()) + "," + genQuote(tbf10.getStrPager()) + "," + genQuote(tbf10.getStrTelOffice()) + "," + genQuote(tbf10.getStrTelWork()) + ",").append("        " + genQuote(tbf10.getStrTelHome()) + "," + genQuote(tbf10.getStrTelFax()) + "," + genQuote(tbf10.getStrHomePage()) + "," + genQuote(tbf10.getStrEmail()) + "," + genQuote(tbf10.getStrEmail1()) + "," + genQuote(tbf10.getStrEmail2()) + ",").append("        " + genQuote(tbf10.getStrComments()) + "," + genQuote(tbf10.getStrPubFlag()) + "," + genQuote(tbf10.getStrRegDate()) + "," + genQuote(USERID) + "," + genQuote(tbf10.getStrRegDate()) + " )");
                rv = stmt.executeUpdate(sqlQuery.toString());
                sqlQuery = new StringBuffer().append("select a.cardno, meetno, meetdate, comments ").append("from tb_" + COMCODE + "_f11 a, (select userid, cardno ").append("                      from tb_" + COMCODE + "_f10 ").append("                      where cardno = " + genQuote(sCardList)).append("                      and userid=" + genQuote(USERID) + ") b ").append("where a.userid = b.userid ").append("and a.cardno = b.cardno");
                rs = conn.executeQuery(sqlQuery.toString());
                while (rs.next()) {
                    String maxMeetNo = getMaxMeetNo(COMCODE, cp.getProperty("eknoware.db.type"));
                    sqlQuery = new StringBuffer().append("INSERT INTO TB_" + COMCODE + "_F11 (MEETNO, CARDNO, USERID, MEETDATE, COMMENTS) ").append("VALUES(" + genQuote(maxMeetNo) + "," + genQuote(cardNo) + "," + genQuote(sNameList) + ",").append("       " + genQuote(rs.getString("MEETDATE")) + "," + genQuote(rs.getString("COMMENTS")) + ")");
                    rv = stmt.executeUpdate(sqlQuery.toString());
                }
            }
        }
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoCaCardTran::insertCopyCard ::: " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoCaCardTran::insertCopyCard : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoCaCardTran::insertCopyCard : " + e.getMessage());
        }
        conn.close();
    }
}

######


public GCmResultSet getInfoStep(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDraftNo = dmProp.getString("DRFTNO");
    String strRefType = dmProp.getString("REFTYPE");
    String strApprId = dmProp.getString("APPRID");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT SEQ FROM TB_").append(strComCode).append("_K11 WHERE ").append(" DRFTNO = " + genQuote(strDraftNo)).append(" AND REFTYPE = " + genQuote(strRefType)).append(" AND APPRID = " + genQuote(strApprId));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GCoDfApproval :: getInfoStep" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getInfoBoxNo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strParentNo = dmProp.getString("PARENTNO");
    String strBoxClass = dmProp.getString("BOXCLASS");
    String strExecClass = dmProp.getString("EXECCLASS");
    String strBoxType = dmProp.getString("BOXTYPE");
    String strUserId = dmProp.getString("USERID");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT BOXNO FROM TB_").append(strComCode).append("_M10 WHERE ").append(" PARENTNO = " + genQuote(strParentNo)).append(" AND BOXCLASS = " + genQuote(strBoxClass)).append(" AND EXECCLASS = " + genQuote(strExecClass)).append(" AND BOXTYPE = " + genQuote(strBoxType)).append(" AND USERID = " + genQuote(strUserId));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GDfApproval :: getInfoBoxNo" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getLastId(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDraftNo = dmProp.getString("DRFTNO");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT APPRID FROM TB_").append(strComCode).append("_K11 WHERE ").append(" DRFTNO = " + genQuote(strDraftNo)).append(" AND SEQ = (SELECT MAX(SEQ) FROM TB_").append(strComCode).append("_K11 WHERE ").append(" DRFTNO = " + genQuote(strDraftNo)).append(" AND REFTYPE in ('1','4','6','7')) ");
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GCoDfApproval :: getLastId" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getApprovedLastId(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDraftNo = dmProp.getString("DRFTNO");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT APPRID FROM TB_").append(strComCode).append("_K11 WHERE ").append(" DRFTNO = " + genQuote(strDraftNo)).append(" AND SEQ = (SELECT MAX(SEQ) FROM TB_").append(strComCode).append("_K11 WHERE ").append(" DRFTNO = " + genQuote(strDraftNo)).append(" AND REFTYPE in ('1','4','6','7')").append(" AND APPRDATE > '0' ").append(" ) ");
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GCoDfApproval :: getApprovedeLastId" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getNextApprId(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String nextApprId = "";
    String strComCode = dmProp.getString("COMCODE");
    String strDraftNo = dmProp.getString("DRFTNO");
    String strSeq = dmProp.getString("SEQ");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append("SELECT A.APPRID,A.REFTYPE,(SELECT REPLACEAPPRID FROM TB_COMM_Z20 WHERE USERID=A.APPRID AND COMCODE=" + genQuote(strComCode) + ") REPLACEAPPRID FROM TB_").append(strComCode).append("_K11 A").append(" WHERE DRFTNO = " + genQuote(strDraftNo)).append("AND SEQ = (SELECT MIN(SEQ) FROM TB_").append(strComCode).append("_K11 ").append(" WHERE SEQ > " + genQuote(strSeq) + ")");
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GCoDfApproval :: getCountRead" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getCountRead(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDraftNo = dmProp.getString("DRFTNO");
    String strRegDraftNo = dmProp.getString("REGDRFTNO");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT COUNT(*) FROM TB_").append(strComCode).append("_K20 WHERE ").append(" DRFTNO = " + genQuote(strDraftNo)).append(" AND READFLAG = '0' ").append(" AND REGDRFTNO != " + genQuote(strRegDraftNo));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GCoDfApproval :: getCountRead" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getSubApprId(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDraftNo = dmProp.getString("DRFTNO");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT A.APPRID,A.APPRNAME,A.REFTYPE,B.USECHECK FROM TB_").append(strComCode).append("_K11 A, ").append(" TB_COMM_Z20 B").append(" WHERE DRFTNO = " + genQuote(strDraftNo) + " AND REFTYPE IN ( '3','6') ").append(" AND B.USERID = A.APPRID ").append(" AND B.USECHECK = 'Y'");
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GCoDfApproval :: getSubApprId" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public int DraftLineInfoToDb(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String Linenum = dmProp.getString("Linenum");
    String Linename = dmProp.getString("Linename");
    String Linenote = dmProp.getString("Linenote");
    String Mode = dmProp.getString("Mode");
    String Line = dmProp.getString("Line");
    String Line3 = dmProp.getString("Line3");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    int rv = 0;
    GCmConnection conn = null;
    Statement stmt = null;
    StringBuffer SqlQuery = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        stmt = conn.createStatement();
        if ("oracle".equals(strDbType)) {
            conn.setAutoCommit(false);
        }
        if (!Linenum.equals("")) {
            SqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(COMCODE).append("_D31 ").append(" WHERE LINENUM = " + genQuote(Linenum));
            rv = stmt.executeUpdate(SqlQuery.toString());
            SqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(COMCODE).append("_D30 ").append(" WHERE LINENUM = " + genQuote(Linenum) + " AND USERID = " + genQuote(USERID));
            rv = stmt.executeUpdate(SqlQuery.toString());
            if (rv <= 0)
                throw new Exception(" During DraftLineInfoToDb error !!!");
            conn.commit();
        }
        if (!Mode.equals("d")) {
            String newLinenum = getMaxNo(COMCODE, strDbType);
            SqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(COMCODE).append("_D30 ").append(" (LINENUM,USERID,LINENAME,LINENOTE) ").append("  VALUES (" + genQuote(newLinenum) + "," + genQuote(USERID) + "," + genQuote(Linename) + "," + genQuote(Linenote) + " )");
            rv = stmt.executeUpdate(SqlQuery.toString());
            if (rv <= 0)
                throw new Exception(" During DraftLineInfoToDb error !!!");
            java.util.Vector vLine2 = eknoware.commlib.util.GCmFcts.getSplit(Line, ",");
            int j = 1;
            for (int i = 0; i < vLine2.size(); i++) {
                java.util.Vector vTmp = eknoware.commlib.util.GCmFcts.getSplit((String) vLine2.elementAt(i), "#");
                SqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(COMCODE).append("_D31 (LINENUM,SEQ,SUBTYPE,SUBAPPRID,SUBAPPRNAME) ").append(" VALUES ( " + genQuote(newLinenum) + "," + genQuote(eknoware.commlib.util.GCmFcts.numToStr(j, 3)) + "," + genQuote(((String) vTmp.elementAt(0)).substring(0, 1)) + "," + genQuote(((String) vTmp.elementAt(0)).substring(1)) + "," + genQuote((String) vTmp.elementAt(1)) + " )");
                rv = stmt.executeUpdate(SqlQuery.toString());
                if (rv <= 0)
                    throw new Exception(" During DraftLineInfoToDb error !!!");
                j++;
            }
            vLine2 = eknoware.commlib.util.GCmFcts.getSplit(Line3, ",");
            for (int i = 0; i < vLine2.size(); i++) {
                java.util.Vector vTmp = eknoware.commlib.util.GCmFcts.getSplit((String) vLine2.elementAt(i), "#");
                SqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(COMCODE).append("_D31 (LINENUM,SEQ,SUBTYPE,SUBAPPRID,SUBAPPRNAME) ").append(" VALUES ( " + genQuote(newLinenum) + "," + genQuote(eknoware.commlib.util.GCmFcts.numToStr(j, 3)) + "," + genQuote(((String) vTmp.elementAt(0)).substring(0, 1)) + "," + genQuote(((String) vTmp.elementAt(0)).substring(1)) + "," + genQuote((String) vTmp.elementAt(1)) + " )");
                rv = stmt.executeUpdate(SqlQuery.toString());
                if (rv <= 0)
                    throw new Exception(" During DraftLineInfoToDb error !!!");
                j++;
            }
        }
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("  GCoDfDraftTran::DraftLineInfoToDb : " + ignored.getMessage());
        }
        GCmLog.writeLog("  GCoDfDraftTran::DraftLineInfoToDb : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog("  GCoDfDraftTran::DraftLineInfoToDb : " + e.getMessage());
        }
        conn.close();
    }
}

######


public boolean updateReadFlag(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strRegDrftNo = dmProp.getString("REGDRFTNO");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" UPDATE TB_").append(strComCode).append("_D20 ").append(" SET READFLAG = '0'").append(" WHERE REGDRFTNO = " + genQuote(strRegDrftNo));
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDfDraftTran :: updateReadFlag" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDfDraftTran :: updateReadFlag" + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public void deleteDraftLine(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strLineNo = dmProp.getString("LINENO");
    String strUserId = dmProp.getString("USERID");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" DELETE FROM  TB_").append(strComCode).append("_D30 ").append(" WHERE LINENO = " + genQuote(strLineNo)).append(" AND USERID = " + genQuote(strUserId));
        conn.executeUpdate(sqlQuery.toString());
        deleteDraftSubLine(conn, dmProp, msgInfo);
        conn.commit();
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDfDraftTran :: deleteDraftLine" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDfDraftTran :: deleteDraftLine " + e.getMessage());
    } finally {
        conn.close();
    }
}

######


public boolean deleteBox(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String pComCode = dmProp.getString("COMCODE");
    String pBox = dmProp.getString("PBOXNO");
    String pDraftNo = dmProp.getString("DRAFTNO");
    String pUserId = dmProp.getString("USERID");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" DELETE FROM  TB_").append(pComCode).append("_D20 ").append(" WHERE BOXNO = " + genQuote(pBox)).append(" AND DRFTNO = " + genQuote(pDraftNo) + " AND USERID=" + genQuote(pUserId));
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDfDraftTran :: deleteBox" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDfDraftTran :: deleteBox " + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public void deleteDraftSubLine(GCmConnection conn, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String strComCode = dmProp.getString("COMCODE");
    String strLineNo = dmProp.getString("LINENO");
    try {
        StringBuffer sqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(strComCode).append("_D31 ").append(" WHERE LINENO = ").append(genQuote(strLineNo));
        conn.executeUpdate(sqlQuery.toString());
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDfDraftTran :: delteDraftSubLine " + e.getMessage());
    }
}

######


public void insertDraftLine(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strUserId = dmProp.getString("USERID");
    String strLineName = dmProp.getString("LINENAME");
    String strLineNote = dmProp.getString("LINENOTE");
    String strRegDate = dmProp.getString("REGDATE");
    dmProp.setProperty("COMCODE", strComCode);
    dmProp.setProperty("REGDATE", strRegDate);
    eknoware.template.GTpDraft draft = new eknoware.template.GTpDraft();
    String strLineNo = draft.getMaxLineNo(cp, dmProp, msgInfo);
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_D30 ").append(" (LINENO,USERID,LINENAME,LINENOTE) ").append(" VALUES (").append(genQuote(strLineNo)).append(", ").append(genQuote(strUserId)).append(", ").append(genQuote(strLineName)).append(", ").append(genQuote(strLineNote));
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDfDraftTran :: insertDraftLine" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDfDraftTran :: insertDraftLine " + e.getMessage());
    } finally {
        conn.close();
    }
}

######


public void insertSubDraftLine(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strLineNo = dmProp.getString("LINENO");
    String strSeq = dmProp.getString("SEQ");
    String strSubType = dmProp.getString("SUBTYPE");
    String strSubApprId = dmProp.getString("SUBAPPRID");
    String strSubApprName = dmProp.getString("SUBAPPRNAME");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_D31 ").append(" (LINENO,SEQ,SUBTYPE,SUBAPPRID,SUBAPPRNAME) ").append(" VALUES (").append(genQuote(strLineNo)).append(", ").append(genQuote(strSeq)).append(", ").append(genQuote(strSubType)).append(", ").append(genQuote(strSubApprId)).append(", ").append(genQuote(strSubApprName));
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDfDraftTran :: insertSubDraftLine" + e.getMessage());
        }
        GCmLog.writeLog(" GCoDfDraftTran :: insertSubDraftLine" + e.getMessage());
    } finally {
        conn.close();
    }
}

######


public int insertDraft(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    int rv = 0;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        String strComCode = dmProp.getString("COMCODE");
        String strDocNo = dmProp.getString("DOCNO");
        String strApprType = dmProp.getString("APPRTYPE");
        String strTitle = dmProp.getString("TITLE");
        String strRegDate = dmProp.getString("REGDATE");
        String strDrftId = dmProp.getString("DRFTID");
        String strDrftName = dmProp.getString("DRFTNAME");
        String strDrftDept = dmProp.getString("DRFTDEPT");
        String strDrftPos = dmProp.getString("DRFTPOS");
        int intAttNum = Integer.parseInt(dmProp.getString("ATTNUM"));
        int intMaintTerm = Integer.parseInt(dmProp.getString("MAINTTERM"));
        String strMaintDate = dmProp.getString("MAINTDATE");
        int intKeepTerm = Integer.parseInt(dmProp.getString("KEEPTERM"));
        String strKeepDate = dmProp.getString("KEEPDATE");
        String strDrftType = dmProp.getString("DRFTTYPE");
        String strSecLvl = dmProp.getString("SECLVL");
        String strCreDate = dmProp.getString("CREDATE");
        String strSheetNo = dmProp.getString("SHEETNO");
        String strDOCSAVENO = dmProp.getString("DOCSAVENO");
        String strDOCSAVENAMEPATH = dmProp.getString("DOCSAVENAMEPATH");
        GTpDraft draft = new GTpDraft();
        String strDraftNo = draft.getMaxDrftNo(cp, dmProp, msgInfo);
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_D10 ").append(" (DRFTNO,DOCNO,APPRTYPE,TITLE,REGDATE,DRFTID,DRFTNAME,DRFTDEPT,DRFTPOS,ATTNUM, ").append(" MAINTTERM,MAINTDATE,KEEPTERM,KEEPDATE,DRFTTYPE,SECLVL,CREDATE,SHEETNO ");
        if (strDOCSAVENO != null && !strDOCSAVENO.equals("")) {
            sqlQuery.append(" ,DOCSAVENO ");
        }
        if (strDOCSAVENAMEPATH != null && !strDOCSAVENAMEPATH.equals("")) {
            sqlQuery.append(" ,DOCSAVENAMEPATH ");
        }
        sqlQuery.append(" ) ");
        sqlQuery.append(" VALUES (").append(genQuote(strDraftNo)).append(", ").append(genQuote(strDocNo)).append(", ").append(genQuote(strApprType)).append(", ").append(genQuote(strTitle)).append(", ").append(genQuote(strRegDate)).append(", ").append(genQuote(strDrftId)).append(", ").append(genQuote(strDrftName)).append(", ").append(genQuote(strDrftDept)).append(", ").append(genQuote(strDrftPos)).append(", ").append(intAttNum).append(", ").append(intMaintTerm).append(", ").append(genQuote(strMaintDate)).append(", ").append(intKeepTerm).append(", ").append(genQuote(strKeepDate)).append(", ").append(genQuote(strDrftType)).append(", ").append(genQuote(strSecLvl)).append(" , ").append(genQuote(strCreDate)).append(" , ").append(genQuote(strSheetNo));
        if (strDOCSAVENO != null && !strDOCSAVENO.equals("")) {
            sqlQuery.append(" , ").append(genQuote(strDOCSAVENO));
        }
        if (strDOCSAVENAMEPATH != null && !strDOCSAVENAMEPATH.equals("")) {
            sqlQuery.append(" , ").append(genQuote(strDOCSAVENAMEPATH));
        }
        sqlQuery.append(" ) ");
        stmt = conn.createStatement();
        rv = stmt.executeUpdate(sqlQuery.toString());
        conn.commit();
        dmProp.setProperty("DRAFTNO", strDraftNo);
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDfDraftTran :: insertDraft()" + e.getMessage());
        }
        GCmLog.writeLog(" GCoDfDraftTran :: insertDraft()" + e.getMessage());
        return -1;
    } finally {
        conn.close();
    }
}

######


public boolean insertAppr(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) throws GCmProcessingErrorException, GCmParameterErrorException {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDraftNo = dmProp.getString("DRAFTNO");
    String strSeq = dmProp.getString("SEQ");
    String strRefType = dmProp.getString("REFTYPE");
    String strApprId = dmProp.getString("APPRID");
    String strApprType = dmProp.getString("APPRTYPE");
    String strReadDate = dmProp.getString("READDATE");
    String strApprStatus = dmProp.getString("APPRSTATUS");
    try {
        GTpUserInfo userInfo = new GTpUserInfo();
        dmProp.setProperty("COMCODE", strComCode);
        dmProp.setProperty("USERID", strApprId);
        GCmResultSet rs = userInfo.getUserInfo(cp, dmProp, msgInfo);
        rs.next();
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_D11 ").append(" (DRFTNO,SEQ,REFTYPE,APPRID,APPRNAME,APPRDEPTCODE,APPRDEPTNAME,APPRPOSNAME,READFLAG,APPRTYPE,READDATE ) ").append(" VALUES (").append(genQuote(strDraftNo)).append(", ").append(genQuote(strSeq)).append(", ").append(genQuote(strRefType)).append(", ").append(genQuote(strApprId)).append(", ").append(genQuote(rs.getString("USERNAME"))).append(", ").append(genQuote(rs.getString("ORGNO"))).append(", ").append(genQuote(rs.getString("ORGNAME"))).append(", ").append(genQuote(rs.getString("POSNAME"))).append(", ").append(genQuote("1")).append(", ").append(genQuote(strApprType)).append(", ").append(genQuote(strReadDate)).append(" ) ");
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        if (strSeq.equals("001") && strApprStatus != null && !strApprStatus.equals("temp")) {
            dmProp.setProperty("DRFTNO", strDraftNo);
            GCoDfApprovalTran df = new GCoDfApprovalTran();
            df.replaceAppr(cp, dmProp, msgInfo);
        }
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDfDraftTran :: insertAppr" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDfDraftTran :: insertAppr" + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean insertRegDraft(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String strComCode = dmProp.getString("COMCODE");
    String strBoxNo = dmProp.getString("BOXNO");
    String strDraftNo = dmProp.getString("DRAFTNO");
    String strRefType = dmProp.getString("REFTYPE");
    String strUserId = dmProp.getString("USERID");
    GCmConnection conn = (GCmConnection) dmProp.getObject("CONN");
    try {
        if (conn == null) {
            conn = GCmDbManager.getInstance().getConnection();
        }
        conn.setAutoCommit(false);
        GTpDraft draft = new GTpDraft();
        GTpBoxs box = new GTpBoxs();
        String strRegDraftNo = draft.getMaxRegDrftNo(cp, dmProp, msgInfo);
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_D20 ").append(" (REGDRFTNO,BOXNO,DRFTNO,REFTYPE,READTYPE,TRASHFLAG,READFLAG,USERID) ").append(" VALUES (").append(genQuote(strRegDraftNo)).append(", ").append(genQuote(strBoxNo)).append(", ").append(genQuote(strDraftNo)).append(", ").append(genQuote(strRefType)).append(", ").append(genQuote("1")).append(", ").append(genQuote("1")).append(", ").append(genQuote("1")).append(", ").append(genQuote(strUserId) + ")");
        GCmLog.writeLog("GCoDfDraftTran.java :: insertRegDraft=" + sqlQuery.toString());
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDfDraftTran :: insertRegDraft " + e.getMessage());
        }
        GCmLog.writeLog(" GCoDfDraftTran ::  insertRegDraft" + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean insertRegDraftSub(GCmConnection conn, GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String strComCode = dmProp.getString("COMCODE");
    String strBoxNo = dmProp.getString("BOXNO");
    String strDraftNo = dmProp.getString("DRAFTNO");
    String strRefType = dmProp.getString("REFTYPE");
    try {
        GTpDraft draft = new GTpDraft();
        GTpBoxs box = new GTpBoxs();
        String strRegDraftNo = draft.getMaxRegDrftNo(cp, dmProp, msgInfo);
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_D20 ").append(" (REGDRFTNO,BOXNO,DRFTNO,REFTYPE,READTYPE,TRASHFLAG,READFLAG) ").append(" VALUES (").append(genQuote(strRegDraftNo)).append(", ").append(genQuote(strBoxNo)).append(", ").append(genQuote(strDraftNo)).append(", ").append(genQuote(strRefType)).append(", ").append(genQuote("1")).append(", ").append(genQuote("1")).append(", ").append(genQuote("1")).append(" ) ");
        GCmLog.writeLog(" GCoDfDraftTran :: insertRegDraftSub ::  " + sqlQuery.toString());
        conn.executeUpdate(sqlQuery.toString());
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDfDraftTran :: insertRegDraft " + e.getMessage());
        }
        GCmLog.writeLog(" GCoDfDraftTran ::  insertRegDraft" + e.getMessage());
        return false;
    } finally {
    }
}

######


public int reSaveDeleteCount(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDraftNo = dmProp.getString("DRAFTNO");
    String strPdocNo = dmProp.getString("PDOCNO");
    String strDocNo = dmProp.getString("DOCNO");
    String strTmpPath = dmProp.getString("TMPPATH");
    String strSeq = "";
    String strNewSeq = "";
    int intCount = 2;
    try {
        GTpDoc doc = new GTpDoc();
        dmProp.setProperty("Docno", strPdocNo);
        dmProp.setProperty("Seq", "01");
        GCmResultSet rs = doc.getDocDtlList(cp, dmProp, msgInfo);
        doc.deleteFileAll(cp, dmProp, msgInfo);
        while (rs.next()) {
            strNewSeq = GCmFcts.numToStr(intCount, 2);
            dmProp.setProperty("COMCODE", strComCode);
            dmProp.setProperty("DOCNO", strDocNo);
            dmProp.setProperty("SEQ", strNewSeq);
            dmProp.setProperty("CONTTYPE", rs.getString("CONTTYPE"));
            dmProp.setProperty("TITLE", rs.getString("TITLE"));
            dmProp.setProperty("FILEEXT", rs.getString("FILEEXT"));
            dmProp.setProperty("FILENAME", rs.getString("FILENAME"));
            dmProp.setProperty("VPATH", rs.getString("VPATH"));
            dmProp.setProperty("MIMETYPE", rs.getString("MIMETYPE"));
            dmProp.setProperty("FILESIZE", rs.getString("FILESIZE"));
            dmProp.setProperty("ORGNAME", rs.getString("ORGNAME"));
            dmProp.setProperty("ORGPATH", rs.getString("ORGPATH"));
            dmProp.setProperty("REGUSER", rs.getString("REGUSER"));
            dmProp.setProperty("REGDATE", rs.getString("REGDATE"));
            dmProp.setProperty("MODUSER", rs.getString("MODUSER"));
            dmProp.setProperty("MODDATE", rs.getString("MODDATE"));
            doc.insertAttDoc(cp, dmProp, msgInfo);
            intCount++;
        }
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        deleteRegDraftList(conn, strComCode, strDraftNo, msgInfo);
        deleteDraftManList(conn, strComCode, strDraftNo, msgInfo);
        deleteDraftList(conn, strComCode, strDraftNo, msgInfo);
        conn.commit();
        return intCount;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDfDraftTran :: reSaveDeleteCount" + e.getMessage());
        }
        GCmLog.writeLog(" GCoDfDraftTran :: reSaveDeleteCount" + e.getMessage());
        return -1;
    } finally {
        conn.close();
    }
}

######


public void deleteRegDraftList(GCmConnection conn, String comCode, String draftNo, GCmMsgInfo msgInfo) throws GCmProcessingErrorException, GCmParameterErrorException {
    try {
        if (conn == null) {
            throw new GCmParameterErrorException("deleteRegDraftList() connection object is null...");
        } else if ((draftNo == null) || (draftNo.equals(""))) {
            throw new GCmParameterErrorException("deleteRegDraftList() draftNo parameter error...");
        } else if ((comCode == null) || (comCode.equals(""))) {
            throw new GCmParameterErrorException("deleteRegDraftList() comCode parameter error...");
        }
        StringBuffer sqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(comCode).append("_D20 ").append(" WHERE DRFTNO = " + genQuote(draftNo));
        conn.executeUpdate(sqlQuery.toString());
    } catch (Exception e) {
        GCmLog.writeLog("GCoDfDraftTran :: deleteRegDraftList" + e.getMessage());
        throw new GCmProcessingErrorException("GCoDfDraftTran :: deleteRegDraftList " + e.getMessage());
    }
}

######


public void deleteDraftManList(GCmConnection conn, String comCode, String draftNo, GCmMsgInfo msgInfo) throws GCmProcessingErrorException, GCmParameterErrorException {
    try {
        if (conn == null) {
            throw new GCmParameterErrorException("deleteDraftManList() connection object is null...");
        } else if ((draftNo == null) || (draftNo.equals(""))) {
            throw new GCmParameterErrorException("deleteDraftManList() draftNo parameter error...");
        } else if ((comCode == null) || (comCode.equals(""))) {
            throw new GCmParameterErrorException("deleteDraftManList() comCode parameter error...");
        }
        StringBuffer sqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(comCode).append("_D11 ").append(" WHERE DRFTNO = " + genQuote(draftNo));
        conn.executeUpdate(sqlQuery.toString());
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDfDraftTran :: deleteDraftManList" + e.getMessage());
        throw new GCmProcessingErrorException("GCoDfDraftTran :: deleteDraftManList " + e.getMessage());
    }
}

######


public void deleteDraftList(GCmConnection conn, String comCode, String draftNo, GCmMsgInfo msgInfo) throws GCmProcessingErrorException, GCmParameterErrorException {
    try {
        if (conn == null) {
            throw new GCmParameterErrorException("deleteDraftList() connection object is null...");
        } else if ((draftNo == null) || (draftNo.equals(""))) {
            throw new GCmParameterErrorException("deleteDraftList() draftNo parameter error...");
        } else if ((comCode == null) || (comCode.equals(""))) {
            throw new GCmParameterErrorException("deleteDraftList() comCode parameter error...");
        }
        StringBuffer sqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(comCode).append("_D10 ").append(" WHERE DRFTNO = " + genQuote(draftNo));
        conn.executeUpdate(sqlQuery.toString());
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDfDraftTran :: delteDraftList" + e.getMessage());
        throw new GCmProcessingErrorException("GCoDfDraftTran :: deleteDraftList" + e.getMessage());
    }
}

######


public boolean draftConfirmOk(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDRAFTID = dmProp.getString("DRAFTID");
    String strBOXNO = dmProp.getString("BOXNO");
    String strDRAFTNO = dmProp.getString("ADRFTNO");
    String strREGDRFTNO = dmProp.getString("AREGDRFTNO");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" UPDATE  TB_").append(strComCode).append("_D20 ").append(" SET BOXNO = " + genQuote(GCmConstDef.DRAFT_ENDBOX)).append(" WHERE BOXNO = " + genQuote(strBOXNO)).append(" AND USERID = " + genQuote(strDRAFTID)).append(" AND DRFTNO = " + genQuote(strDRAFTNO)).append(" AND REGDRFTNO = " + genQuote(strREGDRFTNO));
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDfDraftTran :: draftFinish" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDfDraftTran :: draftFinisth" + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean draftFinish(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GTpUserInfo userInfo = new GTpUserInfo();
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDraftNo = dmProp.getString("DRAFTNO");
    String strDraftId = dmProp.getString("DRAFTID");
    String refType = dmProp.getString("REFTYPE");
    String apprId = dmProp.getString("APPRID");
    String userId = dmProp.getString("USERID");
    String apprStatus = dmProp.getString("APPRSTATUS");
    String strApprId = "";
    String strSubId = "";
    String strRefType = "";
    String strRet = "";
    String lastApprId = "";
    String apprType = "";
    String replaceId = "";
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        GCmLog.writeLog(" GCoDfDraftTran :: draftFinish :: refType= " + refType);
        GCmLog.writeLog(" GCoDfDraftTran :: draftFinish :: apprId= " + apprId);
        if (refType != null && refType.equals("5")) {
            if (userId != null && !userId.equals(apprId)) {
                strApprId = userId;
            } else {
                strApprId = apprId;
            }
            GCmLog.writeLog(" GCoDfDraftTran :: draftFinish :: 1  --> updateDraftFinish ");
            updateDraftFinish(conn, strComCode, strApprId, GCmConstDef.DRAFT_INBOX, strDraftNo, msgInfo);
        } else {
            StringBuffer sqlQuery = new StringBuffer().append(" SELECT APPRID,REFTYPE,APPRTYPE FROM TB_").append(strComCode).append("_D11 ").append(" WHERE DRFTNO = " + genQuote(strDraftNo) + " AND REFTYPE in ('1','2','4','5') ").append(" ORDER BY SEQ ASC ");
            GCmLog.writeLog("GCoDfDraftTran :: draftFinish" + sqlQuery.toString());
            GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
            while (rs.next()) {
                strApprId = rs.getString("APPRID");
                apprType = rs.getString("APPRTYPE");
                strRefType = rs.getString("REFTYPE");
                if (apprType.equals("4")) {
                    dmProp.setProperty("USERID", strApprId);
                    GCmResultSet rs1 = userInfo.getUserInfo(cp, dmProp, msgInfo);
                    rs1.next();
                    replaceId = rs1.getString("REPLACEAPPRID");
                    GCmLog.writeLog("GCoDfDraftTran :: draftFinish :: apprType= 4 :: 2 -> updateDraftFinish ");
                    updateDraftFinish(conn, strComCode, replaceId, GCmConstDef.DRAFT_SENDBOX, strDraftNo, msgInfo);
                }
                if (!rs.getString("REFTYPE").equals("5")) {
                    GCmLog.writeLog("GCoDfDraftTran :: draftFinish :: REFTYPE != 5  ");
                    lastApprId = strApprId;
                }
                if (strRefType.equals("2")) {
                    GCmLog.writeLog("GCoDfDraftTran :: draftFinish :: if(REFTYPE = 2) :: 3 -> updateDraftFinish ");
                    updateDraftFinish(conn, strComCode, strApprId, GCmConstDef.DRAFT_INBOX, strDraftNo, msgInfo);
                } else {
                    GCmLog.writeLog("GCoDfDraftTran :: draftFinish :: else (REFTYPE = 2) :: 4 -> updateDraftFinish ");
                    updateDraftFinish(conn, strComCode, strApprId, GCmConstDef.DRAFT_SENDBOX, strDraftNo, msgInfo);
                }
            }
            if (lastApprId.equals(apprId) && !apprId.equals(userId)) {
                GCmLog.writeLog("GCoDfDraftTran :: draftFinish :: 5 -> updateDraftFinish ");
                updateDraftFinish(conn, strComCode, userId, GCmConstDef.DRAFT_INBOX, strDraftNo, msgInfo);
            } else {
                GCmLog.writeLog("GCoDfDraftTran :: draftFinish :: 6 -> updateDraftFinish ");
                updateDraftFinish(conn, strComCode, lastApprId, GCmConstDef.DRAFT_INBOX, strDraftNo, msgInfo);
            }
            GCmLog.writeLog("GCoDfDraftTran :: draftFinish :: 7 -> updateDraftFinish ");
            updateDraftFinish(conn, strComCode, strDraftId, GCmConstDef.DRAFT_SENDBOX, strDraftNo, msgInfo);
            conn.commit();
            StringBuffer sqlQuery2 = new StringBuffer().append(" SELECT A.APPRID,A.APPRNAME,A.REFTYPE,B.USECHECK FROM TB_").append(strComCode).append("_D11 A, ").append(" TB_COMM_Z20 B").append(" WHERE DRFTNO = " + genQuote(strDraftNo) + " AND REFTYPE IN ( '3','6') ").append(" AND B.USERID = A.APPRID ").append(" AND B.USECHECK = 'Y'");
            GCmLog.writeLog("GCoDfDraftTran :: draftFinish :: " + sqlQuery2.toString());
            GCmResultSet rs2 = conn.executeQuery(sqlQuery2.toString());
            GCmResultSet rs3 = null;
            while (rs2.next()) {
                dmProp.setObject("CONN", conn);
                dmProp.setProperty("COMCODE", strComCode);
                dmProp.setProperty("BOXNO", GCmConstDef.DRAFT_INBOX);
                dmProp.setProperty("DRAFTNO", strDraftNo);
                dmProp.setProperty("USERID", rs2.getString("APPRID"));
                dmProp.setProperty("REFTYPE", rs2.getString("REFTYPE"));
                GCmLog.writeLog("GCoDfDraftTran :: draftFinish :: --> insertRegDraft ");
                insertRegDraft(cp, dmProp, msgInfo);
            }
        }
        GCmLog.writeLog("GCoDfDraftTran :: draftFinish ::  commit() ");
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDfDraftTran :: draftFinish" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDfDraftTran :: draftFinisth" + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public void updateDraftFinish(GCmConnection conn, String comCode, String apprId, String box, String draftNo, GCmMsgInfo msgInfo) throws GCmProcessingErrorException, GCmParameterErrorException {
    int intCount = 0;
    try {
        if (conn == null) {
            throw new GCmParameterErrorException("updateDraftFinish() connection object is null...");
        } else if ((comCode == null) || (comCode.equals(""))) {
            throw new GCmParameterErrorException("updateDraftFinish() comCode parameter error...");
        } else if ((apprId == null) || (apprId.equals(""))) {
            throw new GCmParameterErrorException("updateDraftFinish() apprId parameter error...");
        }
        StringBuffer sqlQuery = new StringBuffer().append(" UPDATE  TB_").append(comCode).append("_D20 ").append(" SET BOXNO = " + genQuote(GCmConstDef.DRAFT_ENDBOX)).append(" WHERE BOXNO = " + genQuote(box)).append(" AND USERID = " + genQuote(apprId)).append(" AND DRFTNO = " + genQuote(draftNo));
        GCmLog.writeLog(" GCoDfDraftTran :: updateDraftFinish" + sqlQuery.toString());
        conn.executeUpdate(sqlQuery.toString());
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDfDraftTran :: updateDraftFinish" + e.getMessage());
        throw new GCmProcessingErrorException("GCoDfDraftTran :: updateDraftFinish " + e.getMessage());
    }
}

######


public boolean setCopyFld(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDrftNo = dmProp.getString("DRFTNO");
    String strRegDrftNo = dmProp.getString("REGDRFTNO");
    String strBoxNo = dmProp.getString("BOXNO");
    String strFldBoxNo = dmProp.getString("FLDBOXNO");
    String strUserId = dmProp.getString("USERID");
    String strPpath = dmProp.getString("PPATH");
    String strDomain = dmProp.getString("DOMAIN");
    String strReadPage = dmProp.getString("READPAGE");
    String strHttpPort = dmProp.getString("HTTPPORT");
    String DraftIDSENDER = dmProp.getString("DraftIDSENDER");
    String strSecLvl = "";
    int intRet = 0;
    java.io.File srcFile = null;
    java.io.File desFile = null;
    String strDocNo = "";
    String strOldDocNo = "";
    String strTitle = "";
    java.util.Vector vDoc = new java.util.Vector();
    GCoDoDoc doc = new GCoDoDoc();
    GCoDoDocTran docTran = new GCoDoDocTran();
    GCoDoDocFolder docFolder = new GCoDoDocFolder();
    GCoDoDocFolderTran docFolderTran = new GCoDoDocFolderTran();
    GTpDraft draft = new GTpDraft();
    GCmResultSet rs = null;
    GCmResultSet rs1 = null;
    GCmResultSet rs2 = null;
    GCmResultSet rs3 = null;
    try {
        GCmLog.writeLog(" GCoDfDraftTran ::  setCopyFld() :: ���۾��� ����Ǿ� ���°�? ");
        String strRegDate = GCmDateFcts.dateToStr(new java.util.Date(), 2);
        rs = draft.getDraftInfo(cp, dmProp, msgInfo);
        rs.next();
        strOldDocNo = rs.getString("DOCNO");
        strTitle = rs.getString("TITLE");
        strSecLvl = rs.getString("SECLVL");
        if (strFldBoxNo.equals("1")) {
            strFldBoxNo = rs.getString("DOCSAVENO");
        }
        dmProp.setProperty("COMCODE", strComCode);
        dmProp.setProperty("DOCNO", strOldDocNo);
        rs2 = doc.getDocInfo(cp, dmProp, msgInfo);
        rs2.next();
        dmProp.setProperty("TITLE", rs2.getString("TITLE"));
        dmProp.setProperty("DOCTYPE", rs2.getString("DOCTYPE"));
        dmProp.setProperty("ATTNUM", rs2.getString("FILENUM"));
        dmProp.setProperty("REGUSER", rs2.getString("REGUSER"));
        dmProp.setProperty("MODDATE", rs2.getString("REGDATE"));
        dmProp.setProperty("TOTFILESIZE", rs2.getString("TOTFILESIZE"));
        dmProp.setProperty("REGDATE", strRegDate);
        dmProp.setProperty("CONTS", rs2.getString("MSTDOC"));
        dmProp.setProperty("MODUSER", strUserId);
        dmProp.setProperty("MODDATE", strRegDate);
        docTran.insertDoc(cp, dmProp, msgInfo);
        strDocNo = dmProp.getProperty("DOCNO");
        dmProp.setProperty("BOXNO", strFldBoxNo);
        dmProp.setProperty("DOCNO", strDocNo);
        dmProp.setProperty("REFNO", "D" + strRegDrftNo);
        dmProp.setProperty("USERID", DraftIDSENDER);
        docTran.insertDocFolder(cp, dmProp, msgInfo);
        String fldpath = "/DATA/" + strComCode + "/BOX/" + strRegDate.substring(0, 6) + "/" + strRegDate.substring(6, 8) + "/";
        java.io.File oFile = null;
        java.util.Vector vec = new java.util.Vector();
        String fld = "";
        String tmp = "";
        tmp = fldpath.substring(0, 1);
        if (tmp.equals("/"))
            fldpath = fldpath.substring(1, fldpath.length());
        vec = GCmFcts.getSplit(fldpath, "/");
        for (int i = 0; i < vec.size(); i++) {
            fld += (String) vec.elementAt(i) + "/";
            oFile = new java.io.File(strPpath + "/" + fld);
            if (!oFile.isDirectory())
                oFile.mkdir();
        }
        String seq = "";
        String conttype = "";
        String titleLst = "";
        String fileext = "";
        String oldfilename = "";
        String filename = "";
        String vpath = "";
        String mimetype = "";
        int filesize = 0;
        String orgname = "";
        String orgpath = "";
        String reguserLst = "";
        String regdateLst = "";
        String moduserLst = "";
        String moddateLst = "";
        String despath = fldpath;
        String conts = "";
        dmProp.setProperty("DOCNO", strOldDocNo);
        dmProp.setProperty("SEQ", "00");
        rs3 = doc.getDocDtlList(cp, dmProp, msgInfo);
        dmProp.setProperty("SEQ", "01");
        rs2 = doc.getDocInfo(cp, dmProp, msgInfo);
        rs2.next();
        conts = rs2.getString("MSTDOC");
        while (rs3.next()) {
            seq = rs3.getString("SEQ");
            conttype = rs3.getString("CONTTYPE");
            titleLst = rs3.getString("TITLE");
            fileext = rs3.getString("FILEEXT");
            oldfilename = rs3.getString("FILENAME");
            vpath = rs3.getString("VPATH");
            mimetype = rs3.getString("MIMETYPE");
            filesize = rs3.getInt("FILESIZE");
            orgname = rs3.getString("ORGNAME");
            orgpath = rs3.getString("ORGPATH");
            reguserLst = rs3.getString("REGUSER");
            regdateLst = rs3.getString("REGDATE");
            moduserLst = rs3.getString("MODUSER");
            moddateLst = rs3.getString("MODDATE");
            filename = strDocNo + "_" + seq + fileext;
            dmProp.setProperty("DOCNO", strDocNo);
            dmProp.setProperty("SEQ", seq);
            dmProp.setProperty("CONTTYPE", conttype);
            dmProp.setProperty("TITLE", titleLst);
            dmProp.setProperty("FILEEXT", fileext);
            dmProp.setProperty("FILENAME", filename);
            dmProp.setProperty("VPATH", fldpath);
            dmProp.setProperty("MIMETYPE", mimetype);
            dmProp.setProperty("FILESIZE", String.valueOf(filesize));
            dmProp.setProperty("ORGNAME", orgname);
            dmProp.setProperty("ORGPATH", orgpath);
            dmProp.setProperty("REGUSER", reguserLst);
            dmProp.setProperty("REGDATE", regdateLst);
            dmProp.setProperty("MODUSER", strUserId);
            dmProp.setProperty("MODDATE", strRegDate);
            docTran.insertAttDoc(cp, dmProp, msgInfo);
            srcFile = new java.io.File(strPpath + vpath, oldfilename);
            desFile = new java.io.File(strPpath + fldpath, filename);
            StringBuffer para = new StringBuffer();
            para.append("comcode=").append(strComCode).append("&userid=").append(strUserId).append("&boxno=").append(strBoxNo).append("&drftno=").append(strDrftNo).append("&regdrftno=").append(strRegDrftNo).append("&seclvl=").append(strSecLvl).append("&from=copyfld");
            GCmHtmlPageSaver html = new GCmHtmlPageSaver();
            String bonmun = html.getHtmlPage(strDomain, Integer.parseInt(strHttpPort), strReadPage, para.toString());
            dmProp.setProperty("CONTS", bonmun);
            dmProp.setProperty("DOCNO", strDocNo);
            docTran.updateContsDoc(cp, dmProp, msgInfo);
            if (Integer.parseInt(seq) > 01) {
                GCmFcts.copyFile(srcFile, desFile);
            }
        }
        return true;
    } catch (Exception e) {
        GCmLog.writeLog(" ���� ::  GCoDfDraftTran ::  setCopyFld() " + e.getMessage());
        return false;
    } finally {
        if (rs != null)
            try {
                rs.close();
            } catch (Exception e) {
            }
        if (rs1 != null)
            try {
                rs1.close();
            } catch (Exception e) {
            }
        if (rs2 != null)
            try {
                rs2.close();
            } catch (Exception e) {
            }
        if (rs3 != null)
            try {
                rs3.close();
            } catch (Exception e) {
            }
        GCmLog.writeLog(" GCoDfDraftTran ::  setCopyFld() :: ���� ���� �ִ°ǰ�?");
    }
}

######


public String setDraftTemp(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strBoxNo = dmProp.getString("BOXNO");
    String strDrftNo = dmProp.getString("DRFTNO");
    String strRegDrftNo = dmProp.getString("REGDRFTNO");
    String strFldBoxNo = dmProp.getString("FLDBOXNO");
    String strFldNo = dmProp.getString("FLDNO");
    String strUserId = dmProp.getString("USERID");
    String strDomain = dmProp.getString("DOMAIN");
    String strReadPage = dmProp.getString("READPAGE");
    String strHttpPort = dmProp.getString("HTTPPORT");
    String strSecLvl = dmProp.getString("SECLVL");
    String bonmun = null;
    try {
        StringBuffer para = new StringBuffer();
        para.append("comcode=").append(strComCode).append("&userid=").append(strUserId).append("&boxno=").append(strBoxNo).append("&drftno=").append(strDrftNo).append("&regdrftno=").append(strRegDrftNo).append("&seclvl=").append(strSecLvl).append("&from=copyfld");
        GCmHtmlPageSaver html = new GCmHtmlPageSaver();
        bonmun = html.getHtmlPage(strDomain, Integer.parseInt(strHttpPort), strReadPage, para.toString());
        return bonmun;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDfDraftTran ::  setDraftTemp() " + e.getMessage());
        return bonmun;
    } finally {
    }
}

######


public GCmResultSet getInfoStep(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDocsNo = dmProp.getString("DRFTNO");
    String strRefType = dmProp.getString("REFTYPE");
    String strApprId = dmProp.getString("APPRID");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT SEQ FROM TB_").append(strComCode).append("_D11 WHERE ").append(" DRFTNO = " + genQuote(strDocsNo)).append(" AND REFTYPE = " + genQuote(strRefType)).append(" AND APPRID = " + genQuote(strApprId));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GCODoApproval :: getInfoStep" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getInfoBoxNo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strParentNo = dmProp.getString("PARENTNO");
    String strBoxClass = dmProp.getString("BOXCLASS");
    String strExecClass = dmProp.getString("EXECCLASS");
    String strBoxType = dmProp.getString("BOXTYPE");
    String strUserId = dmProp.getString("USERID");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT BOXNO FROM TB_").append(strComCode).append("_M10 WHERE ").append(" PARENTNO = " + genQuote(strParentNo)).append(" AND BOXCLASS = " + genQuote(strBoxClass)).append(" AND EXECCLASS = " + genQuote(strExecClass)).append(" AND BOXTYPE = " + genQuote(strBoxType)).append(" AND USERID = " + genQuote(strUserId));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GDfApproval :: getInfoBoxNo" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getLastId(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDocsNo = dmProp.getString("DRFTNO");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT APPRID FROM TB_").append(strComCode).append("_D11 WHERE ").append(" DRFTNO = " + genQuote(strDocsNo)).append(" AND SEQ = (SELECT MAX(SEQ) FROM TB_").append(strComCode).append("_D11 WHERE ").append(" DRFTNO = " + genQuote(strDocsNo)).append(" AND REFTYPE in ('1','4','6','7')) ");
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GCODoApproval :: getLastId" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getApprovedLastId(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDocsNo = dmProp.getString("DRFTNO");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT APPRID FROM TB_").append(strComCode).append("_D11 WHERE ").append(" DRFTNO = " + genQuote(strDocsNo)).append(" AND SEQ = (SELECT MAX(SEQ) FROM TB_").append(strComCode).append("_D11 WHERE ").append(" DRFTNO = " + genQuote(strDocsNo)).append(" AND REFTYPE in ('1','4','6','7')").append(" AND APPRDATE > '0' ").append(" ) ");
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GCODoApproval :: getApprovedeLastId" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getNextApprId(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String nextApprId = "";
    String strComCode = dmProp.getString("COMCODE");
    String strDocsNo = dmProp.getString("DRFTNO");
    String strSeq = dmProp.getString("SEQ");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append("SELECT A.APPRID,A.REFTYPE,(SELECT REPLACEAPPRID FROM TB_COMM_Z20 WHERE USERID=A.APPRID AND COMCODE=" + genQuote(strComCode) + ") REPLACEAPPRID FROM TB_").append(strComCode).append("_D11 A").append(" WHERE DRFTNO = " + genQuote(strDocsNo)).append("AND SEQ = (SELECT MIN(SEQ) FROM TB_").append(strComCode).append("_D11 ").append(" WHERE SEQ > " + genQuote(strSeq) + ")");
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GCODoApproval :: getCountRead" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getCountRead(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDocsNo = dmProp.getString("DRFTNO");
    String strRegDocsNo = dmProp.getString("REGDRFTNO");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT COUNT(*) FROM TB_").append(strComCode).append("_D20 WHERE ").append(" DRFTNO = " + genQuote(strDocsNo)).append(" AND READFLAG = '0' ").append(" AND REGDRFTNO != " + genQuote(strRegDocsNo));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GCODoApproval :: getCountRead" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getSubApprId(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDocsNo = dmProp.getString("DRFTNO");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT A.APPRID,A.APPRNAME,A.REFTYPE,B.USECHECK FROM TB_").append(strComCode).append("_D11 A, ").append(" TB_COMM_Z20 B").append(" WHERE DRFTNO = " + genQuote(strDocsNo) + " AND REFTYPE IN ( '3','6') ").append(" AND B.USERID = A.APPRID ").append(" AND B.USECHECK = 'Y'");
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog("GCODoApproval :: getSubApprId" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public int DocsLineInfoToDb(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String Linenum = dmProp.getString("Linenum");
    String Linename = dmProp.getString("Linename");
    String Linenote = dmProp.getString("Linenote");
    String Mode = dmProp.getString("Mode");
    String Line = dmProp.getString("Line");
    String Line3 = dmProp.getString("Line3");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    int rv = 0;
    GCmConnection conn = null;
    Statement stmt = null;
    StringBuffer SqlQuery = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        stmt = conn.createStatement();
        if ("oracle".equals(strDbType)) {
            conn.setAutoCommit(false);
        }
        if (!Linenum.equals("")) {
            SqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(COMCODE).append("_D31 ").append(" WHERE LINENUM = " + genQuote(Linenum));
            rv = stmt.executeUpdate(SqlQuery.toString());
            SqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(COMCODE).append("_D30 ").append(" WHERE LINENUM = " + genQuote(Linenum) + " AND USERID = " + genQuote(USERID));
            rv = stmt.executeUpdate(SqlQuery.toString());
            if (rv <= 0)
                throw new Exception(" During DocsLineInfoToDb error !!!");
            conn.commit();
        }
        if (!Mode.equals("d")) {
            String newLinenum = getMaxNo(COMCODE, strDbType);
            SqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(COMCODE).append("_D30 ").append(" (LINENUM,USERID,LINENAME,LINENOTE) ").append("  VALUES (" + genQuote(newLinenum) + "," + genQuote(USERID) + "," + genQuote(Linename) + "," + genQuote(Linenote) + " )");
            rv = stmt.executeUpdate(SqlQuery.toString());
            if (rv <= 0)
                throw new Exception(" During DocsLineInfoToDb error !!!");
            java.util.Vector vLine2 = eknoware.commlib.util.GCmFcts.getSplit(Line, ",");
            int j = 1;
            for (int i = 0; i < vLine2.size(); i++) {
                java.util.Vector vTmp = eknoware.commlib.util.GCmFcts.getSplit((String) vLine2.elementAt(i), "#");
                SqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(COMCODE).append("_D31 (LINENUM,SEQ,SUBTYPE,SUBAPPRID,SUBAPPRNAME) ").append(" VALUES ( " + genQuote(newLinenum) + "," + genQuote(eknoware.commlib.util.GCmFcts.numToStr(j, 3)) + "," + genQuote(((String) vTmp.elementAt(0)).substring(0, 1)) + "," + genQuote(((String) vTmp.elementAt(0)).substring(1)) + "," + genQuote((String) vTmp.elementAt(1)) + " )");
                rv = stmt.executeUpdate(SqlQuery.toString());
                if (rv <= 0)
                    throw new Exception(" During DocsLineInfoToDb error !!!");
                j++;
            }
            vLine2 = eknoware.commlib.util.GCmFcts.getSplit(Line3, ",");
            for (int i = 0; i < vLine2.size(); i++) {
                java.util.Vector vTmp = eknoware.commlib.util.GCmFcts.getSplit((String) vLine2.elementAt(i), "#");
                SqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(COMCODE).append("_D31 (LINENUM,SEQ,SUBTYPE,SUBAPPRID,SUBAPPRNAME) ").append(" VALUES ( " + genQuote(newLinenum) + "," + genQuote(eknoware.commlib.util.GCmFcts.numToStr(j, 3)) + "," + genQuote(((String) vTmp.elementAt(0)).substring(0, 1)) + "," + genQuote(((String) vTmp.elementAt(0)).substring(1)) + "," + genQuote((String) vTmp.elementAt(1)) + " )");
                rv = stmt.executeUpdate(SqlQuery.toString());
                if (rv <= 0)
                    throw new Exception(" During DocsLineInfoToDb error !!!");
                j++;
            }
        }
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("  GCoDoDocsTran::DocsLineInfoToDb : " + ignored.getMessage());
        }
        GCmLog.writeLog("  GCoDoDocsTran::DocsLineInfoToDb : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog("  GCoDoDocsTran::DocsLineInfoToDb : " + e.getMessage());
        }
        conn.close();
    }
}

######


public boolean updateReadFlag(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strRegDrftNo = dmProp.getString("REGDRFTNO");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" UPDATE TB_").append(strComCode).append("_D20 ").append(" SET READFLAG = '0'").append(" WHERE REGDRFTNO = " + genQuote(strRegDrftNo));
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDoDocsTran :: updateReadFlag" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDoDocsTran :: updateReadFlag" + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public void deleteDocsLine(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strLineNo = dmProp.getString("LINENO");
    String strUserId = dmProp.getString("USERID");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" DELETE FROM  TB_").append(strComCode).append("_D30 ").append(" WHERE LINENO = " + genQuote(strLineNo)).append(" AND USERID = " + genQuote(strUserId));
        conn.executeUpdate(sqlQuery.toString());
        deleteDocsSubLine(conn, dmProp, msgInfo);
        conn.commit();
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDoDocsTran :: deleteDocsLine" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDoDocsTran :: deleteDocsLine " + e.getMessage());
    } finally {
        conn.close();
    }
}

######


public boolean deleteBox(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String pComCode = dmProp.getString("COMCODE");
    String pBox = dmProp.getString("PBOXNO");
    String pDocsNo = dmProp.getString("DocsNO");
    String pUserId = dmProp.getString("USERID");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" DELETE FROM  TB_").append(pComCode).append("_D20 ").append(" WHERE BOXNO = " + genQuote(pBox)).append(" AND DRFTNO = " + genQuote(pDocsNo) + " AND USERID=" + genQuote(pUserId));
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDoDocsTran :: deleteBox" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDoDocsTran :: deleteBox " + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public void deleteDocsSubLine(GCmConnection conn, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String strComCode = dmProp.getString("COMCODE");
    String strLineNo = dmProp.getString("LINENO");
    try {
        StringBuffer sqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(strComCode).append("_D31 ").append(" WHERE LINENO = ").append(genQuote(strLineNo));
        conn.executeUpdate(sqlQuery.toString());
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDoDocsTran :: delteDocsSubLine " + e.getMessage());
    }
}

######


public void insertDocsLine(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strUserId = dmProp.getString("USERID");
    String strLineName = dmProp.getString("LINENAME");
    String strLineNote = dmProp.getString("LINENOTE");
    String strRegDate = dmProp.getString("REGDATE");
    dmProp.setProperty("COMCODE", strComCode);
    dmProp.setProperty("REGDATE", strRegDate);
    eknoware.template.GTpDocs docs = new eknoware.template.GTpDocs();
    String strLineNo = docs.getMaxLineNo(cp, dmProp, msgInfo);
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_D30 ").append(" (LINENO,USERID,LINENAME,LINENOTE) ").append(" VALUES (").append(genQuote(strLineNo)).append(", ").append(genQuote(strUserId)).append(", ").append(genQuote(strLineName)).append(", ").append(genQuote(strLineNote));
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDoDocsTran :: insertDocsLine" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDoDocsTran :: insertDocsLine " + e.getMessage());
    } finally {
        conn.close();
    }
}

######


public void insertSubDocsLine(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strLineNo = dmProp.getString("LINENO");
    String strSeq = dmProp.getString("SEQ");
    String strSubType = dmProp.getString("SUBTYPE");
    String strSubApprId = dmProp.getString("SUBAPPRID");
    String strSubApprName = dmProp.getString("SUBAPPRNAME");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_D31 ").append(" (LINENO,SEQ,SUBTYPE,SUBAPPRID,SUBAPPRNAME) ").append(" VALUES (").append(genQuote(strLineNo)).append(", ").append(genQuote(strSeq)).append(", ").append(genQuote(strSubType)).append(", ").append(genQuote(strSubApprId)).append(", ").append(genQuote(strSubApprName));
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDoDocsTran :: insertSubDocsLine" + e.getMessage());
        }
        GCmLog.writeLog(" GCoDoDocsTran :: insertSubDocsLine" + e.getMessage());
    } finally {
        conn.close();
    }
}

######


public int insertDocs(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    int rv = 0;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        String strComCode = dmProp.getString("COMCODE");
        String strDocNo = dmProp.getString("DOCNO");
        String strApprType = dmProp.getString("APPRTYPE");
        String strTitle = dmProp.getString("TITLE");
        String strRegDate = dmProp.getString("REGDATE");
        String strDrftId = dmProp.getString("DRFTID");
        String strDrftName = dmProp.getString("DRFTNAME");
        String strDrftDept = dmProp.getString("DRFTDEPT");
        String strDrftPos = dmProp.getString("DRFTPOS");
        int intAttNum = Integer.parseInt(dmProp.getString("ATTNUM"));
        int intMaintTerm = Integer.parseInt(dmProp.getString("MAINTTERM"));
        String strMaintDate = dmProp.getString("MAINTDATE");
        int intKeepTerm = Integer.parseInt(dmProp.getString("KEEPTERM"));
        String strKeepDate = dmProp.getString("KEEPDATE");
        String strDrftType = dmProp.getString("DRFTTYPE");
        String strSecLvl = dmProp.getString("SECLVL");
        String strCreDate = dmProp.getString("CREDATE");
        String strSheetNo = dmProp.getString("SHEETNO");
        String strDOCSAVENO = dmProp.getString("DOCSAVENO");
        GTpDocs Docs = new GTpDocs();
        String strDocsNo = Docs.getMaxDrftNo(cp, dmProp, msgInfo);
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_D10 ").append(" (DRFTNO,DOCNO,APPRTYPE,TITLE,REGDATE,DRFTID,DRFTNAME,DRFTDEPT,DRFTPOS,ATTNUM, ").append(" MAINTTERM,MAINTDATE,KEEPTERM,KEEPDATE,DRFTTYPE,SECLVL,CREDATE,SHEETNO,DOCSAVENO) ").append(" VALUES (").append(genQuote(strDocsNo)).append(", ").append(genQuote(strDocNo)).append(", ").append(genQuote(strApprType)).append(", ").append(genQuote(strTitle)).append(", ").append(genQuote(strRegDate)).append(", ").append(genQuote(strDrftId)).append(", ").append(genQuote(strDrftName)).append(", ").append(genQuote(strDrftDept)).append(", ").append(genQuote(strDrftPos)).append(", ").append(intAttNum).append(", ").append(intMaintTerm).append(", ").append(genQuote(strMaintDate)).append(", ").append(intKeepTerm).append(", ").append(genQuote(strKeepDate)).append(", ").append(genQuote(strDrftType)).append(", ").append(genQuote(strSecLvl)).append(" , ").append(genQuote(strCreDate)).append(" , ").append(genQuote(strSheetNo)).append(" , ").append(genQuote(strDOCSAVENO)).append(" ) ");
        stmt = conn.createStatement();
        rv = stmt.executeUpdate(sqlQuery.toString());
        conn.commit();
        dmProp.setProperty("DocsNO", strDocsNo);
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDoDocsTran :: insertDocs()" + e.getMessage());
        }
        GCmLog.writeLog(" GCoDoDocsTran :: insertDocs()" + e.getMessage());
        return -1;
    } finally {
        conn.close();
    }
}

######


public boolean insertAppr(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) throws GCmProcessingErrorException, GCmParameterErrorException {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDocsNo = dmProp.getString("DocsNO");
    String strSeq = dmProp.getString("SEQ");
    String strRefType = dmProp.getString("REFTYPE");
    String strApprId = dmProp.getString("APPRID");
    String strApprType = dmProp.getString("APPRTYPE");
    String strReadDate = dmProp.getString("READDATE");
    String strApprStatus = dmProp.getString("APPRSTATUS");
    try {
        GTpUserInfo userInfo = new GTpUserInfo();
        dmProp.setProperty("COMCODE", strComCode);
        dmProp.setProperty("USERID", strApprId);
        GCmResultSet rs = userInfo.getUserInfo(cp, dmProp, msgInfo);
        rs.next();
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_D11 ").append(" (DRFTNO,SEQ,REFTYPE,APPRID,APPRNAME,APPRDEPTCODE,APPRDEPTNAME,APPRPOSNAME,READFLAG,APPRTYPE,READDATE ) ").append(" VALUES (").append(genQuote(strDocsNo)).append(", ").append(genQuote(strSeq)).append(", ").append(genQuote(strRefType)).append(", ").append(genQuote(strApprId)).append(", ").append(genQuote(rs.getString("USERNAME"))).append(", ").append(genQuote(rs.getString("ORGNO"))).append(", ").append(genQuote(rs.getString("ORGNAME"))).append(", ").append(genQuote(rs.getString("POSNAME"))).append(", ").append(genQuote("1")).append(", ").append(genQuote(strApprType)).append(", ").append(genQuote(strReadDate)).append(" ) ");
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        if (strSeq.equals("001") && strApprStatus != null && !strApprStatus.equals("temp")) {
            dmProp.setProperty("DRFTNO", strDocsNo);
            GCoDoApprovalTran df = new GCoDoApprovalTran();
            df.replaceAppr(cp, dmProp, msgInfo);
        }
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDoDocsTran :: insertAppr" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDoDocsTran :: insertAppr" + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean insertRegDocs(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String strComCode = dmProp.getString("COMCODE");
    String strBoxNo = dmProp.getString("BOXNO");
    String strDocsNo = dmProp.getString("DocsNO");
    String strRefType = dmProp.getString("REFTYPE");
    String strUserId = dmProp.getString("USERID");
    GCmConnection conn = (GCmConnection) dmProp.getObject("CONN");
    try {
        if (conn == null) {
            conn = GCmDbManager.getInstance().getConnection();
        }
        conn.setAutoCommit(false);
        GTpDocs Docs = new GTpDocs();
        GTpBoxs box = new GTpBoxs();
        String strRegDocsNo = Docs.getMaxRegDrftNo(cp, dmProp, msgInfo);
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_D20 ").append(" (REGDRFTNO,BOXNO,DRFTNO,REFTYPE,READTYPE,TRASHFLAG,READFLAG,USERID) ").append(" VALUES (").append(genQuote(strRegDocsNo)).append(", ").append(genQuote(strBoxNo)).append(", ").append(genQuote(strDocsNo)).append(", ").append(genQuote(strRefType)).append(", ").append(genQuote("1")).append(", ").append(genQuote("1")).append(", ").append(genQuote("1")).append(", ").append(genQuote(strUserId) + ")");
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDoDocsTran :: insertRegDocs " + e.getMessage());
        }
        GCmLog.writeLog(" GCoDoDocsTran ::  insertRegDocs" + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean insertRegDocsSub(GCmConnection conn, GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String strComCode = dmProp.getString("COMCODE");
    String strBoxNo = dmProp.getString("BOXNO");
    String strDocsNo = dmProp.getString("DocsNO");
    String strRefType = dmProp.getString("REFTYPE");
    try {
        GTpDocs Docs = new GTpDocs();
        GTpBoxs box = new GTpBoxs();
        String strRegDocsNo = Docs.getMaxRegDrftNo(cp, dmProp, msgInfo);
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_D20 ").append(" (REGDRFTNO,BOXNO,DRFTNO,REFTYPE,READTYPE,TRASHFLAG,READFLAG) ").append(" VALUES (").append(genQuote(strRegDocsNo)).append(", ").append(genQuote(strBoxNo)).append(", ").append(genQuote(strDocsNo)).append(", ").append(genQuote(strRefType)).append(", ").append(genQuote("1")).append(", ").append(genQuote("1")).append(", ").append(genQuote("1")).append(" ) ");
        conn.executeUpdate(sqlQuery.toString());
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDoDocsTran :: insertRegDocs " + e.getMessage());
        }
        GCmLog.writeLog(" GCoDoDocsTran ::  insertRegDocs" + e.getMessage());
        return false;
    } finally {
    }
}

######


public int reSaveDeleteCount(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDocsNo = dmProp.getString("DocsNO");
    String strPdocNo = dmProp.getString("PDOCNO");
    String strDocNo = dmProp.getString("DOCNO");
    String strTmpPath = dmProp.getString("TMPPATH");
    String strSeq = "";
    String strNewSeq = "";
    int intCount = 2;
    try {
        GTpDoc doc = new GTpDoc();
        dmProp.setProperty("Docno", strPdocNo);
        dmProp.setProperty("Seq", "01");
        GCmResultSet rs = doc.getDocDtlList(cp, dmProp, msgInfo);
        doc.deleteFileAll(cp, dmProp, msgInfo);
        while (rs.next()) {
            strNewSeq = GCmFcts.numToStr(intCount, 2);
            dmProp.setProperty("COMCODE", strComCode);
            dmProp.setProperty("DOCNO", strDocNo);
            dmProp.setProperty("SEQ", strNewSeq);
            dmProp.setProperty("CONTTYPE", rs.getString("CONTTYPE"));
            dmProp.setProperty("TITLE", rs.getString("TITLE"));
            dmProp.setProperty("FILEEXT", rs.getString("FILEEXT"));
            dmProp.setProperty("FILENAME", rs.getString("FILENAME"));
            dmProp.setProperty("VPATH", rs.getString("VPATH"));
            dmProp.setProperty("MIMETYPE", rs.getString("MIMETYPE"));
            dmProp.setProperty("FILESIZE", rs.getString("FILESIZE"));
            dmProp.setProperty("ORGNAME", rs.getString("ORGNAME"));
            dmProp.setProperty("ORGPATH", rs.getString("ORGPATH"));
            dmProp.setProperty("REGUSER", rs.getString("REGUSER"));
            dmProp.setProperty("REGDATE", rs.getString("REGDATE"));
            dmProp.setProperty("MODUSER", rs.getString("MODUSER"));
            dmProp.setProperty("MODDATE", rs.getString("MODDATE"));
            doc.insertAttDoc(cp, dmProp, msgInfo);
            intCount++;
        }
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        deleteRegDocsList(conn, strComCode, strDocsNo, msgInfo);
        deleteDocsManList(conn, strComCode, strDocsNo, msgInfo);
        deleteDocsList(conn, strComCode, strDocsNo, msgInfo);
        conn.commit();
        return intCount;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDoDocsTran :: reSaveDeleteCount" + e.getMessage());
        }
        GCmLog.writeLog(" GCoDoDocsTran :: reSaveDeleteCount" + e.getMessage());
        return -1;
    } finally {
        conn.close();
    }
}

######


public void deleteRegDocsList(GCmConnection conn, String comCode, String DocsNo, GCmMsgInfo msgInfo) throws GCmProcessingErrorException, GCmParameterErrorException {
    try {
        if (conn == null) {
            throw new GCmParameterErrorException("deleteRegDocsList() connection object is null...");
        } else if ((DocsNo == null) || (DocsNo.equals(""))) {
            throw new GCmParameterErrorException("deleteRegDocsList() DocsNo parameter error...");
        } else if ((comCode == null) || (comCode.equals(""))) {
            throw new GCmParameterErrorException("deleteRegDocsList() comCode parameter error...");
        }
        StringBuffer sqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(comCode).append("_D20 ").append(" WHERE DRFTNO = " + genQuote(DocsNo));
        conn.executeUpdate(sqlQuery.toString());
    } catch (Exception e) {
        GCmLog.writeLog("GCoDoDocsTran :: deleteRegDocsList" + e.getMessage());
        throw new GCmProcessingErrorException("GCoDoDocsTran :: deleteRegDocsList " + e.getMessage());
    }
}

######


public void deleteDocsManList(GCmConnection conn, String comCode, String DocsNo, GCmMsgInfo msgInfo) throws GCmProcessingErrorException, GCmParameterErrorException {
    try {
        if (conn == null) {
            throw new GCmParameterErrorException("deleteDocsManList() connection object is null...");
        } else if ((DocsNo == null) || (DocsNo.equals(""))) {
            throw new GCmParameterErrorException("deleteDocsManList() DocsNo parameter error...");
        } else if ((comCode == null) || (comCode.equals(""))) {
            throw new GCmParameterErrorException("deleteDocsManList() comCode parameter error...");
        }
        StringBuffer sqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(comCode).append("_D11 ").append(" WHERE DRFTNO = " + genQuote(DocsNo));
        conn.executeUpdate(sqlQuery.toString());
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDoDocsTran :: deleteDocsManList" + e.getMessage());
        throw new GCmProcessingErrorException("GCoDoDocsTran :: deleteDocsManList " + e.getMessage());
    }
}

######


public void deleteDocsList(GCmConnection conn, String comCode, String DocsNo, GCmMsgInfo msgInfo) throws GCmProcessingErrorException, GCmParameterErrorException {
    try {
        if (conn == null) {
            throw new GCmParameterErrorException("deleteDocsList() connection object is null...");
        } else if ((DocsNo == null) || (DocsNo.equals(""))) {
            throw new GCmParameterErrorException("deleteDocsList() DocsNo parameter error...");
        } else if ((comCode == null) || (comCode.equals(""))) {
            throw new GCmParameterErrorException("deleteDocsList() comCode parameter error...");
        }
        StringBuffer sqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(comCode).append("_D10 ").append(" WHERE DRFTNO = " + genQuote(DocsNo));
        conn.executeUpdate(sqlQuery.toString());
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDoDocsTran :: delteDocsList" + e.getMessage());
        throw new GCmProcessingErrorException("GCoDoDocsTran :: deleteDocsList" + e.getMessage());
    }
}

######


public boolean DocsConfirmOk(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDocsID = dmProp.getString("DocsID");
    String strBOXNO = dmProp.getString("BOXNO");
    String strDocsNO = dmProp.getString("ADRFTNO");
    String strREGDRFTNO = dmProp.getString("AREGDRFTNO");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append(" UPDATE  TB_").append(strComCode).append("_D20 ").append(" SET BOXNO = " + genQuote(GCmConstDef.DOCS_ENDBOX)).append(" WHERE BOXNO = " + genQuote(strBOXNO)).append(" AND USERID = " + genQuote(strDocsID)).append(" AND DRFTNO = " + genQuote(strDocsNO)).append(" AND REGDRFTNO = " + genQuote(strREGDRFTNO));
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDoDocsTran :: DocsFinish" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDoDocsTran :: DocsFinisth" + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean DocsFinish(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GTpUserInfo userInfo = new GTpUserInfo();
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDocsNo = dmProp.getString("DocsNO");
    String strDocsId = dmProp.getString("DocsID");
    String refType = dmProp.getString("REFTYPE");
    String apprId = dmProp.getString("APPRID");
    String userId = dmProp.getString("USERID");
    String apprStatus = dmProp.getString("APPRSTATUS");
    String strApprId = "";
    String strSubId = "";
    String strRefType = "";
    String strRet = "";
    String lastApprId = "";
    String apprType = "";
    String replaceId = "";
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        if (refType != null && refType.equals("5")) {
            if (userId != null && !userId.equals(apprId)) {
                strApprId = userId;
            } else {
                strApprId = apprId;
            }
            updateDocsFinish(conn, strComCode, strApprId, GCmConstDef.DOCS_INBOX, strDocsNo, msgInfo);
        } else {
            StringBuffer sqlQuery = new StringBuffer().append(" SELECT APPRID,REFTYPE,APPRTYPE FROM TB_").append(strComCode).append("_D11 ").append(" WHERE DRFTNO = " + genQuote(strDocsNo) + " AND REFTYPE in ('1','2','4','5') ").append(" ORDER BY SEQ ASC ");
            GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
            while (rs.next()) {
                strApprId = rs.getString("APPRID");
                apprType = rs.getString("APPRTYPE");
                strRefType = rs.getString("REFTYPE");
                if (apprType.equals("4")) {
                    dmProp.setProperty("USERID", strApprId);
                    GCmResultSet rs1 = userInfo.getUserInfo(cp, dmProp, msgInfo);
                    rs1.next();
                    replaceId = rs1.getString("REPLACEAPPRID");
                    updateDocsFinish(conn, strComCode, replaceId, GCmConstDef.DOCS_SENDBOX, strDocsNo, msgInfo);
                }
                if (!rs.getString("REFTYPE").equals("5")) {
                    lastApprId = strApprId;
                }
                if (strRefType.equals("2")) {
                    updateDocsFinish(conn, strComCode, strApprId, GCmConstDef.DOCS_INBOX, strDocsNo, msgInfo);
                } else {
                    updateDocsFinish(conn, strComCode, strApprId, GCmConstDef.DOCS_SENDBOX, strDocsNo, msgInfo);
                }
            }
            if (lastApprId.equals(apprId) && !apprId.equals(userId)) {
                updateDocsFinish(conn, strComCode, userId, GCmConstDef.DOCS_INBOX, strDocsNo, msgInfo);
            } else {
                updateDocsFinish(conn, strComCode, lastApprId, GCmConstDef.DOCS_INBOX, strDocsNo, msgInfo);
            }
            updateDocsFinish(conn, strComCode, strDocsId, GCmConstDef.DOCS_SENDBOX, strDocsNo, msgInfo);
            conn.commit();
            StringBuffer sqlQuery2 = new StringBuffer().append(" SELECT A.APPRID,A.APPRNAME,A.REFTYPE,B.USECHECK FROM TB_").append(strComCode).append("_D11 A, ").append(" TB_COMM_Z20 B").append(" WHERE DRFTNO = " + genQuote(strDocsNo) + " AND REFTYPE IN ( '3','6') ").append(" AND B.USERID = A.APPRID ").append(" AND B.USECHECK = 'Y'");
            GCmResultSet rs2 = conn.executeQuery(sqlQuery2.toString());
            GCmResultSet rs3 = null;
            while (rs2.next()) {
                dmProp.setObject("CONN", conn);
                dmProp.setProperty("COMCODE", strComCode);
                dmProp.setProperty("BOXNO", GCmConstDef.DOCS_INBOX);
                dmProp.setProperty("DocsNO", strDocsNo);
                dmProp.setProperty("USERID", rs2.getString("APPRID"));
                dmProp.setProperty("REFTYPE", rs2.getString("REFTYPE"));
                insertRegDocs(cp, dmProp, msgInfo);
            }
        }
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoDoDocsTran :: DocsFinish" + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoDoDocsTran :: DocsFinisth" + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public void updateDocsFinish(GCmConnection conn, String comCode, String apprId, String box, String DocsNo, GCmMsgInfo msgInfo) throws GCmProcessingErrorException, GCmParameterErrorException {
    int intCount = 0;
    try {
        if (conn == null) {
            throw new GCmParameterErrorException("updateDocsFinish() connection object is null...");
        } else if ((comCode == null) || (comCode.equals(""))) {
            throw new GCmParameterErrorException("updateDocsFinish() comCode parameter error...");
        } else if ((apprId == null) || (apprId.equals(""))) {
            throw new GCmParameterErrorException("updateDocsFinish() apprId parameter error...");
        }
        StringBuffer sqlQuery = new StringBuffer().append(" UPDATE  TB_").append(comCode).append("_D20 ").append(" SET BOXNO = " + genQuote(GCmConstDef.DOCS_ENDBOX)).append(" WHERE BOXNO = " + genQuote(box)).append(" AND USERID = " + genQuote(apprId)).append(" AND DRFTNO = " + genQuote(DocsNo));
        conn.executeUpdate(sqlQuery.toString());
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDoDocsTran :: updateDocsFinish" + e.getMessage());
        throw new GCmProcessingErrorException("GCoDoDocsTran :: updateDocsFinish " + e.getMessage());
    }
}

######


public boolean setCopyFld(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strDrftNo = dmProp.getString("DRFTNO");
    String strRegDrftNo = dmProp.getString("REGDRFTNO");
    String strBoxNo = dmProp.getString("BOXNO");
    String strFldBoxNo = dmProp.getString("FLDBOXNO");
    String strUserId = dmProp.getString("USERID");
    String strPpath = dmProp.getString("PPATH");
    String strDomain = dmProp.getString("DOMAIN");
    String strReadPage = dmProp.getString("READPAGE");
    String strHttpPort = dmProp.getString("HTTPPORT");
    String strSecLvl = "";
    int intRet = 0;
    java.io.File srcFile = null;
    java.io.File desFile = null;
    String strDocNo = "";
    String strOldDocNo = "";
    String strTitle = "";
    java.util.Vector vDoc = new java.util.Vector();
    GCoDoDoc doc = new GCoDoDoc();
    GCoDoDocTran docTran = new GCoDoDocTran();
    GCoDoDocFolder docFolder = new GCoDoDocFolder();
    GCoDoDocFolderTran docFolderTran = new GCoDoDocFolderTran();
    GTpDocs Docs = new GTpDocs();
    try {
        String strRegDate = GCmDateFcts.dateToStr(new java.util.Date(), 2);
        GCmResultSet rs = Docs.getDocsInfo(cp, dmProp, msgInfo);
        rs.next();
        strOldDocNo = rs.getString("DOCNO");
        strTitle = rs.getString("TITLE");
        strSecLvl = rs.getString("SECLVL");
        if (strFldBoxNo.equals("1")) {
            strFldBoxNo = rs.getString("DOCSAVENO");
        }
        dmProp.setProperty("COMCODE", strComCode);
        dmProp.setProperty("DOCNO", strOldDocNo);
        GCmResultSet rs2 = doc.getDocInfo(cp, dmProp, msgInfo);
        rs2.next();
        dmProp.setProperty("TITLE", rs2.getString("TITLE"));
        dmProp.setProperty("DOCTYPE", rs2.getString("DOCTYPE"));
        dmProp.setProperty("ATTNUM", rs2.getString("FILENUM"));
        dmProp.setProperty("REGUSER", rs2.getString("REGUSER"));
        dmProp.setProperty("MODDATE", rs2.getString("REGDATE"));
        dmProp.setProperty("TOTFILESIZE", rs2.getString("TOTFILESIZE"));
        dmProp.setProperty("REGDATE", strRegDate);
        dmProp.setProperty("CONTS", rs2.getString("MSTDOC"));
        dmProp.setProperty("MODUSER", strUserId);
        dmProp.setProperty("MODDATE", strRegDate);
        docTran.insertDoc(cp, dmProp, msgInfo);
        strDocNo = dmProp.getProperty("DOCNO");
        dmProp.setProperty("BOXNO", strFldBoxNo);
        dmProp.setProperty("DOCNO", strDocNo);
        dmProp.setProperty("REFNO", "D" + strRegDrftNo);
        dmProp.setProperty("USERID", strUserId);
        docTran.insertDocFolder(cp, dmProp, msgInfo);
        String fldpath = "/DATA/" + strComCode + "/BOX/" + strRegDate.substring(0, 6) + "/" + strRegDate.substring(6, 8) + "/";
        java.io.File oFile = null;
        java.util.Vector vec = new java.util.Vector();
        String fld = "";
        String tmp = "";
        tmp = fldpath.substring(0, 1);
        if (tmp.equals("/"))
            fldpath = fldpath.substring(1, fldpath.length());
        vec = GCmFcts.getSplit(fldpath, "/");
        for (int i = 0; i < vec.size(); i++) {
            fld += (String) vec.elementAt(i) + "/";
            oFile = new java.io.File(strPpath + "/" + fld);
            if (!oFile.isDirectory())
                oFile.mkdir();
        }
        String seq = "";
        String conttype = "";
        String titleLst = "";
        String fileext = "";
        String oldfilename = "";
        String filename = "";
        String vpath = "";
        String mimetype = "";
        int filesize = 0;
        String orgname = "";
        String orgpath = "";
        String reguserLst = "";
        String regdateLst = "";
        String moduserLst = "";
        String moddateLst = "";
        String despath = fldpath;
        String conts = "";
        dmProp.setProperty("DOCNO", strOldDocNo);
        dmProp.setProperty("SEQ", "00");
        GCmResultSet rs3 = doc.getDocDtlList(cp, dmProp, msgInfo);
        dmProp.setProperty("SEQ", "01");
        rs2 = doc.getDocInfo(cp, dmProp, msgInfo);
        rs2.next();
        conts = rs2.getString("MSTDOC");
        while (rs3.next()) {
            seq = rs3.getString("SEQ");
            conttype = rs3.getString("CONTTYPE");
            titleLst = rs3.getString("TITLE");
            fileext = rs3.getString("FILEEXT");
            oldfilename = rs3.getString("FILENAME");
            vpath = rs3.getString("VPATH");
            mimetype = rs3.getString("MIMETYPE");
            filesize = rs3.getInt("FILESIZE");
            orgname = rs3.getString("ORGNAME");
            orgpath = rs3.getString("ORGPATH");
            reguserLst = rs3.getString("REGUSER");
            regdateLst = rs3.getString("REGDATE");
            moduserLst = rs3.getString("MODUSER");
            moddateLst = rs3.getString("MODDATE");
            filename = strDocNo + "_" + seq + fileext;
            dmProp.setProperty("DOCNO", strDocNo);
            dmProp.setProperty("SEQ", seq);
            dmProp.setProperty("CONTTYPE", conttype);
            dmProp.setProperty("TITLE", titleLst);
            dmProp.setProperty("FILEEXT", fileext);
            dmProp.setProperty("FILENAME", filename);
            dmProp.setProperty("VPATH", fldpath);
            dmProp.setProperty("MIMETYPE", mimetype);
            dmProp.setProperty("FILESIZE", String.valueOf(filesize));
            dmProp.setProperty("ORGNAME", orgname);
            dmProp.setProperty("ORGPATH", orgpath);
            dmProp.setProperty("REGUSER", reguserLst);
            dmProp.setProperty("REGDATE", regdateLst);
            dmProp.setProperty("MODUSER", strUserId);
            dmProp.setProperty("MODDATE", strRegDate);
            docTran.insertAttDoc(cp, dmProp, msgInfo);
            srcFile = new java.io.File(strPpath + vpath, oldfilename);
            desFile = new java.io.File(strPpath + fldpath, filename);
            StringBuffer para = new StringBuffer();
            para.append("comcode=").append(strComCode).append("&userid=").append(strUserId).append("&boxno=").append(strBoxNo).append("&drftno=").append(strDrftNo).append("&regdrftno=").append(strRegDrftNo).append("&seclvl=").append(strSecLvl).append("&from=copyfld");
            GCmHtmlPageSaver html = new GCmHtmlPageSaver();
            String bonmun = html.getHtmlPage(strDomain, Integer.parseInt(strHttpPort), strReadPage, para.toString());
            dmProp.setProperty("CONTS", bonmun);
            dmProp.setProperty("DOCNO", strDocNo);
            docTran.updateContsDoc(cp, dmProp, msgInfo);
            if (Integer.parseInt(seq) > 01) {
                GCmFcts.copyFile(srcFile, desFile);
            }
        }
        return true;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDoDocsTran ::  setCopyFld() " + e.getMessage());
        return false;
    } finally {
    }
}

######


public String setDocsTemp(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strBoxNo = dmProp.getString("BOXNO");
    String strDrftNo = dmProp.getString("DRFTNO");
    String strRegDrftNo = dmProp.getString("REGDRFTNO");
    String strFldBoxNo = dmProp.getString("FLDBOXNO");
    String strFldNo = dmProp.getString("FLDNO");
    String strUserId = dmProp.getString("USERID");
    String strDomain = dmProp.getString("DOMAIN");
    String strReadPage = dmProp.getString("READPAGE");
    String strHttpPort = dmProp.getString("HTTPPORT");
    String strSecLvl = dmProp.getString("SECLVL");
    String bonmun = null;
    try {
        StringBuffer para = new StringBuffer();
        para.append("comcode=").append(strComCode).append("&userid=").append(strUserId).append("&boxno=").append(strBoxNo).append("&drftno=").append(strDrftNo).append("&regdrftno=").append(strRegDrftNo).append("&seclvl=").append(strSecLvl).append("&from=copyfld");
        GCmHtmlPageSaver html = new GCmHtmlPageSaver();
        bonmun = html.getHtmlPage(strDomain, Integer.parseInt(strHttpPort), strReadPage, para.toString());
        return bonmun;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDoDocsTran ::  setCopyFld() " + e.getMessage());
        return bonmun;
    } finally {
    }
}

######


public int insertBox(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String Iconno = dmProp.getString("Iconno");
    String Parentno = dmProp.getString("Parentno");
    String Boxclass = dmProp.getString("Boxclass");
    String Execclass = dmProp.getString("Execclass");
    String Boxtype = dmProp.getString("Boxtype");
    String Boxname = dmProp.getString("Boxname");
    String Baseflag = dmProp.getString("Baseflag");
    String Pubflag = dmProp.getString("Pubflag");
    String Execflag = dmProp.getString("Execflag");
    String Userno = dmProp.getString("Userno");
    String Regdate = dmProp.getString("Regdate");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        String Boxno = getMaxNo(COMCODE, strDbType);
        dmProp.setProperty("Boxno", Boxno);
        StringBuffer SqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_M10 (BOXNO,ICONNO,PARENTNO,BOXCLASS,EXECCLASS,BOXTYPE,BOXNAME,BASEFLAG,PUBFLAG,EXECFLAG,USERID,REGUSER,REGDATE) ").append(" VALUES(" + genQuote(Boxno) + "," + genQuote(Iconno) + "," + genQuote(Parentno) + "," + genQuote(Boxclass) + ",").append("        " + genQuote(Execclass) + "," + genQuote(Boxtype) + "," + genQuote(Boxname) + "," + genQuote(Baseflag) + ",").append("        " + genQuote(Pubflag) + "," + genQuote(Execflag) + "," + genQuote(Userno) + "," + genQuote(USERID) + "," + genQuote(Regdate) + ") ");
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoMeBoxsTran::insertBox : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoMeBoxsTran::insertBox : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoMeBoxsTran::insertBox : " + e.getMessage());
        }
        conn.close();
    }
}

######


public GCmResultSet getBoxAuth(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String Parentno = dmProp.getString("Parentno");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT BOXNO,USERID,DOCREAD,DOCWRITE,DOCDEL,DOCDELADM,FLDMAKE,FLDDEL ").append(" FROM TB_" + COMCODE + "_M20 ").append(" WHERE BOXNO = " + genQuote(Parentno));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        log.writeLog(" GCoMeBoxsTran :: getBoxAuth " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public int insertNewBox(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String Mode = dmProp.getString("Mode");
    String Boardname = dmProp.getString("Boardname");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    String Parentno = dmProp.getString("Parentno");
    String ChkBox = dmProp.getString("ChkBox");
    String actionTarget = dmProp.getString("ActionTarget");
    String ISSCHEDULE = dmProp.getString("ISSCHEDULE");
    String ISLOGGING = dmProp.getString("ISLOGGING");
    String actionFilename = null;
    if (ISSCHEDULE == null)
        ISSCHEDULE = "1";
    if (ISLOGGING == null)
        ISLOGGING = "1";
    String boxtype = "";
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    StringBuffer SqlQuery = null;
    try {
        String Regdate = eknoware.commlib.util.GCmDateFcts.dateToStr(new java.util.Date(), 2);
        conn = GCmDbManager.getInstance().getConnection();
        stmt = conn.createStatement();
        conn.setAutoCommit(true);
        if (Mode.equals("newtab")) {
            Parentno = dmProp.getString("Boxno");
        }
        StringTokenizer st = new StringTokenizer(actionTarget, "/");
        while (st.hasMoreTokens()) {
            actionFilename = st.nextToken();
        }
        if (ChkBox == "1") {
            boxtype = "1";
        } else {
            boxtype = "0";
        }
        String Boxno = getMaxNo(COMCODE, strDbType);
        dmProp.setProperty("Boxno", Boxno);
        int sNo = getBoxSortNo(COMCODE, Parentno, strDbType);
        SqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_M10 (BOXNO,ICONNO,PARENTNO,BOXCLASS,EXECCLASS,BOXTYPE,BOXNAME,BASEFLAG,PUBFLAG,EXECFLAG,USERID,REGUSER,REGDATE,ISUSABLE,TRASHFLAG,ACTIONTARGET,ISLOGGING,ISSCHEDULE) ").append(" VALUES(" + genQuote(Boxno) + ",''," + genQuote(Parentno) + ",''," + sNo + "," + genQuote(boxtype) + "," + genQuote(dmProp.getString("Boxname")) + ",'1',").append("        '0'," + genQuote(Mode.equals("newtab") ? "1" : "0") + "," + genQuote(USERID) + "," + genQuote(USERID) + "," + genQuote(Regdate) + ",'0','1'," + genQuote(actionTarget) + "," + genQuote(ISLOGGING) + "," + genQuote(ISSCHEDULE) + ") ");
        rv = stmt.executeUpdate(SqlQuery.toString());
        if (rv <= 0)
            throw new Exception(" During insertNewBox error !!!");
        if (rv <= 0)
            throw new Exception(" �������� ����� ���� ���� �������� error !!!");
        if (Mode.equals("newtab")) {
            SqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_M20 (BOXNO,USERID,DOCREAD,DOCWRITE,DOCDEL,DOCDELADM,FLDMAKE,FLDDEL) ").append("          SELECT " + genQuote(Boxno) + ",USERID,'1','1','1','1','1','1' ").append("          FROM TB_COMM_Z20 ").append("          WHERE COMCODE = " + genQuote(COMCODE));
            rv = stmt.executeUpdate(SqlQuery.toString());
            if (rv <= 0)
                throw new Exception(" During insertNewBox error !!!");
        }
        if (Mode.equals("newbox") && !Boardname.equals("")) {
            String newBoxno = getMaxNo(COMCODE, strDbType);
            if (ChkBox == "1") {
                boxtype = "1";
            } else {
                boxtype = "0";
            }
            int sNewNo = getBoxSortNo(COMCODE, Boxno, strDbType);
            SqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_M10 (BOXNO,ICONNO,PARENTNO,BOXCLASS,EXECCLASS,BOXTYPE,BOXNAME,BASEFLAG,PUBFLAG,EXECFLAG,USERID,REGUSER,REGDATE,ISUSABLE,TRASHFLAG,ACTIONTARGET,ISLOGGING,ISSCHEDULE) ").append(" VALUES(" + genQuote(newBoxno) + ",''," + genQuote(Boxno) + ",''," + sNewNo + "," + genQuote(boxtype) + "," + genQuote(dmProp.getString("Boardname")) + ",'1',").append("        '0','1'," + genQuote(USERID) + "," + genQuote(USERID) + "," + genQuote(Regdate) + ",'0','1'," + genQuote(actionFilename) + ",'1'," + genQuote(ISSCHEDULE) + ") ");
            rv = stmt.executeUpdate(SqlQuery.toString());
            if (rv <= 0)
                throw new Exception(" During insertNewBox error !!!");
            SqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_M20 (BOXNO,USERID,DOCREAD,DOCWRITE,DOCDEL,DOCDELADM,FLDMAKE,FLDDEL) ").append("          SELECT " + genQuote(newBoxno) + ",USERID,'1','1','1','1','1','1' ").append("          FROM TB_COMM_Z20 ").append("          WHERE COMCODE = " + genQuote(COMCODE));
            rv = stmt.executeUpdate(SqlQuery.toString());
            if (rv <= 0)
                throw new Exception(" During insertNewBox error !!!");
            SqlQuery = new StringBuffer().append(" SELECT BOXNO,USERID,DOCREAD,DOCWRITE,DOCDEL,DOCDELADM,FLDMAKE,FLDDEL ").append(" FROM TB_" + COMCODE + "_M20 ").append(" WHERE BOXNO = " + genQuote(Parentno));
            GCmResultSet rs = conn.executeQuery(SqlQuery.toString());
            for (int i = 0; i <= rs.getRowCount() && rs.next(); i++) {
                String AUSERID = rs.getString("USERID");
                String ADOCREAD = rs.getString("DOCREAD");
                String ADOCWRITE = rs.getString("DOCWRITE");
                String ADOCDEL = rs.getString("DOCDEL");
                String ADOCDELADM = rs.getString("DOCDELADM");
                String AFLDMAKE = rs.getString("FLDMAKE");
                String AFLDDEL = rs.getString("FLDDEL");
                SqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_M20 (BOXNO,USERID,DOCREAD,DOCWRITE,DOCDEL,DOCDELADM,FLDMAKE,FLDDEL) ").append(" VALUES(" + genQuote(newBoxno) + "," + AUSERID + "," + ADOCREAD + "," + ADOCWRITE + "," + ADOCDEL + "," + ADOCDELADM + "," + AFLDMAKE + "," + AFLDDEL).append("          FROM TB_COMM_Z20 ").append("          WHERE BOXNO = " + genQuote(COMCODE));
                rv = stmt.executeUpdate(SqlQuery.toString());
            }
        }
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoMeBoxsTran::insertNewBox : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoMeBoxsTran::insertNewBox : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoMeBoxsTran::insertNewBox : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int updateBoxName(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Boxno = dmProp.getString("Boxno");
    String Boxname = dmProp.getString("Boxname");
    String ChkBox = dmProp.getString("ChkBox");
    String boxtype = "";
    if (ChkBox == "1") {
        boxtype = "1";
    } else {
        boxtype = "0";
    }
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" UPDATE TB_" + COMCODE + "_M10 ").append(" SET BOXNAME = " + genQuote(Boxname) + ", BOXTYPE = " + genQuote(boxtype)).append(" WHERE BOXNO = " + genQuote(Boxno));
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoMeBoxsTran::updateBoxName : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoMeBoxsTran::updateBoxName : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoMeBoxsTran::updateBoxName : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int deleteMasterDoc(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Boxno = dmProp.getString("Boxno");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" DELETE FROM TB_" + COMCODE + "_L10 ").append(" WHERE DOCNO IN ( SELECT DOCNO ").append("                  FROM TB_" + COMCODE + "_A01 ").append("                  WHERE BOXNO = " + genQuote(Boxno) + " )");
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteMasterDoc : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoMeBoxsTran::deleteMasterDoc : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteMasterDoc : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int deleteDocDetail(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Boxno = dmProp.getString("Boxno");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" DELETE FROM TB_" + COMCODE + "_L11 ").append(" WHERE DOCNO IN ( SELECT DOCNO ").append("                  FROM TB_" + COMCODE + "_A01 ").append("                  WHERE BOXNO = " + genQuote(Boxno) + " )");
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteDocDetail : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoMeBoxsTran::deleteDocDetail : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteDocDetail : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int deleteBoxNoti(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Boxno = dmProp.getString("Boxno");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" DELETE FROM TB_" + COMCODE + "_A01 ").append(" WHERE BOXNO = " + genQuote(Boxno));
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteBoxNoti : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoMeBoxsTran::deleteBoxNoti : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteBoxNoti : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int deleteBoxRight(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Boxno = dmProp.getString("Boxno");
    String Userid = dmProp.getString("Userid");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" DELETE FROM TB_" + COMCODE + "_M20 ").append(" WHERE BOXNO = " + genQuote(Boxno) + " AND USERID IN ('" + eknoware.commlib.util.GCmFcts.replace(Userid, ",", "','") + "') ");
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteBoxRight : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoMeBoxsTran::deleteBoxRight : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteBoxRight : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int deleteBox(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Boxno = dmProp.getString("Boxno");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" DELETE FROM TB_" + COMCODE + "_M10 ").append(" WHERE BOXNO = " + genQuote(Boxno));
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteBox : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoMeBoxsTran::deleteBox : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteBox : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int deleteBoardBox(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Boxno = dmProp.getString("Boxno");
    String strDocroot = cp.getProperty("eknoware.system.docroot");
    int rv = 0;
    GCmConnection conn = null;
    Statement stmt = null;
    GCoMeBoxs box = new GCoMeBoxs();
    StringBuffer SqlQuery = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        GCmResultSet rsBox = box.getChildBox(cp, dmProp, msgInfo);
        while (rsBox.next()) {
            dmProp.setProperty("Boxno", rsBox.getString("BOXNO"));
            deleteBoardBox(cp, dmProp, msgInfo);
        }
        SqlQuery = new StringBuffer().append(" DELETE FROM TB_" + COMCODE + "_L10 ").append(" WHERE DOCNO IN ( SELECT DOCNO ").append("                  FROM TB_" + COMCODE + "_A01 ").append("                  WHERE BOXNO = " + genQuote(Boxno) + " )");
        rv = stmt.executeUpdate(SqlQuery.toString());
        SqlQuery = new StringBuffer().append(" DELETE FROM TB_" + COMCODE + "_L11 ").append(" WHERE DOCNO IN ( SELECT DOCNO ").append("                  FROM TB_" + COMCODE + "_A01 ").append("                  WHERE BOXNO = " + genQuote(Boxno) + " )");
        rv = stmt.executeUpdate(SqlQuery.toString());
        SqlQuery = new StringBuffer().append(" DELETE FROM TB_" + COMCODE + "_A01 ").append(" WHERE BOXNO = " + genQuote(Boxno));
        rv = stmt.executeUpdate(SqlQuery.toString());
        SqlQuery = new StringBuffer().append(" DELETE FROM TB_" + COMCODE + "_M20 ").append(" WHERE BOXNO = " + genQuote(Boxno));
        rv = stmt.executeUpdate(SqlQuery.toString());
        SqlQuery = new StringBuffer().append(" DELETE FROM TB_" + COMCODE + "_M10 ").append(" WHERE BOXNO = " + genQuote(Boxno));
        rv = stmt.executeUpdate(SqlQuery.toString());
        eknoware.commlib.util.GCmFcts.setDelete(strDocroot + "/DATA/" + COMCODE + "/BOARD/" + Boxno);
        java.io.File oFile = new java.io.File(strDocroot + "/DATA/" + COMCODE + "/BOARD/" + Boxno);
        if (oFile.isDirectory()) {
            oFile.delete();
        }
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteBoardBox : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoMeBoxsTran::deleteBoardBox : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteBoardBox : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int processDocBoxMake(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String BOXCLASS = dmProp.getString("BOXCLASS");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    StringBuffer SqlQuery = null;
    try {
        String Regdate = eknoware.commlib.util.GCmDateFcts.dateToStr(new java.util.Date(), 2);
        conn = GCmDbManager.getInstance().getConnection();
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        String Boxno = getMaxNo(COMCODE, strDbType);
        dmProp.setProperty("Boxno", Boxno);
        SqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_M10 (BOXNO,ICONNO,PARENTNO,BOXCLASS,EXECCLASS,BOXTYPE,BOXNAME,BASEFLAG,PUBFLAG,EXECFLAG,USERID,REGUSER,REGDATE) ").append(" VALUES(" + genQuote(Boxno) + ",'','000000000000'," + genQuote(BOXCLASS) + ",'1','1'," + genQuote(dmProp.getString("Boxname")) + ",'1',").append("        '0','0',''," + genQuote(USERID) + "," + genQuote(Regdate) + "," + ") ");
        rv = stmt.executeUpdate(SqlQuery.toString());
        if (rv <= 0)
            throw new Exception(" During processDocBoxMake error !!!");
        String Folderno = getMaxNoB10(COMCODE, strDbType);
        SqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_B10 (FLDNO,BOXNO,DOCNO,PARENTNO,FLDNAME,REGUSER,REGDATE,TRASHFLAG,COMMENTS,REFNO) ").append(" VALUES (" + genQuote(Folderno) + "," + genQuote(Boxno) + ",'','000000000000'," + genQuote(dmProp.getString("Boxname")) + ",'',").append("         " + genQuote(Regdate) + ",'','','')");
        rv = stmt.executeUpdate(SqlQuery.toString());
        if (rv <= 0)
            throw new Exception(" During processDocBoxMake error !!!");
        SqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_M20 (BOXNO,USERID,DOCREAD,DOCWRITE,DOCDEL,DOCDELADM,FLDMAKE,FLDDEL) ").append("          SELECT " + genQuote(Boxno) + ",USERID,'1','1','1','1','1','1' ").append("          FROM TB_COMM_Z20 ").append("          WHERE COMCODE = " + genQuote(COMCODE));
        rv = stmt.executeUpdate(SqlQuery.toString());
        if (rv <= 0)
            throw new Exception(" During processDocBoxMake error !!!");
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoMeBoxsTran::processDocBoxMake : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoMeBoxsTran::processDocBoxMake : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoMeBoxsTran::processDocBoxMake : " + e.getMessage());
        }
        conn.close();
    }
}

######


private String getMaxNo(String comcode, String strDbType) {
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(true);
        String strRegdate = GCmFcts.dateToStr(new java.util.Date(), 1);
        String strRet = "";
        StringBuffer sqlQuery = new StringBuffer();
        if ("oracle".equals(strDbType)) {
            sqlQuery.append(" SELECT SQ_").append(comcode).append("_M10.NEXTVAL RETCNT FROM DUAL ");
            GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
            while (rs.next()) {
                strRet = GCmFcts.numToStr(rs.getString("RETCNT"), 4);
                strRet = strRegdate + strRet;
            }
        } else if ("mssql".equals(strDbType)) {
            strRegdate = GCmFcts.dateToStr(new java.util.Date(), 3);
            sqlQuery.append(" INSERT INTO SQ_").append(comcode).append("_M10 VALUES ('A') ");
            conn.executeUpdate(sqlQuery.toString());
            sqlQuery = new StringBuffer().append(" SELECT MAX(RETCNT) FROM SQ_").append(comcode).append("_M10 ");
            GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
            conn.commit();
            while (rs.next()) {
                if (rs.getString("RETCNT").equals("1000000")) {
                    sqlQuery = new StringBuffer().append(" drop table SQ_").append(comcode).append("_M10 ");
                    conn.executeUpdate(sqlQuery.toString());
                    sqlQuery = new StringBuffer().append(" create  table SQ_").append(comcode).append("_M10 ").append(" ( RETCNT int IDENTITY(1,1) NOT NULL, ").append("   TMP char(1) not null ); ");
                    conn.executeUpdate(sqlQuery.toString());
                    strRet = strRegdate + "000001";
                } else {
                    strRet = GCmFcts.numToStr(rs.getString("RETCNT"), 6);
                    strRet = strRegdate + strRet;
                }
            }
        } else if ("mysql".equals(strDbType)) {
        }
        return strRet;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDoDocTran::getMaxNo " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


private String getMaxNoB10(String comcode, String strDbType) {
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(true);
        String strRegdate = GCmFcts.dateToStr(new java.util.Date(), 1);
        String strRet = "";
        StringBuffer sqlQuery = new StringBuffer();
        if ("oracle".equals(strDbType)) {
            sqlQuery.append(" SELECT SQ_").append(comcode).append("_B10.NEXTVAL RETCNT FROM DUAL ");
            GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
            while (rs.next()) {
                strRet = GCmFcts.numToStr(rs.getString("RETCNT"), 4);
                strRet = strRegdate + strRet;
            }
        } else if ("mssql".equals(strDbType)) {
            strRegdate = GCmFcts.dateToStr(new java.util.Date(), 3);
            sqlQuery.append(" INSERT INTO SQ_").append(comcode).append("_B10 VALUES ('A') ");
            conn.executeUpdate(sqlQuery.toString());
            sqlQuery = new StringBuffer().append(" SELECT MAX(RETCNT) FROM SQ_").append(comcode).append("_B10 ");
            GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
            while (rs.next()) {
                if (rs.getString("RETCNT").equals("1000000")) {
                    sqlQuery = new StringBuffer().append(" drop table SQ_").append(comcode).append("_B10 ");
                    conn.executeUpdate(sqlQuery.toString());
                    sqlQuery = new StringBuffer().append(" create  table SQ_").append(comcode).append("_B10 ").append(" ( RETCNT int IDENTITY(1,1) NOT NULL, ").append("   TMP char(1) not null ); ");
                    conn.executeUpdate(sqlQuery.toString());
                    strRet = strRegdate + "000001";
                } else {
                    strRet = GCmFcts.numToStr(rs.getString("RETCNT"), 6);
                    strRet = strRegdate + strRet;
                }
            }
        } else if ("mysql".equals(strDbType)) {
        }
        return strRet;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoDoDocTran::getMaxNoB10 " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


private int getBoxSortNo(String comcode, String parentBoxNo, String strDbType) {
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer();
        if (strDbType.equals("oracle")) {
            sqlQuery.append(" SELECT NVL(MAX(EXECCLASS)+1,1) AS NO FROM TB_").append(comcode).append("_M10 WHERE PARENTNO = " + genQuote(parentBoxNo));
        } else if (strDbType.equals("mssql")) {
            sqlQuery.append(" SELECT ISNULL(MAX(EXECCLASS)+1,1) AS NO FROM TB_").append(comcode).append("_M10 WHERE PARENTNO = " + genQuote(parentBoxNo));
        }
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        rs.next();
        return rs.getInt("NO");
    } catch (Exception e) {
        GCmLog.writeLog(" GCoMeBoxsTran::getBoxSortNo " + e.getMessage());
        return 0;
    } finally {
        conn.close();
    }
}

######


public boolean insertScheduleMenu(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String comCode = dmProp.getString("COMCODE");
    String boxNo = dmProp.getString("BOXNO");
    String mostOrgNo = dmProp.getString("MOSTORGNO");
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery = new StringBuffer().append("INSERT INTO TB_").append(comCode).append("_E12 (BOXNO,MOSTORGNO) VALUES(").append(genQuote(boxNo)).append(", ").append(genQuote(mostOrgNo)).append(")");
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("GCoMeBoxsTran::: insertScheduleMenu" + ignored.getMessage());
        }
        GCmLog.writeLog("GCoMeBoxsTran::: insertScheduleMenu " + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public int deleteScheduleMenu(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Boxno = dmProp.getString("BOXNO");
    GCmLog.writeLog(COMCODE);
    GCmLog.writeLog(Boxno);
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    Statement stmt1 = null;
    Statement stmt2 = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        stmt = conn.createStatement();
        stmt1 = conn.createStatement();
        stmt2 = conn.createStatement();
        conn.setAutoCommit(false);
        StringBuffer SqlQuery = new StringBuffer().append(" DELETE FROM TB_" + COMCODE + "_M20 ").append(" WHERE BOXNO = " + genQuote(Boxno));
        rv = stmt.executeUpdate(SqlQuery.toString());
        StringBuffer SqlQuery1 = new StringBuffer().append("DELETE FROM TB_" + COMCODE + "_E12 ").append("WHERE BOXNO=").append(genQuote(Boxno));
        rv = stmt1.executeUpdate(SqlQuery1.toString());
        StringBuffer SqlQuery2 = new StringBuffer().append("DELETE FROM TB_" + COMCODE + "_M10 ").append(" WHERE BOXNO=").append(genQuote(Boxno));
        rv = stmt2.executeUpdate(SqlQuery2.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteScheduleMenu : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoMeBoxsTran::deleteScheduleMenu : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
            stmt1.close();
            stmt2.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoMeBoxsTran::deleteScheduleMenu : " + e.getMessage());
        }
        conn.close();
    }
}

######


public boolean insertPersonAuthority(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    GCmFcts fct = new GCmFcts();
    String COMCODE = dmProp.getString("COMCODE");
    String userid = dmProp.getString("USERID");
    String boxno = dmProp.getString("BOXNO");
    String docread = dmProp.getString("DOCREAD");
    String docwrite = dmProp.getString("DOCWRITE");
    String docdel = dmProp.getString("DOCDEL");
    String docdeladm = dmProp.getString("DOCDELADM");
    String fldmake = "1";
    String flddel = "1";
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    StringBuffer sqlQuery = new StringBuffer();
    Vector boxVec = new Vector();
    int rv = 0;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        Statement stmt = conn.createStatement();
        conn.setAutoCommit(false);
        boxVec = fct.getSplit(boxno, ",");
        boxno = fct.getInSQL(boxno, ",");
        sqlQuery = new StringBuffer().append("DELETE FROM TB_").append(COMCODE).append("_M20 WHERE BOXNO IN(").append(boxno).append(") AND USERID =").append(genQuote(userid));
        rv = stmt.executeUpdate(sqlQuery.toString());
        for (int i = 0; i < boxVec.size(); i++) {
            sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(COMCODE).append("_M20 (BOXNO, DOCREAD, DOCWRITE, DOCDEL, DOCDELADM, FLDMAKE, FLDDEL, USERID) ").append("VALUES (").append(genQuote((String.valueOf(boxVec.elementAt(i))))).append(",").append(genQuote(docread)).append(",").append(genQuote(docwrite)).append(",").append(genQuote(docdel)).append(",").append(genQuote(docdeladm)).append(",").append(genQuote(fldmake)).append(",").append(genQuote(flddel)).append(",").append(genQuote(userid)).append(" )");
            rv = stmt.executeUpdate(sqlQuery.toString());
        }
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("GCoMeBoxsTran::: insertPersonAuthority" + ignored.getMessage());
        }
        GCmLog.writeLog("GCoMeBoxsTran::: insertPersonAuthority " + e.getMessage());
        GCmLog.writeLog("GCoMeBoxsTran::: insertPersonAuthority " + sqlQuery.toString());
        return false;
    } finally {
        conn.close();
    }
}

######


public int insertMemo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String LIST = dmProp.getString("LIST");
    GEmTB_W10 tbf10 = (GEmTB_W10) dmProp.getObject("tbf10");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    java.util.Vector vList = new java.util.Vector();
    try {
        String cardNo = getMaxMemoNo(COMCODE, cp.getProperty("eknoware.db.type"));
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_U10 (CARDNO, USERID, GRPNO, HOMEPAGE, ").append("         COMMENTS, PUBFLAG, REGDATE ) ").append(" VALUES(" + genQuote(cardNo) + "," + genQuote(USERID) + "," + genQuote(tbf10.getStrGrpNo()) + ",").append("        " + genQuote(tbf10.getStrHomePage()) + "," + genQuote(tbf10.getStrComments()) + ",").append("        " + genQuote(tbf10.getStrPubFlag()) + "," + genQuote(tbf10.getStrRegDate()) + " )");
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(sqlQuery.toString());
        try {
            vList = eknoware.commlib.util.GCmFcts.getSplit(LIST, ",");
            StringBuffer sqlQuery1 = null;
            if (tbf10.getStrPubFlag().equals("0")) {
                sqlQuery1 = new StringBuffer().append("insert into tb_" + COMCODE + "_U50 (CARDNO, USERID) ").append(" VALUES(" + genQuote(cardNo) + "," + genQuote(USERID) + ")");
                stmt = conn.createStatement();
                conn.setAutoCommit(false);
                rv = stmt.executeUpdate(sqlQuery1.toString());
            }
            for (int i = 0; i < vList.size(); i++) {
                String sList = (String) vList.elementAt(i);
                sqlQuery1 = new StringBuffer().append("insert into tb_" + COMCODE + "_U50 (CARDNO, USERID) ").append(" VALUES(" + genQuote(cardNo) + "," + genQuote(sList) + ")");
                stmt = conn.createStatement();
                conn.setAutoCommit(false);
                rv = stmt.executeUpdate(sqlQuery1.toString());
            }
        } catch (SQLException e) {
            GCmLog.writeLog("insertMemo public list : " + e.getMessage());
        }
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoMemoTran::insertMemo : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoMemoTran::insertMemo : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoMemoTran::insertMemo : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int insertCopyMemo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    GEmTB_W10 tbf10 = (GEmTB_W10) dmProp.getObject("tbf10");
    String NameList = dmProp.getString("NameList");
    String CardList = dmProp.getString("CardList");
    int rv = 0;
    GCmConnection conn = null;
    Statement stmt = null;
    GCmResultSet rs = null;
    java.util.Vector vCardList = new java.util.Vector();
    java.util.Vector vNameList = new java.util.Vector();
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(true);
        stmt = conn.createStatement();
        vCardList = eknoware.commlib.util.GCmFcts.getSplit(CardList, ",");
        vNameList = eknoware.commlib.util.GCmFcts.getSplit(NameList, ",");
        StringBuffer sqlQuery = null;
        int count = 0;
        for (int i = 0; i < vCardList.size(); i++) {
            String sCardList = (String) vCardList.elementAt(i);
            sqlQuery = new StringBuffer().append(" select userid, cardno, homepage, title, comments, pubflag, orgno, regdate, copierid, copydate, grpno ").append(" FROM TB_" + COMCODE + "_U10 ").append(" WHERE CARDNO =" + genQuote(sCardList));
            rs = conn.executeQuery(sqlQuery.toString());
            rs.next();
            tbf10.setStrGrpNo(rs.getString("GRPNO"));
            tbf10.setStrHomePage(rs.getString("HOMEPAGE"));
            tbf10.setStrComments(rs.getString("COMMENTS"));
            tbf10.setStrPubFlag(rs.getString("PUBFLAG"));
            tbf10.setStrRegDate(rs.getString("REGDATE"));
            for (int k = 0; k < vNameList.size(); k++) {
                String cardNo = getMaxMemoNo(COMCODE, cp.getProperty("eknoware.db.type"));
                String sNameList = (String) vNameList.elementAt(k);
                sqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_U10 (CARDNO, USERID, GRPNO, HOMEPAGE, ").append("         COMMENTS, PUBFLAG, REGDATE, COPIERID, COPYDATE ) ").append(" VALUES(" + genQuote(cardNo) + "," + genQuote(sNameList) + ",'000000000000',").append("        " + genQuote(tbf10.getStrHomePage()) + ",").append("        " + genQuote(tbf10.getStrComments()) + "," + genQuote(tbf10.getStrPubFlag()) + "," + genQuote(tbf10.getStrRegDate()) + "," + genQuote(USERID) + "," + genQuote(tbf10.getStrRegDate()) + " )");
                rv = stmt.executeUpdate(sqlQuery.toString());
            }
        }
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoMemoTran::insertCopyMemo ::: " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoMemoTran::insertCopyMemo : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoMemoTran::insertCopyMemo : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int updateUserOrgNo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    GEmTB_Z20 tbz20 = (GEmTB_Z20) dmProp.getObject("tbz20");
    StringBuffer SqlQuery = null;
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        SqlQuery = new StringBuffer().append(" UPDATE TB_").append(COMCODE).append("_N11 ").append(" SET ORGNO = " + genQuote(tbz20.getStrOrgNo())).append(" WHERE USERID = " + genQuote(USERID));
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoOrOrgInfoTran::updateUserOrgNo : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoOrOrgInfoTran::updateUserOrgNo : " + e.getMessage());
        GCmLog.writeLog(" GCoOrOrgInfoTran::updateUserOrgNo : queryError :  " + SqlQuery.toString());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoOrOrgInfoTran::updateUserOrgNo : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int updateOrgUser(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String ORGNO = dmProp.getString("ORGNO");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    String isregular = "";
    int rv = 0;
    StringBuffer SqlQuery = null;
    GCmConnection conn = null;
    Statement stmt = null;
    GCmResultSet rs = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        stmt = conn.createStatement();
        SqlQuery = new StringBuffer();
        Vector vUser = eknoware.commlib.util.GCmFcts.getSplit(USERID, ",");
        String rUser = eknoware.commlib.util.GCmFcts.replace(USERID, ",", "','");
        String tUserID = null;
        SqlQuery = new StringBuffer().append("SELECT ISREGULAR FROM TB_").append(COMCODE).append("_N10 WHERE   ORGNO = ").append(genQuote(ORGNO));
        rs = conn.executeQuery(SqlQuery.toString());
        if (rs.next()) {
            isregular = rs.getString("ISREGULAR");
        } else {
            isregular = "";
        }
        SqlQuery = new StringBuffer();
        if (isregular.equals("0")) {
            if ("oracle".equals(strDbType)) {
                SqlQuery.append(" UPDATE TB_COMM_Z20 SET ORGNO='' ").append(" WHERE (ORGNO||USERID) IN (SELECT ORGNO||USERID FROM TB_").append(COMCODE).append("_N11 WHERE ORGNO=").append(genQuote(ORGNO)).append(" AND DEFLT='0') ");
            } else if ("mssql".equals(strDbType)) {
                SqlQuery.append(" UPDATE TB_COMM_Z20 SET ORGNO='' ").append(" WHERE (ORGNO+USERID) IN (SELECT ORGNO+USERID FROM TB_").append(COMCODE).append("_N11 WHERE ORGNO=").append(genQuote(ORGNO)).append(" AND DEFLT='0') ");
            } else if ("mysql".equals(strDbType)) {
            }
            rv = stmt.executeUpdate(SqlQuery.toString());
        }
        if (isregular.equals("1")) {
            SqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(COMCODE).append("_N11 WHERE ORGNO IN ( ").append(" SELECT A.ORGNO FROM TB_").append(COMCODE).append("_N11 A, TB_").append(COMCODE).append("_N10 B WHERE A.ORGNO= B.ORGNO AND A.USERID IN ('").append(rUser).append("') AND B.ISREGULAR='1') ").append("AND USERID IN('").append(rUser).append("')");
            rv = stmt.executeUpdate(SqlQuery.toString());
        }
        SqlQuery = new StringBuffer();
        SqlQuery.append(" DELETE FROM TB_").append(COMCODE).append("_N11 WHERE ORGNO = ").append(genQuote(ORGNO));
        rv = stmt.executeUpdate(SqlQuery.toString());
        for (int i = 0; i < vUser.size(); i++) {
            SqlQuery = new StringBuffer();
            tUserID = String.valueOf(vUser.elementAt(i));
            if ("oracle".equals(strDbType)) {
                if (isregular.equals("0")) {
                    SqlQuery = new StringBuffer();
                    SqlQuery.append("INSERT INTO TB_").append(COMCODE).append("_N11 ").append(" VALUES(").append(genQuote(ORGNO)).append(",").append(genQuote(tUserID)).append(",(SELECT DECODE(COUNT(*),0,0,1) FROM TB_").append(COMCODE).append("_N11 WHERE USERID = ").append(genQuote(tUserID)).append(" AND DEFLT='0')  )");
                } else {
                    SqlQuery = new StringBuffer();
                    SqlQuery.append("INSERT INTO TB_").append(COMCODE).append("_N11  ").append(" SELECT ").append(genQuote(ORGNO)).append(",").append(genQuote(tUserID)).append(", '1' ");
                }
            } else if ("mssql".equals(strDbType)) {
                if (isregular.equals("0")) {
                    SqlQuery = new StringBuffer();
                    SqlQuery.append("INSERT INTO TB_").append(COMCODE).append("_N11  ").append(" SELECT ").append(genQuote(ORGNO)).append(",").append(genQuote(tUserID)).append(", (CASE COUNT(*) WHEN 0 THEN 0 ELSE 1 END)").append(" FROM TB_").append(COMCODE).append("_N11 A, TB_").append(COMCODE).append("_N10 B WHERE A.USERID = ").append(genQuote(tUserID)).append(" AND A.DEFLT='0' AND B.ISREGULAR='0' ");
                } else {
                    SqlQuery = new StringBuffer();
                    SqlQuery.append("INSERT INTO TB_").append(COMCODE).append("_N11  ").append(" SELECT ").append(genQuote(ORGNO)).append(",").append(genQuote(tUserID)).append(", '1' ");
                }
            } else if ("mysql".equals(strDbType)) {
            }
            rv = stmt.executeUpdate(SqlQuery.toString());
        }
        SqlQuery = new StringBuffer();
        if (isregular.equals("0")) {
            if ("oracle".equals(strDbType)) {
                SqlQuery.append("UPDATE TB_COMM_Z20 SET ORGNO = ").append(genQuote(ORGNO)).append(" WHERE USERID IN ( SELECT DECODE(COUNT(*),1,USERID) ").append(" FROM TB_").append(COMCODE).append("_N11 WHERE USERID IN('").append(rUser).append("') AND ORGNO=").append(genQuote(ORGNO)).append(" AND DEFLT='0' GROUP BY USERID )");
            } else if ("mssql".equals(strDbType)) {
                SqlQuery.append("UPDATE TB_COMM_Z20 SET ORGNO = ").append(genQuote(ORGNO)).append(" WHERE USERID IN ( SELECT (CASE COUNT(*) WHEN 1 THEN USERID ELSE '' END) ").append(" FROM TB_").append(COMCODE).append("_N11 WHERE USERID IN('").append(rUser).append("') AND ORGNO=").append(genQuote(ORGNO)).append(" AND DEFLT='0' GROUP BY USERID )");
            } else if ("mysql".equals(strDbType)) {
            }
            rv = stmt.executeUpdate(SqlQuery.toString());
        }
        if (isregular.equals("1")) {
            SqlQuery = new StringBuffer().append(" UPDATE TB_COMM_Z20 SET POSCODE=''").append(" WHERE POSCODE = ").append(genQuote(ORGNO));
            rv = stmt.executeUpdate(SqlQuery.toString());
            SqlQuery = new StringBuffer().append(" UPDATE TB_COMM_Z20 SET POSCODE=").append(genQuote(ORGNO)).append(" WHERE USERID IN('").append(rUser).append("')");
            rv = stmt.executeUpdate(SqlQuery.toString());
        }
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoOrOrgInfoTran::updateOrgUser : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoOrOrgInfoTran::updateOrgUser : " + e.getMessage());
        GCmLog.writeLog(" GCoOrOrgInfoTran::updateOrgUser : queryError :  " + SqlQuery.toString());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoOrOrgInfoTran::updateUserOrgNo : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int insertOrgUser(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Orgno = dmProp.getString("Orgno");
    String Userno = dmProp.getString("Userno");
    String Deflt = dmProp.getString("Deflt");
    StringBuffer SqlQuery = null;
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        SqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(COMCODE).append("_N11 (ORGNO,USERID,DEFLT) ").append(" VALUES (" + genQuote(Orgno) + "," + genQuote(Userno) + "," + genQuote(Deflt) + ") ");
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoOrOrgInfoTran::insertOrgUser : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoOrOrgInfoTran::insertOrgUser : " + e.getMessage());
        GCmLog.writeLog(" GCoOrOrgInfoTran::insertOrgUser : queryError :  " + SqlQuery.toString());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoOrOrgInfoTran::insertOrgUser : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int insertOrg(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Parentno = dmProp.getString("Parentno");
    String Orgname = dmProp.getString("Orgname");
    String isRegular = dmProp.getString("ISREGULAR");
    String description = dmProp.getString("DESCRIPTION");
    String isUsable = dmProp.getString("ISUSABLE");
    String orderby = dmProp.getString("ORDERBY");
    StringBuffer SqlQuery = null;
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        String Orgno = getMaxNo(COMCODE, strDbType);
        int isRegul = 0;
        if (isRegular != null && isRegular.trim().length() != 0) {
            isRegul = Integer.parseInt(isRegular);
        }
        if (isUsable == null || isUsable.length() == 0) {
            isUsable = "0";
        }
        if (description == null) {
            description = "";
        }
        SqlQuery = new StringBuffer().append(" UPDATE TB_").append(COMCODE).append("_N10 SET ORDERBY=ORDERBY+1 ").append(" WHERE ORDERBY >= ").append(orderby).append(" AND PARENTNO=").append(genQuote(Parentno));
        stmt = conn.createStatement();
        rv = stmt.executeUpdate(SqlQuery.toString());
        SqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(COMCODE).append("_N10 (ORGNO,PARENTNO,ORGNAME,READERNO,ISREGULAR,ORDERBY,ISUSABLE) ").append(" VALUES (").append(genQuote(Orgno)).append(",").append(genQuote(Parentno)).append(",").append(genQuote(Orgname)).append(",'',").append(isRegul).append(",").append(orderby).append(",").append(genQuote(isUsable)).append(") ");
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        dmProp.setProperty("Orgno", Orgno);
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoOrOrgInfoTran::insertOrg : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoOrOrgInfoTran::insertOrg : " + e.getMessage());
        GCmLog.writeLog(" GCoOrOrgInfoTran::insertOrg : queryError :  " + SqlQuery.toString());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoOrOrgInfoTran::insertOrg : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int deleteOrg(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Orgno = dmProp.getString("Orgno");
    String parentno = "";
    String orderby = "";
    StringBuffer SqlQuery = null;
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    GCmResultSet rs = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        SqlQuery = new StringBuffer().append("SELECT ORDERBY,PARENTNO FROM TB_").append(COMCODE).append("_N10 WHERE ORGNO=").append(genQuote(Orgno));
        rs = conn.executeQuery(SqlQuery.toString());
        if (rs.next()) {
            orderby = rs.getString("ORDERBY");
            parentno = rs.getString("PARENTNO");
        }
        SqlQuery = new StringBuffer().append(" UPDATE TB_").append(COMCODE).append("_N10 SET ORDERBY=ORDERBY-1 ").append(" WHERE ORDERBY > ").append(orderby).append(" AND PARENTNO=").append(genQuote(parentno));
        rv = stmt.executeUpdate(SqlQuery.toString());
        SqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(COMCODE).append("_N10 ").append(" WHERE ORGNO = " + genQuote(Orgno));
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoOrOrgInfoTran::deleteOrg : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoOrOrgInfoTran::deleteOrg : " + e.getMessage());
        GCmLog.writeLog(" GCoOrOrgInfoTran::deleteOrg : queryError :  " + SqlQuery.toString());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoOrOrgInfoTran::deleteOrg : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int updateOrgName(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Orgno = dmProp.getString("Orgno");
    String Orgname = dmProp.getString("Orgname");
    String orderby = dmProp.getString("ORDERBY");
    String parentNo = "";
    String beforOrderby = "";
    StringBuffer SqlQuery = null;
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    GCmResultSet rs = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        SqlQuery = new StringBuffer().append("SELECT ORDERBY,PARENTNO FROM TB_").append(COMCODE).append("_N10 WHERE ORGNO=").append(genQuote(Orgno));
        rs = conn.executeQuery(SqlQuery.toString());
        if (rs.next()) {
            beforOrderby = rs.getString("ORDERBY");
            parentNo = rs.getString("PARENTNO");
        }
        if (beforOrderby != null && !beforOrderby.equals(orderby)) {
            if (Integer.parseInt(beforOrderby) > Integer.parseInt(orderby)) {
                SqlQuery = new StringBuffer().append(" UPDATE TB_").append(COMCODE).append("_N10 SET ORDERBY=ORDERBY+1 ").append(" WHERE PARENTNO= ").append(genQuote(parentNo)).append(" AND ORDERBY BETWEEN ").append(orderby).append(" AND ").append(Integer.parseInt(beforOrderby) - 1);
            } else {
                SqlQuery = new StringBuffer().append(" UPDATE TB_").append(COMCODE).append("_N10 SET ORDERBY=ORDERBY-1 ").append(" WHERE PARENTNO= ").append(genQuote(parentNo)).append(" AND ORDERBY BETWEEN ").append(Integer.parseInt(beforOrderby) + 1).append(" AND ").append(orderby);
            }
            rv = stmt.executeUpdate(SqlQuery.toString());
        }
        SqlQuery = new StringBuffer().append(" UPDATE TB_").append(COMCODE).append("_N10 ").append(" SET ORGNAME = ").append(genQuote(Orgname)).append(", ORDERBY = ").append(orderby).append(" WHERE ORGNO = " + genQuote(Orgno));
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoOrOrgInfoTran::updateOrgName : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoOrOrgInfoTran::updateOrgName : " + e.getMessage());
        GCmLog.writeLog(" GCoOrOrgInfoTran::updateOrgName : queryError :  " + SqlQuery.toString());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoOrOrgInfoTran::updateOrgName : " + e.getMessage());
        }
        conn.close();
    }
}

######


public GCmResultSet getSchdlInfo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String Schdlno = dmProp.getString("Schdlno");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer();
        if ("oracle".equals(strDbType)) {
            sqlQuery.append(" SELECT * FROM TB_").append(COMCODE).append("_E10 A ").append(" WHERE SCHDLNO = " + genQuote(Schdlno));
        } else if ("mssql".equals(strDbType)) {
            sqlQuery.append(" SELECT * FROM TB_").append(COMCODE).append("_E10 A ").append(" WITH(NOLOCK) WHERE SCHDLNO = " + genQuote(Schdlno));
        } else if ("mysql".equals(strDbType)) {
        }
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoPiSchedule::getSchdlInfo " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getSchdlEveryListTotal(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String Year = dmProp.getString("Year");
    String Month = dmProp.getString("Month");
    String Day = dmProp.getString("Day");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer();
        if ("oracle".equals(strDbType)) {
            sqlQuery.append("SELECT A.SCHDLNO,A.TITLE,A.COMMENTS,A.DIVSCHEDULE,A.SDATE,A.STIME,LDATE,A.LTIME,A.RELATMAN,A.RELATAREA,A.REPEATFLAG,ALARMFLAG,A.USERID,A.BOXNO,A.PARENTNO ").append(",(SELECT USERNAME FROM TB_COMM_Z20 WHERE USERID=A.USERID) USERNAME, (SELECT ORGNAME FROM TB_").append(COMCODE).append("_N10 WHERE ORGNO = (SELECT POSCODE FROM TB_COMM_Z20 WHERE USERID = A.USERID)) POSNAME, (SELECT ORGNAME FROM TB_").append(COMCODE).append("_N10 WHERE ORGNO = (SELECT ORGNO FROM TB_COMM_Z20 WHERE USERID = A.USERID)) ORGNAME, A.SCHDSTATUS ").append(" FROM  TB_").append(COMCODE).append("_E10 A ").append(" WHERE ( EXISTS (SELECT SCHDLNO ").append(" FROM TB_").append(COMCODE).append("_E11 ").append(" WHERE SCHDLNO = A.SCHDLNO ").append(" AND (OPENCODE = ").append(genQuote(USERID)).append(" OR OPENCODE IN (SELECT ORGNO FROM TB_").append(COMCODE).append("_N11 WHERE USERID = ").append(genQuote(USERID)).append(" ))) ").append(" OR A.USERID = ").append(genQuote(USERID)).append(" OR A.REPEATFLAG = '0'").append(") AND ").append(" (A.SCHDSTATUS = '0' OR A.SCHDSTATUS='2') AND ").append(genQuote(Year + Month + Day)).append(" between SDATE and LDATE");
        } else if ("mssql".equals(strDbType)) {
            sqlQuery.append("SELECT A.SCHDLNO,A.TITLE,A.COMMENTS,A.DIVSCHEDULE,A.SDATE,A.STIME,LDATE,A.LTIME,A.RELATMAN,A.RELATAREA,A.REPEATFLAG,ALARMFLAG,A.USERID,A.BOXNO,A.PARENTNO ").append(",(SELECT USERNAME FROM TB_COMM_Z20 WITH(NOLOCK) WHERE USERID=A.USERID) USERNAME, (SELECT ORGNAME FROM TB_").append(COMCODE).append("_N10 WITH(NOLOCK) WHERE ORGNO = (SELECT POSCODE FROM TB_COMM_Z20 WITH(NOLOCK) WHERE USERID = A.USERID)) POSNAME, (SELECT ORGNAME FROM TB_").append(COMCODE).append("_N10 WITH(NOLOCK) WHERE ORGNO = (SELECT ORGNO FROM TB_COMM_Z20 WITH(NOLOCK) WHERE USERID = A.USERID)) ORGNAME , A.SCHDSTATUS ").append(" FROM  TB_").append(COMCODE).append("_E10 A WITH(NOLOCK) ").append(" WHERE ( EXISTS (SELECT SCHDLNO ").append(" FROM TB_").append(COMCODE).append("_E11 WITH(NOLOCK) ").append(" WHERE SCHDLNO = A.SCHDLNO ").append(" AND (OPENCODE = ").append(genQuote(USERID)).append(" OR OPENCODE IN (SELECT ORGNO FROM TB_").append(COMCODE).append("_N11 WITH(NOLOCK) WHERE USERID = ").append(genQuote(USERID)).append(" ))) ").append(" OR A.USERID = ").append(genQuote(USERID)).append(" OR A.REPEATFLAG = '0'").append(") AND ").append(" (A.SCHDSTATUS = '0' OR A.SCHDSTATUS='2') AND ").append(genQuote(Year + Month + Day)).append(" between SDATE and LDATE");
        } else if ("mysql".equals(strDbType)) {
        }
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoPiSchedule::getSchdlEveryListTotal " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getSchdlEveryList(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String Year = dmProp.getString("Year");
    String Month = dmProp.getString("Month");
    String Day = dmProp.getString("Day");
    String OrgNo = dmProp.getString("ORGNO");
    String divSchedule = dmProp.getString("DIVSCHEDULE");
    String schdStatus = dmProp.getString("SCHDSTATUS");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer();
        if ("oracle".equals(strDbType)) {
            if (divSchedule.equals("1") && !OrgNo.equals("000000000000")) {
                sqlQuery.append("SELECT B.* FROM TB_").append(COMCODE).append("_E10 B ").append(" where exists (select SCHDLNO ").append(" from tb_").append(COMCODE).append("_e11 ").append(" WITH(NOLOCK) where SCHDLNO = b.SCHDLNO").append(" and(opencode = ").append(genQuote(USERID)).append(" or opencode in (select orgno").append(" from tb_").append(COMCODE).append("_n11 ").append(" WITH(NOLOCK) where userid=").append(genQuote(USERID)).append(" ))) ").append(" AND B.USERID IN ( SELECT USERID ").append(" from tb_").append(COMCODE).append("_n11 ").append(" WITH(NOLOCK) WHERE ORGNO=").append(genQuote(OrgNo)).append(" AND B.DIVSCHEDULE=").append(genQuote(divSchedule)).append(") AND ").append(genQuote(Year + Month + Day)).append(" BETWEEN B.SDATE AND B.LDATE").append(" AND B.SDATE !=").append(genQuote(Year + Month + Day)).append(" UNION all ").append(" SELECT A.*").append(" from tb_").append(COMCODE).append("_e10 A ").append(" WITH(NOLOCK) where exists (select SCHDLNO ").append(" from tb_").append(COMCODE).append("_e11 ").append(" WITH(NOLOCK) where SCHDLNO = A.SCHDLNO ").append(" and(opencode = ").append(genQuote(USERID)).append(" or opencode in (select orgno").append(" from tb_").append(COMCODE).append("_n11 ").append(" WITH(NOLOCK) where userid=").append(genQuote(USERID)).append(")))").append(" AND A.USERID IN ( SELECT USERID ").append(" from tb_").append(COMCODE).append("_n11 ").append(" WITH(NOLOCK) WHERE ORGNO=").append(genQuote(OrgNo)).append(" AND A.DIVSCHEDULE=").append(genQuote(divSchedule)).append(") AND A.SDATE = ").append(genQuote(Year + Month + Day)).append(" AND (A.STIME IS NULL OR A.STIME = '')");
            } else if (divSchedule.equals("1") && OrgNo.equals("000000000000")) {
                sqlQuery.append("  SELECT B.* ").append(" from tb_").append(COMCODE).append("_e10 B").append(" WITH(NOLOCK) where EXISTS (SELECT SCHDLNO").append(" from tb_").append(COMCODE).append("_e11 ").append(" WITH(NOLOCK) WHERE SCHDLNO = B.SCHDLNO").append(" AND OPENCODE = ").append(genQuote(OrgNo)).append(") AND B.REPEATFLAG='0'").append(" AND ").append(genQuote(Year + Month + Day)).append("BETWEEN B.SDATE AND B.LDATE ").append(" AND B.SDATE != ").append(genQuote(Year + Month + Day)).append(" UNION all ").append(" SELECT A.* ").append(" from tb_").append(COMCODE).append("_e10 A").append(" WITH(NOLOCK) WHERE EXISTS (SELECT SCHDLNO").append(" from tb_").append(COMCODE).append("_e11 ").append(" WITH(NOLOCK) WHERE SCHDLNO = A.SCHDLNO").append(" AND OPENCODE = ").append(genQuote(OrgNo)).append(") AND A.REPEATFLAG='0'").append(" AND A.SDATE = ").append(genQuote(Year + Month + Day)).append(" AND (A.STIME IS NULL OR A.STIME = '')");
            } else if (divSchedule.equals("0")) {
                sqlQuery.append(" SELECT B.* ").append(" from tb_").append(COMCODE).append("_e10 B").append(" WHERE ( EXISTS (SELECT SCHDLNO ").append(" from tb_").append(COMCODE).append("_e11 ").append(" WITH(NOLOCK) WHERE SCHDLNO = B.SCHDLNO").append(" AND(OPENCODE = ").append(genQuote(USERID)).append(" OR OPENCODE IN (SELECT ORGNO FROM TB_eknow_N11 WHERE USERID = '1' )))").append(" AND B.DIVSCHEDULE = ").append(genQuote(divSchedule)).append(" OR B.USERID =").append(genQuote(USERID)).append(") AND B.REPEATFLAG!='0'").append(" AND ").append(genQuote(Year + Month + Day)).append(" BETWEEN B.SDATE AND B.LDATE ").append(" AND B.SDATE != ").append(genQuote(Year + Month + Day)).append(" UNION  all ").append(" SELECT A.*").append(" from tb_").append(COMCODE).append("_e10 A").append(" WITH(NOLOCK) WHERE ( EXISTS (SELECT SCHDLNO").append(" from tb_").append(COMCODE).append("_e11 ").append(" WITH(NOLOCK) WHERE SCHDLNO = A.SCHDLNO ").append(" AND(OPENCODE = ").append(genQuote(USERID)).append(" OR OPENCODE IN (SELECT ORGNO ").append(" from tb_").append(COMCODE).append("_n11 ").append(" WITH(NOLOCK) WHERE USERID = ").append(genQuote(USERID)).append("))) AND A.DIVSCHEDULE = ").append(genQuote(divSchedule)).append(" OR A.USERID =").append(genQuote(USERID)).append(") AND A.REPEATFLAG!='0'").append(" AND A.SDATE = ").append(genQuote(Year + Month + Day)).append(" AND (A.STIME IS NULL OR A.STIME = '')");
            }
        } else if ("mssql".equals(strDbType)) {
            if (divSchedule.equals("1") && !OrgNo.equals("000000000000")) {
                sqlQuery.append("SELECT B.* FROM TB_").append(COMCODE).append("_E10 B ").append(" WITH(NOLOCK) where exists (select SCHDLNO ").append(" from tb_").append(COMCODE).append("_e11 ").append(" WITH(NOLOCK) where SCHDLNO = b.SCHDLNO").append(" and(opencode = ").append(genQuote(USERID)).append(" or opencode in (select orgno").append(" from tb_").append(COMCODE).append("_n11 ").append(" WITH(NOLOCK) where userid=").append(genQuote(USERID)).append(" ))) ").append(" AND B.USERID IN ( SELECT USERID ").append(" from tb_").append(COMCODE).append("_n11 ").append(" WITH(NOLOCK) WHERE ORGNO=").append(genQuote(OrgNo)).append(" AND B.DIVSCHEDULE=").append(genQuote(divSchedule)).append(") AND ").append(genQuote(Year + Month + Day)).append(" BETWEEN B.SDATE AND B.LDATE").append(" AND B.SDATE !=").append(genQuote(Year + Month + Day)).append(" UNION all ").append(" SELECT A.*").append(" from tb_").append(COMCODE).append("_e10 A ").append(" WITH(NOLOCK) where exists (select SCHDLNO ").append(" from tb_").append(COMCODE).append("_e11 ").append(" WITH(NOLOCK) where SCHDLNO = A.SCHDLNO ").append(" and(opencode = ").append(genQuote(USERID)).append(" or opencode in (select orgno").append(" from tb_").append(COMCODE).append("_n11 ").append(" WITH(NOLOCK) where userid=").append(genQuote(USERID)).append(")))").append(" AND A.USERID IN ( SELECT USERID ").append(" from tb_").append(COMCODE).append("_n11 ").append(" WITH(NOLOCK) WHERE ORGNO=").append(genQuote(OrgNo)).append(" AND A.DIVSCHEDULE=").append(genQuote(divSchedule)).append(") AND A.SDATE = ").append(genQuote(Year + Month + Day)).append(" AND (A.STIME IS NULL OR A.STIME = '')");
            } else if (divSchedule.equals("1") && OrgNo.equals("000000000000")) {
                sqlQuery.append("  SELECT B.* ").append(" from tb_").append(COMCODE).append("_e10 B").append(" WITH(NOLOCK) where EXISTS (SELECT SCHDLNO").append(" from tb_").append(COMCODE).append("_e11 ").append(" WITH(NOLOCK) WHERE SCHDLNO = B.SCHDLNO").append(" AND OPENCODE = ").append(genQuote(OrgNo)).append(") AND B.REPEATFLAG='0'").append(" AND ").append(genQuote(Year + Month + Day)).append("BETWEEN B.SDATE AND B.LDATE ").append(" AND B.SDATE != ").append(genQuote(Year + Month + Day)).append(" UNION all ").append(" SELECT A.* ").append(" from tb_").append(COMCODE).append("_e10 A").append(" WITH(NOLOCK) WHERE EXISTS (SELECT SCHDLNO").append(" from tb_").append(COMCODE).append("_e11 ").append(" WITH(NOLOCK) WHERE SCHDLNO = A.SCHDLNO").append(" AND OPENCODE = ").append(genQuote(OrgNo)).append(") AND A.REPEATFLAG='0'").append(" AND A.SDATE = ").append(genQuote(Year + Month + Day)).append(" AND (A.STIME IS NULL OR A.STIME = '')");
            } else if (divSchedule.equals("0")) {
                sqlQuery.append(" SELECT B.* ").append(" from tb_").append(COMCODE).append("_e10 B").append(" WITH(NOLOCK) WHERE ( EXISTS (SELECT SCHDLNO ").append(" from tb_").append(COMCODE).append("_e11 ").append(" WITH(NOLOCK) WHERE SCHDLNO = B.SCHDLNO").append(" AND(OPENCODE = ").append(genQuote(USERID)).append(" OR OPENCODE IN (SELECT ORGNO FROM TB_eknow_N11 WITH(NOLOCK) WHERE USERID = '1' )))").append(" AND B.DIVSCHEDULE = ").append(genQuote(divSchedule)).append(" OR B.USERID =").append(genQuote(USERID)).append(") AND B.REPEATFLAG!='0'").append(" AND ").append(genQuote(Year + Month + Day)).append(" BETWEEN B.SDATE AND B.LDATE ").append(" AND B.SDATE != ").append(genQuote(Year + Month + Day)).append(" UNION  all ").append(" SELECT A.*").append(" from tb_").append(COMCODE).append("_e10 A").append(" WITH(NOLOCK) WHERE ( EXISTS (SELECT SCHDLNO").append(" from tb_").append(COMCODE).append("_e11 ").append(" WHERE SCHDLNO = A.SCHDLNO ").append(" AND(OPENCODE = ").append(genQuote(USERID)).append(" OR OPENCODE IN (SELECT ORGNO ").append(" from tb_").append(COMCODE).append("_n11 ").append(" WITH(NOLOCK) WHERE USERID = ").append(genQuote(USERID)).append("))) AND A.DIVSCHEDULE = ").append(genQuote(divSchedule)).append(" OR A.USERID =").append(genQuote(USERID)).append(") AND A.REPEATFLAG!='0'").append(" AND A.SDATE = ").append(genQuote(Year + Month + Day)).append(" AND (A.STIME IS NULL OR A.STIME = '')");
            }
        } else if ("mysql".equals(strDbType)) {
        }
        if (!schdStatus.equals("0"))
            sqlQuery.append(" AND SCHDSTATUS =" + schdStatus);
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoPiSchedule::getSchdlEveryList " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getMainSchdlList(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String Year = dmProp.getString("Year");
    String Month = dmProp.getString("Month");
    String Day = dmProp.getString("Day");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer();
        if ("oracle".equals(strDbType)) {
            sqlQuery.append(" SELECT A.*,B.* FROM TB_").append(COMCODE).append("_E10 A, TB_").append(COMCODE).append("_G10 B ").append(" WHERE " + genQuote(Year + Month + Day) + " BETWEEN A.SDATE AND A.LDATE ").append(" AND A.USERID = " + genQuote(USERID)).append(" AND A.GRPNO = B.GRPNO (+) ").append(" ORDER BY A.TITLE ");
        } else if ("mssql".equals(strDbType)) {
            sqlQuery.append(" SELECT A.*,B.* FROM TB_").append(COMCODE).append("_E10 A WITH(NOLOCK) , TB_").append(COMCODE).append("_G10 B  WITH(NOLOCK) ").append(" WHERE " + genQuote(Year + Month + Day) + " BETWEEN A.SDATE AND A.LDATE ").append(" AND A.USERID = " + genQuote(USERID)).append(" AND A.GRPNO *= B.GRPNO  ").append(" ORDER BY A.TITLE ");
        } else if ("mysql".equals(strDbType)) {
            sqlQuery.append(" SELECT A.*,B.* FROM TB_").append(COMCODE).append("_E10 A, TB_").append(COMCODE).append("_G10 B ").append(" WHERE " + genQuote(Year + Month + Day) + " BETWEEN A.SDATE AND A.LDATE ").append(" AND A.USERID = " + genQuote(USERID)).append(" AND A.GRPNO = B.GRPNO (+) ").append(" ORDER BY A.TITLE ");
        }
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoPiSchedule::getMainSchdlList " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getSchdlList(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String Year = dmProp.getString("Year");
    String Month = dmProp.getString("Month");
    String Day = dmProp.getString("Day");
    String OrgNo = dmProp.getString("ORGNO");
    String divSchedule = dmProp.getString("DIVSCHEDULE");
    String schdStatus = dmProp.getString("SCHDSTATUS");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer();
        if ("oracle".equals(strDbType)) {
            if (divSchedule.equals("1") && !OrgNo.equals("000000000000")) {
                sqlQuery.append("SELECT A.SCHDLNO,A.TITLE,A.COMMENTS,A.DIVSCHEDULE,A.SDATE,A.STIME,LDATE,A.LTIME,A.RELATMAN,A.RELATAREA,A.REPEATFLAG,ALARMFLAG,A.USERID,A.BOXNO,A.PARENTNO,A.SCHDSTATUS ").append(",(SELECT USERNAME FROM TB_COMM_Z20 WHERE USERID=A.USERID) USERNAME ").append(" FROM  TB_").append(COMCODE).append("_E10 A ").append(" WHERE EXISTS (SELECT SCHDLNO ").append(" FROM TB_").append(COMCODE).append("_E11 ").append(" WHERE SCHDLNO = A.SCHDLNO ").append(" AND (OPENCODE = ").append(genQuote(USERID)).append(" OR OPENCODE IN (SELECT ORGNO FROM TB_").append(COMCODE).append("_N11 WHERE USERID = ").append(genQuote(USERID)).append(" ))) ").append(" AND A.USERID IN ( SELECT USERID FROM TB_").append(COMCODE).append("_N11 WHERE ORGNO=").append(genQuote(OrgNo)).append(" AND ").append(genQuote(Year + Month + Day)).append(" between SDATE and LDATE )").append(" AND A.DIVSCHEDULE=").append(genQuote(divSchedule));
            } else if (divSchedule.equals("1") && OrgNo.equals("000000000000")) {
                sqlQuery.append("SELECT A.SCHDLNO,A.TITLE,A.COMMENTS,A.DIVSCHEDULE,A.SDATE,A.STIME,LDATE,A.LTIME,A.RELATMAN,A.RELATAREA,A.REPEATFLAG,ALARMFLAG,A.USERID,A.BOXNO,A.PARENTNO,A.SCHDSTATUS ").append(", (SELECT USERNAME FROM TB_COMM_Z20 WHERE USERID=A.USERID) USERNAME ").append(" FROM  TB_").append(COMCODE).append("_E10 A ").append(" WHERE EXISTS (SELECT SCHDLNO ").append(" FROM TB_").append(COMCODE).append("_E11 ").append(" WHERE SCHDLNO = A.SCHDLNO ").append(" AND OPENCODE = ").append(genQuote(OrgNo)).append(") AND ").append(genQuote(Year + Month + Day)).append(" BETWEEN A.SDATE and A.LDATE").append(" AND A.REPEATFLAG='0'");
            } else if (divSchedule.equals("0")) {
                sqlQuery.append("SELECT A.SCHDLNO,A.TITLE,A.COMMENTS,A.DIVSCHEDULE,A.SDATE,A.STIME,LDATE,A.LTIME,A.RELATMAN,A.RELATAREA,A.REPEATFLAG,ALARMFLAG,A.USERID,A.BOXNO,A.PARENTNO,A.SCHDSTATUS ").append(", (SELECT USERNAME FROM TB_COMM_Z20 WHERE USERID=A.USERID) USERNAME ").append(" FROM  TB_").append(COMCODE).append("_E10 A ").append(" WHERE( EXISTS (SELECT SCHDLNO ").append(" FROM TB_").append(COMCODE).append("_E11 ").append(" WHERE SCHDLNO = A.SCHDLNO ").append("AND(OPENCODE = ").append(genQuote(USERID)).append(" OR OPENCODE IN (SELECT ORGNO FROM TB_").append(COMCODE).append("_N11 WHERE USERID = ").append(genQuote(USERID)).append(" ))) ").append(" AND A.DIVSCHEDULE = ").append(genQuote(divSchedule)).append(" OR A.USERID =").append(genQuote(USERID)).append(") AND ").append(genQuote(Year + Month + Day)).append(" BETWEEN A.SDATE and A.LDATE").append(" AND A.REPEATFLAG!='0'");
            }
        } else if ("mssql".equals(strDbType)) {
            if (divSchedule.equals("1") && !OrgNo.equals("000000000000")) {
                sqlQuery.append("SELECT A.SCHDLNO,A.TITLE,A.COMMENTS,A.DIVSCHEDULE,A.SDATE,A.STIME,LDATE,A.LTIME,A.RELATMAN,A.RELATAREA,A.REPEATFLAG,ALARMFLAG,A.USERID,A.BOXNO,A.PARENTNO,A.SCHDSTATUS ").append(",(SELECT USERNAME FROM TB_COMM_Z20 WITH(NOLOCK) WHERE USERID=A.USERID) USERNAME ").append(" FROM  TB_").append(COMCODE).append("_E10 A ").append(" WITH(NOLOCK) WHERE EXISTS (SELECT SCHDLNO ").append(" FROM TB_").append(COMCODE).append("_E11 ").append(" WITH(NOLOCK) WHERE SCHDLNO = A.SCHDLNO ").append(" AND (OPENCODE = ").append(genQuote(USERID)).append(" OR OPENCODE IN (SELECT ORGNO FROM TB_").append(COMCODE).append("_N11 WITH(NOLOCK) WHERE USERID = ").append(genQuote(USERID)).append(" ))) ").append(" AND A.USERID IN ( SELECT USERID FROM TB_").append(COMCODE).append("_N11 WITH(NOLOCK) WHERE ORGNO=").append(genQuote(OrgNo)).append(" AND ").append(genQuote(Year + Month + Day)).append(" between SDATE and LDATE )").append(" AND A.DIVSCHEDULE=").append(genQuote(divSchedule));
            } else if (divSchedule.equals("1") && OrgNo.equals("000000000000")) {
                sqlQuery.append("SELECT A.SCHDLNO,A.TITLE,A.COMMENTS,A.DIVSCHEDULE,A.SDATE,A.STIME,LDATE,A.LTIME,A.RELATMAN,A.RELATAREA,A.REPEATFLAG,ALARMFLAG,A.USERID,A.BOXNO,A.PARENTNO,A.SCHDSTATUS ").append(", (SELECT USERNAME FROM TB_COMM_Z20 WITH(NOLOCK) WHERE USERID=A.USERID) USERNAME ").append(" FROM  TB_").append(COMCODE).append("_E10 A ").append(" WITH(NOLOCK) WHERE EXISTS (SELECT SCHDLNO ").append(" FROM TB_").append(COMCODE).append("_E11 ").append(" WITH(NOLOCK) WHERE SCHDLNO = A.SCHDLNO ").append(" AND OPENCODE = ").append(genQuote(OrgNo)).append(") AND ").append(genQuote(Year + Month + Day)).append(" BETWEEN A.SDATE and A.LDATE").append(" AND A.REPEATFLAG='0'");
            } else if (divSchedule.equals("0")) {
                sqlQuery.append("SELECT A.SCHDLNO,A.TITLE,A.COMMENTS,A.DIVSCHEDULE,A.SDATE,A.STIME,LDATE,A.LTIME,A.RELATMAN,A.RELATAREA,A.REPEATFLAG,ALARMFLAG,A.USERID,A.BOXNO,A.PARENTNO,A.SCHDSTATUS, A.SHAREDW ").append(" , (SELECT USERNAME FROM TB_COMM_Z20 WHERE USERID=A.USERID) USERNAME  ").append(" FROM  TB_").append(COMCODE).append("_E10 A WITH(NOLOCK) ").append(" WHERE ( EXISTS (SELECT SCHDLNO ").append(" FROM TB_").append(COMCODE).append("_E11 WITH(NOLOCK) ").append(" WHERE SCHDLNO = A.SCHDLNO ").append(" AND (OPENCODE = ").append(genQuote(USERID)).append(" OR OPENCODE IN (SELECT ORGNO FROM TB_").append(COMCODE).append("_N11 WITH(NOLOCK) WHERE USERID = ").append(genQuote(USERID)).append(" ))) ").append(" OR A.USERID = ").append(genQuote(USERID)).append(" OR A.REPEATFLAG = '0'").append(") AND ").append(genQuote(Year + Month + Day)).append(" between SDATE and LDATE");
            }
        } else if ("mysql".equals(strDbType)) {
        }
        if (schdStatus.equals("6")) {
            sqlQuery.append(" AND SCHDSTATUS in('0','2','5')");
        } else {
            if (!schdStatus.equals("0"))
                sqlQuery.append(" AND SCHDSTATUS =" + schdStatus);
        }
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoPiSchedule::getSchdlList " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public int updateOtherNewSchedule(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String Sub2 = dmProp.getString("Sub2");
    String Sub4 = dmProp.getString("Sub4");
    GEmTB_E10 dm = (GEmTB_E10) dmProp.getObject("TB_E10");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    int rv = 0;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        StringBuffer SqlQuery = new StringBuffer().append(" delete from TB_" + COMCODE + "_E10 ").append(" WHERE SCHDLNO = " + genQuote(dm.getStrSchdlNo()) + " AND USERID =").append(genQuote(USERID));
        rv = stmt.executeUpdate(SqlQuery.toString());
        SqlQuery = new StringBuffer().append(" INSERT INTO TB_" + COMCODE + "_E10 (SCHDLNO,USERID,DIVSCHEDULE,TITLE,COMMENTS,SDATE,STIME,LDATE,LTIME,RELATMAN,RELATID,RELATAREA,REPEATFLAG,PARENTNO,ALARMFLAG,WRITERID) ").append("          SELECT " + genQuote(dm.getStrSchdlNo()) + ",USERID," + genQuote(dm.getStrDivSchedule()) + "," + genQuote(dm.getStrTitle()) + ",").append("         " + genQuote(dm.getStrComments()) + "," + genQuote(dm.getStrSdate()) + "," + genQuote(dm.getStrStime()) + "," + genQuote(dm.getStrLdate()) + "," + genQuote(dm.getStrLtime()) + ",").append("         " + genQuote(dm.getStrRelatMan()) + "," + genQuote(dm.getStrRelatId()) + "," + genQuote(dm.getStrRelatArea()) + "," + genQuote(dm.getStrRepeatFlag()) + "," + genQuote(dm.getStrParentNo()) + "," + genQuote(dm.getStrAlarmFlag()) + "," + genQuote(USERID)).append("          FROM TB_COMM_Z20 ");
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoPiScheduleTran::updateOtherNewSchedule " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoPiScheduleTran::updateOtherNewSchedule " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoPiScheduleTran::updateOtherNewSchedule " + e.getMessage());
        }
        conn.close();
    }
}

######


public int insertNewSchedule(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String schdStatus = dmProp.getString("SCHDSTATUS");
    String SHAREDW = dmProp.getString("SHAREDW");
    GEmTB_E10 dm = (GEmTB_E10) dmProp.getObject("TB_E10");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        String schdlno = getMaxNo(COMCODE, strDbType);
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(COMCODE).append("_E10(SCHDLNO,USERID,TITLE,COMMENTS,SDATE,STIME,LDATE,LTIME,RELATMAN,RELATAREA,REPEATFLAG,PARENTNO,ALARMFLAG,DIVSCHEDULE,SCHDSTATUS, SHAREDW ) ").append(" VALUES (" + genQuote(schdlno) + "," + genQuote(dm.getStrUserId()) + "," + genQuote(dm.getStrTitle()) + ",").append("         " + genQuote(dm.getStrComments()) + "," + genQuote(dm.getStrSdate()) + "," + genQuote(dm.getStrStime()) + "," + genQuote(dm.getStrLdate()) + "," + genQuote(dm.getStrLtime()) + ",").append("         " + genQuote(dm.getStrRelatMan()) + "," + genQuote(dm.getStrRelatArea()) + "," + genQuote(dm.getStrRepeatFlag()) + "," + genQuote(dm.getStrParentNo()) + "," + genQuote(dm.getStrAlarmFlag()) + ", " + genQuote(dm.getStrDivSchedule()) + "," + genQuote(schdStatus) + "," + genQuote(SHAREDW) + ")");
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        dmProp.setProperty("Schdlno", schdlno);
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoPiScheduleTran::insertNewSchedule22 " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoPiScheduleTran::insertNewSchedule111 " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoPiScheduleTran::insertNewSchedule3333333 " + e.getMessage());
        }
        conn.close();
    }
}

######


public int insertScheduleOpen(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String OpenCode = dmProp.getProperty("OPENCODE");
    String schdlno = dmProp.getProperty("SCHDLNO");
    String divScheduleOpen = dmProp.getProperty("DIVSCHEDULEOPEN");
    int rv = 0;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append("SELECT COUNT(*) FROM TB_").append(COMCODE).append("_E11 WHERE SCHDLNO =").append(genQuote(schdlno));
        conn.setAutoCommit(false);
        GCmResultSet rs = conn.executeQuery(SqlQuery.toString());
        rs.next();
        if (rs.getInt(1) > 0) {
            StringBuffer SqlQuery1 = new StringBuffer().append("DELETE FROM TB_").append(COMCODE).append("_E11 WHERE SCHDLNO =").append(genQuote(schdlno));
            stmt = conn.createStatement();
            stmt.executeUpdate(SqlQuery1.toString());
        }
        java.util.Vector vNotice = GCmFcts.getSplit(OpenCode, ",");
        java.util.Vector vNotisType = GCmFcts.getSplit(divScheduleOpen, ",");
        String sNotice = "";
        String sNotisType = "";
        for (int i = 0; i < vNotice.size(); i++) {
            sNotice = String.valueOf(vNotice.elementAt(i));
            sNotisType = String.valueOf(vNotisType.elementAt(i));
            StringBuffer SqlQuery2 = new StringBuffer().append("INSERT INTO TB_").append(COMCODE).append("_E11 (SCHDLNO,OPENCODE,DIVSCHDOPEN) VALUES(").append(genQuote(schdlno)).append(" , ").append(genQuote(sNotice)).append(", ").append(genQuote(sNotisType)).append(")");
            stmt = conn.createStatement();
            stmt.executeUpdate(SqlQuery2.toString());
            sNotice = "";
            sNotisType = "";
        }
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoPiScheduleTran::insertScheduleOpen " + ignored.getMessage());
        }
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoPiScheduleTran::insertScheduleOpen " + e.getMessage());
        }
        conn.close();
    }
}

######


public int updateSchedule(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    GEmTB_E10 dm = (GEmTB_E10) dmProp.getObject("TB_E10");
    String schdlno = dm.getStrSchdlNo();
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" UPDATE TB_").append(COMCODE).append("_E10 ").append(" SET DIVSCHEDULE=" + genQuote(dm.getStrDivSchedule()) + ",TITLE=" + genQuote(dm.getStrTitle()) + ",COMMENTS=" + genQuote(dm.getStrComments()) + ",SDATE=" + genQuote(dm.getStrSdate()) + ", ").append("     STIME=" + genQuote(dm.getStrStime()) + ",LDATE=" + genQuote(dm.getStrLdate()) + ",LTIME=" + genQuote(dm.getStrLtime()) + ",RELATMAN=" + genQuote(dm.getStrRelatMan()) + ", ").append("     RELATAREA=" + genQuote(dm.getStrRelatArea()) + ",REPEATFLAG=" + genQuote(dm.getStrRepeatFlag()) + ",PARENTNO=" + genQuote(dm.getStrParentNo()) + ",ALARMFLAG=" + genQuote(dm.getStrAlarmFlag())).append(" WHERE SCHDLNO=" + genQuote(dm.getStrSchdlNo()) + " AND USERID=" + genQuote(dm.getStrUserId()));
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        dmProp.setProperty("Schdlno", schdlno);
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoPiScheduleTran::updateSchedule " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoPiScheduleTran::updateSchedule " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoPiScheduleTran::updateSchedule " + e.getMessage());
        }
        conn.close();
    }
}

######


public int deleteSchedule(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    GEmTB_E10 dm = (GEmTB_E10) dmProp.getObject("TB_E10");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(COMCODE).append("_E10 ").append(" WHERE SCHDLNO = " + genQuote(dm.getStrSchdlNo()) + " AND USERID = " + genQuote(USERID));
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        StringBuffer SqlQuery1 = new StringBuffer().append(" DELETE FROM TB_").append(COMCODE).append("_E11 ").append(" WHERE SCHDLNO = ").append(genQuote(dm.getStrSchdlNo()));
        rv = stmt.executeUpdate(SqlQuery1.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoPiScheduleTran::deleteSchedule " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoPiScheduleTran::deleteSchedule " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoPiScheduleTran::deleteSchedule " + e.getMessage());
        }
        conn.close();
    }
}

######


public GCmResultSet getPosCodeList(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" select ORGNO, ORGNAME, READERNO,ISREGULAR,DESCRIPTION,ISUSABLE,ORDERBY,PARENTNO ").append(" from tb_eknow_n10 ").append(" where isRegular ='1' ").append(" ORDER BY ORGNO ");
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoPoPosition::getPosCodeList : " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getPosCodeInfo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String PosCode = dmProp.getString("PosCode");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT POSCODE, POSNAME, POSRANK ").append(" FROM TB_").append(COMCODE).append("_N20 ").append(" WHERE POSCODE = " + genQuote(PosCode));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoPoPosition:getPosCodeList : " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getPosCodeApllyUserCnt(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String PosCode = dmProp.getString("PosCode");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT DISTINCT POSCODE ").append(" FROM TB_COMM_Z20 ").append(" WHERE POSCODE IN (" + PosCode + ") AND COMCODE = " + genQuote(COMCODE));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        rs.next();
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoPoPosition::getPosCodeApllyUserCnt : " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getPosRankApllyUserCnt(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String PosRank = dmProp.getString("PosRank");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT DISTINCT POSCODE ").append(" FROM TB_COMM_Z20 ").append(" WHERE POSCODE IN ( ").append("SELECT POSCODE FROM TB_EKNOW_N20 WHERE POSRANK='").append(PosRank).append("') AND COMCODE = " + genQuote(COMCODE));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoPoPosition::getPosCodeApllyUserCnt : " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getComInfo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT COMNAME,CHKFILEDATE,CHKFILEINT,LMTFILESIZE,curfilesize,docread,").append(" docwrite,docdel,fldmake, flddel,brdread,brdwrite,brddel,chkalarmint,maxnotitab,").append(" maxnotilvl,MAILSVR,SMTPSVR,DEFLTEMAIL,MAXUSER ,ADDR,TEL,FAX,CEO,MANAGER,CHKPREVIEW ").append(" FROM TB_COMM_Z10 ").append(" WHERE COMCODE = " + genQuote(COMCODE));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoSyComInfo::getComInfo : " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getMailSvrInfo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT MAILSVR, SMTPSVR, BOARDLMT, DRAFTLMT, MAILLMT, DOCLMT,CHKPREVIEW ").append(" FROM TB_COMM_Z10 ").append(" WHERE COMCODE = " + genQuote(COMCODE));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoSyComInfo::getMailSvrInfo :" + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet currentUserCount(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT MAXUSER,(SELECT COUNT(USERID) FROM TB_COMM_Z20 WHERE COMCODE = T.COMCODE AND (USECHECK='Y' AND SECLVL!='9')) CURUSER ").append(" FROM TB_COMM_Z10 T ").append(" WHERE T.COMCODE = ").append(genQuote(COMCODE));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoSyComInfo::currentUserCount : " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getUserInfo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer();
        if ("oracle".equals(strDbType)) {
            sqlQuery.append("SELECT USERID, COMCODE, PASSWD, ORGNO, POSCODE, USERNAME, SECLVL, TEL1, TEL2, TEL3, ZIPCODE, ADDR, ALARMFLAG, ALARMTIME, ALARMREPEAT, ").append("ALARMTYPE, ALARMMAILON, ALARMDRFTON, LOGINFLAG, LOGINDATE, BOXNO, SIGNDOCNO, INDATE, BIRTHDAY, LUNARFLAG, PAGESIZE,REPLACEAPPRID, ").append("( SELECT ORGNAME  FROM TB_").append(COMCODE).append("_N10 WHERE ORGNO=T.ORGNO )ORGNAME, ").append("( SELECT ORGNAME FROM TB_").append(COMCODE).append("_N10 WHERE ORGNO=T.POSCODE)POSNAME,").append(" (SELECT AA.USERNAME FROM TB_COMM_Z20 AA WHERE AA.USERID = T.REPLACEAPPRID) APPRNAME ").append(" FROM TB_COMM_Z20 T ").append("WHERE USERID = ").append(genQuote(USERID));
        } else if ("mssql".equals(strDbType)) {
            sqlQuery.append("SELECT USERID, COMCODE, PASSWD, ORGNO, POSCODE, USERNAME, SECLVL, TEL1, TEL2, TEL3, ZIPCODE, ADDR, ALARMFLAG, ALARMTIME, ALARMREPEAT, ").append("ALARMTYPE, ALARMMAILON, ALARMDRFTON, LOGINFLAG, LOGINDATE, BOXNO, SIGNDOCNO, INDATE, BIRTHDAY, LUNARFLAG, PAGESIZE,REPLACEAPPRID, ").append("( SELECT ORGNAME  FROM TB_").append(COMCODE).append("_N10 WHERE ORGNO=T.ORGNO )ORGNAME, ").append("( SELECT ORGNAME FROM TB_").append(COMCODE).append("_N10 WHERE ORGNO=T.POSCODE)POSNAME,").append(" (SELECT AA.USERNAME FROM TB_COMM_Z20 AA WHERE AA.USERID = T.REPLACEAPPRID) APPRNAME ").append(" FROM TB_COMM_Z20 T ").append("WHERE USERID = ").append(genQuote(USERID));
        } else if ("mysql".equals(strDbType)) {
            sqlQuery.append("SELECT USERID, COMCODE, PASSWD, ORGNO, POSCODE, USERNAME, SECLVL, TEL1, TEL2, TEL3, ZIPCODE, ADDR, ALARMFLAG, ALARMTIME, ALARMREPEAT, ").append("ALARMTYPE, ALARMMAILON, ALARMDRFTON, LOGINFLAG, LOGINDATE, BOXNO, SIGNDOCNO, INDATE, BIRTHDAY, LUNARFLAG, PAGESIZE,REPLACEAPPRID, ").append("( SELECT ORGNAME  FROM TB_").append(COMCODE).append("_N10 WHERE ORGNO=T.ORGNO )ORGNAME, ").append("( SELECT ORGNAME FROM TB_").append(COMCODE).append("_N10 WHERE ORGNO=T.POSCODE)POSNAME,").append(" (SELECT AA.USERNAME FROM TB_COMM_Z20 AA WHERE AA.USERID = T.REPLACEAPPRID) APPRNAME ").append(" FROM TB_COMM_Z20 T ").append("WHERE USERID = ").append(genQuote(USERID));
        }
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoUiUserInfo::getUserInfo : " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getUserList(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String SortOpt = dmProp.getString("SortOpt");
    String SortID = dmProp.getString("SortID");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer();
        if ("oracle".equals(strDbType)) {
            sqlQuery.append("SELECT USERID, COMCODE, PASSWD, ORGNO, POSCODE, USERNAME, SECLVL, TEL1, TEL2, TEL3, ZIPCODE, ADDR, ALARMFLAG, ALARMTIME, ALARMREPEAT, ").append("ALARMTYPE, ALARMMAILON, ALARMDRFTON, LOGINFLAG, LOGINDATE, BOXNO, SIGNDOCNO, INDATE, BIRTHDAY, LUNARFLAG, PAGESIZE,REPLACEAPPRID, ").append("( SELECT ORGNAME  FROM TB_").append(COMCODE).append("_N10 WHERE ORGNO=T.ORGNO )ORGNAME, ").append("( SELECT POSNAME FROM TB_").append(COMCODE).append("_N20 WHERE POSCODE=T.POSCODE)POSNAME").append(" FROM TB_COMM_Z20 T ").append("WHERE USECHECK='Y' AND SECLVL NOT IN('9')");
        } else if ("mssql".equals(strDbType)) {
            sqlQuery.append("SELECT USERID, COMCODE, PASSWD, ORGNO, POSCODE, USERNAME, SECLVL, TEL1, TEL2, TEL3, ZIPCODE, ADDR, ALARMFLAG, ALARMTIME, ALARMREPEAT, ").append("ALARMTYPE, ALARMMAILON, ALARMDRFTON, LOGINFLAG, LOGINDATE, BOXNO, SIGNDOCNO, INDATE, BIRTHDAY, LUNARFLAG, PAGESIZE,REPLACEAPPRID, ").append("( SELECT ORGNAME  FROM TB_").append(COMCODE).append("_N10 WHERE ORGNO=T.ORGNO )ORGNAME, ").append("( SELECT POSNAME FROM TB_").append(COMCODE).append("_N20 WHERE POSCODE=T.POSCODE)POSNAME").append(" FROM TB_COMM_Z20 T ").append("WHERE USECHECK='Y' AND SECLVL NOT IN('9')");
        } else if ("mysql".equals(strDbType)) {
        }
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoUiUserInfo::getUserList : " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getIdRegular(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String UserNo = dmProp.getString("UserNo");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer().append(" SELECT USERID ").append(" FROM TB_COMM_Z20 ").append(" WHERE USERID = " + genQuote(UserNo));
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoUiUserInfo::getIdRegular : " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public int getUserCnt() {
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        String sqlQuery = "SELECT COUNT(USERID)" + " FROM TB_COMM_Z20 " + " WHERE USECHECK='Y' AND SECLVL NOT IN('9')";
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        if (rs.next()) {
            return rs.getInt(1);
        }
        return 0;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoUiUserInfo::getIdRegular : " + e.getMessage());
        return 0;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getUseCheck(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    try {
        conn = GCmDbManager.getInstance().getConnection();
        String sqlQuery = "SELECT USECHECK FROM TB_COMM_Z20 WHERE USERID =" + genQuote(USERID);
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoUiUserInfo::getUseCheck : " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public GCmResultSet getUserInfoCommon(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer sqlQuery = new StringBuffer();
        if ("oracle".equals(strDbType)) {
        } else if ("mssql".equals(strDbType)) {
            sqlQuery.append("SELECT USERID,  PASSWD,   USERNAME,  TEL1, TEL2, TEL3, ZIPCODE, ADDR ").append(" FROM TB_COMM_Z20 ").append("WHERE USERID = ").append(genQuote(USERID));
        } else if ("mysql".equals(strDbType)) {
        }
        GCmLog.writeLog(" GCoUiUserInfo::getUserInfoCommon : " + sqlQuery.toString());
        GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
        return rs;
    } catch (Exception e) {
        GCmLog.writeLog(" GCoUiUserInfo::getUserInfo : " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


public int updateUserPassword(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String Oldpasswd = dmProp.getString("Oldpasswd");
    String Passwd = dmProp.getString("Passwd");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" UPDATE TB_COMM_Z20 ").append(" SET PASSWD = " + genQuote(Passwd)).append(" WHERE USERID = " + genQuote(USERID) + " AND PASSWD = " + genQuote(Oldpasswd));
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoUiUserInfoTran::updateUserPassword : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoUiUserInfoTran::updateUserPassword : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoUiUserInfoTran::updateUserPassword : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int updatePrivateUserInfo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    GEmTB_Z20 tbz20 = (GEmTB_Z20) dmProp.getObject("tbz20");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    GCmResultSet rs = null;
    StringBuffer SqlQuery = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        SqlQuery = new StringBuffer().append(" UPDATE TB_COMM_Z20 ").append(" SET USERNAME=" + genQuote(tbz20.getStrUserName()) + ", ALARMFLAG=" + genQuote(tbz20.getStrAlarmFlag()) + ", ALARMTIME=" + tbz20.getStrAlarmTime() + ",").append("     ALARMREPEAT=" + tbz20.getStrAlarmRepeat() + ", ALARMTYPE=" + genQuote(tbz20.getStrAlarmType()) + ", ALARMMAILON=" + genQuote(tbz20.getStrAlarmMailOn()) + ", ALARMDRFTON=" + genQuote(tbz20.getStrAlarmDrftOn()) + ",").append("     TEL1=" + genQuote(tbz20.getStrTel1()) + ", TEL2=" + genQuote(tbz20.getStrTel2()) + ", TEL3=" + genQuote(tbz20.getStrTel3()) + " , ZIPCODE=" + genQuote(tbz20.getStrZipCode()) + ",").append("     ADDR=" + genQuote(tbz20.getStrAddr()) + ", INDATE=" + genQuote(tbz20.getStrInDate()) + ", BIRTHDAY=" + genQuote(tbz20.getStrBirthDay()) + ", LUNARFLAG=" + genQuote(tbz20.getStrLunarFlag()) + ", ORGNO = " + genQuote(tbz20.getStrOrgNo()) + " , POSCODE = " + genQuote(tbz20.getStrPosCode()) + ", BOXNO = " + genQuote(tbz20.getStrBoxNo()) + ", PAGESIZE = " + genQuote(tbz20.getStrPageSize()) + " , REPLACEAPPRID=" + genQuote(tbz20.getStrReplaceApprId())).append(" WHERE USERID = " + genQuote(USERID));
        rv = stmt.executeUpdate(SqlQuery.toString());
        if (rv <= 0)
            throw new Exception(" During updatePrivateUserInfo error !!!");
        SqlQuery = new StringBuffer().append(" SELECT COUNT(*) FROM TB_").append(COMCODE).append("_N11 WHERE USERID=").append(genQuote(USERID)).append(" AND DEFLT='0'");
        rs = conn.executeQuery(SqlQuery.toString());
        rs.next();
        if (rs.getInt(1) > 0) {
            SqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(COMCODE).append("_N11 ").append(" WHERE USERID = " + genQuote(USERID)).append(" AND DEFLT ='0' ");
            rv = stmt.executeUpdate(SqlQuery.toString());
        }
        SqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(COMCODE).append("_N11 ").append(" WHERE USERID = " + genQuote(USERID)).append(" AND ORGNO = ").append(genQuote(tbz20.getStrOrgNo()));
        rv = stmt.executeUpdate(SqlQuery.toString());
        SqlQuery = new StringBuffer().append("INSERT INTO TB_").append(COMCODE).append("_N11 VALUES(").append(genQuote(tbz20.getStrOrgNo())).append(",").append(genQuote(USERID)).append(", '0')");
        rv = stmt.executeUpdate(SqlQuery.toString());
        if (rv <= 0)
            throw new Exception(" During updatePrivateUserInfo error !!!");
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoUiUserInfoTran::updatePrivateUserInfo : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoUiUserInfoTran::updatePrivateUserInfo : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoUiUserInfoTran::updatePrivateUserInfo : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int updateUserInfo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    GEmTB_Z20 tbz20 = (GEmTB_Z20) dmProp.getObject("tbz20");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" UPDATE TB_COMM_Z20 ").append(" SET USERNAME=" + genQuote(tbz20.getStrUserName()) + ", ALARMFLAG=" + genQuote(tbz20.getStrAlarmFlag()) + ", ALARMTIME=" + tbz20.getStrAlarmTime() + ",").append("     ALARMREPEAT=" + tbz20.getStrAlarmRepeat() + ", ALARMTYPE=" + genQuote(tbz20.getStrAlarmType()) + ", ALARMMAILON=" + genQuote(tbz20.getStrAlarmMailOn()) + ", ALARMDRFTON=" + genQuote(tbz20.getStrAlarmDrftOn()) + ",").append("     TEL1=" + genQuote(tbz20.getStrTel1()) + ", TEL2=" + genQuote(tbz20.getStrTel2()) + ", TEL3=" + genQuote(tbz20.getStrTel3()) + " , ZIPCODE=" + genQuote(tbz20.getStrZipCode()) + ", PASSWD=" + genQuote(tbz20.getStrPassWd()) + ", SECLVL=" + genQuote(tbz20.getStrSecLvl()) + ",").append("     ADDR=" + genQuote(tbz20.getStrAddr()) + ", INDATE=" + genQuote(tbz20.getStrInDate()) + ", BIRTHDAY=" + genQuote(tbz20.getStrBirthDay()) + ", LUNARFLAG=" + genQuote(tbz20.getStrLunarFlag()) + ", ORGNO = " + genQuote(tbz20.getStrOrgNo()) + " , POSCODE = " + genQuote(tbz20.getStrPosCode())).append(" WHERE USERID = " + genQuote(tbz20.getStrUserId()));
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        GCmLog.writeLog(" GCoUiUserInfoTran::updateUserInfo : " + SqlQuery.toString());
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoUiUserInfoTran::updateUserInfo : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoUiUserInfoTran::updateUserInfo : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoUiUserInfoTran::updateUserInfo : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int deleteUserInfo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String USERID = dmProp.getString("USERID");
    String PASSWD = dmProp.getString("PASSWD");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" DELETE TB_COMM_Z20 ").append(" WHERE USERID = '" + USERID + "'").append(" AND  PASSWD = '" + PASSWD + "'");
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        GCmLog.writeLog(" GCoUiUserInfoTran::updateUserInfo : " + SqlQuery.toString());
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoUiUserInfoTran::updateUserInfo : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoUiUserInfoTran::updateUserInfo : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoUiUserInfoTran::updateUserInfo : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int updateUserInfoCommon(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    GEmTB_Z20 tbz20 = (GEmTB_Z20) dmProp.getObject("tbz20");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" UPDATE TB_COMM_Z20 ").append(" SET USERNAME=" + genQuote(tbz20.getStrUserName()) + ", ALARMFLAG=" + genQuote(tbz20.getStrAlarmFlag()) + ", ALARMTIME=" + tbz20.getStrAlarmTime() + ",").append("     ALARMREPEAT=" + tbz20.getStrAlarmRepeat() + ", ALARMTYPE=" + genQuote(tbz20.getStrAlarmType()) + ", ALARMMAILON=" + genQuote(tbz20.getStrAlarmMailOn()) + ", ALARMDRFTON=" + genQuote(tbz20.getStrAlarmDrftOn()) + ",").append("     TEL1=" + genQuote(tbz20.getStrTel1()) + ", TEL2=" + genQuote(tbz20.getStrTel2()) + ", TEL3=" + genQuote(tbz20.getStrTel3()) + " , ZIPCODE=" + genQuote(tbz20.getStrZipCode()) + ", PASSWD=" + genQuote(tbz20.getStrPassWd()) + ", SECLVL=" + genQuote(tbz20.getStrSecLvl()) + ",").append("     ADDR=" + genQuote(tbz20.getStrAddr()) + ", INDATE=" + genQuote(tbz20.getStrInDate()) + ", BIRTHDAY=" + genQuote(tbz20.getStrBirthDay()) + ", LUNARFLAG=" + genQuote(tbz20.getStrLunarFlag()) + ", ORGNO = " + genQuote(tbz20.getStrOrgNo()) + " , POSCODE = " + genQuote(tbz20.getStrPosCode()) + ", BOXNO = " + genQuote(tbz20.getStrBoxNo())).append(" WHERE USERID = " + genQuote(tbz20.getStrUserId()));
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoUiUserInfoTran::updateUserInfo : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoUiUserInfoTran::updateUserInfo : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoUiUserInfoTran::updateUserInfo : " + e.getMessage());
        }
        conn.close();
    }
}

######


public int insertNewUser(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    GEmTB_Z20 tbz20 = (GEmTB_Z20) dmProp.getObject("tbz20");
    int rv;
    GCmConnection conn = null;
    Statement stmt = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        StringBuffer SqlQuery = new StringBuffer().append(" INSERT INTO TB_COMM_Z20 ").append(" ( USERID,PASSWD,ORGNO,POSCODE,USERNAME,SECLVL,ALARMFLAG,ALARMTIME,ALARMREPEAT,ALARMTYPE,ALARMMAILON, ALARMDRFTON, ").append("   LOGINFLAG,LOGINDATE,BOXNO,SIGNDOCNO,COMCODE,TEL1,TEL2,TEL3,ZIPCODE,ADDR,INDATE,BIRTHDAY,LUNARFLAG) ").append("   VALUES(" + genQuote(tbz20.getStrUserId()) + "," + genQuote(tbz20.getStrPassWd()) + "," + genQuote(tbz20.getStrOrgNo()) + ",").append("          " + genQuote(tbz20.getStrPosCode()) + "," + genQuote(tbz20.getStrUserName()) + "," + genQuote(tbz20.getStrSecLvl()) + ",").append("          " + genQuote(tbz20.getStrAlarmFlag()) + "," + tbz20.getStrAlarmTime() + "," + tbz20.getStrAlarmRepeat() + ",").append("          " + genQuote(tbz20.getStrAlarmType()) + "," + genQuote(tbz20.getStrAlarmMailOn()) + "," + genQuote(tbz20.getStrAlarmDrftOn()) + ",").append("          " + genQuote(tbz20.getStrLogInFlag()) + "," + genQuote(tbz20.getStrLogInDate()) + "," + genQuote(tbz20.getStrBoxNo()) + ",").append("          " + genQuote(tbz20.getStrSignDocNo()) + "," + genQuote(COMCODE) + "," + genQuote(tbz20.getStrTel1()) + ",").append("          " + genQuote(tbz20.getStrTel2()) + "," + genQuote(tbz20.getStrTel3()) + "," + genQuote(tbz20.getStrZipCode()) + ",").append("          " + genQuote(tbz20.getStrAddr()) + "," + genQuote(tbz20.getStrInDate()) + "," + genQuote(tbz20.getStrBirthDay()) + ",").append("          " + genQuote(tbz20.getStrLunarFlag()) + ")");
        stmt = conn.createStatement();
        conn.setAutoCommit(false);
        rv = stmt.executeUpdate(SqlQuery.toString());
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoUiUserInfoTran::insertNewUser : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoUiUserInfoTran::insertNewUser : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (Exception e) {
            GCmLog.writeLog(" GCoUiUserInfoTran::insertNewUser : " + e.getMessage());
        }
        conn.close();
    }
}

######


public boolean insertMail(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strMailNo = dmProp.getString("MAILNO");
    String strDocNo = dmProp.getString("DOCNO");
    String strSeqno = dmProp.getString("SEQNO");
    String strMailType = dmProp.getString("MAILTYPE");
    String strSendType = dmProp.getString("SENDTYPE");
    String strDlvrType = dmProp.getString("DLVRTYPE");
    String strTitle = dmProp.getString("TITLE");
    String strRegDate = dmProp.getString("REGDATE");
    String strSndrId = dmProp.getString("SNDRID");
    String strSndrName = dmProp.getString("SNDRNAME");
    String strToId = dmProp.getString("TOID");
    String strToName = dmProp.getString("TONAME");
    String strCcId = dmProp.getString("CCID");
    String strCcName = dmProp.getString("CCNAME");
    String strBccId = dmProp.getString("BCCID");
    String strBccName = dmProp.getString("BCCNAME");
    int intAttNum = dmProp.getInt("ATTNUM");
    int intRcvrNum = dmProp.getInt("RCVRNUM");
    int intReadNum = dmProp.getInt("READNUM");
    String strAcctName = dmProp.getString("ACCTNAME");
    StringBuffer sqlQuery = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_C10 ").append(" (MAILNO, DOCNO, MAILTYPE, SENDTYPE, DLVRTYPE, TITLE, REGDATE, ").append(" SNDRID, SNDRNAME, TOID, TONAME, CCID, CCNAME, BCCID, BCCNAME, ").append(" ATTNUM, RCVRNUM, READNUM ");
        if (strAcctName != null && !strAcctName.equals(""))
            sqlQuery.append(", ACCTNAME ");
        sqlQuery.append(" ) VALUES ( ").append(genQuote(strMailNo) + ", ").append(genQuote(strDocNo) + ", ").append(genQuote(strMailType) + ", ").append(genQuote(strSendType) + ", ").append(genQuote(strDlvrType) + ", ").append(genQuote(strTitle) + ", ").append(genQuote(strRegDate) + ", ").append(genQuote(strSndrId) + ", ").append(genQuote(strSndrName) + ", ").append(genQuote(strToId) + ", ").append(genQuote(strToName) + ", ").append(genQuote(strCcId) + ", ").append(genQuote(strCcName) + ", ").append(genQuote(strBccId) + ", ").append(genQuote(strBccName) + ", ").append(intAttNum).append(", ").append(intRcvrNum).append(", ").append(intReadNum);
        if (strAcctName != null && !strAcctName.equals(""))
            sqlQuery.append(", " + genQuote(strAcctName));
        sqlQuery.append(" ) ");
        GCmLog.writeLog("GCoWmMailTran :: insertMail " + sqlQuery.toString());
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("GCoWmMailTran :: insertMail" + ignored.getMessage());
            GCmLog.writeLog("GCoWmMailTran :: insertMail" + sqlQuery.toString());
        }
        GCmLog.writeLog("GCoWmMailTran :: insertMail " + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean insertRegMail(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    StringBuffer sqlQuery = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        String strComCode = dmProp.getString("COMCODE");
        String strBoxNo = dmProp.getString("BOXNO");
        String strMailNo = dmProp.getString("MAILNO");
        String strSrType = dmProp.getString("SRTYPE");
        String strReadFlag = dmProp.getString("READFLAG");
        String strTrashFlag = dmProp.getString("TRASHFLAG");
        String strUserid = dmProp.getString("USERID");
        String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
        if (strBoxNo == null || strBoxNo.length() == 0) {
            strBoxNo = GCmConstDef.MAIL_INBOX;
        }
        GTpMail mail = new GTpMail();
        conn.setAutoCommit(false);
        if ("oracle".equals(strDbType)) {
            sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_C20 ").append(" (REGMAILNO, BOXNO, MAILNO, SRTYPE, READFLAG, TRASHFLAG,USERID) ").append(" SELECT NVL(MAX(REGMAILNO)+1,TO_CHAR(sysdate,'yyyymmdd') || '0001'),").append(genQuote(strBoxNo) + ", ").append(genQuote(strMailNo) + ", ").append(genQuote(strSrType) + ", ").append(genQuote(strReadFlag) + ", ").append(genQuote(strTrashFlag) + ", ").append(genQuote(strUserid)).append(" FROM TB_").append(strComCode).append("_C20 ").append(" WHERE SUBSTR(REGMAILNO,1,8) = TO_CHAR(sysdate,'yyyymmdd')  ");
        } else if ("mssql".equals(strDbType)) {
            sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_C20 ").append(" (REGMAILNO, BOXNO, MAILNO, SRTYPE, READFLAG, TRASHFLAG,USERID) ").append(" SELECT left(CONVERT(varchar, getdate(), 112),10)+RIGHT(RIGHT(ISNULL(MAX(REGMAILNO),'111111110000'),6)+1,4),").append(genQuote(strBoxNo) + ", ").append(genQuote(strMailNo) + ", ").append(genQuote(strSrType) + ", ").append(genQuote(strReadFlag) + ", ").append(genQuote(strTrashFlag) + ", ").append(genQuote(strUserid)).append(" FROM TB_").append(strComCode).append("_C20 ").append(" WHERE SUBSTRING(REGMAILNO,1,8)=left(CONVERT(varchar, getdate(), 112),10) ");
        }
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("GCoWmMailTran :: insertRegMail" + ignored.getMessage());
        }
        GCmLog.writeLog("GCoWmMailTran :: insertRegMail" + e.getMessage());
        GCmLog.writeLog("GCoWmMailTran :: insertRegMail" + sqlQuery.toString());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean insertRcvMail(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strMailNo = dmProp.getString("MAILNO");
    String strRcvrId = dmProp.getString("RCVRID");
    String strRcvrName = dmProp.getString("RCVRNAME");
    String strReadFlag = dmProp.getString("READFLAG");
    String strReadDate = dmProp.getString("READDATE");
    String strRcvType = dmProp.getString("RCVTYPE");
    String strMailType = dmProp.getString("MAILTYPE");
    StringBuffer sqlQuery = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        sqlQuery = new StringBuffer().append(" INSERT INTO TB_").append(strComCode).append("_C11 ").append(" (MAILNO, RCVRID,MAILTYPE, RCVRNAME, READFLAG, READDATE,RCVTYPE) ").append(" VALUES ( ").append(genQuote(strMailNo) + ", ").append(genQuote(strRcvrId) + ", ").append(genQuote(strMailType) + ", ").append(genQuote(strRcvrName) + ", ").append(genQuote(strReadFlag) + ", ").append(genQuote(strReadDate) + ", ").append(genQuote(strRcvType)).append(" ) ");
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("GCoWmMailTran  :: insertRcvMail" + ignored.getMessage());
            GCmLog.writeLog("GCoWmMailTran :: insertRcvMail" + sqlQuery.toString());
        }
        GCmLog.writeLog("GCoWmMailTran :: insertRcvMail " + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean deleteRegMail(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strRegMailNo = dmProp.getString("REGMAILNO");
    StringBuffer sqlQuery = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        sqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(strComCode).append("_C20 ").append(" WHERE REGMAILNO =  " + genQuote(strRegMailNo));
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("GCoWmMailTran :: deleteRegMail " + ignored.getMessage());
            GCmLog.writeLog("GCoWmMailTran :: deleteRegMail" + sqlQuery.toString());
        }
        GCmLog.writeLog("GCoWmMailTran :: deleteRegMail " + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean deleteMailAll(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) throws GCmProcessingErrorException, GCmParameterErrorException {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strMailNo = dmProp.getString("MAILNO");
    String strRegMailNo = dmProp.getString("REGMAILNO");
    String strPpath = dmProp.getString("PPATH");
    String strDocNo = "";
    String strSeq = "";
    String strFileName = "";
    String strFileExt = "";
    String strVpath = "";
    String strFilePath = "";
    java.io.File delFile = null;
    StringBuffer sqlQuery = null;
    int intCnt = 0;
    int refCnt = 0;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        if ((strMailNo == null) || (strMailNo.equals(""))) {
            throw new GCmParameterErrorException("deleteMailAll() MAILNO parameter error..");
        }
        conn.setAutoCommit(false);
        sqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(strComCode).append("_C20 ").append(" WHERE REGMAILNO =  " + genQuote(strRegMailNo));
        conn.executeUpdate(sqlQuery.toString());
        StringBuffer sqlQuery2 = new StringBuffer().append(" SELECT COUNT(*) FROM TB_").append(strComCode).append("_C20 ").append(" WHERE MAILNO =  " + genQuote(strMailNo));
        GCmResultSet rs = conn.executeQuery(sqlQuery2.toString());
        while (rs.next()) {
            intCnt = rs.getInt(1);
        }
        if (intCnt == 0) {
            StringBuffer sqlQuery3 = new StringBuffer().append(" SELECT DOCNO FROM TB_").append(strComCode).append("_C10 ").append(" WHERE MAILNO =  " + genQuote(strMailNo));
            GCmResultSet rs2 = conn.executeQuery(sqlQuery3.toString());
            while (rs2.next()) {
                strDocNo = rs2.getString("DOCNO");
            }
            StringBuffer sqlQuery4 = new StringBuffer().append(" DELETE FROM TB_").append(strComCode).append("_C11 ").append(" WHERE MAILNO = " + genQuote(strMailNo));
            conn.executeUpdate(sqlQuery4.toString());
            StringBuffer sqlQuery5 = new StringBuffer().append(" DELETE FROM TB_").append(strComCode).append("_C10 ").append(" WHERE MAILNO = " + genQuote(strMailNo));
            conn.executeUpdate(sqlQuery5.toString());
            StringBuffer sqlQuery6 = new StringBuffer().append(" SELECT DOCNO, SEQ, CONTTYPE, TITLE, FILEEXT, FILENAME, VPATH, MIMETYPE, FILESIZE, ORGNAME, ").append(" ORGPATH,REGUSER,REGDATE,MODUSER,MODDATE FROM TB_").append(strComCode).append("_L11 ").append(" WHERE DOCNO = " + genQuote(strDocNo));
            GCmResultSet rs3 = conn.executeQuery(sqlQuery6.toString());
            StringBuffer sqlQuery9 = new StringBuffer().append(" select count(*)CNT from tb_").append(strComCode).append("_b10 where docno=").append(genQuote(strDocNo));
            GCmResultSet rs9 = conn.executeQuery(sqlQuery9.toString());
            rs9.next();
            refCnt = rs9.getInt("CNT");
            if (refCnt == 0) {
                while (rs3.next()) {
                    StringBuffer sqlQuery7 = new StringBuffer();
                    strSeq = rs3.getString("SEQ");
                    strFileName = rs3.getString("FILENAME");
                    strFileExt = rs3.getString("FILEEXT");
                    strVpath = rs3.getString("VPATH");
                    strFilePath = strPpath + strVpath + strFileName;
                    sqlQuery7.append(" DELETE FROM TB_").append(strComCode).append("_L11 ").append(" WHERE DOCNO = " + genQuote(strDocNo)).append(" AND SEQ = " + genQuote(strSeq));
                    conn.executeUpdate(sqlQuery7.toString());
                    delFile = new java.io.File(strPpath, strVpath + strFileName);
                    if (delFile.isFile())
                        delFile.delete();
                }
                StringBuffer sqlQuery8 = new StringBuffer().append(" DELETE FROM TB_").append(strComCode).append("_L10 ").append(" WHERE DOCNO = " + genQuote(strDocNo));
                conn.executeUpdate(sqlQuery8.toString());
            }
            if (!strVpath.equals("")) {
                delFile = new java.io.File(strPpath, strVpath + strDocNo + "_00.eml");
                if (delFile.isFile())
                    delFile.delete();
            }
        }
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("GCoWmMailTran :: deleteMailAll " + ignored.getMessage());
            GCmLog.writeLog("GCoWmMailTran :: deleteMailAll" + sqlQuery.toString());
        }
        GCmLog.writeLog("GCoWmMailTran :: deleteMailAll " + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public int deleteTempMailInfo(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    String COMCODE = dmProp.getString("COMCODE");
    String Docno = dmProp.getString("DOCNO");
    int rv = 0;
    int refcnt = 0;
    GCmConnection conn = null;
    Statement stmt = null;
    GCmResultSet rs = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        stmt = conn.createStatement();
        StringBuffer SqlQuery = new StringBuffer();
        SqlQuery.append(" SELECT COUNT(*) REFCNT FROM TB_" + COMCODE + "_B10 ").append(" WHERE DOCNO=").append(genQuote(Docno));
        rs = conn.executeQuery(SqlQuery.toString());
        if (rs.next()) {
            refcnt = rs.getInt("REFCNT");
        }
        if (refcnt == 0) {
            SqlQuery = new StringBuffer();
            SqlQuery.append(" DELETE FROM TB_" + COMCODE + "_L10 ").append(" WHERE DOCNO = " + genQuote(Docno));
            rv = stmt.executeUpdate(SqlQuery.toString());
            SqlQuery = new StringBuffer().append(" DELETE FROM TB_" + COMCODE + "_L11 ").append(" WHERE DOCNO = " + genQuote(Docno));
            stmt = conn.createStatement();
            rv = stmt.executeUpdate(SqlQuery.toString());
        }
        conn.commit();
        return rv;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog(" GCoWmMailTran::deleteTempMailInfo : " + ignored.getMessage());
        }
        GCmLog.writeLog(" GCoWmMailTran::deleteTempMailInfo : " + e.getMessage());
        return -1;
    } finally {
        try {
            stmt.close();
        } catch (SQLException e) {
            GCmLog.writeLog(" GCoWmMailTran::deleteTempMailInfo : " + e.getMessage());
        }
        conn.close();
    }
}

######


public boolean deleteMail(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strRegMailNo = dmProp.getString("MAILNO");
    StringBuffer sqlQuery = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        sqlQuery = new StringBuffer().append(" DELETE FROM TB_").append(strComCode).append("_C10 ").append(" WHERE MAILNO =  " + genQuote(strRegMailNo));
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("GCoWmMailTran :: deleteMail" + ignored.getMessage());
            GCmLog.writeLog("GCoWmMailTran :: deleteMail" + sqlQuery.toString());
        }
        GCmLog.writeLog("GCoWmMailTran :: deleteMail" + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean moveBox(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strUserId = dmProp.getString("USERID");
    String strRegMailNo = dmProp.getString("REGMAILNO");
    String strTarget = dmProp.getString("TARGET");
    String strSrc = dmProp.getString("SRC");
    StringBuffer sqlQuery = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        sqlQuery = new StringBuffer().append(" UPDATE TB_eknow_C20 ").append(" SET BOXNO = ").append(genQuote(strTarget)).append(" WHERE BOXNO = ").append(genQuote(strSrc)).append(" AND REGMAILNO = ").append(genQuote(strRegMailNo));
        conn.executeUpdate(sqlQuery.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("GCoWmMailTran :: moveBox" + ignored.getMessage());
            GCmLog.writeLog("GCoWmMailTran :: moveBox" + sqlQuery.toString());
        }
        GCmLog.writeLog("GCoWmMailTran :: moveBox" + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean emptyBox(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strDelBoxNo = "";
    StringBuffer sqlQuery = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        String strComCode = dmProp.getString("COMCODE");
        String strUserId = dmProp.getString("USERID");
        String strBoxNo = dmProp.getString("BOXNO");
        String strExecClass = dmProp.getString("EXECCLASS");
        String strPpath = dmProp.getString("PPATH");
        conn.setAutoCommit(false);
        if (strExecClass.equals(GCmConstDef.MAIL_DELBOX)) {
            sqlQuery = new StringBuffer().append(" SELECT REGMAILNO, MAILNO FROM TB_").append(strComCode).append("_C20 ").append(" WHERE BOXNO =  " + genQuote(strBoxNo));
            GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
            while (rs.next()) {
                GCmProperties dmDel = new GCmProperties();
                dmDel.setValue("COMCODE", strComCode);
                dmDel.setValue("MAILNO", rs.getString("MAILNO"));
                dmDel.setValue("REGMAILNO", rs.getString("REGMAILNO"));
                dmDel.setValue("PPATH", strPpath);
                deleteMailAll(cp, dmDel, msgInfo);
            }
        } else {
            StringBuffer sqlQuery2 = new StringBuffer().append(" SELECT BOXNO FROM TB_").append(strComCode).append("_M10 ").append(" WHERE BOXCLASS = " + genQuote(GCmConstDef.BOXCLASS_MAIL)).append(" AND EXECCLASS = " + genQuote(GCmConstDef.MAIL_DELBOX)).append(" AND BOXTYPE = " + genQuote(GCmConstDef.BOXTYPE_PRIVATE)).append(" AND USERID = " + genQuote(strUserId));
            GCmResultSet rs2 = conn.executeQuery(sqlQuery2.toString());
            while (rs2.next()) {
                strDelBoxNo = rs2.getString("BOXNO");
            }
            if (!strDelBoxNo.equals("")) {
                StringBuffer sqlQuery3 = new StringBuffer().append(" UPDATE TB_").append(strComCode).append("_C20 ").append(" SET BOXNO = " + genQuote(strDelBoxNo)).append(" WHERE BOXNO = " + genQuote(strBoxNo));
                conn.executeUpdate(sqlQuery3.toString());
            }
        }
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("GCoWmMailTran :: deleteMailAll " + ignored.getMessage());
            GCmLog.writeLog("GCoWmMailTran :: deleteMailAll" + sqlQuery.toString());
        }
        GCmLog.writeLog("GCoWmMailTran :: deleteMailAll " + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean updateMoveMail(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    String strComCode = dmProp.getString("COMCODE");
    String strBoxNo = dmProp.getString("BOXNO");
    String strRegMailNo = dmProp.getString("REGMAILNO");
    StringBuffer sqlQuery = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        StringBuffer sqlQuery3 = new StringBuffer().append(" UPDATE TB_").append(strComCode).append("_C20 ").append(" SET BOXNO = " + genQuote(strBoxNo)).append(" WHERE REGMAILNO = " + genQuote(strRegMailNo));
        conn.executeUpdate(sqlQuery3.toString());
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("GCoWmMailTran :: updateMoveMail" + ignored.getMessage());
            GCmLog.writeLog("GCoWmMailTran :: updateMoveMail" + sqlQuery.toString());
        }
        GCmLog.writeLog("GCoWmMailTran :: updateMoveMail" + e.getMessage());
        return false;
    } finally {
        conn.close();
    }
}

######


public boolean setCopyFld(GCmProperties cp, GCmProperties dmProp, GCmMsgInfo msgInfo) {
    GCmConnection conn = null;
    StringBuffer sqlQuery = null;
    GCmResultSet rs = null;
    String strDbType = cp.getProperty("eknoware.db.type").toLowerCase();
    String COMCODE = dmProp.getString("COMCODE");
    String BOXNO = dmProp.getString("BOXNO");
    String REFNO = dmProp.getString("REFNO");
    String USERID = dmProp.getString("USERID");
    String DOCNO = null;
    String FLDNO = null;
    int intRet = 0;
    java.io.File srcFile = null;
    java.io.File desFile = null;
    String strDocNo = "";
    String strOldDocNo = "";
    String strTitle = "";
    java.util.Vector vDoc = new java.util.Vector();
    GTpDoc doc = new GTpDoc();
    GTpDocFolder docFolder = new GTpDocFolder();
    GTpMail mail = new GTpMail();
    GCoDoDocTran docTran = new GCoDoDocTran();
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        sqlQuery = new StringBuffer();
        sqlQuery.append("SELECT DOCNO ").append(" FROM TB_EKNOW_C10 A, TB_EKNOW_C20 B ").append(" WHERE A.MAILNO = B.MAILNO AND B.REGMAILNO=").append(genQuote(REFNO));
        rs = conn.executeQuery(sqlQuery.toString());
        if (REFNO != null && REFNO.length() > 0) {
            REFNO = "C" + REFNO;
        }
        if (rs.next()) {
            DOCNO = rs.getString("DOCNO");
            FLDNO = getMaxNoB10(COMCODE, strDbType);
            sqlQuery = new StringBuffer();
            sqlQuery.append("INSERT INTO TB_").append(COMCODE).append("_B10 (FLDNO,BOXNO,DOCNO,REFNO,USERID) VALUES(").append(genQuote(FLDNO)).append(",").append(genQuote(BOXNO)).append(",").append(genQuote(DOCNO)).append(",").append(genQuote(REFNO)).append(",").append(genQuote(USERID)).append(")");
            conn.executeUpdate(sqlQuery.toString());
        } else {
            return false;
        }
        conn.commit();
        return true;
    } catch (Exception e) {
        try {
            conn.rollback();
        } catch (SQLException ignored) {
            GCmLog.writeLog("GCoWmMailTran :: setCopyFld" + ignored.getMessage());
        }
        GCmLog.writeLog("GCoWmMailTran ::  setCopyFld() " + e.getMessage());
        GCmLog.writeLog("GCoWmMailTran :: setCopyFld" + sqlQuery.toString());
        return false;
    } finally {
        conn.close();
    }
}

######


private String getMaxNoB10(String comcode, String strDbType) {
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(true);
        String strRegdate = GCmFcts.dateToStr(new java.util.Date(), 1);
        String strRet = "";
        StringBuffer sqlQuery = new StringBuffer();
        if ("oracle".equals(strDbType)) {
            sqlQuery.append(" SELECT SQ_").append(comcode).append("_B10.NEXTVAL RETCNT FROM DUAL ");
            GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
            while (rs.next()) {
                strRet = GCmFcts.numToStr(rs.getString("RETCNT"), 4);
                strRet = strRegdate + strRet;
            }
        } else if ("mssql".equals(strDbType)) {
            strRegdate = GCmFcts.dateToStr(new java.util.Date(), 3);
            sqlQuery.append(" INSERT INTO SQ_").append(comcode).append("_B10 VALUES ('A') ");
            conn.executeUpdate(sqlQuery.toString());
            sqlQuery = new StringBuffer().append(" SELECT MAX(RETCNT) FROM SQ_").append(comcode).append("_B10 ");
            GCmResultSet rs = conn.executeQuery(sqlQuery.toString());
            while (rs.next()) {
                if (rs.getString("RETCNT").equals("1000000")) {
                    sqlQuery = new StringBuffer().append(" drop table SQ_").append(comcode).append("_B10 ");
                    conn.executeUpdate(sqlQuery.toString());
                    sqlQuery = new StringBuffer().append(" create  table SQ_").append(comcode).append("_B10 ").append(" ( RETCNT int IDENTITY(1,1) NOT NULL, ").append("   TMP char(1) not null ); ");
                    conn.executeUpdate(sqlQuery.toString());
                    strRet = strRegdate + "000001";
                } else {
                    strRet = GCmFcts.numToStr(rs.getString("RETCNT"), 6);
                    strRet = strRegdate + strRet;
                }
            }
        } else if ("mysql".equals(strDbType)) {
        }
        return strRet;
    } catch (Exception e) {
        System.err.println(" GCoDoDocTran::getMaxNoB10 " + e.getMessage());
        return null;
    } finally {
        conn.close();
    }
}

######


@Nullable
@Override
public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
    return inflater.inflate(R.layout.gegevens_registreer_fragment, container, false);
}

######


@Override
public void onCheckedChanged(RadioGroup radioGroup, int i) {
    if (particulierRb.isChecked()) {
        etBedrijfsnaam.setVisibility(View.INVISIBLE);
        etBSN_KVK.setHint("BSN");
        etAdres.setHint("Adres");
        etTelefoon.setHint("Telefoonnummer");
        etMail.setHint("Email");
        valAvInput.clearEdittext((ViewGroup) view.findViewById(R.id.gegevens_viewgroup));
        etBedrijfsnaam.setText("1");
    }
    if (bedrijfRb.isChecked()) {
        etBedrijfsnaam.setVisibility(View.VISIBLE);
        etBSN_KVK.setHint("Kvk nummer");
        etAdres.setHint("Adres (Bedrijf)");
        etTelefoon.setHint("Telefoonnummer (Bedrijf)");
        etMail.setHint("Email (Bedrijf)");
        valAvInput.clearEdittext((ViewGroup) view.findViewById(R.id.gegevens_viewgroup));
    }
}

######


public void onClick(DialogInterface dialog, int id) {
    Intent intent = new Intent(getContext(), LoginActivity.class);
    startActivity(intent);
}

######


public void onClick(DialogInterface dialog, int id) {
    dialog.cancel();
}

######


@Override
public void onClick(View v) {
    if (radioGroup.getCheckedRadioButtonId() == -1) {
        AlertDialog.Builder builder1 = new AlertDialog.Builder(view.getContext());
        builder1.setMessage("Maak een keuze voor particulier of bedrijf");
        builder1.setPositiveButton("OK", new DialogInterface.OnClickListener() {

            public void onClick(DialogInterface dialog, int id) {
                dialog.cancel();
            }
        });
        AlertDialog alert11 = builder1.create();
        alert11.show();
    } else if (!valAvInput.emptyEdittext((ViewGroup) view.findViewById(R.id.gegevens_viewgroup))) {
        Toast.makeText(getContext(), "Vul alle velden in", Toast.LENGTH_LONG).show();
    } else if (!valAvInput.checkEmail(etMail.getText().toString())) {
        etMail.setError("Vul een geldige mail in");
    } else if (!valAvInput.validateLetters(etVoornaam.getText().toString())) {
        etVoornaam.setError("Voornaam mag alleen letters bevatten");
    } else if (!valAvInput.validateLetters(etAchternaam.getText().toString())) {
        etAchternaam.setError("Achternaam mag alleen letters bevatten");
    } else if (!isAlKlant(etBSN_KVK.getText().toString())) {
    } else {
        String klantId = etBSN_KVK.getText().toString();
        String voornaam = etVoornaam.getText().toString();
        String achternaam = etAchternaam.getText().toString();
        String telefoonnummer = etTelefoon.getText().toString();
        String email = etMail.getText().toString();
        String adres = etAdres.getText().toString();
        String bedrijfsnaam = etBedrijfsnaam.toString();
        if (particulierRb.isChecked()) {
            bedrijfsnaam = "";
        }
        Klant klant = new Klant(klantId, voornaam, achternaam, telefoonnummer, email, adres, bedrijfsnaam);
        Log.d("GegevensRegistreer", "klant: " + klant.getKlantId());
        String sql = "SELECT * FROM ZwarteLijst WHERE KlantklantID = '" + klantId + "';";
        try {
            DatabaseConnector db2 = new DatabaseConnector();
            db2.execute(sql);
            Object oResult = db.get();
            String strResult = oResult.toString();
            strResult = strResult.replace("\"", "");
            Log.d("Registreeractivity", "strResult: " + strResult);
            if (strResult.equals("msg:select:empty")) {
                FragmentManager fragmentManager = getActivity().getSupportFragmentManager();
                Bundle klantGegevens = new Bundle();
                klantGegevens.putSerializable("klantGegevens", klant);
                AfspraakRegistreerFragment afspraakFragment = new AfspraakRegistreerFragment();
                afspraakFragment.setArguments(klantGegevens);
                fragmentManager.beginTransaction().replace(R.id.registreeractivity_fragment_container, afspraakFragment).commit();
            } else {
                AlertDialog.Builder builder1 = new AlertDialog.Builder(view.getContext());
                builder1.setMessage("U bent afgewezen om klant te worden bij deze bank");
                builder1.setPositiveButton("OK", new DialogInterface.OnClickListener() {

                    public void onClick(DialogInterface dialog, int id) {
                        Intent intent = new Intent(getContext(), LoginActivity.class);
                        startActivity(intent);
                    }
                });
                AlertDialog alert11 = builder1.create();
                alert11.show();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

######


@Override
public void onViewCreated(@NonNull final View view, @Nullable Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    etVoornaam = view.findViewById(R.id.gegevens_registreer_etVoornaam);
    etAchternaam = view.findViewById(R.id.gegevens_registreer_etAchternaam);
    etAdres = view.findViewById(R.id.gegevens_registreer_etAdres);
    etMail = view.findViewById(R.id.gegevens_registreer_etEmail);
    etTelefoon = view.findViewById(R.id.gegevens_registreer_etTelefoonnummer);
    etBSN_KVK = view.findViewById(R.id.gegevens_registreer_etBSN_KVK);
    etBedrijfsnaam = view.findViewById(R.id.gegevens_registreer_etBedrijfsnaam);
    particulierRb = view.findViewById(R.id.gegevens_registreer_rbParticulier);
    bedrijfRb = view.findViewById(R.id.gegevens_registreer_rbBedrijf);
    final RadioGroup radioGroup = view.findViewById(R.id.gegevens_registreer_radiogroup);
    radioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {

        @Override
        public void onCheckedChanged(RadioGroup radioGroup, int i) {
            if (particulierRb.isChecked()) {
                etBedrijfsnaam.setVisibility(View.INVISIBLE);
                etBSN_KVK.setHint("BSN");
                etAdres.setHint("Adres");
                etTelefoon.setHint("Telefoonnummer");
                etMail.setHint("Email");
                valAvInput.clearEdittext((ViewGroup) view.findViewById(R.id.gegevens_viewgroup));
                etBedrijfsnaam.setText("1");
            }
            if (bedrijfRb.isChecked()) {
                etBedrijfsnaam.setVisibility(View.VISIBLE);
                etBSN_KVK.setHint("Kvk nummer");
                etAdres.setHint("Adres (Bedrijf)");
                etTelefoon.setHint("Telefoonnummer (Bedrijf)");
                etMail.setHint("Email (Bedrijf)");
                valAvInput.clearEdittext((ViewGroup) view.findViewById(R.id.gegevens_viewgroup));
            }
        }
    });
    Button btnAanvraagVersturen = view.findViewById(R.id.gegevens_registreer_btnVerstuurAanvraag);
    btnAanvraagVersturen.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (radioGroup.getCheckedRadioButtonId() == -1) {
                AlertDialog.Builder builder1 = new AlertDialog.Builder(view.getContext());
                builder1.setMessage("Maak een keuze voor particulier of bedrijf");
                builder1.setPositiveButton("OK", new DialogInterface.OnClickListener() {

                    public void onClick(DialogInterface dialog, int id) {
                        dialog.cancel();
                    }
                });
                AlertDialog alert11 = builder1.create();
                alert11.show();
            } else if (!valAvInput.emptyEdittext((ViewGroup) view.findViewById(R.id.gegevens_viewgroup))) {
                Toast.makeText(getContext(), "Vul alle velden in", Toast.LENGTH_LONG).show();
            } else if (!valAvInput.checkEmail(etMail.getText().toString())) {
                etMail.setError("Vul een geldige mail in");
            } else if (!valAvInput.validateLetters(etVoornaam.getText().toString())) {
                etVoornaam.setError("Voornaam mag alleen letters bevatten");
            } else if (!valAvInput.validateLetters(etAchternaam.getText().toString())) {
                etAchternaam.setError("Achternaam mag alleen letters bevatten");
            } else if (!isAlKlant(etBSN_KVK.getText().toString())) {
            } else {
                String klantId = etBSN_KVK.getText().toString();
                String voornaam = etVoornaam.getText().toString();
                String achternaam = etAchternaam.getText().toString();
                String telefoonnummer = etTelefoon.getText().toString();
                String email = etMail.getText().toString();
                String adres = etAdres.getText().toString();
                String bedrijfsnaam = etBedrijfsnaam.toString();
                if (particulierRb.isChecked()) {
                    bedrijfsnaam = "";
                }
                Klant klant = new Klant(klantId, voornaam, achternaam, telefoonnummer, email, adres, bedrijfsnaam);
                Log.d("GegevensRegistreer", "klant: " + klant.getKlantId());
                String sql = "SELECT * FROM ZwarteLijst WHERE KlantklantID = '" + klantId + "';";
                try {
                    DatabaseConnector db2 = new DatabaseConnector();
                    db2.execute(sql);
                    Object oResult = db.get();
                    String strResult = oResult.toString();
                    strResult = strResult.replace("\"", "");
                    Log.d("Registreeractivity", "strResult: " + strResult);
                    if (strResult.equals("msg:select:empty")) {
                        FragmentManager fragmentManager = getActivity().getSupportFragmentManager();
                        Bundle klantGegevens = new Bundle();
                        klantGegevens.putSerializable("klantGegevens", klant);
                        AfspraakRegistreerFragment afspraakFragment = new AfspraakRegistreerFragment();
                        afspraakFragment.setArguments(klantGegevens);
                        fragmentManager.beginTransaction().replace(R.id.registreeractivity_fragment_container, afspraakFragment).commit();
                    } else {
                        AlertDialog.Builder builder1 = new AlertDialog.Builder(view.getContext());
                        builder1.setMessage("U bent afgewezen om klant te worden bij deze bank");
                        builder1.setPositiveButton("OK", new DialogInterface.OnClickListener() {

                            public void onClick(DialogInterface dialog, int id) {
                                Intent intent = new Intent(getContext(), LoginActivity.class);
                                startActivity(intent);
                            }
                        });
                        AlertDialog alert11 = builder1.create();
                        alert11.show();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    });
}

######


private boolean checkKvkBsn(String kvk_bsn) {
    if (particulierRb.isChecked()) {
        int bsn = Integer.parseInt(kvk_bsn);
        if (!valAvInput.isValidBSN(bsn)) {
            return false;
        }
    }
    if (bedrijfRb.isChecked()) {
        if (kvk_bsn.length() != 8) {
            return false;
        }
    }
    return true;
}

######


private boolean isAlKlant(String klantId) {
    String sql = "SELECT * FROM Klant WHERE Klantid = '" + klantId + "';";
    String strResult = "";
    try {
        db.execute(sql);
        Object oResult = db.get();
        strResult = oResult.toString();
        strResult = strResult.replace("\"", "");
        Log.d("isAlKlant", "strResult: " + strResult);
    } catch (Exception e) {
        e.printStackTrace();
    }
    if (strResult.equals("msg:select:empty")) {
        return true;
    } else {
        Toast.makeText(getContext(), "U bent al bekend bij de bank", Toast.LENGTH_LONG).show();
        return false;
    }
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("gen_key_test", "id INTEGER NOT NULL AUTO_INCREMENT, name VARCHAR(100), PRIMARY KEY (id)");
    createTable("gen_key_test2", "id INTEGER NOT NULL AUTO_INCREMENT, name VARCHAR(100), PRIMARY KEY (id)");
}

######


@Test
public void testSimpleGeneratedKeys() throws SQLException {
    Statement statement = sharedConnection.createStatement();
    statement.execute("truncate gen_key_test");
    statement.executeUpdate("INSERT INTO gen_key_test (id, name) VALUES (null, 'Dave')", Statement.RETURN_GENERATED_KEYS);
    int[] autoInc = setAutoInc();
    ResultSet resultSet = statement.getGeneratedKeys();
    assertTrue(resultSet.next());
    assertEquals(autoInc[0] + autoInc[1], resultSet.getInt(1));
}

######


@Test
public void testSimpleGeneratedKeysWithPreparedStatement() throws SQLException {
    sharedConnection.createStatement().execute("truncate gen_key_test");
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO gen_key_test (id, name) VALUES (null, ?)", Statement.RETURN_GENERATED_KEYS);
    preparedStatement.setString(1, "Dave");
    preparedStatement.execute();
    ResultSet resultSet = preparedStatement.getGeneratedKeys();
    assertTrue(resultSet.next());
    int[] autoInc = setAutoInc();
    assertEquals(autoInc[0] + autoInc[1], resultSet.getInt(1));
}

######


@Test
public void testGeneratedKeysInsertOnDuplicateUpdate() throws SQLException {
    Statement statement = sharedConnection.createStatement();
    statement.execute("truncate gen_key_test");
    statement.execute("INSERT INTO gen_key_test (name) VALUES ('Dave')");
    int[] autoInc = setAutoInc();
    statement.executeUpdate("INSERT INTO gen_key_test (id, name) VALUES (" + (autoInc[0] + autoInc[1]) + ", 'Dave') ON DUPLICATE KEY UPDATE id = id", Statement.RETURN_GENERATED_KEYS);
    ResultSet resultSet = statement.getGeneratedKeys();
    ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
    assertEquals(1, resultSetMetaData.getColumnCount());
    assertFalse(resultSet.next());
}

######


@Test
public void testGeneratedKeysNegativeValue() throws SQLException {
    Assume.assumeFalse(isGalera());
    Statement statement = sharedConnection.createStatement();
    statement.execute("ALTER TABLE gen_key_test2 AUTO_INCREMENT = 65500");
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO gen_key_test2 (name) VALUES (?)", Statement.RETURN_GENERATED_KEYS);
    preparedStatement.setString(1, "t");
    preparedStatement.execute();
    ResultSet rs = preparedStatement.getGeneratedKeys();
    assertTrue(rs.next());
    assertEquals(65500, rs.getInt(1));
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("genkeys", "priKey INT NOT NULL AUTO_INCREMENT, dataField VARCHAR(64), PRIMARY KEY (priKey)");
}

######


@Test
public void generatedKeys() throws Exception {
    Statement st = sharedConnection.createStatement();
    int[] autoInc = setAutoInc();
    st.executeUpdate("insert into genkeys(dataField) values('a')", Statement.RETURN_GENERATED_KEYS);
    ResultSet rs = st.getGeneratedKeys();
    assertTrue(rs.next());
    assertEquals(autoInc[0] + autoInc[1], rs.getInt(1));
    assertEquals(autoInc[0] + autoInc[1], rs.getInt("priKey"));
    assertEquals(autoInc[0] + autoInc[1], rs.getInt("foo"));
    int[] indexes = { 1, 2, 3 };
    st.executeUpdate("insert into genkeys(dataField) values('b')", indexes);
    rs = st.getGeneratedKeys();
    assertTrue(rs.next());
    assertEquals(autoInc[1] + 2 * autoInc[0], rs.getInt(1));
    try {
        rs.getInt(2);
        fail("should never get here");
    } catch (SQLException e) {
    }
    String[] columnNames = { "priKey", "Alice", "Bob" };
    st.executeUpdate("insert into genkeys(dataField) values('c')", columnNames);
    rs = st.getGeneratedKeys();
    assertTrue(rs.next());
    for (int i = 0; i < 3; i++) {
        assertEquals(autoInc[1] + 3 * autoInc[0], rs.getInt(columnNames[i]));
    }
}

######


@Override
public void persist(T obj) {
    getManager().persist(obj);
    ;
    getManager().flush();
}

######


@Override
public void remove(T obj) {
}

######


@Override
public T merge(T obj) {
    obj = manager.merge(obj);
    return obj;
}

######


@Override
public void refresh(T obj) {
    manager.refresh(obj);
}

######


@Override
public T findById(ID id) {
    return null;
}

######


@Override
public T findMaxId(ID id) {
    return null;
}

######


@Override
public T findMinId(ID id) {
    return null;
}

######


@Override
@SuppressWarnings("unchecked")
public List<T> findAll() {
    CriteriaQuery cq = manager.getCriteriaBuilder().createQuery();
    cq.select(cq.from(entityClass));
    return manager.createQuery(cq).getResultList();
}

######


@SuppressWarnings("unchecked")
protected T findOneResult(String namedQuery, Map<String, Object> parameters) {
    T result = null;
    try {
        Query query = manager.createNamedQuery(namedQuery);
        if (parameters != null && !parameters.isEmpty()) {
            populateQueryParameters(query, parameters);
        }
        result = (T) query.getSingleResult();
    } catch (NoResultException e) {
        System.out.println("No result found for named query: " + namedQuery);
    } catch (Exception e) {
        System.out.println("Error while running query: " + e.getMessage());
        e.printStackTrace();
    }
    return result;
}

######


private void populateQueryParameters(Query query, Map<String, Object> parameters) {
    for (Entry<String, Object> entry : parameters.entrySet()) {
        query.setParameter(entry.getKey(), entry.getValue());
    }
}

######


public T findOneByField(String campo, String condicao, String valor) {
    T result = null;
    try {
        Query query = manager.createQuery("select x from " + entityClass.getSimpleName() + " x " + "where x." + campo + " " + condicao + ":value");
        query.setParameter(campo, valor);
        result = (T) query.getSingleResult();
    } catch (NoResultException e) {
        System.out.println("No result found");
    } catch (Exception e) {
        System.out.println("Error while running query: " + e.getMessage());
        e.printStackTrace();
    }
    return result;
}

######


protected EntityManager getManager() {
    return manager;
}

######


public Session getSession() {
    return session;
}

######


public void setSession(Session session) {
    this.session = session;
}

######


private Class<T> getEntityClass() {
    return entityClass;
}

######


private void setEntityClass(Class<T> entityClass) {
    this.entityClass = entityClass;
}

######


public SQLiteDatabase getConnection() {
    return this.database;
}

######


public void beginTransaction() {
    this.database.beginTransaction();
}

######


public void endTransaction() {
    this.database.endTransaction();
}

######


public boolean insertBean(Object bean) throws NotNullableException {
    this.openConnection();
    boolean result = insertBean(bean, this.database);
    this.closeConnection();
    return result;
}

######


public boolean insertBean(Object bean, SQLiteDatabase conn) throws NotNullableException {
    long result = 0;
    try {
        Entity entity = bean.getClass().getAnnotation(Entity.class);
        ArrayList<Field> beanFields = getFields(bean);
        OneRelations oneRelations = bean.getClass().getAnnotation(OneRelations.class);
        if (oneRelations != null) {
            for (int i = 0; i < oneRelations.value().length; i++) {
                HasOne hasOne = oneRelations.value()[i];
                Field relationField = getField(bean, hasOne.reference());
                if (isNullRelation(bean, relationField)) {
                    if (relationField.getAnnotation(Column.class).nullable()) {
                        beanFields.remove(relationField);
                    } else {
                        throw new NotNullableException();
                    }
                }
            }
        }
        Field primaryField = primaryField(bean);
        beanFields.remove(primaryField);
        HashMap<String, String> sqlSets = buildStrings(beanFields);
        String sql = "INSERT INTO " + entity.table() + " (" + sqlSets.get(FIELDS) + ")";
        sql += " VALUES(" + sqlSets.get(PARAMETERS) + ")";
        this.pst = conn.compileStatement(sql);
        prepare(pst, bean, beanFields);
        result = this.pst.executeInsert();
    } catch (SQLException s) {
        s.printStackTrace();
    }
    return (result != -1) ? true : false;
}

######


public boolean insertMany(Object mainBean, Object linkedBean) {
    this.openConnection();
    boolean result = insertMany(mainBean, linkedBean, this.database);
    this.closeConnection();
    return result;
}

######


public boolean insertMany(Object mainBean, Object linkedBean, SQLiteDatabase conn) {
    ManyRelations hasMultiple = mainBean.getClass().getAnnotation(ManyRelations.class);
    if (hasMultiple != null) {
        HasMany hasMany = null;
        for (int i = 0; i < hasMultiple.value().length; i++) {
            if (hasMultiple.value()[i].entity().equals(linkedBean.getClass())) {
                hasMany = hasMultiple.value()[i];
            }
        }
        if (hasMany != null) {
            Field foreignField = getField(linkedBean, hasMany.foreignKey());
            setValue(linkedBean, foreignField, getValue(mainBean, primaryField(mainBean)));
            try {
                return this.insertBean(linkedBean, conn);
            } catch (NotNullableException e) {
                e.printStackTrace();
            }
        }
    }
    return false;
}

######


public Object selectBean(Object bean) {
    this.openConnection();
    Object result = selectBean(bean, this.database);
    this.closeConnection();
    return result;
}

######


public Object selectBean(Object bean, SQLiteDatabase conn) {
    Object result = null;
    try {
        Entity entity = bean.getClass().getAnnotation(Entity.class);
        ArrayList<Field> beanFields = getFields(bean);
        Field primaryField = primaryField(bean);
        String sql = "SELECT * FROM " + entity.table() + " WHERE " + primaryColumn(primaryField) + " = ?";
        Cursor rs = prepare(bean, sql, primaryField, conn);
        if (rs.moveToFirst()) {
            result = result(rs, bean, beanFields);
        }
    } catch (SQLException s) {
        s.printStackTrace();
    }
    return result;
}

######


public Object selectOne(Object bean, Object one) {
    this.openConnection();
    Object result = selectOne(bean, one, this.database);
    this.closeConnection();
    return result;
}

######


public Object selectOne(Object bean, Object one, SQLiteDatabase conn) {
    Object result = null;
    try {
        Entity entity = one.getClass().getAnnotation(Entity.class);
        ArrayList<Field> beanFields = getFields(one);
        Field primaryField = primaryField(one);
        OneRelations oneRelations = bean.getClass().getAnnotation(OneRelations.class);
        if (oneRelations != null) {
            HasOne hasOne = null;
            for (int i = 0; i < oneRelations.value().length; i++) {
                if (oneRelations.value()[i].entity() == one.getClass()) {
                    hasOne = oneRelations.value()[i];
                }
            }
            String sql = "SELECT * FROM " + entity.table() + " WHERE " + primaryColumn(primaryField) + " = ?";
            Cursor rs = prepare(bean, sql, getField(bean, hasOne.reference()), conn);
            if (rs.moveToFirst()) {
                result = result(rs, one, beanFields);
            }
        }
    } catch (SQLException s) {
        s.printStackTrace();
    }
    return result;
}

######


public ArrayList<Object> selectAllBeans(Object bean) {
    return selectAllBeans(bean, getOrderField(bean));
}

######


public ArrayList<Object> selectAllBeans(Object bean, int limit, boolean desc, Field orderBy) {
    this.openConnection();
    ArrayList<Object> beans = selectAllBeans(bean, limit, desc, orderBy, this.database);
    this.closeConnection();
    return beans;
}

######


public ArrayList<Object> selectAllBeans(Object bean, Field orderBy) {
    this.openConnection();
    ArrayList<Object> beans = selectAllBeans(bean, 0, false, orderBy, this.database);
    this.closeConnection();
    return beans;
}

######


public ArrayList<Object> selectAllBeans(Object bean, SQLiteDatabase conn) {
    return selectAllBeans(bean, 0, false, getOrderField(bean), conn);
}

######


public ArrayList<Object> selectAllBeans(Object bean, int limit, boolean desc, Field orderBy, SQLiteDatabase conn) {
    ArrayList<Object> beans = new ArrayList<Object>();
    try {
        Entity entity = bean.getClass().getAnnotation(Entity.class);
        ArrayList<Field> beanFields = getFields(bean);
        String sql = "SELECT * FROM " + entity.table();
        System.out.println(orderBy);
        if (orderBy != null) {
            sql += " ORDER BY " + databaseColumn(orderBy);
        }
        if (desc) {
            sql += " DESC";
        }
        if (limit > 0) {
            sql += " LIMIT " + limit;
        }
        Cursor rs = conn.rawQuery(sql, null);
        while (rs.moveToNext()) {
            beans.add(result(rs, bean, beanFields));
        }
    } catch (SQLException s) {
        s.printStackTrace();
    }
    return beans;
}

######


public ArrayList<Object> selectMany(Object bean, Object target) {
    return selectMany(bean, target, getOrderField(target));
}

######


public ArrayList<Object> selectMany(Object bean, Object target, Field orderBy) {
    this.openConnection();
    ArrayList<Object> beans = selectMany(bean, target, orderBy, this.database);
    this.closeConnection();
    return beans;
}

######


public ArrayList<Object> selectMany(Object bean, Object target, SQLiteDatabase conn) {
    return selectMany(bean, target, getOrderField(target), conn);
}

######


public ArrayList<Object> selectMany(Object bean, Object target, Field orderBy, SQLiteDatabase conn) {
    ArrayList<Object> beans = new ArrayList<Object>();
    try {
        ManyRelations hasMultiple = bean.getClass().getAnnotation(ManyRelations.class);
        if (hasMultiple != null) {
            HasMany hasMany = null;
            for (int i = 0; i < hasMultiple.value().length; i++) {
                if (hasMultiple.value()[i].entity().equals(target.getClass())) {
                    hasMany = hasMultiple.value()[i];
                }
            }
            if (hasMany != null) {
                Entity entity = target.getClass().getAnnotation(Entity.class);
                String sql = "SELECT * FROM " + entity.table() + " WHERE " + databaseColumn(getField(target, hasMany.foreignKey())) + " = ?";
                if (orderBy != null) {
                    sql += " ORDER BY " + databaseColumn(orderBy);
                }
                ArrayList<Field> targetFields = getFields(target);
                Cursor rs = prepare(bean, sql, primaryField(bean), conn);
                while (rs.moveToNext()) {
                    beans.add(result(rs, target, targetFields));
                }
            }
        }
    } catch (SQLException s) {
        s.printStackTrace();
    }
    return beans;
}

######


public Integer countBean(Object bean) {
    this.openConnection();
    Integer count = countBean(bean, this.database);
    this.closeConnection();
    return count;
}

######


public Integer countBean(Object bean, SQLiteDatabase conn) {
    Integer count = 0;
    Entity entity = bean.getClass().getAnnotation(Entity.class);
    String sql = "SELECT COUNT(*) FROM " + entity.table();
    Cursor rs = conn.rawQuery(sql, null);
    if (rs.moveToFirst())
        count = rs.getInt(0);
    return count;
}

######


public Object firstOrLastBean(Object bean, boolean last) {
    this.openConnection();
    Object result = firstOrLastBean(bean, last, this.database);
    this.closeConnection();
    return result;
}

######


public Object firstOrLastBean(Object bean, boolean last, SQLiteDatabase conn) {
    Object result = null;
    try {
        Entity entity = bean.getClass().getAnnotation(Entity.class);
        ArrayList<Field> beanFields = getFields(bean);
        String sql = "SELECT * FROM " + entity.table() + " ORDER BY " + primaryColumn(primaryField(bean));
        if (last)
            sql += " DESC";
        sql += " LIMIT 1";
        Cursor rs = conn.rawQuery(sql, null);
        if (rs.moveToFirst()) {
            result = result(rs, bean, beanFields);
        }
    } catch (SQLException s) {
        s.printStackTrace();
    }
    return result;
}

######


public ArrayList<Object> selectWhere(Object bean, Condition condition) {
    return selectWhere(bean, condition, getOrderField(bean));
}

######


public ArrayList<Object> selectWhere(Object bean, Condition condition, Field orderBy) {
    this.openConnection();
    ArrayList<Object> beans = selectWhere(bean, condition, orderBy, this.database);
    this.closeConnection();
    return beans;
}

######


public ArrayList<Object> selectWhere(Object bean, Condition condition, SQLiteDatabase conn) {
    return selectWhere(bean, condition, getOrderField(bean), conn);
}

######


public ArrayList<Object> selectWhere(Object bean, Condition condition, Field orderBy, SQLiteDatabase conn) {
    ArrayList<Object> beans = new ArrayList<Object>();
    try {
        ArrayList<Field> beanFields = getFields(bean);
        condition.prepareSQL(bean);
        String sql = condition.getSql();
        if (orderBy != null) {
            sql += " ORDER BY " + databaseColumn(orderBy);
        }
        Cursor rs = conn.rawQuery(sql, null);
        while (rs.moveToNext()) {
            beans.add(result(rs, bean, beanFields));
        }
    } catch (SQLException s) {
        s.printStackTrace();
    }
    return beans;
}

######


public boolean deleteBean(Object bean) {
    this.openConnection();
    boolean result = deleteBean(bean, this.database);
    this.closeConnection();
    return result;
}

######


public boolean deleteMany(Object bean, SQLiteDatabase conn) {
    ManyRelations hasMultiple = bean.getClass().getAnnotation(ManyRelations.class);
    boolean result = true;
    if (hasMultiple != null) {
        try {
            for (int i = 0; i < hasMultiple.value().length; i++) {
                HasMany hasMany = hasMultiple.value()[i];
                Class<?> child = hasMany.entity();
                Object childInstance = child.newInstance();
                ArrayList<Object> results = selectMany(bean, childInstance, conn);
                for (Object object : results) {
                    boolean status = deleteBean(object, conn);
                    if (!status) {
                        result = false;
                    }
                }
            }
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
    return result;
}

######


public boolean deleteBean(Object bean, SQLiteDatabase conn) {
    boolean response = true;
    try {
        Entity entity = bean.getClass().getAnnotation(Entity.class);
        ManyRelations hasMultiple = bean.getClass().getAnnotation(ManyRelations.class);
        Field primaryField = primaryField(bean);
        if (hasMultiple != null) {
            response = deleteMany(bean, conn);
        }
        if (response) {
            String sql = "DELETE FROM " + entity.table() + " WHERE " + primaryColumn(primaryField) + " = ?";
            this.pst = conn.compileStatement(sql);
            prepare(this.pst, bean, 1, primaryField);
            long result = this.pst.executeInsert();
            return (result != -1) ? true : false;
        }
    } catch (SQLException s) {
        s.printStackTrace();
    }
    return response;
}

######


public static ArrayList<Field> filterFields(ArrayList<Field> fields) {
    for (Field field : fields) {
        if (field.getName().startsWith("$")) {
            fields.remove(field);
        }
    }
    return fields;
}

######


public static Field getOrderField(Object bean) {
    OrderBy orderBy = bean.getClass().getAnnotation(OrderBy.class);
    if (orderBy != null) {
        return getField(bean, orderBy.field());
    } else {
        return null;
    }
}

######


public static boolean isNullRelation(Object bean, Field field) {
    if (field.getType() == int.class) {
        if ((int) getValue(bean, field) == 0) {
            return true;
        }
    } else {
        if (getValue(bean, field) == null) {
            return true;
        }
    }
    return false;
}

######


public static Object getValue(Object bean, Field field) {
    try {
        return getGetter(field).invoke(bean);
    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
        e.printStackTrace();
    }
    return null;
}

######


public static void setValue(Object bean, Field field, Object value) {
    try {
        getSetter(field).invoke(bean, value);
    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
        e.printStackTrace();
    }
}

######


public static Field getField(Object bean, String fieldName) {
    try {
        return bean.getClass().getDeclaredField(fieldName);
    } catch (NoSuchFieldException | SecurityException e) {
        e.printStackTrace();
    }
    return null;
}

######


public static ArrayList<Field> getFields(Object bean) {
    return filterFields(new ArrayList<Field>(Arrays.asList(bean.getClass().getDeclaredFields())));
}

######


public static Field primaryField(Object bean) {
    Field primaryField = null;
    Entity entity = bean.getClass().getAnnotation(Entity.class);
    try {
        primaryField = bean.getClass().getDeclaredField(entity.primaryKey());
    } catch (NoSuchFieldException | SecurityException e) {
        e.printStackTrace();
    }
    return primaryField;
}

######


public static String primaryColumn(Field primaryField) {
    Column column = primaryField.getAnnotation(Column.class);
    if (column == null) {
        return primaryField.getName();
    } else {
        return column.name();
    }
}

######


public static HashMap<String, String> buildStrings(ArrayList<Field> fields) {
    HashMap<String, String> result = new HashMap<String, String>();
    ArrayList<String> columns = databaseColumns(fields);
    String fieldString = "";
    String parameterString = "";
    String joiner = ",";
    for (int i = 0; i < columns.size(); i++) {
        fieldString += columns.get(i);
        parameterString += "?";
        if (i < columns.size() - 1) {
            fieldString += joiner;
            parameterString += joiner;
        }
    }
    result.put(FIELDS, fieldString);
    result.put(PARAMETERS, parameterString);
    return result;
}

######


public static ArrayList<Method> getGetters(Object bean, ArrayList<Field> fields) {
    ArrayList<Method> beanGetters = new ArrayList<Method>();
    for (Field field : fields) {
        if (field.getAnnotation(Ignore.class) == null) {
            Method getter = getGetter(field);
            if (getter != null) {
                beanGetters.add(getter);
            }
        }
    }
    return beanGetters;
}

######


public static Method getGetter(Field field) {
    Method result = null;
    try {
        if (!field.getName().startsWith("$")) {
            char[] fieldName = field.getName().trim().toCharArray();
            String methodName = "";
            if ((field.getType() == Boolean.class || field.getType() == boolean.class) && new String(fieldName).contains("is")) {
                methodName = new String(fieldName);
            } else {
                fieldName[0] = Character.toUpperCase(fieldName[0]);
                methodName = "get" + new String(fieldName);
            }
            result = field.getDeclaringClass().getDeclaredMethod(methodName);
        }
    } catch (NoSuchMethodException | SecurityException e) {
        e.printStackTrace();
    }
    return result;
}

######


public static ArrayList<Method> getSetters(Object bean, ArrayList<Field> fields) {
    ArrayList<Method> beanSetters = new ArrayList<Method>();
    for (Field field : fields) {
        if (field.getAnnotation(Ignore.class) == null) {
            Method setter = getSetter(field);
            if (setter != null) {
                beanSetters.add(setter);
            }
        }
    }
    return beanSetters;
}

######


public static Method getSetter(Field field) {
    try {
        if (!field.getName().startsWith("$")) {
            char[] fieldName = field.getName().trim().toCharArray();
            String methodName = "";
            if ((field.getType() == Boolean.class || field.getType() == boolean.class) && new String(fieldName).contains("is")) {
                methodName = new String(fieldName);
                methodName = methodName.substring(2);
                methodName = "set" + methodName;
            } else {
                fieldName[0] = Character.toUpperCase(fieldName[0]);
                methodName = "set" + new String(fieldName);
            }
            return field.getDeclaringClass().getDeclaredMethod(methodName, field.getType());
        }
    } catch (NoSuchMethodException | SecurityException e) {
        e.printStackTrace();
    }
    return null;
}

######


public static ArrayList<String> databaseColumns(ArrayList<Field> fields) {
    ArrayList<String> databaseColumns = new ArrayList<String>();
    for (Field field : fields) {
        if (field.getAnnotation(Ignore.class) == null) {
            databaseColumns.add(databaseColumn(field));
        }
    }
    return databaseColumns;
}

######


public static String databaseColumn(Field field) {
    Column columnAnnotation = field.getAnnotation(Column.class);
    if (columnAnnotation != null) {
        return columnAnnotation.name();
    } else {
        return field.getName();
    }
}

######


public static Cursor prepare(Object bean, String sql, Field parameter, SQLiteDatabase conn) {
    return conn.rawQuery(sql, new String[] { getValue(bean, parameter).toString() });
}

######


public static Cursor prepare(Object bean, String sql, ArrayList<Field> parameters, SQLiteDatabase conn) {
    String[] params = new String[parameters.size()];
    for (int i = 0; i < parameters.size(); i++) {
        params[i] = parameters.get(i).toString();
    }
    return conn.rawQuery(sql, params);
}

######


public static void prepare(SQLiteStatement pst, Object bean, ArrayList<Field> fields) throws SQLException {
    ArrayList<Method> getters = getGetters(bean, fields);
    for (int i = 0; i < getters.size(); i++) {
        dataSet(pst, i + 1, bean, getters.get(i));
    }
}

######


public static void prepare(SQLiteStatement pst, Object bean, int index, Field field) throws SQLException {
    Method getter = null;
    if (field.getAnnotation(Ignore.class) == null) {
        try {
            getter = getGetter(field);
        } catch (SecurityException e) {
            e.printStackTrace();
        }
    }
    dataSet(pst, index, bean, getter);
}

######


public static Object result(Cursor rs, Object bean, ArrayList<Field> fields) throws SQLException {
    Object result = null;
    try {
        result = bean.getClass().newInstance();
    } catch (InstantiationException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    }
    ArrayList<Method> setters = getSetters(bean, fields);
    for (int i = 0; i < setters.size(); i++) {
        result = dataGet(rs, i + 1, result, setters.get(i), fields.get(i));
    }
    return result;
}

######


public static Object result(Cursor rs, Object bean, int index, Field field) throws SQLException {
    Method setter = null;
    if (field.getAnnotation(Ignore.class) == null) {
        try {
            setter = getSetter(field);
        } catch (SecurityException e) {
            e.printStackTrace();
        }
        return dataGet(rs, index, bean, setter, field);
    }
    return null;
}

######


public static void dataSet(SQLiteStatement pst, int index, Object bean, Method getter) throws SQLException {
    try {
        Object test = getter.invoke(bean);
        if (test instanceof String) {
            pst.bindString(index, (String) test);
        } else if (test instanceof Integer) {
            pst.bindString(index, Integer.toString((Integer) test));
        } else if (test instanceof Double) {
            pst.bindDouble(index, (Double) test);
        }
    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
        e.printStackTrace();
    }
}

######


public static Object dataGet(Cursor rs, int index, Object bean, Method setter, Field field) throws SQLException {
    try {
        Class<?> test = setter.getParameterTypes()[0];
        if (test == String.class) {
            setter.invoke(bean, rs.getString(rs.getColumnIndex(databaseColumn(field))));
        } else if (test == Integer.class || test == int.class) {
            setter.invoke(bean, rs.getInt(rs.getColumnIndex(databaseColumn(field))));
        } else if (test == Double.class) {
            setter.invoke(bean, rs.getDouble(rs.getColumnIndex(databaseColumn(field))));
        }
    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
        e.printStackTrace();
    }
    return bean;
}

######


public Genero buscarGenero(int id) throws IOException {
    Genero genero = null;
    String sql = "select id, nome from genero where id=?";
    try (Connection conn = ConnectionFactory.getConnection();
        PreparedStatement pst = conn.prepareStatement(sql)) {
        pst.setInt(1, id);
        try (ResultSet rs = pst.executeQuery()) {
            if (rs.next()) {
                genero = new Genero();
                genero.setId(id);
                genero.setNome(rs.getString("nome"));
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
        throw new IOException(e);
    }
    return genero;
}

######


public ArrayList<Genero> listarGeneros() throws IOException {
    ArrayList<Genero> generos = new ArrayList<>();
    String sql = "select id, nome from genero order by nome";
    try (Connection conn = ConnectionFactory.getConnection();
        PreparedStatement pst = conn.prepareStatement(sql);
        ResultSet rs = pst.executeQuery()) {
        while (rs.next()) {
            Genero genero = new Genero();
            genero.setId(rs.getInt("id"));
            genero.setNome(rs.getString("nome"));
            generos.add(genero);
        }
    } catch (SQLException e) {
        e.printStackTrace();
        throw new IOException(e);
    }
    return generos;
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("geom_test", "g geometry");
}

######


private void geometryTest(String geometryString, String geometryBinary) throws SQLException {
    try (Statement stmt = sharedConnection.createStatement()) {
        stmt.execute("TRUNCATE geom_test");
        String prefix = "";
        if (!isMariadbServer() && minVersion(8, 0, 3)) {
            prefix = "ST_";
        }
        String tmpGeometryBinary = geometryBinary;
        if (tmpGeometryBinary == null) {
            String sql = "SELECT " + prefix + "AsWKB(" + prefix + "GeomFromText('" + geometryString + "'))";
            try (ResultSet rs = stmt.executeQuery(sql)) {
                assertTrue(rs.next());
                tmpGeometryBinary = printHexBinary(rs.getBytes(1));
            }
        }
        String sql = "INSERT INTO geom_test VALUES (" + prefix + "GeomFromText('" + geometryString + "'))";
        stmt.execute(sql);
        try (ResultSet rs = stmt.executeQuery("SELECT " + prefix + "AsText(g), " + prefix + "AsBinary(g), g FROM geom_test")) {
            assertTrue(rs.next());
            assertEquals(geometryString, rs.getString(1));
            String returnWkb = printHexBinary((byte[]) rs.getObject(2));
            assertEquals(tmpGeometryBinary, returnWkb);
            Object geometry = null;
            try {
                geometry = rs.getObject(3);
            } catch (Exception e) {
                fail();
            }
            String returnGeometry = printHexBinary((byte[]) geometry);
            BigInteger returnNumber = new BigInteger(returnGeometry, 16);
            BigInteger geometryNumber = new BigInteger(tmpGeometryBinary, 16);
            assertEquals(geometryNumber, returnNumber);
        }
    }
}

######


@Test
public void pointTest() throws SQLException {
    String pointString = "POINT(1 1)";
    String pointWkb = "0101000000000000000000F03F000000000000F03F";
    geometryTest(pointString, pointWkb);
}

######


@Test
public void lineStringTest() throws SQLException {
    String lineString = "LINESTRING(0 0,1 1,2 2)";
    geometryTest(lineString, null);
}

######


@Test
public void polygonTest() throws SQLException {
    String polygonString = "POLYGON((0 0,10 0,0 10,0 0))";
    geometryTest(polygonString, null);
}

######


private String printHexBinary(byte[] data) {
    StringBuilder builder = new StringBuilder(data.length * 2);
    for (byte b : data) {
        builder.append(hexCode[(b >> 4) & 0xF]);
        builder.append(hexCode[(b & 0xF)]);
    }
    return builder.toString();
}

######


protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setContentType("text/html;charset=utf-8");
    String courseIDStr = request.getParameter("courseID");
    boolean nan = false;
    try {
        Integer.parseInt(courseIDStr);
    } catch (Exception e) {
        nan = true;
    }
    String userToken = request.getParameter("userToken");
    String account = request.getParameter("account");
    if (userToken == null) {
        userToken = "";
    }
    if (account == null) {
        account = "";
    }
    JSONObject jsonRet;
    Status status = new Status();
    if (nan || courseIDStr.equals("") || userToken.equals("") || account.equals("")) {
        status.setStatus(false);
        status.setInfo("空参数");
        jsonRet = JSONObject.fromObject(status);
    } else {
        int courseID = Integer.parseInt(courseIDStr);
        List<Material> materials = new ArrayList<Material>();
        try {
            DBConnect connect = new DBConnect();
            String query;
            PreparedStatement pst;
            ResultSet rs;
            query = "SELECT * FROM resource WHERE courseID = ?";
            pst = connect.prepareStatement(query);
            pst.setInt(1, courseID);
            rs = pst.executeQuery();
            while (rs.next()) {
                Material m = new Material();
                m.setName(rs.getString("name"));
                m.setPath(rs.getString("path"));
                m.setType(rs.getString("type"));
                materials.add(m);
            }
            rs.close();
            status.setStatus(true);
            status.setInfo("获取文件成功");
        } catch (SQLException e) {
            e.printStackTrace();
            status.setStatus(false);
            status.setInfo("数据库错误");
        }
        jsonRet = JSONObject.fromObject(status);
        jsonRet.put("materials", materials);
    }
    PrintWriter out = response.getWriter();
    out.print(jsonRet.toString());
}

######


protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
}

######


protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String userid = request.getParameter("userid");
    try {
        Class.forName("com.mysql.jdbc.Driver");
        Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/userVerificationdb", "root", "root");
        Statement st = con.createStatement();
        ResultSet rs;
        rs = st.executeQuery("select * from account where username='" + userid + "'");
        if (rs.next()) {
            String Squestion1 = rs.getString("Squestion1");
            String Sanswer1 = rs.getString("Sanswer1");
            String Squestion2 = rs.getString("Squestion2");
            String Sanswer2 = rs.getString("Sanswer2");
            String emailid = rs.getString("emailid");
            HttpSession session = request.getSession();
            session.setAttribute("userid", userid);
            session.setMaxInactiveInterval(30 * 60);
            Cookie userName = new Cookie("userid", userid);
            Cookie question1 = new Cookie("Squestion1", Squestion1);
            Cookie answer1 = new Cookie("Sanswer1", Sanswer1);
            Cookie question2 = new Cookie("Squestion2", Squestion2);
            Cookie answer2 = new Cookie("Sanswer2", Sanswer2);
            Cookie emailadd = new Cookie("emailid", emailid);
            userName.setMaxAge(30 * 60);
            response.addCookie(userName);
            response.addCookie(question1);
            response.addCookie(answer1);
            response.addCookie(question2);
            response.addCookie(answer2);
            response.addCookie(emailadd);
            response.sendRedirect("SecurityQuestion.jsp");
        } else {
            JOptionPane.showMessageDialog(null, "no user");
            response.sendRedirect("InvalidUserNPass.jsp");
        }
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


@Override
public void initialize(URL location, ResourceBundle resources) {
    formatdayPicker();
    try {
        dataBaseGVinput();
        fillComboBox();
    } catch (Exception e) {
        e.printStackTrace();
    }
    filTergv();
    tableItemClick();
    btnXoagv.setOnAction(e -> {
        deleteGiaoVien();
    });
}

######


private void dataBaseGVinput() throws SQLException {
    obgv.clear();
    Connection conngv = SQLiteConnection.connector();
    PreparedStatement preparegv = null;
    ResultSet rsi = null;
    String gvstr = "select *  from GIAOVIEN";
    try {
        preparegv = conngv.prepareStatement(gvstr);
        rsi = preparegv.executeQuery();
        while (rsi.next()) {
            obgv.add(new GiaoVienModel(rsi.getString(1), rsi.getString(2), rsi.getString(3), rsi.getString(4), rsi.getString(5), rsi.getString(6), rsi.getString(7), rsi.getString("MaKhoaGV")));
        }
        rsi.close();
        preparegv.close();
        conngv.close();
    } catch (Exception e) {
    }
    idgv.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("IdGv"));
    hogv.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("HoGv"));
    tengv.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("TenGv"));
    ngaysinhgv.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("NgaysinhGv"));
    sexgv.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("SexGv"));
    phonegv.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("PhoneGv"));
    diachigv.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("DiachiGv"));
    khoagv.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("KhoaGv"));
    tablegv.setItems(obgv);
}

######


private void filTergv() {
    FilteredList<GiaoVienModel> filtergv = new FilteredList<>(obgv, e -> true);
    txtFindgv.setOnAction(e -> {
        txtFindgv.textProperty().addListener(((observable, oldValue, newValue) -> {
            filtergv.setPredicate((Predicate<? super GiaoVienModel>) gv -> {
                if (newValue == null || newValue.isEmpty()) {
                    return true;
                }
                String lowerCase = newValue.toLowerCase();
                if (gv.getIdGv().toLowerCase().contains(lowerCase)) {
                    return true;
                } else if (gv.getTenGv().toLowerCase().contains(lowerCase)) {
                    return true;
                } else if (gv.getHoGv().toLowerCase().contains(lowerCase)) {
                    return true;
                }
                return false;
            });
        }));
        SortedList<GiaoVienModel> sort = new SortedList<>(filtergv);
        sort.comparatorProperty().bind(tablegv.comparatorProperty());
        tablegv.setItems(sort);
    });
}

######


@Override
public String toString(LocalDate date) {
    if (date != null) {
        return dateFormatter.format(date);
    } else {
        return "";
    }
}

######


@Override
public LocalDate fromString(String string) {
    if (string != null && !string.isEmpty()) {
        return LocalDate.parse(string, dateFormatter);
    } else {
        return null;
    }
}

######


private void formatdayPicker() {
    bDategv.setConverter(new StringConverter<LocalDate>() {

        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(pattern);

        {
            bDategv.setPromptText("Ngày sinh");
        }

        @Override
        public String toString(LocalDate date) {
            if (date != null) {
                return dateFormatter.format(date);
            } else {
                return "";
            }
        }

        @Override
        public LocalDate fromString(String string) {
            if (string != null && !string.isEmpty()) {
                return LocalDate.parse(string, dateFormatter);
            } else {
                return null;
            }
        }
    });
}

######


private void clearText() {
    txtHogv.clear();
    txtDiachigv.clear();
    txtTengv.clear();
    txtMagv.clear();
    txtPhonegv.clear();
    bDategv.setValue(null);
    radNugv.setSelected(false);
    radNamgv.setSelected(false);
}

######


private void themGiaoVien() throws SQLException {
    if (emtyFeild()) {
        if (radNamgv.isSelected()) {
            lblsex = radNamgv.getText();
        } else if (radNugv.isSelected()) {
            lblsex = radNugv.getText();
        }
        Connection conngv = SQLiteConnection.connector();
        PreparedStatement preparegv1 = null;
        String gvstr1 = "insert into GIAOVIEN (MaGV,HoGV,TenGV,NgaySinhGV,GioiTinhGV,PhoneGV,DiaChiGV,MaKhoaGV) values (?,?,?,?,?,?,?,?)";
        try {
            preparegv1 = conngv.prepareStatement(gvstr1);
            preparegv1.setString(1, txtMagv.getText());
            preparegv1.setString(2, txtHogv.getText());
            preparegv1.setString(3, txtTengv.getText());
            preparegv1.setString(4, bDategv.getEditor().getText());
            preparegv1.setString(5, lblsex);
            preparegv1.setString(6, txtPhonegv.getText());
            preparegv1.setString(7, txtDiachigv.getText());
            preparegv1.setString(8, comKhoa.getSelectionModel().getSelectedItem());
            preparegv1.executeUpdate();
            dataBaseGVinput();
            clearText();
            preparegv1.close();
            conngv.close();
        } catch (Exception e) {
        } finally {
        }
    }
}

######


private void fillComboBox() {
    Connection connbox = SQLiteConnection.connector();
    PreparedStatement precombox;
    ResultSet rscbox;
    String khoadb = "select DISTINCT MaKhoaGV from GIAOVIEN order by MaKhoaGV asc";
    try {
        precombox = connbox.prepareStatement(khoadb);
        rscbox = precombox.executeQuery();
        while (rscbox.next()) {
            combox.add(rscbox.getString("MaKhoaGV"));
        }
        rscbox.close();
        precombox.close();
    } catch (Exception e) {
    }
    comKhoa.setItems(combox);
}

######


private boolean emtyFeild() {
    if (txtMagv.getText().isEmpty() | txtHogv.getText().isEmpty() | txtTengv.getText().isEmpty() | txtPhonegv.getText().isEmpty() | txtDiachigv.getText().isEmpty()) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị nhập đầy đủ thông tin!!");
        alert.showAndWait();
        return false;
    }
    if (bDategv.getEditor().getText().isEmpty()) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị nhập Ngày Sinh");
        alert.showAndWait();
        return false;
    }
    if (radioCheck()) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị chọn Giới Tính!");
        alert.showAndWait();
        return false;
    }
    if (comKhoa.getValue() == null) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị chọn Khoa!");
        alert.showAndWait();
        return false;
    }
    return true;
}

######


private boolean radioCheck() {
    if (radNamgv.isSelected() || radNugv.isSelected()) {
        return false;
    } else
        return true;
}

######


private void tableItemClick() {
    tablegv.setOnMouseClicked(e -> {
        if (tablegv.getSelectionModel().getSelectedItem() != null) {
            try {
                GiaoVienModel gv = tablegv.getSelectionModel().getSelectedItem();
                String qr = "select * from GIAOVIEN where MaGV=?";
                Connection conn = SQLiteConnection.connector();
                PreparedStatement pre;
                ResultSet rs;
                pre = conn.prepareStatement(qr);
                pre.setString(1, gv.getIdGv());
                rs = pre.executeQuery();
                while (rs.next()) {
                    txtMagv.setText(rs.getString(1));
                    txtHogv.setText(rs.getString(2));
                    txtTengv.setText(rs.getString(3));
                    bDategv.getEditor().setText(rs.getString(4));
                    if (rs.getString(5).equals("Nam")) {
                        radNamgv.setSelected(true);
                    } else
                        radNugv.setSelected(true);
                    txtPhonegv.setText(rs.getString(6));
                    txtDiachigv.setText(rs.getString(7));
                }
                rs.close();
                pre.close();
                conn.close();
            } catch (Exception m) {
                m.printStackTrace();
            }
        }
    });
}

######


private void deleteGiaoVien() {
    if (!txtMagv.getText().isEmpty()) {
        Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
        alert.setHeaderText(null);
        alert.setContentText("Bạn có muốn xoá " + txtHogv.getText() + " " + txtTengv.getText() + "\nKhỏi danh sách?");
        Optional<ButtonType> action = alert.showAndWait();
        Connection conn = SQLiteConnection.connector();
        PreparedStatement pred = null;
        if (action.get() == ButtonType.OK) {
            try {
                String qr = "delete from GIAOVIEN where MaGV=?";
                pred = conn.prepareStatement(qr);
                pred.setString(1, txtMagv.getText());
                pred.executeUpdate();
                pred.close();
                dataBaseGVinput();
                clearText();
                editDisableTxt();
                conn.close();
            } catch (Exception x) {
                x.printStackTrace();
            }
        }
    } else {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setHeaderText(null);
        alert.setContentText("Chọn trong danh sách để xoá!");
        alert.showAndWait();
    }
}

######


private void editEnableTxt() {
    txtMagv.setEditable(true);
    txtHogv.setEditable(true);
    txtTengv.setEditable(true);
    txtPhonegv.setEditable(true);
    txtDiachigv.setEditable(true);
    radNugv.setDisable(false);
    radNamgv.setDisable(false);
    bDategv.setDisable(false);
    comKhoa.setDisable(false);
    btnOKgv.setDisable(false);
    btnAdd.setDisable(false);
}

######


private void editDisableTxt() {
    txtMagv.setEditable(false);
    txtHogv.setEditable(false);
    txtTengv.setEditable(false);
    txtPhonegv.setEditable(false);
    txtDiachigv.setEditable(false);
    radNugv.setDisable(true);
    radNamgv.setDisable(true);
    bDategv.setDisable(true);
    comKhoa.setDisable(true);
    btnOKgv.setDisable(true);
    btnAdd.setDisable(true);
}

######


private boolean maGvisCheck() throws SQLException {
    PreparedStatement preCk = null;
    ResultSet rsCk = null;
    Connection connection = SQLiteConnection.connector();
    String gvstr1 = "select ? from GIAOVIEN";
    try {
        preCk = connection.prepareStatement(gvstr1);
        preCk.setString(1, txtMagv.getText());
        rsCk = preCk.executeQuery();
        if (rsCk.next()) {
            return true;
        } else {
            Alert alert = new Alert(Alert.AlertType.ERROR);
            alert.setTitle("Lỗi");
            alert.setHeaderText(null);
            alert.setContentText("Không tìm thấy Mã Giáo Viên!");
            alert.showAndWait();
            return false;
        }
    } catch (Exception e) {
        return false;
    } finally {
        rsCk.close();
        preCk.close();
    }
}

######


private void suaGiaoVien() throws SQLException {
    if (emtyFeild()) {
        if (radNamgv.isSelected()) {
            lblsex = radNamgv.getText();
        } else if (radNugv.isSelected()) {
            lblsex = radNugv.getText();
        }
        Connection conngv = SQLiteConnection.connector();
        PreparedStatement preparegvs = null;
        String str2 = "update GIAOVIEN set HoGV = ?,TenGV = ?,NgaySinhGV = ?,GioiTinhGV = ?,PhoneGV = ?,DiaChiGV = ?,MaKhoaGV = ? where MaGV = ?";
        try {
            preparegvs = conngv.prepareStatement(str2);
            preparegvs.setString(1, txtHogv.getText());
            preparegvs.setString(2, txtTengv.getText());
            preparegvs.setString(3, bDategv.getEditor().getText());
            preparegvs.setString(4, lblsex);
            preparegvs.setString(5, txtPhonegv.getText());
            preparegvs.setString(6, txtDiachigv.getText());
            preparegvs.setString(7, comKhoa.getSelectionModel().getSelectedItem());
            preparegvs.setString(8, txtMagv.getText());
            preparegvs.executeUpdate();
            dataBaseGVinput();
            preparegvs.close();
            conngv.close();
            clearText();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
        }
    }
}

######


@FXML
void onThemSua(ActionEvent event) {
    if (event.getSource() == btnSuagv) {
        editEnableTxt();
        btnAdd.setDisable(true);
        btnOKgv.setOnAction(e -> {
            try {
                if (maGvisCheck()) {
                    suaGiaoVien();
                    editDisableTxt();
                }
            } catch (SQLException s) {
                s.printStackTrace();
            }
        });
    }
    if (event.getSource() == btnThemgv) {
        clearText();
        editEnableTxt();
        btnOKgv.setDisable(true);
        btnAdd.setOnAction(e -> {
            try {
                themGiaoVien();
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
            editDisableTxt();
        });
    }
}

######


@SqlUpdate("create table groupes (idt integer primary key autoincrement, idProduit integer, idService integer, nbPersonnes integer, nvPrix varchar(255), description varchar(240))")
void createGroupeTable();

######


@SqlUpdate("insert into groupes (idProduit, idService, nbPersonnes, nvPrix, description) values (:idProduit, :idService , :nbPersonnes, :nvPrix, :description)")
@GetGeneratedKeys
int insert(@BindBean Groupe g);

######


@SqlUpdate("update groupes set idProduit = :idProduit, idService = :idService, nbPersonnes = :nbPersonnes, nvPrix = :nvPrix, description = :description")
void update(@BindBean Groupe p);

######


@SqlQuery("select count(*) from groupes")
public int count();

######


@SqlQuery("select * from groupes where idt = :idt")
@RegisterMapperFactory(BeanMapperFactory.class)
Groupe findByIdt(@Bind("idt") int idt);

######


@SqlQuery("select * from groupes where idProduit = :idProduit")
@RegisterMapperFactory(BeanMapperFactory.class)
Groupe findByIdProduct(@Bind("idProduit") int idProduit);

######


@SqlQuery("select * from groupes where idService = :idService")
@RegisterMapperFactory(BeanMapperFactory.class)
Groupe findByIdService(@Bind("idService") int idService);

######


@SqlUpdate("delete from groupes where idt = :idt")
int deleteGroupe(@Bind("idt") int idt);

######


@SqlUpdate("drop table if exists groupes")
void dropGroupeTable();

######


void close();

######


public void testClass(String inVal) throws Exception {
    GCmMsgManager msgMgr = GCmMsgManager.getInstance();
    try {
        if (inVal == null || inVal.length() == 0) {
            throw new Exception(msgMgr.getMessage("A11001"));
        } else if (inVal.equals("1")) {
            throw new Exception(msgMgr.getMessage("A11002"));
        } else if (inVal.equals("2")) {
            throw new Exception(msgMgr.getMessage("A12001"));
        } else if (inVal.equals("3")) {
            throw new Exception(msgMgr.getMessage("A13001"));
        }
    } catch (Exception e) {
        throw new Exception(e.getMessage());
    }
}

######


public void testConnection() throws Exception {
    GCmConnection conn = null;
    conn = GCmDbManager.getInstance().getConnection();
    if (conn == null) {
        GCmLog.writeLog("1connection is null1");
    } else {
        testConnection2(conn);
    }
    if (conn == null) {
        GCmLog.writeLog("2connection is null2");
    } else {
        GCmLog.writeLog("3connection is not null");
        conn.close();
    }
}

######


public void testConnection2(GCmConnection xx) throws Exception {
    if (xx == null) {
        GCmLog.writeLog("4connection is null3");
    } else {
        GCmLog.writeLog("5connection : conn==null;");
    }
}

######


public int guestBookAdd(GuestBook gb) {
    int result = 0;
    String sql = "INSERT INTO guestbook (gid, name_, pw, content, regDate, clientIP, blind) VALUES ((SELECT * FROM (SELECT CONCAT('G', LPAD(IFNULL(SUBSTRING(MAX(gid), 2), 0) + 1, 5, 0)) AS newGid FROM guestbook) g), ?, ?, ?, NOW(), ?,  0)";
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = MySQLConnection.connect();
        pstmt = conn.prepareStatement(sql);
        pstmt.setString(1, gb.getName_());
        pstmt.setString(2, gb.getPw());
        pstmt.setString(3, gb.getContent());
        pstmt.setString(4, gb.getClientIP());
        result = pstmt.executeUpdate();
    } catch (SQLException se) {
        se.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (pstmt != null)
                pstmt.close();
        } catch (SQLException se) {
        }
        try {
            MySQLConnection.close();
        } catch (SQLException se) {
            se.printStackTrace();
        }
    }
    return result;
}

######


public List<GuestBook> guestBookList(String key, String value) {
    List<GuestBook> result = new ArrayList<GuestBook>();
    String sql = "SELECT gid, name_, content, regDate FROM guestbook WHERE blind = 0";
    switch(key) {
        case "ALL":
            sql += "";
            break;
        case "name_":
            sql += " AND INSTR(name_, ?)";
            break;
        case "content":
            sql += " AND INSTR(content, ?)";
            break;
        case "regDate":
            sql += " AND INSTR(regDate, ?)";
            break;
    }
    sql += " ORDER BY gid DESC";
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = MySQLConnection.connect();
        pstmt = conn.prepareStatement(sql);
        if (!key.equals("ALL")) {
            pstmt.setString(1, value);
        }
        ResultSet rs = pstmt.executeQuery();
        while (rs.next()) {
            String gid = rs.getString("gid");
            String name_ = rs.getString("name_");
            String content = rs.getString("content");
            String regDate = rs.getString("regDate");
            GuestBook gb = new GuestBook();
            gb.setGid(gid);
            gb.setName_(name_);
            gb.setContent(content);
            gb.setRegDate(LocalDate.parse(regDate));
            result.add(gb);
        }
        rs.close();
    } catch (SQLException se) {
        System.out.print(se.getMessage());
    } catch (Exception e) {
        System.out.print(e.getMessage());
    } finally {
        try {
            if (pstmt != null)
                pstmt.close();
        } catch (SQLException se) {
        }
        try {
            MySQLConnection.close();
        } catch (SQLException se) {
            System.out.print(se.getMessage());
        }
    }
    return result;
}

######


public int totalCount() {
    int result = 0;
    String sql = "SELECT COUNT(*) AS totalCount FROM guestbook WHERE blind = 0";
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = MySQLConnection.connect();
        pstmt = conn.prepareStatement(sql);
        ResultSet rs = pstmt.executeQuery();
        while (rs.next()) {
            result = rs.getInt("totalCount");
        }
        rs.close();
    } catch (SQLException se) {
        se.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (pstmt != null)
                pstmt.close();
        } catch (SQLException se) {
        }
        try {
            MySQLConnection.close();
        } catch (SQLException se) {
            se.printStackTrace();
        }
    }
    return result;
}

######


public List<GuestBook> picList() {
    List<GuestBook> result = new ArrayList<GuestBook>();
    String sql = "SELECT pid, picName, picContent FROM pictureList ORDER BY pid";
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = MySQLConnection.connect();
        pstmt = conn.prepareStatement(sql);
        ResultSet rs = pstmt.executeQuery();
        while (rs.next()) {
            String pid = rs.getString("pid");
            String picName = rs.getString("picName");
            String picContent = rs.getString("picContent");
            GuestBook gb = new GuestBook();
            gb.setPid(pid);
            gb.setPicName(picName);
            gb.setPicContent(picContent);
            result.add(gb);
        }
        rs.close();
    } catch (SQLException se) {
        System.out.print(se.getMessage());
    } catch (Exception e) {
        System.out.print(e.getMessage());
    } finally {
        try {
            if (pstmt != null)
                pstmt.close();
        } catch (SQLException se) {
        }
        try {
            MySQLConnection.close();
        } catch (SQLException se) {
            System.out.print(se.getMessage());
        }
    }
    return result;
}

######


public int guestbookRemove(GuestBook gb) {
    int result = 0;
    String sql = "DELETE FROM guestbook WHERE blind=0 AND gid=? AND pw=?";
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = MySQLConnection.connect();
        pstmt = conn.prepareStatement(sql);
        pstmt.setString(1, gb.getGid());
        pstmt.setString(2, gb.getPw());
        result = pstmt.executeUpdate();
    } catch (SQLException se) {
        se.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (pstmt != null)
                pstmt.close();
        } catch (SQLException se) {
        }
        try {
            MySQLConnection.close();
        } catch (SQLException se) {
            se.printStackTrace();
        }
    }
    return result;
}

######


public List<GwasDTO> getGwasMappingByGeneSymbol(List<GwasDTO> gwasMappings, String mgiGeneSymbol) throws SQLException {
    List<GwasDTO> mappedList = new ArrayList<>();
    for (GwasDTO gwasMapping : gwasMappings) {
        if (gwasMapping.getGwasMgiGeneSymbol().equals(mgiGeneSymbol)) {
            mappedList.add(gwasMapping);
        }
        return mappedList;
    }
    return null;
}

######


public List<GwasDTO> getGwasMappingDetailRows(String sql) throws SQLException {
    Connection connection = admintoolsDataSource.getConnection();
    String query = "SELECT * FROM impc2gwas WHERE pheno_mapping_category != 'no mapping' AND " + sql;
    System.out.println("gwas mapping detail rows query: " + query);
    List<GwasDTO> results = new ArrayList<>();
    try (PreparedStatement ps = connection.prepareStatement(query)) {
        ResultSet resultSet = ps.executeQuery();
        while (resultSet.next()) {
            GwasDTO gwasMappingRow = new GwasDTO();
            gwasMappingRow.setGwasMgiAlleleName(resultSet.getString("mgi_allele_name"));
            gwasMappingRow.setGwasMgiAlleleId(resultSet.getString("mgi_allele_id"));
            gwasMappingRow.setGwasMouseGender(resultSet.getString("impc_mouse_gender"));
            gwasMappingRow.setGwasPhenoMappingCategory(resultSet.getString("pheno_mapping_category"));
            gwasMappingRow.setGwasSnpId(resultSet.getString("gwas_snp_id"));
            gwasMappingRow.setGwasPvalue(resultSet.getFloat("gwas_p_value"));
            gwasMappingRow.setGwasReportedGene(resultSet.getString("gwas_reported_gene"));
            gwasMappingRow.setGwasMappedGene(resultSet.getString("gwas_mapped_gene"));
            gwasMappingRow.setGwasUpstreamGene(resultSet.getString("gwas_upstream_gene"));
            gwasMappingRow.setGwasDownstreamGene(resultSet.getString("gwas_downstream_gene"));
            results.add(gwasMappingRow);
        }
        resultSet.close();
        ps.close();
        connection.close();
    } catch (Exception e) {
        log.error("Fetch IMPC GWAS mapping data failed: " + e.getLocalizedMessage());
        e.printStackTrace();
    }
    return results;
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    LogOutBtnActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    EditHallInfoActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    Menu = new javax.swing.JPanel();
    LogOutBtn = new javax.swing.JButton();
    UserLogged = new javax.swing.JLabel();
    HallAccesed = new javax.swing.JLabel();
    EditHallInfo = new javax.swing.JButton();
    ChairsPanel = new javax.swing.JPanel();
    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    setSize(getPreferredSize());
    Menu.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 2));
    LogOutBtn.setText("LogOut");
    LogOutBtn.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            LogOutBtnActionPerformed(evt);
        }
    });
    UserLogged.setFont(new java.awt.Font("Times New Roman", 0, 18));
    UserLogged.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    HallAccesed.setFont(new java.awt.Font("Times New Roman", 0, 18));
    HallAccesed.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    EditHallInfo.setText("Edit");
    EditHallInfo.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            EditHallInfoActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout MenuLayout = new javax.swing.GroupLayout(Menu);
    Menu.setLayout(MenuLayout);
    MenuLayout.setHorizontalGroup(MenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(MenuLayout.createSequentialGroup().addGap(18, 18, 18).addComponent(HallAccesed, javax.swing.GroupLayout.PREFERRED_SIZE, 218, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(EditHallInfo, javax.swing.GroupLayout.PREFERRED_SIZE, 158, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(379, 379, 379).addComponent(UserLogged, javax.swing.GroupLayout.DEFAULT_SIZE, 266, Short.MAX_VALUE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(LogOutBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 113, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap()));
    MenuLayout.setVerticalGroup(MenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, MenuLayout.createSequentialGroup().addContainerGap().addGroup(MenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(EditHallInfo, javax.swing.GroupLayout.DEFAULT_SIZE, 31, Short.MAX_VALUE).addComponent(HallAccesed, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(UserLogged, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(LogOutBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addContainerGap()));
    ChairsPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    javax.swing.GroupLayout ChairsPanelLayout = new javax.swing.GroupLayout(ChairsPanel);
    ChairsPanel.setLayout(ChairsPanelLayout);
    ChairsPanelLayout.setHorizontalGroup(ChairsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 0, Short.MAX_VALUE));
    ChairsPanelLayout.setVerticalGroup(ChairsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 451, Short.MAX_VALUE));
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(ChairsPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(Menu, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addContainerGap()));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(Menu, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(ChairsPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addContainerGap()));
    pack();
    setLocationRelativeTo(null);
}

######


private void LogOutBtnActionPerformed(java.awt.event.ActionEvent evt) {
    this.dispose();
}

######


private void EditHallInfoActionPerformed(java.awt.event.ActionEvent evt) {
    int sala = Integer.parseInt(HallAccesed.getText().substring(2));
    this.dispose();
    HallInfo_Update HIU = new HallInfo_Update(User, CM, sala);
    HIU.setVisible(true);
    HIU.setResizable(false);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(Hall.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(Hall.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(Hall.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(Hall.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    ManagerID_TxtActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    StartHour_TxtActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    CreateHallInfoActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    HallTitle = new javax.swing.JLabel();
    jPanel1 = new javax.swing.JPanel();
    ID_Lbl = new javax.swing.JLabel();
    Hall_Number_Txt = new javax.swing.JTextField();
    Name_Lbl = new javax.swing.JLabel();
    Name_Txt = new javax.swing.JTextField();
    ChairNr_Lbl = new javax.swing.JLabel();
    Chairs_Txt = new javax.swing.JTextField();
    Manager_ID_Lbl = new javax.swing.JLabel();
    ManagerID_Txt = new javax.swing.JTextField();
    StartHour_Lbl = new javax.swing.JLabel();
    FinalHour_Lbl = new javax.swing.JLabel();
    StartHour_Txt = new javax.swing.JTextField();
    FinalHour_Txt = new javax.swing.JTextField();
    CreateHallInfo = new javax.swing.JButton();
    MovieNameLbl = new javax.swing.JLabel();
    MovieNames = new javax.swing.JComboBox<>();
    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    setSize(getPreferredSize());
    HallTitle.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    HallTitle.setText("Hall ");
    HallTitle.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    HallTitle.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    ID_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    ID_Lbl.setText("Hall_Number");
    ID_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Hall_Number_Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    Name_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Name_Lbl.setText("Hall_Name");
    Name_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Name_Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    ChairNr_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    ChairNr_Lbl.setText("Chairs");
    ChairNr_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Chairs_Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    Manager_ID_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Manager_ID_Lbl.setText("Manager_ID");
    Manager_ID_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    ManagerID_Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    ManagerID_Txt.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            ManagerID_TxtActionPerformed(evt);
        }
    });
    StartHour_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    StartHour_Lbl.setText("Opened between");
    StartHour_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    FinalHour_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    FinalHour_Lbl.setText("and");
    FinalHour_Lbl.setToolTipText("");
    FinalHour_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    StartHour_Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    StartHour_Txt.setText("8:00");
    StartHour_Txt.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            StartHour_TxtActionPerformed(evt);
        }
    });
    FinalHour_Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    FinalHour_Txt.setText("21:00");
    CreateHallInfo.setText("Go");
    CreateHallInfo.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            CreateHallInfoActionPerformed(evt);
        }
    });
    MovieNameLbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    MovieNameLbl.setText("Movie");
    MovieNameLbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
    jPanel1.setLayout(jPanel1Layout);
    jPanel1Layout.setHorizontalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addContainerGap().addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false).addComponent(Name_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(ID_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addComponent(Manager_ID_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(StartHour_Lbl, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addComponent(FinalHour_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, 95, Short.MAX_VALUE)).addComponent(ChairNr_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(FinalHour_Txt, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 361, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(Chairs_Txt, javax.swing.GroupLayout.PREFERRED_SIZE, 361, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(StartHour_Txt, javax.swing.GroupLayout.DEFAULT_SIZE, 361, Short.MAX_VALUE).addComponent(ManagerID_Txt)).addComponent(Name_Txt, javax.swing.GroupLayout.PREFERRED_SIZE, 361, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(Hall_Number_Txt, javax.swing.GroupLayout.PREFERRED_SIZE, 361, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(0, 0, Short.MAX_VALUE)).addGroup(jPanel1Layout.createSequentialGroup().addComponent(MovieNameLbl, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addComponent(CreateHallInfo, javax.swing.GroupLayout.PREFERRED_SIZE, 274, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(0, 0, Short.MAX_VALUE)).addComponent(MovieNames, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))).addContainerGap()));
    jPanel1Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] { ChairNr_Lbl, FinalHour_Lbl, ID_Lbl, Manager_ID_Lbl, Name_Lbl, StartHour_Lbl });
    jPanel1Layout.setVerticalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addContainerGap().addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(ID_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(Hall_Number_Txt)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(Name_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(Name_Txt, javax.swing.GroupLayout.DEFAULT_SIZE, 45, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(ChairNr_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(Chairs_Txt)).addGap(11, 11, 11).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(ManagerID_Txt).addComponent(Manager_ID_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, 40, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(StartHour_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(StartHour_Txt, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(FinalHour_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(FinalHour_Txt)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(MovieNameLbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(MovieNames, javax.swing.GroupLayout.DEFAULT_SIZE, 41, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 28, Short.MAX_VALUE).addComponent(CreateHallInfo, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap()));
    jPanel1Layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] { ChairNr_Lbl, FinalHour_Lbl, ID_Lbl, Manager_ID_Lbl, Name_Lbl, StartHour_Lbl });
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(HallTitle, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(HallTitle, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    pack();
    setLocationRelativeTo(null);
}

######


private void FillComboBox() {
    try {
        Client sclav = new Client();
        sclav.connectToServer();
        String SQL = "Select * from movies";
        sclav.Query(SQL);
        ResultSet rs = sclav.rs;
        while (rs.next()) {
            String name = rs.getString("name");
            MovieNames.addItem(name);
        }
    } catch (SQLException ex) {
        Logger.getLogger(HallInfo_Create.class.getName()).log(Level.SEVERE, null, ex);
    } catch (IOException ex) {
        Logger.getLogger(HallInfo_Create.class.getName()).log(Level.SEVERE, null, ex);
    } catch (ClassNotFoundException ex) {
        Logger.getLogger(HallInfo_Create.class.getName()).log(Level.SEVERE, null, ex);
    }
}

######


private void CreateHallInfoActionPerformed(java.awt.event.ActionEvent evt) {
    String S = Name_Txt.getText();
    String T = (String) MovieNames.getSelectedItem();
    int nr = 0;
    int nrc = 0;
    try {
        nr = parseInt(Hall_Number_Txt.getText());
        try {
            nrc = parseInt(Chairs_Txt.getText());
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Wrong Chair Number");
        }
    } catch (NumberFormatException e) {
        JOptionPane.showMessageDialog(null, "Wrong Hall Number");
    }
    if (nr < 1 || nr > 30) {
        nr = 0;
        JOptionPane.showMessageDialog(null, "Wrong Hall Number");
    }
    if (nrc < 1 || nrc > 60) {
        nrc = 0;
        JOptionPane.showMessageDialog(null, "Wrong Chair Number");
    }
    int ok = 1;
    SimpleDateFormat formatter = new SimpleDateFormat("HH:mm");
    java.util.Date d1 = null;
    java.util.Date d2 = null;
    try {
        d1 = (java.util.Date) formatter.parse(StartHour_Txt.getText());
        d2 = (java.util.Date) formatter.parse(FinalHour_Txt.getText());
    } catch (ParseException ex) {
        JOptionPane.showMessageDialog(null, "Wrong Time Information");
    }
    if (d1 != null && d2 != null && d2.before(d1)) {
        ok = 0;
        JOptionPane.showMessageDialog(null, "Wrong Time Information");
    }
    if (S.equals("") || nr == 0 || nrc == 0 || ok == 0) {
        this.dispose();
        HallInfo_Create HICU = new HallInfo_Create(User, CM);
        HICU.setVisible(true);
        HICU.setResizable(false);
    } else {
        ResultSet rs = null;
        try {
            Client sclav = new Client();
            sclav.connectToServer();
            String SQL = "select id from halls where id=" + nr;
            sclav.Query(SQL);
            rs = sclav.rs;
        } catch (IOException ex) {
            Logger.getLogger(HallInfo_Create.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(HallInfo_Create.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            if (!rs.next()) {
                Client sclav = new Client();
                sclav.connectToServer();
                String aux1 = formatter.format(d1);
                String aux2 = formatter.format(d2);
                String SQL = "INSERT INTO halls values (" + nr + ",'" + S + "'," + nrc + ",'" + User + "','" + aux1 + "','" + aux2 + "','" + T + "')";
                sclav.Query(SQL);
                int conf = sclav.confExec;
                this.dispose();
                Halls HS = new Halls(User, CM);
                HS.setVisible(true);
                HS.setResizable(false);
            } else {
                JOptionPane.showMessageDialog(null, "Hall already created");
            }
        } catch (SQLException ex) {
            Logger.getLogger(HallInfo_Create.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(HallInfo_Create.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(HallInfo_Create.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
}

######


private void StartHour_TxtActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void ManagerID_TxtActionPerformed(java.awt.event.ActionEvent evt) {
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(HallInfo_Create.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(HallInfo_Create.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(HallInfo_Create.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(HallInfo_Create.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
}

######


private void FillComboBox() {
    try {
        Client sclav = new Client();
        sclav.connectToServer();
        String SQL = "Select * from movies";
        sclav.Query(SQL);
        ResultSet rs = sclav.rs;
        while (rs.next()) {
            String name = rs.getString("name");
            MovieNames.addItem(name);
        }
    } catch (SQLException ex) {
        Logger.getLogger(HallInfo_Create.class.getName()).log(Level.SEVERE, null, ex);
    } catch (IOException ex) {
        Logger.getLogger(HallInfo_Update.class.getName()).log(Level.SEVERE, null, ex);
    } catch (ClassNotFoundException ex) {
        Logger.getLogger(HallInfo_Update.class.getName()).log(Level.SEVERE, null, ex);
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    UpdateHallInfoActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    HallTitle = new javax.swing.JLabel();
    Panel = new javax.swing.JPanel();
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    jLabel4 = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    jLabel6 = new javax.swing.JLabel();
    jLabel7 = new javax.swing.JLabel();
    Hall_Number_Txt = new javax.swing.JTextField();
    Name_Txt = new javax.swing.JTextField();
    Chairs_Txt = new javax.swing.JTextField();
    ManagerID_Txt = new javax.swing.JTextField();
    StartHour_Txt = new javax.swing.JTextField();
    FinalHour_Txt = new javax.swing.JTextField();
    MovieNames = new javax.swing.JComboBox<>();
    UpdateHallInfo = new javax.swing.JButton();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    HallTitle.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    HallTitle.setText("Hall ");
    HallTitle.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    HallTitle.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    Panel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel1.setText("Hall_Number");
    jLabel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel2.setText("Hall_Name");
    jLabel2.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel3.setText("Chairs");
    jLabel3.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel4.setText("Manager_ID");
    jLabel4.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    jLabel5.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel5.setText("Opened between");
    jLabel5.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    jLabel6.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel6.setText("and");
    jLabel6.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    jLabel7.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel7.setText("Movie");
    jLabel7.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Hall_Number_Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    Name_Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    Chairs_Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    ManagerID_Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    StartHour_Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    FinalHour_Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    UpdateHallInfo.setText("Update");
    UpdateHallInfo.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            UpdateHallInfoActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout PanelLayout = new javax.swing.GroupLayout(Panel);
    Panel.setLayout(PanelLayout);
    PanelLayout.setHorizontalGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(PanelLayout.createSequentialGroup().addContainerGap().addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false).addComponent(jLabel7, javax.swing.GroupLayout.DEFAULT_SIZE, 103, Short.MAX_VALUE).addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, 103, Short.MAX_VALUE).addComponent(jLabel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(Hall_Number_Txt).addComponent(Name_Txt).addComponent(Chairs_Txt).addComponent(ManagerID_Txt).addComponent(StartHour_Txt).addComponent(FinalHour_Txt).addComponent(MovieNames, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addGroup(PanelLayout.createSequentialGroup().addComponent(UpdateHallInfo, javax.swing.GroupLayout.PREFERRED_SIZE, 262, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(0, 0, Short.MAX_VALUE))).addContainerGap()));
    PanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] { jLabel1, jLabel2, jLabel3, jLabel4, jLabel5, jLabel6, jLabel7 });
    PanelLayout.setVerticalGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(PanelLayout.createSequentialGroup().addContainerGap().addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(Hall_Number_Txt).addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, 42, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(Name_Txt).addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, 42, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(Chairs_Txt).addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, 41, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(ManagerID_Txt).addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, 34, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(StartHour_Txt).addComponent(jLabel5, javax.swing.GroupLayout.DEFAULT_SIZE, 43, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(FinalHour_Txt).addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, 38, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(jLabel7, javax.swing.GroupLayout.DEFAULT_SIZE, 38, Short.MAX_VALUE).addComponent(MovieNames)).addGap(18, 18, 18).addComponent(UpdateHallInfo, javax.swing.GroupLayout.DEFAULT_SIZE, 50, Short.MAX_VALUE).addContainerGap()));
    PanelLayout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] { jLabel1, jLabel2, jLabel3, jLabel4, jLabel5, jLabel6, jLabel7 });
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(HallTitle, javax.swing.GroupLayout.DEFAULT_SIZE, 488, Short.MAX_VALUE).addComponent(Panel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(HallTitle, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(Panel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    pack();
    setLocationRelativeTo(null);
}

######


private void UpdateHallInfoActionPerformed(java.awt.event.ActionEvent evt) {
    String S = Name_Txt.getText();
    String T = (String) MovieNames.getSelectedItem();
    String M = ManagerID_Txt.getText();
    int nr = 0;
    int nrc = 0;
    try {
        nr = parseInt(Hall_Number_Txt.getText());
        try {
            nrc = parseInt(Chairs_Txt.getText());
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Wrong Chair Number");
        }
    } catch (NumberFormatException e) {
        JOptionPane.showMessageDialog(null, "Wrong Hall Number");
    }
    if (nr < 1 || nr > 30) {
        nr = 0;
        JOptionPane.showMessageDialog(null, "Wrong Hall Number");
    }
    if (nrc < 1 || nrc > 60) {
        nrc = 0;
        JOptionPane.showMessageDialog(null, "Wrong Chair Number");
    }
    int ok = 1;
    SimpleDateFormat formatter = new SimpleDateFormat("HH:mm");
    java.util.Date d1 = null;
    java.util.Date d2 = null;
    try {
        d1 = (java.util.Date) formatter.parse(StartHour_Txt.getText());
        d2 = (java.util.Date) formatter.parse(FinalHour_Txt.getText());
    } catch (ParseException ex) {
        JOptionPane.showMessageDialog(null, "Wrong Time Information");
    }
    if (d1 != null && d2 != null && d2.before(d1)) {
        ok = 0;
        JOptionPane.showMessageDialog(null, "Wrong Time Information");
    }
    if (S.equals("") || nr == 0 || nrc == 0 || ok == 0) {
        this.dispose();
        HallInfo_Update HIU = new HallInfo_Update(User, CM, ID);
        HIU.setVisible(true);
        HIU.setResizable(false);
    } else {
        try {
            String aux1 = formatter.format(d1);
            String aux2 = formatter.format(d2);
            Client sclav = new Client();
            sclav.connectToServer();
            String SQL_update = "Update halls " + "set name='" + S + "', " + "numberChairs=" + nrc + ", " + "manager_id='" + M + "', " + "startHour='" + aux1 + "', " + "finalHour='" + aux2 + "', " + "movieName='" + T + "' " + "where id=" + ID + ";";
            sclav.Query(SQL_update);
            int updt = sclav.confExec;
            this.dispose();
            if (updt > 0) {
                JOptionPane.showMessageDialog(null, "Update Done");
            }
            Hall H = new Hall(User, CM, "S " + ID);
            H.setVisible(true);
            H.setResizable(false);
        } catch (IOException ex) {
            Logger.getLogger(HallInfo_Update.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(HallInfo_Update.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(HallInfo_Update.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(HallInfo_Update.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(HallInfo_Update.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(HallInfo_Update.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    AddHallBtnActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    LogOutBtnActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    Rap1GoBtnActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    Rap2GoBtn1ActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    Menu = new javax.swing.JPanel();
    AddHallBtn = new javax.swing.JButton();
    LogOutBtn = new javax.swing.JButton();
    UserLogged = new javax.swing.JLabel();
    HallLayout = new javax.swing.JPanel();
    RightPanelLayout = new javax.swing.JPanel();
    RaportsTitle = new javax.swing.JLabel();
    RaportLayout = new javax.swing.JPanel();
    Report1 = new javax.swing.JPanel();
    Date1lb = new javax.swing.JLabel();
    Date2lb = new javax.swing.JLabel();
    Date1Txt = new javax.swing.JTextField();
    Date2Txt = new javax.swing.JTextField();
    Rap1GoBtn = new javax.swing.JButton();
    Report2 = new javax.swing.JPanel();
    HallTxt = new javax.swing.JTextField();
    Hallb = new javax.swing.JLabel();
    Rap2GoBtn1 = new javax.swing.JButton();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    setSize(getPreferredSize());
    Menu.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 2));
    AddHallBtn.setText("Add");
    AddHallBtn.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            AddHallBtnActionPerformed(evt);
        }
    });
    LogOutBtn.setText("LogOut");
    LogOutBtn.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            LogOutBtnActionPerformed(evt);
        }
    });
    UserLogged.setFont(new java.awt.Font("Times New Roman", 0, 18));
    UserLogged.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    javax.swing.GroupLayout MenuLayout = new javax.swing.GroupLayout(Menu);
    Menu.setLayout(MenuLayout);
    MenuLayout.setHorizontalGroup(MenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(MenuLayout.createSequentialGroup().addContainerGap().addComponent(AddHallBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 154, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(619, 619, 619).addComponent(UserLogged, javax.swing.GroupLayout.DEFAULT_SIZE, 260, Short.MAX_VALUE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(LogOutBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 113, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap()));
    MenuLayout.setVerticalGroup(MenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(MenuLayout.createSequentialGroup().addContainerGap().addGroup(MenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(UserLogged, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(MenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(AddHallBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(LogOutBtn))).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    MenuLayout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] { AddHallBtn, LogOutBtn, UserLogged });
    HallLayout.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 2));
    javax.swing.GroupLayout HallLayoutLayout = new javax.swing.GroupLayout(HallLayout);
    HallLayout.setLayout(HallLayoutLayout);
    HallLayoutLayout.setHorizontalGroup(HallLayoutLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 0, Short.MAX_VALUE));
    HallLayoutLayout.setVerticalGroup(HallLayoutLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 0, Short.MAX_VALUE));
    RightPanelLayout.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    RaportsTitle.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    RaportsTitle.setText("Raports");
    RaportsTitle.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    RaportLayout.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Report1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Date1lb.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Date1lb.setText("Date1");
    Date1lb.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Date2lb.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Date2lb.setText("Date2");
    Date2lb.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Date1Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    Date1Txt.setText("01/01/2000 08:00");
    Date2Txt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    Date2Txt.setText("01/01/2100 08:00");
    Rap1GoBtn.setText("Go");
    Rap1GoBtn.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            Rap1GoBtnActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout Report1Layout = new javax.swing.GroupLayout(Report1);
    Report1.setLayout(Report1Layout);
    Report1Layout.setHorizontalGroup(Report1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(Report1Layout.createSequentialGroup().addGap(24, 24, 24).addGroup(Report1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addGroup(Report1Layout.createSequentialGroup().addComponent(Date1lb, javax.swing.GroupLayout.PREFERRED_SIZE, 134, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(Date1Txt)).addGroup(Report1Layout.createSequentialGroup().addComponent(Date2lb, javax.swing.GroupLayout.PREFERRED_SIZE, 134, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(Date2Txt))).addGap(25, 25, 25)).addGroup(Report1Layout.createSequentialGroup().addGap(110, 110, 110).addComponent(Rap1GoBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 300, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(99, Short.MAX_VALUE)));
    Report1Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] { Date1lb, Date2lb });
    Report1Layout.setVerticalGroup(Report1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(Report1Layout.createSequentialGroup().addGap(23, 23, 23).addGroup(Report1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(Date1Txt).addComponent(Date1lb, javax.swing.GroupLayout.DEFAULT_SIZE, 45, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(Report1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(Date2lb, javax.swing.GroupLayout.DEFAULT_SIZE, 51, Short.MAX_VALUE).addComponent(Date2Txt, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(Rap1GoBtn, javax.swing.GroupLayout.DEFAULT_SIZE, 49, Short.MAX_VALUE).addContainerGap()));
    Report1Layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] { Date1lb, Date2lb });
    Report2.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    HallTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    HallTxt.setText("15");
    Hallb.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Hallb.setText("Hall");
    Hallb.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Rap2GoBtn1.setText("Go");
    Rap2GoBtn1.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            Rap2GoBtn1ActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout Report2Layout = new javax.swing.GroupLayout(Report2);
    Report2.setLayout(Report2Layout);
    Report2Layout.setHorizontalGroup(Report2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(Report2Layout.createSequentialGroup().addGap(30, 30, 30).addComponent(Hallb, javax.swing.GroupLayout.PREFERRED_SIZE, 136, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(HallTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 312, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(21, Short.MAX_VALUE)).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, Report2Layout.createSequentialGroup().addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(Rap2GoBtn1, javax.swing.GroupLayout.PREFERRED_SIZE, 301, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(98, 98, 98)));
    Report2Layout.setVerticalGroup(Report2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(Report2Layout.createSequentialGroup().addGap(28, 28, 28).addGroup(Report2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(Hallb, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(HallTxt, javax.swing.GroupLayout.DEFAULT_SIZE, 55, Short.MAX_VALUE)).addGap(26, 26, 26).addComponent(Rap2GoBtn1, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(35, Short.MAX_VALUE)));
    javax.swing.GroupLayout RaportLayoutLayout = new javax.swing.GroupLayout(RaportLayout);
    RaportLayout.setLayout(RaportLayoutLayout);
    RaportLayoutLayout.setHorizontalGroup(RaportLayoutLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(Report1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(Report2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE));
    RaportLayoutLayout.setVerticalGroup(RaportLayoutLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(RaportLayoutLayout.createSequentialGroup().addComponent(Report1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(Report2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)));
    javax.swing.GroupLayout RightPanelLayoutLayout = new javax.swing.GroupLayout(RightPanelLayout);
    RightPanelLayout.setLayout(RightPanelLayoutLayout);
    RightPanelLayoutLayout.setHorizontalGroup(RightPanelLayoutLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(RaportsTitle, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, RightPanelLayoutLayout.createSequentialGroup().addGap(0, 0, Short.MAX_VALUE).addComponent(RaportLayout, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)));
    RightPanelLayoutLayout.setVerticalGroup(RightPanelLayoutLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(RightPanelLayoutLayout.createSequentialGroup().addComponent(RaportsTitle, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(RaportLayout, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(Menu, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addGroup(layout.createSequentialGroup().addComponent(HallLayout, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(RightPanelLayout, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))).addContainerGap()));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(Menu, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(RightPanelLayout, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(HallLayout, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addContainerGap()));
    pack();
    setLocationRelativeTo(null);
}

######


private void AddHallBtnActionPerformed(java.awt.event.ActionEvent evt) {
    HallInfo_Create HICU = new HallInfo_Create(User, CM);
    HICU.setVisible(true);
    HICU.setResizable(false);
    this.dispose();
}

######


private void LogOutBtnActionPerformed(java.awt.event.ActionEvent evt) {
    Start JF = new Start();
    JF.setVisible(true);
    JF.setResizable(false);
    this.dispose();
}

######


private void Rap1GoBtnActionPerformed(java.awt.event.ActionEvent evt) {
    SimpleDateFormat originalFormat = new SimpleDateFormat("dd/MM/yyyy HH:mm");
    SimpleDateFormat targetFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    java.util.Date Date1 = new java.util.Date();
    try {
        Date1 = originalFormat.parse(Date1Txt.getText());
    } catch (ParseException ex) {
        Logger.getLogger(Halls.class.getName()).log(Level.SEVERE, null, ex);
    }
    String Date1v2 = targetFormat.format(Date1);
    java.util.Date Date2 = new java.util.Date();
    try {
        Date2 = originalFormat.parse(Date2Txt.getText());
    } catch (ParseException ex) {
        Logger.getLogger(Halls.class.getName()).log(Level.SEVERE, null, ex);
    }
    String Date2v2 = targetFormat.format(Date2);
    if (Date1.before(Date2)) {
        try {
            String SQL = "SELECT * from ticket where SellingHour between '" + Date1v2 + "' and '" + Date2v2 + "'";
            Client sclav = new Client();
            sclav.connectToServer();
            sclav.Query(SQL);
            ResultSet rs = sclav.rs;
            rs.last();
            int rows = rs.getRow();
            rs.beforeFirst();
            ResultSetMetaData meta = rs.getMetaData();
            int cols = meta.getColumnCount();
            JFrame frame = new JFrame();
            Object[][] rowData = new Object[rows][5];
            int i = 0;
            while (rs.next()) {
                Object[] temp = { rs.getInt("id_hall"), rs.getString("clientName"), rs.getInt("chairNumber"), rs.getTime("MovieStartHour"), rs.getTimestamp("SellingHour") };
                rowData[i] = temp;
                i++;
            }
            Object[] columnNames = { "Nr Sala", "Nume Client", "Loc", "Ora Start Film", "Data Vanzarii" };
            JTable table = new JTable(rowData, columnNames);
            JScrollPane scrollPane = new JScrollPane(table);
            frame.add(scrollPane, BorderLayout.CENTER);
            frame.setSize(1000, 500);
            frame.setVisible(true);
            frame.setLocationRelativeTo(null);
        } catch (SQLException ex) {
            Logger.getLogger(Halls.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(Halls.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(Halls.class.getName()).log(Level.SEVERE, null, ex);
        }
    } else {
        JOptionPane.showMessageDialog(null, "Wrong Information");
    }
}

######


private void Rap2GoBtn1ActionPerformed(java.awt.event.ActionEvent evt) {
    String hall = HallTxt.getText();
    int aux = Integer.parseInt(hall);
    if (aux > 1 && aux < 31) {
        try {
            String SQL = "SELECT * from ticket where id_hall=" + aux;
            Client sclav = new Client();
            sclav.connectToServer();
            sclav.Query(SQL);
            ResultSet rs = sclav.rs;
            rs.last();
            int rows = rs.getRow();
            rs.beforeFirst();
            ResultSetMetaData meta = rs.getMetaData();
            int cols = meta.getColumnCount();
            JFrame frame = new JFrame();
            Object[][] rowData = new Object[rows][5];
            int i = 0;
            while (rs.next()) {
                Object[] temp = { rs.getInt("id_hall"), rs.getString("clientName"), rs.getInt("chairNumber"), rs.getTime("MovieStartHour"), rs.getTimestamp("SellingHour") };
                rowData[i] = temp;
                i++;
            }
            Object[] columnNames = { "Nr Sala", "Nume Client", "Loc", "Ora Start Film", "Data Vanzarii" };
            JTable table = new JTable(rowData, columnNames);
            JScrollPane scrollPane = new JScrollPane(table);
            frame.add(scrollPane, BorderLayout.CENTER);
            frame.setSize(1000, 500);
            frame.setVisible(true);
            frame.setLocationRelativeTo(null);
        } catch (SQLException ex) {
            Logger.getLogger(Halls.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(Halls.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(Halls.class.getName()).log(Level.SEVERE, null, ex);
        }
    } else {
        JOptionPane.showMessageDialog(null, "Incorrect Hall");
    }
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(Halls.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(Halls.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(Halls.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(Halls.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
}

######


@Transactional(readOnly = true)
public Images getAllImages(int start, int length, String search) throws Exception {
    Images images = new Images();
    if (!search.equals("")) {
        images = getImagesFromSearch(start, length, search);
    } else {
        images = queryDatabaseByRows(start, length);
    }
    images.setStart(start);
    images.setLength(length);
    return images;
}

######


private Images getImagesFromSearch(int start, int length, String search) throws SolrServerException {
    List<ImaImageRecord> list = new ArrayList<ImaImageRecord>();
    Images images = new Images();
    List<String> ids = imagesSolrDao.getIdsForKeywordsSearch(search, start, length);
    for (String id : ids) {
        ImaImageRecord record = getImageWithId(Integer.valueOf(id));
        list.add(record);
    }
    images.setTotal(imagesSolrDao.getNumberFound());
    images.setImages(list);
    return images;
}

######


private Images queryDatabaseByRows(int start, int length) {
    Images images = new Images();
    Query q = sessionFactory.getCurrentSession().createQuery("from ImaImageRecord where published_status_id=1");
    if (length != 0) {
        q.setFirstResult(start);
        q.setMaxResults(length);
    }
    images.setTotal(0);
    images.setImages(q.list());
    return images;
}

######


@Transactional(readOnly = true)
public ImaImageRecord getImageWithId(int id) {
    return (ImaImageRecord) sessionFactory.getCurrentSession().createQuery("FROM ImaImageRecord WHERE published_status_id=1 AND id=?").setInteger(0, id).uniqueResult();
}

######


@Override
@Transactional(readOnly = true)
public long getTotalNumberOfImages() {
    return (Long) sessionFactory.getCurrentSession().createQuery("select count(*) from ImaImageRecord where published_status_id=1").uniqueResult();
}

######


@Override
public void handleMessage(Message msg) {
    super.handleMessage(msg);
    HistoryActivity historyActivity = this.weakReference.get();
    switch(msg.what) {
        case FRESH_LIST:
            historyActivity.freshList();
            break;
        case INIT_HISTORY:
            break;
        case ILLEGAL_DATE:
            break;
    }
}

######


public List<HospitalModel> getAllHospitalsByHospitalType(HospitalTypeEnum hospitalTypeEnum) {
    return getEntitymanager().createQuery("SELECT e FROM HospitalModel e WHERE e.hospitalType =:param", HospitalModel.class).setParameter("param", hospitalTypeEnum).getResultList();
}

######


public List<HospitalPoliclinicRelModel> getPoliclinicByHospital(HospitalModel hospitalModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM HospitalPoliclinicRelModel e WHERE e.hospital = :hospitalModel ORDER BY e.policlinic.policlinicName");
    query.setParameter("hospitalModel", hospitalModel);
    return query.getResultList();
}

######


private Connection connect() {
    String sql = "jdbc:sqlite:HRDatabase.db";
    Connection conn = null;
    try {
        conn = DriverManager.getConnection(sql);
    } catch (SQLException ex) {
        Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
    }
    return conn;
}

######


public void createTable(String sql) {
    Connection conn = null;
    try {
        conn = connect();
        Statement statement = conn.createStatement();
        statement.executeUpdate(sql);
    } catch (SQLException ex) {
        Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
}

######


public void addLoginDetail(String username, String password, String authorisationLvl) {
    Connection conn = null;
    try {
        conn = connect();
        String sql = "SELECT username FROM loginDetails WHERE username = ?";
        PreparedStatement pS = conn.prepareStatement(sql);
        pS.setString(1, username);
        ResultSet result = pS.executeQuery();
        if (result.next()) {
            System.out.println("Username \"" + username + "\" already exists");
        } else {
            sql = "INSERT INTO loginDetails VALUES(?,?,?,?)";
            pS = conn.prepareStatement(sql);
            pS.setString(2, username);
            pS.setString(3, password);
            pS.setString(4, authorisationLvl);
            pS.executeUpdate();
            printTable("loginDetails");
        }
    } catch (SQLException ex) {
        if (ex.getMessage().contains("no such table: loginDetails")) {
            String sql = "CREATE TABLE IF NOT EXISTS loginDetails(" + "ID INTEGER PRIMARY KEY, " + "username String, " + "password String, " + "authorisationLvl String);";
            createTable(sql);
            System.out.println("Created table \"loginDetails\" in database");
            addLoginDetail(username, password, authorisationLvl);
        } else {
            Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
        }
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
}

######


public String createPersonalRecord(PersonalDetailsRecord record) {
    String feedback = "Unexpected error (createPersonalRecord database)";
    Connection conn = null;
    try {
        conn = connect();
        String sql = "INSERT INTO personalRecords VALUES(?,?,?,?,?,?,?,?,?,?,?,?)";
        PreparedStatement pS = conn.prepareStatement(sql);
        pS.setInt(1, record.getID());
        pS.setString(2, record.getFirstname());
        pS.setString(3, record.getLastname());
        pS.setString(4, record.getDateOfBirth());
        pS.setString(5, record.getAddress());
        pS.setString(6, record.getTown());
        pS.setString(7, record.getCounty());
        pS.setString(8, record.getPostcode());
        pS.setString(9, record.getPhoneNb());
        pS.setString(10, record.getMobileNb());
        pS.setString(11, record.getEmergencyContact());
        pS.setString(12, record.getEmergencyContactNb());
        pS.executeUpdate();
        feedback = "Added Personal record for user #" + record.getID() + " in database";
        printTable("personalRecords");
    } catch (SQLException ex) {
        if (ex.getMessage().contains("no such table: personalRecords")) {
            String sql = "CREATE TABLE IF NOT EXISTS personalRecords(" + "ID int, " + "firstname String, " + "lastname String, " + "dateOfBirth String, " + "address String, " + "town String, " + "county String, " + "postcode String, " + "phoneNb String, " + "mobileNb String, " + "emergencyContact String, " + "emergencyContactNb String, " + "primary key(ID));";
            createTable(sql);
            System.out.println("Created table \"personalRecords\" in database");
            feedback = createPersonalRecord(record);
        } else if (ex.getMessage().contains("UNIQUE constraint failed")) {
            feedback = "Personal details record for user " + record.getID() + " already exists";
        } else {
            Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            feedback = ex.getMessage();
        }
    } catch (NullPointerException ex) {
        feedback = "Input record is null";
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    return feedback;
}

######


public String amendPersonalRecord(PersonalDetailsRecord record) {
    String feedback = "Unexpected error (amendPersonalRecord database)";
    Connection conn = null;
    try {
        conn = connect();
        String sql = "SELECT ID FROM personalRecords WHERE ID = ?";
        PreparedStatement pS = conn.prepareStatement(sql);
        pS.setInt(1, record.getID());
        ResultSet result = pS.executeQuery();
        if (!result.next()) {
            feedback = "Personal details record for user #" + record.getID() + " doesn't exist";
        } else {
            sql = "UPDATE personalRecords SET " + "firstname = ?, " + "lastname = ?, " + "dateOfBirth = ?, " + "address = ?, " + "town = ?, " + "county = ?, " + "postcode = ?, " + "phoneNb = ?, " + "mobileNb = ?, " + "emergencyContact = ?, " + "emergencyContactNb = ? " + "WHERE ID = ?";
            pS = conn.prepareStatement(sql);
            pS.setString(1, record.getFirstname());
            pS.setString(2, record.getLastname());
            pS.setString(3, record.getDateOfBirth());
            pS.setString(4, record.getAddress());
            pS.setString(5, record.getTown());
            pS.setString(6, record.getCounty());
            pS.setString(7, record.getPostcode());
            pS.setString(8, record.getPhoneNb());
            pS.setString(9, record.getMobileNb());
            pS.setString(10, record.getEmergencyContact());
            pS.setString(11, record.getEmergencyContactNb());
            pS.setInt(12, record.getID());
            pS.executeUpdate();
            feedback = "Amended Personal record for user #" + record.getID() + " in database";
            printTable("personalRecords");
        }
    } catch (SQLException ex) {
        if (ex.getMessage().contains("no such table: personalRecords")) {
            String sql = "CREATE TABLE IF NOT EXISTS personalRecords(" + "ID int, " + "firstname String, " + "lastname String, " + "dateOfBirth String, " + "address String, " + "town String, " + "county String, " + "postcode String, " + "phoneNb String, " + "mobileNb String, " + "emergencyContact String, " + "emergencyContactNb String, " + "primary key(ID));";
            createTable(sql);
            System.out.println("Created table \"personalRecords\" in database");
            feedback = amendPersonalRecord(record);
        } else {
            Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            feedback = ex.getMessage();
        }
    } catch (NullPointerException ex) {
        feedback = "Input record is null";
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    return feedback;
}

######


public PersonalDetailsRecord readPersonalRecord(int ID) {
    Connection conn = null;
    PersonalDetailsRecord personalDetailsRecord = null;
    try {
        conn = connect();
        String sql = "SELECT * FROM personalRecords WHERE ID = ?";
        PreparedStatement pS = conn.prepareStatement(sql);
        pS.setInt(1, ID);
        ResultSet result = pS.executeQuery();
        personalDetailsRecord = new PersonalDetailsRecord(result.getInt("ID"), result.getString("firstname"), result.getString("lastname"), result.getString("dateOfBirth"), result.getString("address"), result.getString("town"), result.getString("county"), result.getString("postcode"), result.getString("phoneNb"), result.getString("mobileNb"), result.getString("emergencyContact"), result.getString("emergencyContactNb"));
    } catch (SQLException ex) {
        if (ex.getMessage().contains("no such table: personalRecords")) {
            String sql = "CREATE TABLE IF NOT EXISTS personalRecords(" + "ID int, " + "firstname String, " + "lastname String, " + "dateOfBirth String, " + "address String, " + "town String, " + "county String, " + "postcode String, " + "phoneNb String, " + "mobileNb String, " + "emergencyContact String, " + "emergencyContactNb String, " + "primary key(ID));";
            createTable(sql);
            System.out.println("Created table \"personalRecords\" in database");
            readPersonalRecord(ID);
        } else if (ex.getMessage().contains("ResultSet closed")) {
            System.out.println("Personal details record for user " + ID + " don't exist");
        } else {
            Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
        }
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    printTable("personalRecords");
    return personalDetailsRecord;
}

######


public String createAnnualReviewRecord(AnnualReviewRecord record) {
    String feedback = "Unexpected error (createAnnualReviewRecord database)";
    Connection conn = null;
    try {
        conn = connect();
        String sql = "INSERT INTO annualReviewRecords VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
        PreparedStatement pS = conn.prepareStatement(sql);
        pS.setInt(2, record.getID());
        pS.setString(3, record.getName());
        pS.setInt(4, record.getReviewerID1());
        pS.setInt(5, record.getReviewerID2());
        pS.setString(6, record.getSection());
        pS.setString(7, record.getJobTitle());
        pS.setString(11, record.getReviewStatus());
        pS.setBoolean(12, record.isReviewer1Signed());
        pS.setBoolean(14, record.isReviewer2Signed());
        pS.setBoolean(16, record.isRevieweeSigned());
        pS.setString(18, record.getGoals());
        pS.setString(19, record.getObjectives());
        pS.setString(20, record.getAchievements());
        pS.executeUpdate();
        feedback = "Added Annual Review record for user #" + record.getID() + " in database";
        printTable("annualReviewRecords");
    } catch (SQLException ex) {
        if (ex.getMessage().contains("no such table: annualReviewRecords")) {
            String sql = "CREATE TABLE IF NOT EXISTS annualReviewRecords(" + "reviewID INTEGER PRIMARY KEY, " + "staffID int, " + "name String, " + "reviewerID1 int, " + "reviewerID2 int, " + "section String, " + "jobTitle String, " + "performance String, " + "comments String, " + "recommendation String, " + "reviewStatus String, " + "reviewer1Signed boolean, " + "dateReviewer1 String, " + "reviewer2Signed boolean, " + "dateReviewer2 String, " + "revieweeSigned boolean, " + "dateReviewee String, " + "goals String, " + "objectives String, " + "achievements String);";
            createTable(sql);
            System.out.println("Created table \"annualReviewRecords\" in database");
            feedback = createAnnualReviewRecord(record);
        } else {
            Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
        }
    } catch (NullPointerException ex) {
        feedback = "Input record is null";
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    return feedback;
}

######


public String amendAnnualReviewRecord(AnnualReviewRecord record) {
    String feedback = "Unexpected error (amendAnnualReviewRecord database)";
    Connection conn = null;
    try {
        conn = connect();
        String sql = "SELECT reviewID FROM annualReviewRecords WHERE reviewID = ?";
        PreparedStatement pS = conn.prepareStatement(sql);
        pS.setInt(1, record.getReviewID());
        ResultSet result = pS.executeQuery();
        if (!result.next()) {
            feedback = "Review record " + record.getReviewID() + " doesn't exist";
        } else {
            sql = "UPDATE annualReviewRecords SET " + "name = ?, " + "section = ?, " + "jobTitle = ?, " + "performance = ?, " + "comments = ?, " + "recommendation = ?, " + "reviewStatus = ?, " + "reviewer1Signed = ?, " + "dateReviewer1 = ?, " + "reviewer2Signed = ?, " + "dateReviewer2 = ?, " + "revieweeSigned = ?, " + "dateReviewee = ?, " + "goals = ?, " + "objectives = ?, " + "achievements = ? WHERE reviewID = ?";
            pS = conn.prepareStatement(sql);
            pS.setString(1, record.getName());
            pS.setString(2, record.getSection());
            pS.setString(3, record.getJobTitle());
            pS.setString(4, record.getPerformance());
            pS.setString(5, record.getComments());
            pS.setString(6, record.getRecommendation());
            pS.setString(7, record.getReviewStatus());
            pS.setBoolean(8, record.isReviewer1Signed());
            pS.setString(9, record.getDateReviewer1());
            pS.setBoolean(10, record.isReviewer2Signed());
            pS.setString(11, record.getDateReviewer2());
            pS.setBoolean(12, record.isRevieweeSigned());
            pS.setString(13, record.getDateReviewee());
            pS.setString(14, record.getGoals());
            pS.setString(15, record.getObjectives());
            pS.setString(16, record.getAchievements());
            pS.setInt(17, record.getReviewID());
            pS.executeUpdate();
            feedback = "Amended Review record #" + record.getReviewID() + " in database";
            printTable("annualReviewRecords");
        }
    } catch (SQLException ex) {
        if (ex.getMessage().contains("no such table: annualReviewRecords")) {
            String sql = "CREATE TABLE IF NOT EXISTS annualReviewRecords(" + "reviewID INTEGER PRIMARY KEY, " + "staffID int, " + "name String, " + "reviewerID1 int, " + "reviewerID2 int, " + "section String, " + "jobTitle String, " + "performance String, " + "comments String, " + "recommendation String, " + "reviewStatus String, " + "reviewer1Signed boolean, " + "dateReviewer1 String, " + "reviewer2Signed boolean, " + "dateReviewer2 String, " + "revieweeSigned boolean, " + "dateReviewee String, " + "goals String, " + "objectives String, " + "achievements String);";
            createTable(sql);
            System.out.println("Created table \"annualReviewRecords\" in database");
            feedback = amendAnnualReviewRecord(record);
        } else {
            Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
        }
    } catch (NullPointerException ex) {
        feedback = "Input record is null";
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    return feedback;
}

######


public AnnualReviewRecord readAnnualReviewRecord(int reviewID) {
    Connection conn = null;
    AnnualReviewRecord annualReviewRecord = null;
    try {
        conn = connect();
        String sql = "SELECT * FROM annualReviewRecords WHERE reviewID = ?";
        PreparedStatement pS = conn.prepareStatement(sql);
        pS.setInt(1, reviewID);
        ResultSet result = pS.executeQuery();
        annualReviewRecord = new AnnualReviewRecord(result.getInt("reviewID"), result.getInt("staffID"), result.getString("name"), result.getInt("reviewerID1"), result.getInt("reviewerID2"), result.getString("section"), result.getString("jobTitle"), result.getString("performance"), result.getString("comments"), result.getString("recommendation"), result.getString("reviewStatus"), result.getBoolean("reviewer1Signed"), result.getString("dateReviewer1"), result.getBoolean("reviewer2Signed"), result.getString("dateReviewer2"), result.getBoolean("revieweeSigned"), result.getString("dateReviewee"), result.getString("goals"), result.getString("objectives"), result.getString("achievements"));
    } catch (SQLException ex) {
        if (ex.getMessage().contains("no such table: annualReviewRecords")) {
            String sql = "CREATE TABLE IF NOT EXISTS annualReviewRecords(" + "reviewID INTEGER PRIMARY KEY, " + "staffID int, " + "name String, " + "reviewerID1 int, " + "reviewerID2 int, " + "section String, " + "jobTitle String, " + "performance String, " + "comments String, " + "recommendation String, " + "reviewStatus String, " + "reviewer1Signed boolean, " + "dateReviewer1 String, " + "reviewer2Signed boolean, " + "dateReviewer2 String, " + "revieweeSigned boolean, " + "dateReviewee String, " + "goals String, " + "objectives String, " + "achievements String);";
            createTable(sql);
            System.out.println("Created table \"annualReviewRecords\" in database");
            annualReviewRecord = readAnnualReviewRecord(reviewID);
        } else if (ex.getMessage().contains("ResultSet closed")) {
            System.out.println("Review record " + reviewID + " doesn't exist");
        } else {
            Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
        }
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    printTable("annualReviewRecords");
    return annualReviewRecord;
}

######


public ArrayList getPastReviewRecords(int userID) {
    ArrayList<AnnualReviewRecord> records = new ArrayList<>();
    Connection conn = null;
    try {
        conn = connect();
        String sql = "SELECT * FROM annualReviewRecords WHERE staffID = ? AND reviewStatus = ?";
        PreparedStatement pS = conn.prepareStatement(sql);
        pS.setInt(1, userID);
        pS.setString(2, "Signed");
        ResultSet result = pS.executeQuery();
        while (result.next()) {
            AnnualReviewRecord annualReviewRecord = new AnnualReviewRecord(result.getInt("reviewID"), result.getInt("staffID"), result.getString("name"), result.getInt("reviewerID1"), result.getInt("reviewerID2"), result.getString("section"), result.getString("jobTitle"), result.getString("performance"), result.getString("comments"), result.getString("recommendation"), result.getString("reviewStatus"), result.getBoolean("reviewer1Signed"), result.getString("dateReviewer1"), result.getBoolean("reviewer2Signed"), result.getString("dateReviewer2"), result.getBoolean("revieweeSigned"), result.getString("dateReviewee"), result.getString("goals"), result.getString("objectives"), result.getString("achievements"));
            records.add(annualReviewRecord);
        }
    } catch (SQLException ex) {
        if (ex.getMessage().contains("no such table: annualReviewRecords")) {
            String sql = "CREATE TABLE IF NOT EXISTS annualReviewRecords(" + "reviewID INTEGER PRIMARY KEY, " + "staffID int, " + "name String, " + "reviewerID1 int, " + "reviewerID2 int, " + "section String, " + "jobTitle String, " + "performance String, " + "comments String, " + "recommendation String, " + "reviewStatus String, " + "reviewer1Signed boolean, " + "dateReviewer1 String, " + "reviewer2Signed boolean, " + "dateReviewer2 String, " + "revieweeSigned boolean, " + "dateReviewee String, " + "goals String, " + "objectives String, " + "achievements String);";
            createTable(sql);
            System.out.println("Created table \"annualReviewRecords\" in database");
            records = getPastReviewRecords(userID);
        } else {
            Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
        }
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    return records;
}

######


public HashMap checkIfInvolvedInReview(int staffID) {
    Connection conn = null;
    HashMap<String, Integer> returnHash = new HashMap<>();
    try {
        conn = connect();
        String sql = "SELECT reviewID, staffID, reviewerID1, reviewerID2 " + "FROM annualReviewRecords WHERE reviewStatus = 'Uncompleted'";
        PreparedStatement pS = conn.prepareStatement(sql);
        ResultSet result = pS.executeQuery();
        while (result.next()) {
            if (result.getInt("reviewerID1") == staffID) {
                returnHash.put("Reviewer1", result.getInt("reviewID"));
                return returnHash;
            } else if (result.getInt("reviewerID2") == staffID) {
                returnHash.put("Reviewer2", result.getInt("reviewID"));
                return returnHash;
            } else if (result.getInt("staffID") == staffID) {
                returnHash.put("Reviewee", result.getInt("reviewID"));
                return returnHash;
            }
        }
        returnHash.put("Not Involved", 0);
        return returnHash;
    } catch (SQLException ex) {
        if (ex.getMessage().contains("no such table: annualReviewRecords")) {
            String sql = "CREATE TABLE IF NOT EXISTS annualReviewRecords(" + "reviewID INTEGER PRIMARY KEY, " + "staffID int, " + "name String, " + "reviewerID1 int, " + "reviewerID2 int, " + "section String, " + "jobTitle String, " + "performance String, " + "comments String, " + "recommendation String, " + "reviewStatus String, " + "reviewer1Signed boolean, " + "dateReviewer1 String, " + "reviewer2Signed boolean, " + "dateReviewer2 String, " + "revieweeSigned boolean, " + "dateReviewee String, " + "goals String, " + "objectives String, " + "achievements String);";
            createTable(sql);
            System.out.println("Created table \"annualReviewRecords\" in database");
            readPersonalRecord(staffID);
        } else {
            Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
        }
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    printTable("annualReviewRecords");
    return returnHash;
}

######


public HashMap login(String username, String password) {
    Connection conn = null;
    try {
        conn = connect();
        HashMap<String, String> userInfo = new HashMap<>();
        Statement statement = conn.createStatement();
        ResultSet result = statement.executeQuery("SELECT ID, username, password, " + "authorisationLvl FROM loginDetails");
        while (result.next()) {
            if (result.getString("username").equals(username)) {
                if (result.getString("password").equals(password)) {
                    ResultSetMetaData rsmd = result.getMetaData();
                    int columnsNumber = rsmd.getColumnCount();
                    for (int i = 1; i <= columnsNumber; i++) {
                        userInfo.put(rsmd.getColumnName(i), result.getString(i));
                    }
                    return userInfo;
                } else {
                    userInfo.put("Failed", "Incorrect password");
                    return userInfo;
                }
            }
        }
        userInfo.put("Failed", "Username not found");
        return userInfo;
    } catch (SQLException ex) {
        Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
    } finally {
        try {
            if (conn != null) {
                conn.close();
            }
        } catch (SQLException ex) {
            Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return null;
}

######


public void printTable(String tableName) {
    Connection conn = null;
    try {
        conn = connect();
        String sql = "SELECT * FROM " + tableName;
        Statement statement = conn.createStatement();
        ResultSet result = statement.executeQuery(sql);
        ResultSetMetaData rsmd = result.getMetaData();
        int columnsNumber = rsmd.getColumnCount();
        System.out.println("--------------------");
        for (int i = 1; i <= columnsNumber; i++) {
            if (i > 1)
                System.out.print(" | ");
            System.out.print(rsmd.getColumnName(i));
        }
        System.out.println("");
        while (result.next()) {
            for (int i = 1; i <= columnsNumber; i++) {
                if (i > 1)
                    System.out.print(" | ");
                System.out.print(result.getString(i));
            }
            System.out.println("");
        }
        System.out.println("--------------------");
    } catch (SQLException ex) {
        Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
}

######


public void deleteLoginDetails(String value) {
    Connection conn = null;
    try {
        conn = connect();
        String sql = "DELETE FROM loginDetails WHERE username = ?";
        PreparedStatement pS = conn.prepareStatement(sql);
        pS.setString(1, value);
        pS.executeUpdate();
    } catch (SQLException ex) {
        System.out.println(ex.getMessage());
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
}

######


public void deletePersonalDetails(int value) {
    Connection conn = null;
    try {
        conn = connect();
        String sql = "DELETE FROM personalRecords WHERE ID = ?";
        PreparedStatement pS = conn.prepareStatement(sql);
        pS.setInt(1, value);
        pS.executeUpdate();
    } catch (SQLException ex) {
        System.out.println(ex.getMessage());
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
}

######


public void deleteAnnualReview(int value) {
    Connection conn = null;
    try {
        conn = connect();
        String sql = "DELETE FROM annualReviewRecords WHERE staffID = ?";
        PreparedStatement pS = conn.prepareStatement(sql);
        pS.setInt(1, value);
        pS.executeUpdate();
    } catch (SQLException ex) {
        System.out.println(ex.getMessage());
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(HRDatabase.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
}

######


ConnectorFsrModel getFlight(String connectorId) throws DaoException;

######


ConnectorFsrModel bookFlight1(String connectorId, int passenger) throws DaoException;

######


ConnectorFsrModel bookFlight2(String connectorId, int passenger) throws DaoException;

######


ConnectorFsrModel bookFlight3(String connectorId, int passenger) throws DaoException;

######


int passdata(TicketModel ticketModel) throws DaoException;

######


boolean insertTraveller(TravellerModel model2) throws DaoException;

######


boolean payment(PaymentModel paymentModel) throws DaoException;

######


TicketModel ticket(int ticketId) throws DaoException;

######


@Results(id = "userResult", value = { @Result(id = true, column = "uid", property = "id") })
@Select("select * from users where uid = #{id}")
User getUserById(Integer id);

######


@Override
public void validateBuild() throws IndexerException {
    Long numFound = getDocumentCount(server);
    if (numFound <= MINIMUM_DOCUMENT_COUNT)
        throw new IndexerException(new ValidationException("Actual impc_images document count is " + numFound + "."));
    if (numFound != documentCount)
        logger.warn("WARNING: Added " + documentCount + " impc_images documents but SOLR reports " + numFound + " documents.");
    else
        logger.info("validateBuild(): Indexed " + documentCount + " impc_images documents.");
}

######


public static void main(String[] args) throws IndexerException {
    ImpcImagesIndexer main = new ImpcImagesIndexer();
    main.initialise(args);
    main.run();
    main.validateBuild();
    logger.info("Process finished.  Exiting.");
}

######


@Override
public void run() throws IndexerException {
    int count = 0;
    logger.info("running impc_images indexer");
    try {
        parameterStableIdToMaTermIdMap = this.populateParameterStableIdToMaIdMap();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    logger.info("populating image urls from db");
    imageBeans = populateImageUrls();
    logger.info("Image beans map size=" + imageBeans.size());
    if (imageBeans.size() < 100) {
        logger.error("Didn't get any image entries from the db with omero_ids set so exiting the impc_image Indexer!!");
    }
    logger.info("populating alleles");
    this.alleles = populateAlleles();
    logger.info("populated alleles");
    String impcMediaBaseUrl = config.get("impcMediaBaseUrl");
    logger.info("omeroRootUrl=" + impcMediaBaseUrl);
    impcAnnotationBaseUrl = impcMediaBaseUrl.replace("webgateway", "webclient");
    try {
        server.deleteByQuery("*:*");
        SolrQuery query = ImageService.allImageRecordSolrQuery().setRows(Integer.MAX_VALUE);
        List<ImageDTO> imageList = observationService.query(query).getBeans(ImageDTO.class);
        for (ImageDTO imageDTO : imageList) {
            String downloadFilePath = imageDTO.getDownloadFilePath();
            if (imageBeans.containsKey(downloadFilePath)) {
                ImageBean iBean = imageBeans.get(downloadFilePath);
                String fullResFilePath = iBean.fullResFilePath;
                if (iBean.image_link != null) {
                    imageDTO.setImageLink(iBean.image_link);
                }
                imageDTO.setFullResolutionFilePath(fullResFilePath);
                int omeroId = iBean.omeroId;
                imageDTO.setOmeroId(omeroId);
                if (omeroId == 0 || imageDTO.getProcedureStableId().equals(excludeProcedureStableId)) {
                    System.out.println("skipping omeroId=" + omeroId + "param and center" + imageDTO.getParameterStableId() + imageDTO.getPhenotypingCenter());
                    continue;
                }
                if (omeroId != 0 && downloadFilePath != null) {
                    if (downloadFilePath.endsWith(".pdf")) {
                        imageDTO.setDownloadUrl(impcAnnotationBaseUrl + "/annotation/" + omeroId);
                        imageDTO.setJpegUrl(impcMediaBaseUrl + "/render_image/" + 119501);
                    } else {
                        imageDTO.setDownloadUrl(impcMediaBaseUrl + "/archived_files/download/" + omeroId);
                        imageDTO.setJpegUrl(impcMediaBaseUrl + "/render_image/" + omeroId);
                    }
                } else {
                    logger.info("omero id is null for " + downloadFilePath);
                }
                if (imageDTO.getGeneAccession() != null && !imageDTO.getGeneAccession().equals("")) {
                    String geneAccession = imageDTO.getGeneAccession();
                    if (alleles.containsKey(geneAccession)) {
                        populateImageDtoStatuses(imageDTO, geneAccession);
                        if (imageDTO.getSymbol() != null) {
                            String symbolGene = imageDTO.getSymbol() + "_" + imageDTO.getGeneAccession();
                            imageDTO.setSymbolGene(symbolGene);
                        }
                    }
                }
                if (imageDTO.getParameterAssociationStableId() != null && !imageDTO.getParameterAssociationStableId().isEmpty()) {
                    ArrayList<String> maIds = new ArrayList<>();
                    ArrayList<String> maTerms = new ArrayList<>();
                    ArrayList<String> maTermSynonyms = new ArrayList<>();
                    ArrayList<String> topLevelMaIds = new ArrayList<>();
                    ArrayList<String> topLevelMaTerm = new ArrayList<>();
                    ArrayList<String> topLevelMaTermSynonym = new ArrayList<>();
                    ArrayList<String> intermediateLevelMaIds = new ArrayList<>();
                    ArrayList<String> intermediateLevelMaTerm = new ArrayList<>();
                    ArrayList<String> intermediateLevelMaTermSynonym = new ArrayList<>();
                    for (String paramString : imageDTO.getParameterAssociationStableId()) {
                        if (parameterStableIdToMaTermIdMap.containsKey(paramString)) {
                            String maTermId = parameterStableIdToMaTermIdMap.get(paramString);
                            maIds.add(maTermId);
                            OntologyTermBean maTermBean = maService.getTerm(maTermId);
                            if (maTermBean != null) {
                                maTerms.add(maTermBean.getName());
                                maTermSynonyms.addAll(maTermBean.getSynonyms());
                                List<OntologyTermBean> topLevels = maService.getTopLevel(maTermId);
                                for (OntologyTermBean topLevel : topLevels) {
                                    topLevelMaIds.add(topLevel.getId());
                                    topLevelMaTerm.add(topLevel.getName());
                                    topLevelMaTermSynonym.addAll(topLevel.getSynonyms());
                                }
                                List<OntologyTermBean> intermediateLevels = maService.getIntermediates(maTermId);
                                for (OntologyTermBean intermediateLevel : intermediateLevels) {
                                    intermediateLevelMaIds.add(intermediateLevel.getId());
                                    intermediateLevelMaTerm.add(intermediateLevel.getName());
                                    intermediateLevelMaTermSynonym.addAll(intermediateLevel.getSynonyms());
                                }
                            }
                        }
                    }
                    if (!maIds.isEmpty()) {
                        imageDTO.setMaTermId(maIds);
                        ArrayList<String> maIdTerms = new ArrayList<>();
                        for (int i = 0; i < maIds.size(); i++) {
                            String maId = maIds.get(i);
                            String maTerm = maTerms.get(i);
                            maIdTerms.add(maId + "_" + maTerm);
                        }
                        imageDTO.setMaIdTerm(maIdTerms);
                    }
                    if (!maTerms.isEmpty()) {
                        imageDTO.setMaTerm(maTerms);
                    }
                    if (!maTermSynonyms.isEmpty()) {
                        imageDTO.setMaTermSynonym(maTermSynonyms);
                    }
                    if (!topLevelMaIds.isEmpty()) {
                        imageDTO.setTopLevelMaId(topLevelMaIds);
                    }
                    if (!topLevelMaTerm.isEmpty()) {
                        imageDTO.setTopLevelMaTerm(topLevelMaTerm);
                    }
                    if (!topLevelMaTermSynonym.isEmpty()) {
                        imageDTO.setTopLevelMaTermSynonym(topLevelMaTermSynonym);
                    }
                    if (!intermediateLevelMaIds.isEmpty()) {
                        imageDTO.setIntermediateLevelMaId(intermediateLevelMaIds);
                    }
                    if (!intermediateLevelMaTerm.isEmpty()) {
                        imageDTO.setIntermediateLevelMaTerm(intermediateLevelMaTerm);
                    }
                    if (!intermediateLevelMaTermSynonym.isEmpty()) {
                        imageDTO.setIntermediateLevelMaTermSynonym(intermediateLevelMaTermSynonym);
                    }
                }
                server.addBean(imageDTO);
                count++;
            }
            if (count % 10000 == 0) {
                logger.info(" added ImageDTO" + count + " beans");
            }
        }
        server.commit();
        documentCount = count;
    } catch (SolrServerException | IOException e) {
        throw new IndexerException(e);
    }
}

######


private Map<String, ImageBean> populateImageUrls() throws IndexerException {
    Map<String, ImageBean> imageBeansMap = new HashMap<>();
    final String getExtraImageInfoSQL = "SELECT " + ImageDTO.OMERO_ID + ", " + ImageDTO.DOWNLOAD_FILE_PATH + ", " + ImageDTO.IMAGE_LINK + ", " + ImageDTO.FULL_RESOLUTION_FILE_PATH + " FROM image_record_observation WHERE omero_id is not null AND omero_id != 0";
    try (PreparedStatement statement = komp2DataSource.getConnection().prepareStatement(getExtraImageInfoSQL)) {
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            ImageBean bean = new ImageBean();
            bean.omeroId = resultSet.getInt(ImageDTO.OMERO_ID);
            bean.fullResFilePath = resultSet.getString(ImageDTO.FULL_RESOLUTION_FILE_PATH);
            bean.image_link = resultSet.getString(ImageDTO.IMAGE_LINK);
            imageBeansMap.put(resultSet.getString(ImageDTO.DOWNLOAD_FILE_PATH), bean);
        }
    } catch (Exception e) {
        throw new IndexerException(e);
    }
    return imageBeansMap;
}

######


@Override
protected Logger getLogger() {
    return logger;
}

######


public Map<String, List<AlleleDTO>> populateAlleles() throws IndexerException {
    return IndexerMap.getGeneToAlleles(alleleIndexing);
}

######


private void populateImageDtoStatuses(ImageDTO img, String geneAccession) {
    if (alleles.containsKey(geneAccession)) {
        List<AlleleDTO> localAlleles = alleles.get(geneAccession);
        for (AlleleDTO allele : localAlleles) {
            if (allele.getMarkerSymbol() != null) {
                img.addSymbol(allele.getMarkerSymbol());
            }
            if (allele.getMarkerName() != null) {
                img.addMarkerName(allele.getMarkerName());
            }
            if (allele.getMarkerSynonym() != null) {
                img.addMarkerSynonym(allele.getMarkerSynonym());
            }
            if (allele.getMarkerType() != null) {
                List<String> markerTypes = new ArrayList<>();
                markerTypes.add(allele.getMarkerType());
                img.addMarkerType(markerTypes);
            }
            if (allele.getHumanGeneSymbol() != null) {
                img.addHumanGeneSymbol(allele.getHumanGeneSymbol());
            }
            if (allele.getStatus() != null) {
                img.addStatus(allele.getStatus());
            }
            if (allele.getImitsPhenotypeStarted() != null) {
                img.addImitsPhenotypeStarted(allele.getImitsPhenotypeStarted());
            }
            if (allele.getImitsPhenotypeComplete() != null) {
                img.addImitsPhenotypeComplete(allele.getImitsPhenotypeComplete());
            }
            if (allele.getImitsPhenotypeStatus() != null) {
                img.addImitsPhenotypeStatus(allele.getImitsPhenotypeStatus());
            }
            if (allele.getLegacyPhenotypeStatus() != null) {
                img.setLegacyPhenotypeStatus(allele.getLegacyPhenotypeStatus());
            }
            img.setLatestProductionCentre(allele.getLatestProductionCentre());
            img.setLatestPhenotypingCentre(allele.getLatestPhenotypingCentre());
            img.setAlleleName(allele.getAlleleName());
            img.setSubtype(allele.getMarkerType());
            img.addLatestPhenotypeStatus(allele.getLatestPhenotypeStatus());
            if (img.getLegacyPhenotypeStatus() != null) {
                img.setLegacyPhenotypeStatus(allele.getLegacyPhenotypeStatus());
            }
        }
    }
}

######


public Map<String, String> populateParameterStableIdToMaIdMap() throws SQLException {
    System.out.println("populating parameterStableId to MA map");
    Map<String, String> paramToMa = new HashMap<String, String>();
    String query = "SELECT * FROM phenotype_parameter pp INNER JOIN phenotype_parameter_lnk_ontology_annotation pploa ON pp.id=pploa.parameter_id INNER JOIN phenotype_parameter_ontology_annotation ppoa ON ppoa.id=pploa.annotation_id WHERE ppoa.ontology_db_id=8 LIMIT 100000";
    try (PreparedStatement statement = komp2DataSource.getConnection().prepareStatement(query)) {
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            String parameterStableId = resultSet.getString("stable_id");
            String maAcc = resultSet.getString("ontology_acc");
            System.out.println("adding " + parameterStableId + " " + maAcc);
            paramToMa.put(parameterStableId, maAcc);
        }
    }
    System.out.println("paramToMa size=" + paramToMa.size());
    return paramToMa;
}

######


private void insertData() throws SQLException {
    Statement stat = connect.createStatement();
    String Data = "insert into hist (_peso, _altura, _imc, FK_USER) values ('" + peso + "','" + altura + "','" + imc + "','" + user_fk + "');";
    stat.execute(Data);
    connect.close();
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jComboBox1ActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    okActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    BookIdActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    BrNameActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    SubmitActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    ResetActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    BackActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jComboBox1 = new javax.swing.JComboBox();
    jLabel1 = new javax.swing.JLabel();
    ok = new javax.swing.JButton();
    BookId = new javax.swing.JTextField();
    Title = new javax.swing.JTextField();
    AuthorName = new javax.swing.JTextField();
    BranchIdNo = new javax.swing.JTextField();
    BrName = new javax.swing.JTextField();
    BrAddress = new javax.swing.JTextField();
    TnoC = new javax.swing.JTextField();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    jLabel4 = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    jLabel6 = new javax.swing.JLabel();
    jLabel7 = new javax.swing.JLabel();
    jLabel8 = new javax.swing.JLabel();
    Submit = new javax.swing.JButton();
    Reset = new javax.swing.JButton();
    Back = new javax.swing.JButton();
    jComboBox1.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "", "Book", "Authors", "LibraryBranch", "BookCopies" }));
    jComboBox1.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jComboBox1ActionPerformed(evt);
        }
    });
    jLabel1.setFont(new java.awt.Font("Times New Roman", 0, 18));
    jLabel1.setText("SELECT ANY OPTION");
    ok.setText("OK");
    ok.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            okActionPerformed(evt);
        }
    });
    BookId.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            BookIdActionPerformed(evt);
        }
    });
    BrName.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            BrNameActionPerformed(evt);
        }
    });
    jLabel2.setFont(new java.awt.Font("Times New Roman", 0, 12));
    jLabel2.setText("Book_id");
    jLabel3.setFont(new java.awt.Font("Times New Roman", 0, 12));
    jLabel3.setText("Title");
    jLabel4.setFont(new java.awt.Font("Times New Roman", 0, 12));
    jLabel4.setText("Author Name");
    jLabel5.setFont(new java.awt.Font("Times New Roman", 0, 12));
    jLabel5.setText("Branch_id");
    jLabel6.setFont(new java.awt.Font("Times New Roman", 0, 12));
    jLabel6.setText("Branch Name");
    jLabel7.setText("Address");
    jLabel8.setFont(new java.awt.Font("Times New Roman", 0, 12));
    jLabel8.setText("Number of copies");
    Submit.setText("SUBMIT");
    Submit.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            SubmitActionPerformed(evt);
        }
    });
    Reset.setText("RESET");
    Reset.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            ResetActionPerformed(evt);
        }
    });
    Back.setText("BACK");
    Back.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            BackActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel5).addComponent(jLabel4).addComponent(jLabel8).addComponent(jLabel2)).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(29, 29, 29).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addComponent(BranchIdNo, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(72, 72, 72).addComponent(jLabel6)).addComponent(AuthorName, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(layout.createSequentialGroup().addComponent(BookId, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(81, 81, 81).addComponent(jLabel3))).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addComponent(Reset).addGap(76, 76, 76))).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(Title, javax.swing.GroupLayout.PREFERRED_SIZE, 89, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(Back).addComponent(BrName, javax.swing.GroupLayout.PREFERRED_SIZE, 93, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 191, Short.MAX_VALUE).addComponent(jLabel7).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(BrAddress, javax.swing.GroupLayout.PREFERRED_SIZE, 93, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(206, Short.MAX_VALUE)))).addGroup(layout.createSequentialGroup().addComponent(TnoC, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap()))).addGroup(layout.createSequentialGroup().addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 185, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(97, 97, 97).addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 179, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(0, 0, Short.MAX_VALUE)))).addGroup(layout.createSequentialGroup().addGap(301, 301, 301).addComponent(ok, javax.swing.GroupLayout.PREFERRED_SIZE, 66, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(0, 0, Short.MAX_VALUE)).addGroup(layout.createSequentialGroup().addGap(90, 90, 90).addComponent(Submit).addGap(354, 863, Short.MAX_VALUE)));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(20, 20, 20).addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(74, 74, 74).addComponent(Title, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)).addGroup(layout.createSequentialGroup().addGap(31, 31, 31).addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(16, 16, 16).addComponent(ok, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(35, 35, 35).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(jLabel2).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(BookId, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel3))))).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 28, Short.MAX_VALUE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel4).addComponent(AuthorName, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(35, 35, 35).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(BranchIdNo, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(BrName, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel6).addComponent(jLabel5).addComponent(jLabel7).addComponent(BrAddress, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(45, 45, 45).addComponent(jLabel8)).addComponent(TnoC, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(20, 20, 20).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(Submit).addComponent(Reset).addComponent(Back)).addGap(30, 30, 30)));
    pack();
}

######


private void jComboBox1ActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void okActionPerformed(java.awt.event.ActionEvent evt) {
    String name = jComboBox1.getSelectedItem().toString();
    if ("".equals(name)) {
        JOptionPane.showMessageDialog(null, "Please select any option");
    } else if ("Book".equals(name)) {
        BookId.setVisible(true);
        Title.setVisible(true);
        jLabel2.setVisible(true);
        jLabel3.setVisible(true);
        AuthorName.setVisible(false);
        jLabel4.setVisible(false);
        BrName.setVisible(false);
        BrAddress.setVisible(false);
        jLabel6.setVisible(false);
        jLabel7.setVisible(false);
        jLabel8.setVisible(false);
        BranchIdNo.setVisible(false);
        TnoC.setVisible(false);
        jLabel5.setVisible(false);
        jLabel8.setVisible(false);
        String bid = BookId.getText();
        String t = Title.getText();
        flag = 1;
    } else if ("Authors".equals(name)) {
        AuthorName.setVisible(true);
        BookId.setVisible(true);
        jLabel4.setVisible(true);
        jLabel2.setVisible(true);
        Title.setVisible(false);
        jLabel3.setVisible(false);
        BrName.setVisible(false);
        BrAddress.setVisible(false);
        jLabel6.setVisible(false);
        jLabel7.setVisible(false);
        jLabel8.setVisible(false);
        BranchIdNo.setVisible(false);
        TnoC.setVisible(false);
        jLabel5.setVisible(false);
        jLabel8.setVisible(false);
        String bid = BookId.getText();
        String an = AuthorName.getText();
        flag = 2;
    } else if ("LibraryBranch".equals(name)) {
        BranchIdNo.setVisible(true);
        BrName.setVisible(true);
        BrAddress.setVisible(true);
        jLabel6.setVisible(true);
        jLabel7.setVisible(true);
        jLabel5.setVisible(true);
        BookId.setVisible(false);
        AuthorName.setVisible(false);
        jLabel3.setVisible(false);
        jLabel2.setVisible(false);
        jLabel4.setVisible(false);
        jLabel8.setVisible(false);
        TnoC.setVisible(false);
        jLabel2.setVisible(false);
        jLabel8.setVisible(false);
        String bid = BranchIdNo.getText();
        String bn = BrName.getText();
        String adr = BrAddress.getText();
        flag = 3;
    } else if ("BookCopies".equals(name)) {
        BranchIdNo.setVisible(true);
        BookId.setVisible(true);
        TnoC.setVisible(true);
        jLabel2.setVisible(true);
        jLabel5.setVisible(true);
        jLabel8.setVisible(true);
        Title.setVisible(false);
        jLabel3.setVisible(false);
        AuthorName.setVisible(false);
        jLabel4.setVisible(false);
        BrName.setVisible(false);
        BrAddress.setVisible(false);
        jLabel6.setVisible(false);
        jLabel7.setVisible(false);
        String bid = BranchIdNo.getText();
        String bkid = BookId.getText();
        String noc = TnoC.getText();
        flag = 4;
    }
}

######


private void BookIdActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void BrNameActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void SubmitActionPerformed(java.awt.event.ActionEvent evt) {
    try {
        conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/librarynew?user=root&password=shravya92");
        Statement stmt = conn.createStatement();
        String name = jComboBox1.getSelectedItem().toString();
        switch(flag) {
            case 0:
                JOptionPane.showMessageDialog(null, "Please choose a option");
            case 1:
                String bid = BookId.getText();
                String t = Title.getText();
                String add = "insert into book values('" + bid + "','" + t + "');";
                stmt.executeUpdate(add);
                JOptionPane.showMessageDialog(null, "Succesfull");
                BookId.setText("");
                Title.setText("");
                jComboBox1.setSelectedIndex(0);
                BookId.setVisible(false);
                Title.setVisible(false);
                jLabel2.setVisible(false);
                jLabel3.setVisible(false);
                break;
            case 2:
                String bid1 = BookId.getText();
                String an1 = AuthorName.getText();
                String add1 = "insert into Book_Authors values('" + bid1 + "','" + an1 + "');";
                stmt.executeUpdate(add1);
                JOptionPane.showMessageDialog(null, "Succesfull");
                BookId.setText("");
                AuthorName.setText("");
                jComboBox1.setSelectedIndex(0);
                BookId.setVisible(false);
                AuthorName.setVisible(false);
                jLabel2.setVisible(false);
                jLabel4.setVisible(false);
                break;
            case 3:
                String bid2 = BranchIdNo.getText();
                int b = Integer.parseInt(bid2);
                String bn2 = BrName.getText();
                String adr2 = BrAddress.getText();
                String add2 = "insert into Library_Branch values(" + b + ",'" + bn2 + "','" + adr2 + "');";
                stmt.executeUpdate(add2);
                JOptionPane.showMessageDialog(null, "Succesfull");
                BranchIdNo.setText("");
                BrName.setText("");
                BrAddress.setText("");
                jComboBox1.setSelectedIndex(0);
                BranchIdNo.setVisible(false);
                BrName.setVisible(false);
                BrAddress.setVisible(false);
                jLabel6.setVisible(false);
                jLabel7.setVisible(false);
                jLabel8.setVisible(false);
                break;
            case 4:
                String bid3 = BranchIdNo.getText();
                int b1 = Integer.parseInt(bid3);
                String bkid3 = BookId.getText();
                String noc = TnoC.getText();
                String add3 = "insert into book_copies values('" + bkid3 + "'," + b1 + ",'" + noc + "');";
                stmt.executeUpdate(add3);
                JOptionPane.showMessageDialog(null, "Succesfull");
                BranchIdNo.setText("");
                BookId.setText("");
                TnoC.setText("");
                jComboBox1.setSelectedIndex(0);
                BranchIdNo.setVisible(false);
                BookId.setVisible(false);
                TnoC.setVisible(false);
                jLabel2.setVisible(false);
                jLabel5.setVisible(false);
                jLabel8.setVisible(false);
                break;
        }
        conn.close();
    } catch (SQLException ex) {
        JOptionPane.showMessageDialog(null, ex);
    }
}

######


public void close() {
    WindowEvent winclosingevent = new WindowEvent(this, WindowEvent.WINDOW_CLOSING);
    Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(winclosingevent);
}

######


private void BackActionPerformed(java.awt.event.ActionEvent evt) {
    close();
    HomePage hp = new HomePage();
    hp.setVisible(true);
}

######


private void ResetActionPerformed(java.awt.event.ActionEvent evt) {
    switch(flag) {
        case 1:
            BookId.setText("");
            Title.setText("");
        case 2:
            BookId.setText("");
            AuthorName.setText("");
        case 3:
            BranchIdNo.setText("");
            BrName.setText("");
            BrAddress.setText("");
        case 4:
            BranchIdNo.setText("");
            BookId.setText("");
            TnoC.setText("");
    }
}

######


public void run() {
    new insert().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(insert.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(insert.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(insert.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(insert.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new insert().setVisible(true);
        }
    });
}

######


@Override
public void onClick(View v) {
    EditText editName = findViewById(R.id.editText_name);
    EditText editPhone = findViewById(R.id.editText_phone);
    EditText editEmail = findViewById(R.id.editText_email);
    EditText editCardnum = findViewById(R.id.editText_cardnum);
    EditText editCardexp = findViewById(R.id.editText_cardexp);
    name = editName.getText().toString();
    phone = Integer.parseInt(editPhone.getText().toString());
    email = editEmail.getText().toString();
    cardnum = Integer.parseInt(editCardnum.getText().toString());
    cardexp = Integer.parseInt(editCardexp.getText().toString());
    AppointmentDatabase.execSQL("INSERT INTO customers VALUES(name,phone,email,cardnum,cardexp,0)");
}

######


@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_insert_customer);
    final SQLiteDatabase AppointmentDatabase = getBaseContext().openOrCreateDatabase("appointment.db", MODE_PRIVATE, null);
    addCustButton = (Button) findViewById(R.id.button_addCustomer);
    addCustButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            EditText editName = findViewById(R.id.editText_name);
            EditText editPhone = findViewById(R.id.editText_phone);
            EditText editEmail = findViewById(R.id.editText_email);
            EditText editCardnum = findViewById(R.id.editText_cardnum);
            EditText editCardexp = findViewById(R.id.editText_cardexp);
            name = editName.getText().toString();
            phone = Integer.parseInt(editPhone.getText().toString());
            email = editEmail.getText().toString();
            cardnum = Integer.parseInt(editCardnum.getText().toString());
            cardexp = Integer.parseInt(editCardexp.getText().toString());
            AppointmentDatabase.execSQL("INSERT INTO customers VALUES(name,phone,email,cardnum,cardexp,0)");
        }
    });
}

######


@Insert({ "insert into mbtest.test_identity", "(first_name, last_name)", "values(#{firstName,jdbcType=VARCHAR}, #{lastName,jdbcType=VARCHAR})" })
@Options(keyProperty = "id", useGeneratedKeys = true, keyColumn = "name_id")
int insertNameAnnotated(Name name);

######


int insertNameMapped(Name name);

######


public List<InspectionPlaceModel> getAppointments(InspectionPlaceModel inspectionPlaceModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM InspectionPlaceModel e WHERE e.pk = :inspectionPlace");
    query.setParameter("inspectionPlace", inspectionPlaceModel.getPk());
    return query.getResultList();
}

######


public List<InspectionPlaceModel> getAppointmentHeaderByInspectionPlace(InspectionPlaceModel inspectionPlaceModel, Date startDate, Date endDate) {
    Query query = getEntitymanager().createQuery("SELECT DISTINCT(ip) FROM InspectionPlaceModel ip INNER JOIN ip.appointmentModels ap WHERE ip = :INSPECTION_PLACE AND ap.appointmentStatus = :APPOINTMENT_STATUS AND ap.appointmentDate BETWEEN :START_DATE AND :END_DATE");
    query.setParameter("INSPECTION_PLACE", inspectionPlaceModel);
    query.setParameter("APPOINTMENT_STATUS", AppointmentStatusEnum.NOT_RESERVED);
    query.setParameter("START_DATE", startDate);
    query.setParameter("END_DATE", endDate);
    return query.getResultList();
}

######


public List<InspectionPlaceModel> getAppointmentHeaderByInspectionPlace(InspectionPlaceModel inspectionPlaceModel, Date startDate) {
    Query query = getEntitymanager().createQuery("SELECT DISTINCT(ip) FROM InspectionPlaceModel ip INNER JOIN ip.appointmentModels ap WHERE ip = :INSPECTION_PLACE AND ap.appointmentStatus = :APPOINTMENT_STATUS AND ap.appointmentDate > :START_DATE");
    query.setParameter("INSPECTION_PLACE", inspectionPlaceModel);
    query.setParameter("APPOINTMENT_STATUS", AppointmentStatusEnum.NOT_RESERVED);
    query.setParameter("START_DATE", startDate);
    return query.getResultList();
}

######


public List<InspectionPlaceModel> getAppointmentHeaderByInspectionPlace(InspectionPlaceModel inspectionPlaceModel) {
    Query query = getEntitymanager().createQuery("SELECT DISTINCT(ip) FROM InspectionPlaceModel ip INNER JOIN ip.appointmentModels ap WHERE ip = :INSPECTION_PLACE AND ap.appointmentStatus = :APPOINTMENT_STATUS AND ap.appointmentDate > :START_DATE");
    query.setParameter("INSPECTION_PLACE", inspectionPlaceModel);
    query.setParameter("APPOINTMENT_STATUS", AppointmentStatusEnum.NOT_RESERVED);
    query.setParameter("START_DATE", DateUtil.getEndOfDay());
    return query.getResultList();
}

######


public Timestamp mapRow(ResultSet resultSet, int i) throws SQLException {
    return resultSet.getTimestamp(1);
}

######


@Override
protected boolean exceedsThreshold(final HttpServletRequest request) {
    final String query = "SELECT AUD_DATE FROM COM_AUDIT_TRAIL WHERE AUD_CLIENT_IP = ? AND AUD_USER = ? " + "AND AUD_ACTION = ? AND APPLIC_CD = ? AND AUD_DATE >= ? ORDER BY AUD_DATE DESC";
    final String userToUse = constructUsername(request, getUsernameParameter());
    final Calendar cutoff = Calendar.getInstance();
    cutoff.add(Calendar.SECOND, -1 * getFailureRangeInSeconds());
    final List<Timestamp> failures = this.jdbcTemplate.query(query, new Object[] { request.getRemoteAddr(), userToUse, this.authenticationFailureCode, this.applicationCode, cutoff.getTime() }, new int[] { Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.TIMESTAMP }, new RowMapper<Timestamp>() {

        public Timestamp mapRow(ResultSet resultSet, int i) throws SQLException {
            return resultSet.getTimestamp(1);
        }
    });
    if (failures.size() < 2) {
        return false;
    }
    return 1000.0 / (failures.get(0).getTime() - failures.get(1).getTime()) > getThresholdRate();
}

######


@Override
protected void recordSubmissionFailure(final HttpServletRequest request) {
}

######


@Override
public void setUp() throws Exception {
    super.setUp();
    a1 = AccountBuilder.createDefault(db);
    a2 = AccountBuilder.createDefault(db);
    integrity = new IntegrityCheck(db);
}

######


public void test_should_detect_that_running_balance_is_broken() {
    TransactionBuilder.withDb(db).account(a1).amount(1000).create();
    TransactionBuilder.withDb(db).account(a1).amount(2000).create();
    TransactionBuilder.withDb(db).account(a2).amount(-100).create();
    assertFalse(integrity.isBroken());
    breakRunningBalanceForAccount(a1);
    assertTrue(integrity.isBroken());
    db.rebuildRunningBalanceForAccount(a1);
    assertFalse(integrity.isBroken());
    breakRunningBalance();
    assertTrue(integrity.isBroken());
    db.rebuildRunningBalances();
    assertFalse(integrity.isBroken());
}

######


private void breakRunningBalanceForAccount(Account a) {
    db.db().execSQL("delete from running_balance where account_id=?", new String[] { String.valueOf(a.id) });
}

######


private void breakRunningBalance() {
    db.db().execSQL("delete from running_balance");
}

######


private static Connection getConnection() {
    Connection conn = null;
    try {
        Class.forName("com.mysql.jdbc.Driver");
    } catch (ClassNotFoundException ex) {
        System.err.println("JDBC Driver Not Found: " + ex.getMessage());
    }
    try {
        String jdbc = "jdbc:mysql://ipro.lambton.on.ca/inventory";
        conn = DriverManager.getConnection(jdbc, "products", "products");
    } catch (SQLException ex) {
        System.err.println("Failed to Connect: " + ex.getMessage());
    }
    return conn;
}

######


public static int getQuantityForId(int id) {
    int quantity = -1;
    try {
        Connection conn = getConnection();
        String query = "SELECT quantity FROM inventory WHERE id = ?";
        PreparedStatement pstmt = conn.prepareStatement(query);
        pstmt.setInt(1, id);
        ResultSet rs = pstmt.executeQuery();
        rs.first();
        quantity = rs.getInt("quantity");
        conn.close();
    } catch (SQLException ex) {
        System.err.println("Failed to Get Quantity for ID " + id + ": " + ex.getMessage());
    }
    return quantity;
}

######


@QueryHints(value = { @QueryHint(name = "org.hibernate.cacheable", value = "true") })
@Query("SELECT p FROM Person p JOIN p.department d WHERE d = :dept")
Page<Person> findByDepartement(@Param("dept") Department department, Pageable pageable);

######


@QueryHints(value = { @QueryHint(name = "org.hibernate.cacheable", value = "true") })
@Query("SELECT p FROM Person p JOIN p.department d WHERE d = :dept AND p.fullname LIKE :term")
Page<Person> findByDepartementAndTerm(@Param("dept") Department department, @Param("term") String term, Pageable pageable);

######


@QueryHints(value = { @QueryHint(name = "org.hibernate.cacheable", value = "true") })
@Query("SELECT p FROM Person p WHERE p.fullname LIKE :term")
Page<Person> findByTerm(@Param("term") String term, Pageable pageable);

######


@QueryHints(value = { @QueryHint(name = "org.hibernate.cacheable", value = "true") })
Page<Person> findAll(Pageable pageable);

######


List<String> getSourceCities() throws DaoException;

######


List<String> getDestinationCities(String fromCity) throws DaoException;

######


public String getFiled_name() {
    return filed_name;
}

######


public void setFiled_name(String filed_name) {
    this.filed_name = filed_name;
}

######


public Item_student getStudent(String aStudent) throws NumberFormatException, SQLException {
    Item_student item = new Item_student();
    setTable("student");
    item.setAccess(Integer.parseInt(getFieldValue("access", aStudent)));
    item.setStudent_number(getFieldValue("user_number", aStudent));
    item.setStudent_name(getFieldValue("user_name", aStudent));
    item.setStudent_class(getFieldValue("student_class", aStudent));
    item.setStudent_age_class(getFieldValue("student_age_class", aStudent));
    DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    Date date = null;
    String timeStamp = getFieldValue("registration_time", aStudent);
    timeStamp = timeStamp.replace(".0", "");
    setTable("student_basic_news");
    item.setStudent_sum_mark(Integer.parseInt(getFieldValue("student_sum_mark", aStudent)));
    item.setExamin(Integer.parseInt(getFieldValue("examine", aStudent)));
    try {
        date = format2.parse(timeStamp);
    } catch (ParseException e) {
        e.printStackTrace();
    }
    item.setTime(date);
    return item;
}

######


public String getTable() {
    return table;
}

######


public void setTable(String table) {
    this.table = table;
}

######


public ArrayList<Item_student> getStudents() {
    String sql1 = "Select " + filed_name + " From " + table + " ;";
    ArrayList<Item_student> mode = new ArrayList<Item_student>();
    DBHelper db = new DBHelper();
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    try {
        conn = db.getConnetion();
        stmt = conn.prepareStatement(sql1);
        rs = stmt.executeQuery();
        while (rs.next()) {
            Item_student item = new Item_student();
            String aStudent = rs.getString(filed_name);
            item = getStudent(aStudent);
            mode.add(item);
        }
        return mode;
    } catch (Exception ex) {
        ex.printStackTrace();
        return null;
    } finally {
        if (rs != null) {
            try {
                rs.close();
                rs = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        if (stmt != null) {
            try {
                stmt.close();
                stmt = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }
}

######


public int alter_examine(String students_number, int examine) {
    DBHelper db = new DBHelper();
    PreparedStatement stmt = null;
    Connection conn = null;
    ResultSet rs = null;
    try {
        conn = db.getConnetion();
        String sql = "Select * from " + table + " where user_number='" + students_number + "';";
        stmt = conn.prepareStatement(sql);
        rs = stmt.executeQuery(sql);
        while (rs.next()) {
            int za = rs.getInt("examine");
            if (za != 0) {
                sql = "update " + table + " set examine='" + examine + "' where user_number='" + students_number + "';";
                stmt = conn.prepareStatement(sql);
                stmt.executeUpdate(sql);
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
        return 0;
    } finally {
        if (rs != null) {
            try {
                rs.close();
                rs = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        if (stmt != null) {
            try {
                stmt.close();
                stmt = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        try {
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    return 1;
}

######


public int getStudents_check(String sql) {
    DBHelper db = new DBHelper();
    PreparedStatement stmt = null;
    Connection conn = null;
    ResultSet rs = null;
    int reslut = 0;
    try {
        conn = db.getConnetion();
        stmt = conn.prepareStatement(sql);
        rs = stmt.executeQuery(sql);
        while (rs.next()) {
            reslut = rs.getInt(1);
        }
    } catch (Exception e) {
        e.printStackTrace();
        return 0;
    }
    return reslut;
}

######


public String getFieldValue(String word, String filed_value) throws SQLException {
    String sql = "Select " + word + " From " + table + " where " + filed_name + "=\"" + filed_value + "\" ;";
    System.out.println("sql:" + sql);
    DBHelper db = new DBHelper();
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    String result = "";
    try {
        conn = db.getConnetion();
        stmt = conn.prepareStatement(sql);
        rs = stmt.executeQuery();
        while (rs.next()) {
            result = rs.getString(word);
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        if (rs != null) {
            try {
                rs.close();
                rs = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        if (stmt != null) {
            try {
                stmt.close();
                stmt = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        conn.close();
    }
    return result;
}

######


public static void main(String[] args) throws SQLException {
    DBHelper db = new DBHelper();
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    try {
        conn = db.getConnetion();
        String sql = "Select * From student_basic_news Where user_number=201321091074 ;";
        stmt = conn.prepareStatement(sql);
        rs = stmt.executeQuery();
        Item_student item = new Item_student();
    } catch (Exception ex) {
        ex.printStackTrace();
    } finally {
        if (rs != null) {
            try {
                rs.close();
                rs = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        if (stmt != null) {
            try {
                stmt.close();
                stmt = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }
    Items items = new Items();
    items.setTable("student_basic_news");
    items.setFiled_name("user_number");
    DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
}

######


Boolean insertUser(UserModel userModel) throws DaoException;

######


UserModel getUser(UserModel userModel) throws DaoException;

######


UserModel getPassword(String userId) throws DaoException;

######


Boolean updateUser(UserModel userModel) throws DaoException;

######


List<TicketModel> getHistory(UserModel userModel) throws DaoException;

######


Boolean cancelTicket(int ticketId) throws DaoException;

######


List<TicketModel> getHistory(String email) throws DaoException;

######


List<TravellerModel> getTicketDetails(int ticketId) throws DaoException;

######


@Override
public void handle(ActionEvent event) {
    count++;
    if (kontrol())
        ekle();
    tablodoldur();
}

######


@Override
public void handle(ActionEvent event) {
    for (int i = 0; i < 6; i++) {
        text[i].setText("");
        combo.setValue("");
    }
}

######


@Override
public void handle(ActionEvent event) {
    try {
        Search a = new Search();
        a.start(primaryStage);
        primaryStage.show();
    } catch (Exception e) {
        System.out.println(e.toString());
    }
}

######


@Override
public void start(final Stage primaryStage) throws Exception {
    primaryStage.setTitle("DataBase Project");
    GridPane grid = new GridPane();
    grid.setPadding(new Insets(10, 10, 10, 10));
    grid.setVgap(8);
    grid.setHgap(10);
    Image ımage1 = new Image("file:egitim1.png");
    ImageView ıv = new ImageView();
    ıv.setImage(ımage1);
    ıv.setTranslateX(450);
    ıv.setTranslateY(10);
    combo = new ComboBox();
    combo.setMaxSize(150, 30);
    combo.setPromptText("operation type..");
    combo.setEditable(true);
    combo.getItems().addAll("Degree cancellation");
    GridPane.setConstraints(combo, 1, 7);
    grid.getChildren().addAll(combo);
    Font LabelFont1 = new Font(12);
    btn1 = new Button("Save");
    btn1.getStyleClass().add("button-green");
    btn1.setMinSize(100, 30);
    btn1.setTranslateX(300);
    btn1.setTranslateY(70);
    btn1.setOnAction(new EventHandler<ActionEvent>() {

        @Override
        public void handle(ActionEvent event) {
            count++;
            if (kontrol())
                ekle();
            tablodoldur();
        }
    });
    btn2 = new Button("Clean");
    btn2.setMinSize(100, 30);
    btn2.setTranslateX(300);
    btn2.setTranslateY(120);
    btn2.setOnAction(new EventHandler<ActionEvent>() {

        @Override
        public void handle(ActionEvent event) {
            for (int i = 0; i < 6; i++) {
                text[i].setText("");
                combo.setValue("");
            }
        }
    });
    btn3 = new Button("Search");
    btn3.getStyleClass().add("button-blue");
    btn3.setMinSize(100, 30);
    btn3.setTranslateX(300);
    btn3.setTranslateY(170);
    btn3.setOnAction(new EventHandler<ActionEvent>() {

        @Override
        public void handle(ActionEvent event) {
            try {
                Search a = new Search();
                a.start(primaryStage);
                primaryStage.show();
            } catch (Exception e) {
                System.out.println(e.toString());
            }
        }
    });
    grid.getChildren().addAll(btn1, btn2, btn3);
    label[0] = new Label("*T.C");
    label[1] = new Label("*Name");
    label[2] = new Label("*Surname");
    label[3] = new Label("*University");
    label[4] = new Label("*Decision No");
    label[5] = new Label("*Decision Date");
    label[6] = new Label(" Operation");
    for (int i = 0; i < 7; i++) {
        GridPane.setConstraints(label[i], 0, i + 1);
        label[i].setFont(LabelFont1);
    }
    for (int i = 0; i < 7; i++) {
        grid.getChildren().addAll(label[i]);
    }
    text[0] = new TextField();
    GridPane.setConstraints(text[0], 1, 0 + 1);
    text[1] = new TextField();
    GridPane.setConstraints(text[1], 1, 1 + 1);
    text[2] = new TextField();
    GridPane.setConstraints(text[2], 1, 2 + 1);
    text[3] = new TextField();
    GridPane.setConstraints(text[3], 1, 3 + 1);
    text[4] = new TextField();
    GridPane.setConstraints(text[4], 1, 4 + 1);
    text[5] = new TextField();
    GridPane.setConstraints(text[5], 1, 5 + 1);
    for (int i = 0; i < 6; i++) {
        grid.getChildren().addAll(text[i]);
    }
    tableview = new TableView();
    tableview.setMinSize(640, 0);
    tableview.setMaxSize(700, 250);
    tableview.setTranslateX(15);
    tableview.setTranslateY(280);
    Group root = new Group();
    root.getChildren().addAll(grid, tableview, ıv);
    Scene scene = new Scene(root, 715, 540);
    scene.getStylesheets().add(getClass().getResource("Viper.css").toExternalForm());
    primaryStage.setScene(scene);
    primaryStage.setResizable(false);
    primaryStage.show();
}

######


public static void main(String[] args) {
    launch(args);
}

######


private void ekle() {
    try {
        try {
            Class.forName("com.mysql.jdbc.Driver");
        } catch (ClassNotFoundException ex) {
            JOptionPane.showMessageDialog(null, "An error occurred in the driver" + ex);
        }
        Connection conn = null;
        try {
            conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/database", "root", "");
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Error on connection" + e);
        }
        try {
            PreparedStatement prepared = conn.prepareStatement("INSERT INTO diploma(TC,NAME,SURNAME,UNIVERSITY,DECISIONNO,DECISIONDATE,OPERATION)" + "VALUES(?,?,?,?,?,?,?);");
            prepared.setString(1, text[0].getText());
            prepared.setString(2, text[1].getText());
            prepared.setString(3, text[2].getText());
            prepared.setString(4, text[3].getText());
            prepared.setString(5, text[4].getText());
            prepared.setString(6, text[5].getText());
            prepared.setString(7, combo.getValue().toString());
            int donut = prepared.executeUpdate();
            if (donut > 0) {
                JOptionPane.showMessageDialog(null, "successful");
            } else
                JOptionPane.showMessageDialog(null, "error!!!");
        } catch (SQLException ex) {
            JOptionPane.showMessageDialog(null, "An error occurred during sql commands" + ex);
        }
        conn.close();
    } catch (SQLException ex) {
        Logger.getLogger(JavaFXApplication4.class.getName()).log(Level.SEVERE, null, ex);
    }
}

######


private boolean kontrol() {
    boolean donut = false;
    String mesaj = "";
    if (text[1].getText().isEmpty())
        mesaj += "Please do not leave Name blank";
    if (text[2].getText().isEmpty())
        mesaj += "Please do not leave Surname blank";
    if (text[3].getText().isEmpty())
        mesaj += "Please do not leave University blank";
    if (text[4].getText().isEmpty())
        mesaj += "Please do not leave DecisionNo blank";
    if (text[5].getText().isEmpty())
        mesaj += "Please do not leave DecisionDate blank";
    JOptionPane.showMessageDialog(null, mesaj);
    if (mesaj == "")
        donut = true;
    return donut;
}

######


public ObservableValue<String> call(TableColumn.CellDataFeatures<ObservableList, String> param) {
    return new SimpleStringProperty(param.getValue().get(j).toString());
}

######


public void tablodoldur() {
    Connection c;
    data = FXCollections.observableArrayList();
    try {
        c = DBConnect.connect();
        String SQL = "SELECT * from diploma";
        ResultSet rs = c.createStatement().executeQuery(SQL);
        for (int i = 0; i < rs.getMetaData().getColumnCount(); i++) {
            final int j = i;
            TableColumn col = new TableColumn(rs.getMetaData().getColumnName(i + 1));
            col.setCellValueFactory(new Callback<TableColumn.CellDataFeatures<ObservableList, String>, ObservableValue<String>>() {

                public ObservableValue<String> call(TableColumn.CellDataFeatures<ObservableList, String> param) {
                    return new SimpleStringProperty(param.getValue().get(j).toString());
                }
            });
            if (count < 2) {
                tableview.getColumns().addAll(col);
                System.out.println("Column [" + i + "] ");
            }
        }
        while (rs.next()) {
            ObservableList<String> row = FXCollections.observableArrayList();
            for (int i = 1; i <= rs.getMetaData().getColumnCount(); i++) {
                row.add(rs.getString(i));
            }
            System.out.println("Row [1] added " + row);
            data.add(row);
        }
        tableview.setItems(data);
    } catch (Exception e) {
        System.out.println("Error on Building Data");
    }
}

######


public static void main(String[] args) {
    try {
        DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());
        Connection conexion = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "system", "javaoracle");
        conexion.setAutoCommit(false);
        PreparedStatement prepararselect = conexion.prepareStatement("update emp set salario= salario*1.10 where apellido=?");
        prepararselect.setString(1, "negro");
        prepararselect.executeUpdate();
        PreparedStatement prepararselect2 = conexion.prepareStatement("update emp set salario= salario+5000 where apellido=?");
        prepararselect2.setString(1, "sala");
        prepararselect2.executeUpdate();
        conexion.rollback();
    } catch (Exception e) {
        System.out.println("Error: " + e.toString());
    }
}

######


public static void main(String[] args) throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/karthik", "root", "visog");
    PreparedStatement pstm = con.prepareStatement("insert into employee values(?,?,?)");
    pstm.setInt(1, 3);
    pstm.setString(2, "rajesh");
    pstm.setInt(3, 2400);
    int i = pstm.executeUpdate();
    if (i > 0) {
        System.out.println("insertion Successfull");
    } else {
        System.out.println("insertion Failure");
    }
}

######


public static void main(String[] args) {
    try {
        DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());
        Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:XE", "system", "javaoracle");
        Statement stmt = conn.createStatement();
        int afectados = stmt.executeUpdate("delete from emp where apellido = 'tovar'");
        if (afectados == 0)
            System.out.println("Sin cambios (" + afectados + " registros afectados)");
        else
            System.out.println("Cambios realizados (" + afectados + " registros afectados)");
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void setUniqueId(final String id) {
    this.uniqueId = id;
}

######


public void setApplicationId(final String id) {
    this.applicationId = id;
}

######


public void setLockTimeout(final int seconds) {
    this.lockTimeout = seconds;
}

######


public void setTableName(final String name) {
    this.tableName = name;
}

######


public void setApplicationIdColumnName(final String name) {
    this.applicationIdColumnName = name;
}

######


public void setUniqueIdColumnName(final String name) {
    this.uniqueIdColumnName = name;
}

######


public void setExpirationDateColumnName(final String name) {
    this.expirationDateColumnName = name;
}

######


public void setDataSource(final DataSource dataSource) {
    this.dataSource = dataSource;
}

######


public void setPlatform(final DatabasePlatform platform) {
    this.platform = platform;
}

######


public static void main(String[] args) {
    try {
        DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());
        Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:XE", "system", "javaoracle");
        PreparedStatement stmt = conn.prepareStatement("select apellido from emp where emp_no = ?");
        stmt.setInt(1, 7900);
        ResultSet rs = stmt.executeQuery();
        rs.next();
        System.out.println(rs.getString(1));
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public Connection getConnection() throws ClassNotFoundException {
    try {
        Class.forName(driver);
        con = DriverManager.getConnection(url, username, password);
        return con;
    } catch (SQLException e) {
        e.printStackTrace();
        return null;
    }
}

######


public void closeConnection() {
    try {
        if (con != null)
            con.close();
    } catch (SQLException e) {
        throw new RuntimeException(e);
    }
}

######


public DatabaseMetaData getDatabaseMetaData() throws ClassNotFoundException, SQLException {
    Connection conn = getConnection();
    java.sql.DatabaseMetaData dbmd = conn.getMetaData();
    return dbmd;
}

######


@Autowired
public void setDataSource(final DataSource dataSource) {
    this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
}

######


public void afterPropertiesSet() throws Exception {
    SimpleJdbcTestUtils.deleteFromTables(simpleJdbcTemplate, "locks");
}

######


@Test
public void testAcquireAndRelease() throws Exception {
    final String appId = "basic";
    final String uniqueId = appId + "-1";
    final LockingStrategy lock = newLockTxProxy(appId, uniqueId, JpaLockingStrategy.DEFAULT_LOCK_TIMEOUT);
    try {
        assertTrue(lock.acquire());
        assertEquals(uniqueId, getOwner(appId));
        lock.release();
        assertNull(getOwner(appId));
    } catch (Exception e) {
        logger.debug("testAcquireAndRelease produced an error", e);
        fail("testAcquireAndRelease failed");
    }
}

######


@Test
public void testLockExpiration() throws Exception {
    final String appId = "expquick";
    final String uniqueId = appId + "-1";
    final LockingStrategy lock = newLockTxProxy(appId, uniqueId, 1);
    try {
        assertTrue(lock.acquire());
        assertEquals(uniqueId, getOwner(appId));
        assertFalse(lock.acquire());
        Thread.sleep(1500);
        assertTrue(lock.acquire());
        assertEquals(uniqueId, getOwner(appId));
        lock.release();
        assertNull(getOwner(appId));
    } catch (Exception e) {
        logger.debug("testLockExpiration produced an error", e);
        fail("testLockExpiration failed");
    }
}

######


@Test
public void testNonReentrantBehavior() {
    final String appId = "reentrant";
    final String uniqueId = appId + "-1";
    final LockingStrategy lock = newLockTxProxy(appId, uniqueId, JpaLockingStrategy.DEFAULT_LOCK_TIMEOUT);
    try {
        assertTrue(lock.acquire());
        assertEquals(uniqueId, getOwner(appId));
        assertFalse(lock.acquire());
        lock.release();
        assertNull(getOwner(appId));
    } catch (Exception e) {
        logger.debug("testNonReentrantBehavior produced an error", e);
        fail("testNonReentrantBehavior failed.");
    }
}

######


@Test
@IfProfileValue(name = "cas.jpa.concurrent", value = "true")
public void testConcurrentAcquireAndRelease() throws Exception {
    final ExecutorService executor = Executors.newFixedThreadPool(CONCURRENT_SIZE);
    try {
        testConcurrency(executor, getConcurrentLocks("concurrent-new"));
    } catch (Exception e) {
        logger.debug("testConcurrentAcquireAndRelease produced an error", e);
        fail("testConcurrentAcquireAndRelease failed.");
    } finally {
        executor.shutdownNow();
    }
}

######


@Test
@IfProfileValue(name = "cas.jpa.concurrent", value = "true")
public void testConcurrentAcquireAndReleaseOnExistingLock() throws Exception {
    final LockingStrategy[] locks = getConcurrentLocks("concurrent-exists");
    locks[0].acquire();
    locks[0].release();
    final ExecutorService executor = Executors.newFixedThreadPool(CONCURRENT_SIZE);
    try {
        testConcurrency(executor, locks);
    } catch (Exception e) {
        logger.debug("testConcurrentAcquireAndReleaseOnExistingLock produced an error", e);
        fail("testConcurrentAcquireAndReleaseOnExistingLock failed.");
    } finally {
        executor.shutdownNow();
    }
}

######


private LockingStrategy[] getConcurrentLocks(final String appId) {
    final LockingStrategy[] locks = new LockingStrategy[CONCURRENT_SIZE];
    for (int i = 1; i <= locks.length; i++) {
        locks[i - 1] = newLockTxProxy(appId, appId + "-" + i, JpaLockingStrategy.DEFAULT_LOCK_TIMEOUT);
    }
    return locks;
}

######


private LockingStrategy newLockTxProxy(final String appId, final String uniqueId, final int ttl) {
    final JpaLockingStrategy lock = new JpaLockingStrategy();
    lock.entityManager = SharedEntityManagerCreator.createSharedEntityManager(factory);
    lock.setApplicationId(appId);
    lock.setUniqueId(uniqueId);
    lock.setLockTimeout(ttl);
    return (LockingStrategy) Proxy.newProxyInstance(JpaLockingStrategy.class.getClassLoader(), new Class[] { LockingStrategy.class }, new TransactionalLockInvocationHandler(lock));
}

######


private String getOwner(final String appId) {
    final List<Map<String, Object>> results = simpleJdbcTemplate.queryForList("SELECT unique_id FROM locks WHERE application_id=?", appId);
    if (results.size() == 0) {
        return null;
    }
    return (String) results.get(0).get("unique_id");
}

######


private void testConcurrency(final ExecutorService executor, final LockingStrategy[] locks) throws Exception {
    final List<Locker> lockers = new ArrayList<Locker>(locks.length);
    for (int i = 0; i < locks.length; i++) {
        lockers.add(new Locker(locks[i]));
    }
    int lockCount = 0;
    for (Future<Boolean> result : executor.invokeAll(lockers)) {
        if (result.get()) {
            lockCount++;
        }
    }
    assertTrue("Lock count should be <= 1 but was " + lockCount, lockCount <= 1);
    final List<Releaser> releasers = new ArrayList<Releaser>(locks.length);
    for (int i = 0; i < locks.length; i++) {
        releasers.add(new Releaser(locks[i]));
    }
    int releaseCount = 0;
    for (Future<Boolean> result : executor.invokeAll(lockers)) {
        if (result.get()) {
            releaseCount++;
        }
    }
    assertTrue("Release count should be <= 1 but was " + releaseCount, releaseCount <= 1);
}

######


public JpaLockingStrategy getLock() {
    return jpaLock;
}

######


public Object doInTransaction(final TransactionStatus status) {
    try {
        final Object result = method.invoke(jpaLock, args);
        jpaLock.entityManager.flush();
        logger.debug("Performed {} on {}", method.getName(), jpaLock);
        return result;
    } catch (Exception e) {
        throw new RuntimeException("Transactional method invocation failed.", e);
    }
}

######


public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {
    return new TransactionTemplate(txManager).execute(new TransactionCallback<Object>() {

        public Object doInTransaction(final TransactionStatus status) {
            try {
                final Object result = method.invoke(jpaLock, args);
                jpaLock.entityManager.flush();
                logger.debug("Performed {} on {}", method.getName(), jpaLock);
                return result;
            } catch (Exception e) {
                throw new RuntimeException("Transactional method invocation failed.", e);
            }
        }
    });
}

######


public Boolean call() throws Exception {
    try {
        return lock.acquire();
    } catch (Exception e) {
        logger.debug("{} failed to acquire lock", lock, e);
        return false;
    }
}

######


public Boolean call() throws Exception {
    try {
        lock.release();
        return true;
    } catch (Exception e) {
        logger.debug("{} failed to release lock", lock, e);
        return false;
    }
}

######


protected void updateTicket(final Ticket ticket) {
    entityManager.merge(ticket);
    log.debug("Updated ticket [{}].", ticket);
}

######


@Transactional(readOnly = false)
public void addTicket(final Ticket ticket) {
    entityManager.persist(ticket);
    log.debug("Added ticket [{}] to registry.", ticket);
}

######


@Transactional(readOnly = false)
public boolean deleteTicket(final String ticketId) {
    final Ticket ticket = getRawTicket(ticketId);
    if (ticket == null) {
        return false;
    }
    if (ticket instanceof ServiceTicket) {
        removeTicket(ticket);
        log.debug("Deleted ticket [{}] from the registry.", ticket);
        return true;
    }
    deleteTicketAndChildren(ticket);
    log.debug("Deleted ticket [{}] and its children from the registry.", ticket);
    return true;
}

######


private void deleteTicketAndChildren(final Ticket ticket) {
    final List<TicketGrantingTicketImpl> ticketGrantingTicketImpls = entityManager.createQuery("select t from TicketGrantingTicketImpl t where t.ticketGrantingTicket.id = :id", TicketGrantingTicketImpl.class).setLockMode(LockModeType.PESSIMISTIC_WRITE).setParameter("id", ticket.getId()).getResultList();
    final List<ServiceTicketImpl> serviceTicketImpls = entityManager.createQuery("select s from ServiceTicketImpl s where s.ticketGrantingTicket.id = :id", ServiceTicketImpl.class).setParameter("id", ticket.getId()).getResultList();
    for (final ServiceTicketImpl s : serviceTicketImpls) {
        removeTicket(s);
    }
    for (final TicketGrantingTicketImpl t : ticketGrantingTicketImpls) {
        deleteTicketAndChildren(t);
    }
    removeTicket(ticket);
}

######


private void removeTicket(final Ticket ticket) {
    try {
        if (log.isDebugEnabled()) {
            final Date creationDate = new Date(ticket.getCreationTime());
            log.debug("Removing Ticket [{}] created: {}", ticket, creationDate.toString());
        }
        entityManager.remove(ticket);
    } catch (final Exception e) {
        log.error("Error removing {} from registry.", ticket, e);
    }
}

######


@Transactional(readOnly = true)
public Ticket getTicket(final String ticketId) {
    return getProxiedTicketInstance(getRawTicket(ticketId));
}

######


private Ticket getRawTicket(final String ticketId) {
    try {
        if (ticketId.startsWith(this.ticketGrantingTicketPrefix)) {
            return entityManager.find(TicketGrantingTicketImpl.class, ticketId, LockModeType.PESSIMISTIC_WRITE);
        }
        return entityManager.find(ServiceTicketImpl.class, ticketId);
    } catch (final Exception e) {
        log.error("Error getting ticket {} from registry.", ticketId, e);
    }
    return null;
}

######


@Transactional(readOnly = true)
public Collection<Ticket> getTickets() {
    final List<TicketGrantingTicketImpl> tgts = entityManager.createQuery("select t from TicketGrantingTicketImpl t", TicketGrantingTicketImpl.class).getResultList();
    final List<ServiceTicketImpl> sts = entityManager.createQuery("select s from ServiceTicketImpl s", ServiceTicketImpl.class).getResultList();
    final List<Ticket> tickets = new ArrayList<Ticket>();
    tickets.addAll(tgts);
    tickets.addAll(sts);
    return tickets;
}

######


public void setTicketGrantingTicketPrefix(final String ticketGrantingTicketPrefix) {
    this.ticketGrantingTicketPrefix = ticketGrantingTicketPrefix;
}

######


@Override
protected boolean needsCallback() {
    return false;
}

######


@Transactional(readOnly = true)
public int sessionCount() {
    return countToInt(entityManager.createQuery("select count(t) from TicketGrantingTicketImpl t").getSingleResult());
}

######


@Transactional(readOnly = true)
public int serviceTicketCount() {
    return countToInt(entityManager.createQuery("select count(t) from ServiceTicketImpl t").getSingleResult());
}

######


private int countToInt(final Object result) {
    final int intval;
    if (result instanceof Long) {
        intval = ((Long) result).intValue();
    } else if (result instanceof Integer) {
        intval = (Integer) result;
    } else {
        intval = ((Number) result).intValue();
    }
    return intval;
}

######


@Autowired
public void setElasticsearchTemplate(ElasticsearchTemplate elasticsearchTemplate) {
    this.elasticsearchTemplate = elasticsearchTemplate;
}

######


@Override
public Page<KbsTopicComment> findByDataid(String id, int p, int ps) {
    Page<KbsTopicComment> pages = null;
    SearchQuery searchQuery = new NativeSearchQueryBuilder().withQuery(termQuery("dataid", id)).withSort(new FieldSortBuilder("optimal").unmappedType("boolean").order(SortOrder.DESC)).withSort(new FieldSortBuilder("updatetime").unmappedType("date").order(SortOrder.DESC)).build().setPageable(new PageRequest(p, ps));
    if (elasticsearchTemplate.indexExists(KbsTopicComment.class)) {
        pages = elasticsearchTemplate.queryForPage(searchQuery, KbsTopicComment.class);
    }
    return pages;
}

######


@Override
public List<KbsTopicComment> findByOptimal(String dataid) {
    List<KbsTopicComment> commentList = null;
    SearchQuery searchQuery = new NativeSearchQueryBuilder().withQuery(termQuery("dataid", dataid)).withQuery(termQuery("optimal", true)).build();
    if (elasticsearchTemplate.indexExists(KbsTopicComment.class)) {
        commentList = elasticsearchTemplate.queryForList(searchQuery, KbsTopicComment.class);
    }
    return commentList;
}

######


@Override
public Page<KbsTopicComment> findByCon(NativeSearchQueryBuilder searchQueryBuilder, String field, String aggname, String q, final int p, final int ps) {
    Page<KbsTopicComment> pages = null;
    if (!StringUtils.isBlank(q)) {
        searchQueryBuilder.withQuery(new QueryStringQueryBuilder(q).defaultOperator(Operator.AND));
    }
    SearchQuery searchQuery = searchQueryBuilder.build();
    if (elasticsearchTemplate.indexExists(KbsTopicComment.class)) {
        if (!StringUtils.isBlank(q)) {
            pages = elasticsearchTemplate.queryForPage(searchQuery, KbsTopicComment.class, new UKResultMapper());
        } else {
            pages = elasticsearchTemplate.queryForPage(searchQuery, KbsTopicComment.class, new UKAggTopResultExtractor(field, aggname));
        }
    }
    return pages;
}

######


@Override
public Page<KbsTopicComment> findByCon(NativeSearchQueryBuilder searchQueryBuilder, String q, int p, int ps) {
    searchQueryBuilder.withPageable(new PageRequest(p, ps)).withSort(new FieldSortBuilder("updatetime").unmappedType("date").order(SortOrder.DESC));
    searchQueryBuilder.withHighlightFields(new HighlightBuilder.Field("content").fragmentSize(200));
    if (!StringUtils.isBlank(q)) {
        searchQueryBuilder.withQuery(new QueryStringQueryBuilder(q).defaultOperator(Operator.AND));
    }
    return elasticsearchTemplate.queryForPage(searchQueryBuilder.build(), KbsTopicComment.class, new UKResultMapper());
}

######


@Override
public Page<KbsTopicComment> countByCon(NativeSearchQueryBuilder searchQueryBuilder, String q, int p, int ps) {
    Page<KbsTopicComment> pages = null;
    if (!StringUtils.isBlank(q)) {
        searchQueryBuilder.withQuery(new QueryStringQueryBuilder(q).defaultOperator(Operator.AND));
    }
    SearchQuery searchQuery = searchQueryBuilder.build().setPageable(new PageRequest(p, ps));
    if (elasticsearchTemplate.indexExists(Topic.class)) {
        pages = elasticsearchTemplate.queryForPage(searchQuery, KbsTopicComment.class, new UKAggResultExtractor("creater"));
    }
    return pages;
}

######


public Long getId() {
    return id;
}

######


public void setId(Long id) {
    this.id = id;
}

######


public String getKdgiat() {
    return kdgiat;
}

######


public void setKdgiat(String kdgiat) {
    this.kdgiat = kdgiat;
}

######


public String getNmgiat() {
    return nmgiat;
}

######


public void setNmgiat(String nmgiat) {
    this.nmgiat = nmgiat;
}

######


@Override
public String toString() {
    return "apdol.entity.Kegiatan[ id=" + id + " ]";
}

######


public boolean isKodeNoChange(String kode) {
    if (kode.equalsIgnoreCase(this.kdgiat)) {
        return true;
    } else {
        return false;
    }
}

######


public boolean isNamaNoChange(String nama) {
    if (nama.equalsIgnoreCase(this.nmgiat)) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public void initialize(URL location, ResourceBundle resources) {
    formatdayPicker();
    filTergv();
    tableItemClick();
    fillComboBox();
    fillComBoxKhoa();
    btnXoakh.setOnAction(e -> {
        deleteGiaoVien();
    });
    btnRefKh.setOnAction(e -> {
        try {
            dataBaseGVKhoa();
        } catch (SQLException e1) {
            e1.printStackTrace();
        }
    });
}

######


private void fillComBoxKhoa() {
    Connection connbox = SQLiteConnection.connector();
    PreparedStatement precombox;
    ResultSet rscbox;
    String khoadb = "select DISTINCT MaKhoaGV from GIAOVIEN order by MaKhoaGV asc";
    try {
        precombox = connbox.prepareStatement(khoadb);
        rscbox = precombox.executeQuery();
        while (rscbox.next()) {
            comboxhienthisv.add(rscbox.getString("MaKhoaGV"));
        }
        rscbox.close();
        precombox.close();
    } catch (Exception e) {
    }
    comHienThi.setItems(comboxhienthisv);
}

######


private void dataBaseGVKhoa() throws SQLException {
    obgv.clear();
    Connection conngv = SQLiteConnection.connector();
    PreparedStatement preparegv = null;
    ResultSet rsi = null;
    String gvstr = "select *  from GIAOVIEN where MaKhoaGV=?";
    try {
        preparegv = conngv.prepareStatement(gvstr);
        preparegv.setString(1, comHienThi.getSelectionModel().getSelectedItem());
        rsi = preparegv.executeQuery();
        while (rsi.next()) {
            obgv.add(new GiaoVienModel(rsi.getString(1), rsi.getString(2), rsi.getString(3), rsi.getString(4), rsi.getString(5), rsi.getString(6), rsi.getString(7), rsi.getString("MaKhoaGV")));
        }
        rsi.close();
        preparegv.close();
        conngv.close();
    } catch (Exception e) {
    }
    clmakh.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("IdGv"));
    clhokh.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("HoGv"));
    cltenkh.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("TenGv"));
    clngaysinhkh.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("NgaysinhGv"));
    clsexkh.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("SexGv"));
    clphonekh.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("PhoneGv"));
    cldiachikh.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("DiachiGv"));
    clkhoa.setCellValueFactory(new PropertyValueFactory<GiaoVienModel, String>("KhoaGv"));
    tablegv.setItems(obgv);
}

######


private void filTergv() {
    FilteredList<GiaoVienModel> filtergv = new FilteredList<>(obgv, e -> true);
    txtFindkh.setOnAction(e -> {
        txtFindkh.textProperty().addListener(((observable, oldValue, newValue) -> {
            filtergv.setPredicate((Predicate<? super GiaoVienModel>) gv -> {
                if (newValue == null || newValue.isEmpty()) {
                    return true;
                }
                String lowerCase = newValue.toLowerCase();
                if (gv.getIdGv().toLowerCase().contains(lowerCase)) {
                    return true;
                } else if (gv.getTenGv().toLowerCase().contains(lowerCase)) {
                    return true;
                } else if (gv.getHoGv().toLowerCase().contains(lowerCase)) {
                    return true;
                }
                return false;
            });
        }));
        SortedList<GiaoVienModel> sort = new SortedList<>(filtergv);
        sort.comparatorProperty().bind(tablegv.comparatorProperty());
        tablegv.setItems(sort);
    });
}

######


@Override
public String toString(LocalDate date) {
    if (date != null) {
        return dateFormatter.format(date);
    } else {
        return "";
    }
}

######


@Override
public LocalDate fromString(String string) {
    if (string != null && !string.isEmpty()) {
        return LocalDate.parse(string, dateFormatter);
    } else {
        return null;
    }
}

######


private void formatdayPicker() {
    bDatekh.setConverter(new StringConverter<LocalDate>() {

        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(pattern);

        {
            bDatekh.setPromptText("Ngày sinh");
        }

        @Override
        public String toString(LocalDate date) {
            if (date != null) {
                return dateFormatter.format(date);
            } else {
                return "";
            }
        }

        @Override
        public LocalDate fromString(String string) {
            if (string != null && !string.isEmpty()) {
                return LocalDate.parse(string, dateFormatter);
            } else {
                return null;
            }
        }
    });
}

######


private void clearText() {
    txtHokh.clear();
    txtDiachikh.clear();
    txtTenkh.clear();
    txtMakh.clear();
    txtPhonekh.clear();
    bDatekh.setValue(null);
    radNukh.setSelected(false);
    radNamkh.setSelected(false);
}

######


private void themGiaoVien() throws SQLException {
    if (emtyFeild()) {
        if (radNamkh.isSelected()) {
            lblsex = radNamkh.getText();
        } else if (radNukh.isSelected()) {
            lblsex = radNukh.getText();
        }
        Connection conngv = SQLiteConnection.connector();
        PreparedStatement preparegv1 = null;
        String gvstr1 = "insert into GIAOVIEN (MaGV,HoGV,TenGV,NgaySinhGV,GioiTinhGV,PhoneGV,DiaChiGV,MaKhoaGV) values (?,?,?,?,?,?,?,?)";
        try {
            preparegv1 = conngv.prepareStatement(gvstr1);
            preparegv1.setString(1, txtMakh.getText());
            preparegv1.setString(2, txtHokh.getText());
            preparegv1.setString(3, txtTenkh.getText());
            preparegv1.setString(4, bDatekh.getEditor().getText());
            preparegv1.setString(5, lblsex);
            preparegv1.setString(6, txtPhonekh.getText());
            preparegv1.setString(7, txtDiachikh.getText());
            preparegv1.setString(8, comKhoa.getSelectionModel().getSelectedItem());
            preparegv1.executeUpdate();
            dataBaseGVKhoa();
            clearText();
            preparegv1.close();
            conngv.close();
        } catch (Exception e) {
        } finally {
        }
    }
}

######


private void fillComboBox() {
    Connection connbox = SQLiteConnection.connector();
    PreparedStatement precombox;
    ResultSet rscbox;
    String khoadb = "select DISTINCT MaKhoaGV from GIAOVIEN order by MaKhoaGV asc";
    try {
        precombox = connbox.prepareStatement(khoadb);
        rscbox = precombox.executeQuery();
        while (rscbox.next()) {
            combox.add(rscbox.getString("MaKhoaGV"));
        }
        rscbox.close();
        precombox.close();
    } catch (Exception e) {
    }
    comKhoa.setItems(combox);
}

######


private boolean emtyFeild() {
    if (txtMakh.getText().isEmpty() | txtHokh.getText().isEmpty() | txtTenkh.getText().isEmpty() | txtPhonekh.getText().isEmpty() | txtDiachikh.getText().isEmpty()) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị nhập đầy đủ thông tin!!");
        alert.showAndWait();
        return false;
    }
    if (bDatekh.getEditor().getText().isEmpty()) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị nhập Ngày Sinh");
        alert.showAndWait();
        return false;
    }
    if (radioCheck()) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị chọn Giới Tính!");
        alert.showAndWait();
        return false;
    }
    if (comKhoa.getValue() == null) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị chọn Khoa!");
        alert.showAndWait();
        return false;
    }
    return true;
}

######


private boolean radioCheck() {
    if (radNamkh.isSelected() || radNukh.isSelected()) {
        return false;
    } else
        return true;
}

######


private void tableItemClick() {
    tablegv.setOnMouseClicked(e -> {
        if (tablegv.getSelectionModel().getSelectedItem() != null) {
            try {
                GiaoVienModel gv = tablegv.getSelectionModel().getSelectedItem();
                String qr = "select * from GIAOVIEN where MaGV=?";
                Connection conn = SQLiteConnection.connector();
                PreparedStatement pre;
                ResultSet rs;
                pre = conn.prepareStatement(qr);
                pre.setString(1, gv.getIdGv());
                rs = pre.executeQuery();
                while (rs.next()) {
                    txtMakh.setText(rs.getString(1));
                    txtHokh.setText(rs.getString(2));
                    txtTenkh.setText(rs.getString(3));
                    bDatekh.getEditor().setText(rs.getString(4));
                    if (rs.getString(5).equals("Nam")) {
                        radNamkh.setSelected(true);
                    } else
                        radNukh.setSelected(true);
                    txtPhonekh.setText(rs.getString(6));
                    txtDiachikh.setText(rs.getString(7));
                }
                rs.close();
                pre.close();
                conn.close();
            } catch (Exception m) {
                m.printStackTrace();
            }
        }
    });
}

######


private void deleteGiaoVien() {
    if (!txtMakh.getText().isEmpty()) {
        Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
        alert.setHeaderText(null);
        alert.setContentText("Bạn có muốn xoá " + txtHokh.getText() + " " + txtTenkh.getText() + "\nKhỏi danh sách?");
        Optional<ButtonType> action = alert.showAndWait();
        Connection conn = SQLiteConnection.connector();
        PreparedStatement pred = null;
        if (action.get() == ButtonType.OK) {
            try {
                String qr = "delete from GIAOVIEN where MaGV=?";
                pred = conn.prepareStatement(qr);
                pred.setString(1, txtMakh.getText());
                pred.executeUpdate();
                pred.close();
                dataBaseGVKhoa();
                clearText();
                editDisableTxt();
                conn.close();
            } catch (Exception x) {
                x.printStackTrace();
            }
        }
    } else {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setHeaderText(null);
        alert.setContentText("Chọn trong danh sách để xoá!");
        alert.showAndWait();
    }
}

######


private void editEnableTxt() {
    txtMakh.setEditable(true);
    txtHokh.setEditable(true);
    txtTenkh.setEditable(true);
    txtPhonekh.setEditable(true);
    txtDiachikh.setEditable(true);
    radNukh.setDisable(false);
    radNamkh.setDisable(false);
    bDatekh.setDisable(false);
    comKhoa.setDisable(false);
    btnUpdateKh.setDisable(false);
    btnAddkh.setDisable(false);
}

######


private void editDisableTxt() {
    txtMakh.setEditable(false);
    txtHokh.setEditable(false);
    txtTenkh.setEditable(false);
    txtPhonekh.setEditable(false);
    txtDiachikh.setEditable(false);
    radNukh.setDisable(true);
    radNamkh.setDisable(true);
    bDatekh.setDisable(true);
    comKhoa.setDisable(true);
    btnUpdateKh.setDisable(true);
    btnAddkh.setDisable(true);
}

######


private boolean maGvisCheck() throws SQLException {
    PreparedStatement preCk = null;
    ResultSet rsCk = null;
    Connection connection = SQLiteConnection.connector();
    String gvstr1 = "select ? from GIAOVIEN";
    try {
        preCk = connection.prepareStatement(gvstr1);
        preCk.setString(1, txtMakh.getText());
        rsCk = preCk.executeQuery();
        if (rsCk.next()) {
            return true;
        } else {
            Alert alert = new Alert(Alert.AlertType.ERROR);
            alert.setTitle("Lỗi");
            alert.setHeaderText(null);
            alert.setContentText("Không tìm thấy Mã Giáo Viên!");
            alert.showAndWait();
            return false;
        }
    } catch (Exception e) {
        return false;
    } finally {
        rsCk.close();
        preCk.close();
    }
}

######


private void suaGiaoVien() throws SQLException {
    if (emtyFeild()) {
        if (radNamkh.isSelected()) {
            lblsex = radNamkh.getText();
        } else if (radNukh.isSelected()) {
            lblsex = radNukh.getText();
        }
        Connection conngv = SQLiteConnection.connector();
        PreparedStatement preparegvs = null;
        String str2 = "update GIAOVIEN set HoGV = ?,TenGV = ?,NgaySinhGV = ?,GioiTinhGV = ?,PhoneGV = ?,DiaChiGV = ?,MaKhoaGV = ? where MaGV = ?";
        try {
            preparegvs = conngv.prepareStatement(str2);
            preparegvs.setString(1, txtHokh.getText());
            preparegvs.setString(2, txtTenkh.getText());
            preparegvs.setString(3, bDatekh.getEditor().getText());
            preparegvs.setString(4, lblsex);
            preparegvs.setString(5, txtPhonekh.getText());
            preparegvs.setString(6, txtDiachikh.getText());
            preparegvs.setString(7, comKhoa.getSelectionModel().getSelectedItem());
            preparegvs.setString(8, txtMakh.getText());
            preparegvs.executeUpdate();
            dataBaseGVKhoa();
            preparegvs.close();
            conngv.close();
            clearText();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
        }
    }
}

######


@FXML
void onThemSuaKh(ActionEvent event) {
    if (event.getSource() == btnSuakh) {
        editEnableTxt();
        btnAddkh.setDisable(true);
        btnUpdateKh.setOnAction(e -> {
            try {
                if (maGvisCheck()) {
                    suaGiaoVien();
                    editDisableTxt();
                }
            } catch (SQLException s) {
                s.printStackTrace();
            }
        });
    }
    if (event.getSource() == btnThemkh) {
        clearText();
        editEnableTxt();
        btnUpdateKh.setDisable(true);
        btnAddkh.setOnAction(e -> {
            try {
                themGiaoVien();
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
            editDisableTxt();
        });
    }
}

######


public List xiaoshoudingdan_zhixingqingkuang() {
    String sql = "select * from employee";
    return kingdeeDao.queryForList(sql);
}

######


public List caigoudingdan_zhixingqingkuang() {
    return null;
}

######


public IPageList report_xsddhztj(QueryObject qo, String query, String begin, String end, String huizong) {
    String sql = "execute report_xsddhztj '" + query + "','" + begin + "','" + end + "'," + huizong + ",'" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    String totalsql = "execute report_xsddhztj_count '" + query + "','" + begin + "','" + end + "'," + huizong + ",'" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    return QueryUtil.query(qo, totalsql, sql, true, jdbcDao);
}

######


public IPageList user_list(QueryObject qo, String duodianzhichi) {
    String sql = "select u1.nick,u1.sex,u1.xingming,u1.chengshi,u1.zhuzhi,u1.shouji,u1.zuoji,u1.mail,u1.beizhu,u1.isHuiyuan,u1.gongsimingcheng,u1.gongsidizhi,u1.gongsidianhua,u1.gongsichuanzhen,hy.title as huiyuan,u1.tingyong from User u1 left join User u2 on u1.shopkeeper=u2.nick left join Huiyuan hy on u1.huiyuan=hy.id where u2.duodianzhichi='" + duodianzhichi + "'";
    return QueryUtil.query(qo, null, sql, orderby, jdbcDao);
}

######


public List hint_xsddjq(Integer diffday) {
    String sql = "execute hint_xsddjq " + diffday;
    return jdbcDao.queryForList(sql);
}

######


public IPageList list_xsdd(QueryObject qo, String query, String begin, String end, String status) {
    String sql = "execute list_xsdd '" + query + "','" + begin + "','" + end + "','" + status + "','" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    String totalsql = "execute list_xsdd_count '" + query + "','" + begin + "','" + end + "','" + status + "'";
    return QueryUtil.query(qo, totalsql, sql, true, jdbcDao);
}

######


public IPageList list_xsdd_wdj(QueryObject qo, String query, String begin, String end) {
    String sql = "execute list_xsdd_wdj '" + query + "','" + begin + "','" + end + "','" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    String totalsql = "execute list_xsdd_wdj_count '" + query + "','" + begin + "','" + end + "','" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    return QueryUtil.query(qo, totalsql, sql, true, jdbcDao);
}

######


public IPageList list_xsck(QueryObject qo, String query, String begin, String end, String status) {
    String sql = "execute list_xsck '" + query + "','" + begin + "','" + end + "','" + status + "','" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    String totalsql = "execute list_xsck_count '" + query + "','" + begin + "','" + end + "','" + status + "'";
    return QueryUtil.query(qo, totalsql, sql, true, jdbcDao);
}

######


public IPageList list_fhtz(QueryObject qo, String query, String begin, String end, String status) {
    String sql = "execute list_fhtz '" + query + "','" + begin + "','" + end + "','" + status + "','" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    String totalsql = "execute list_fhtz_count '" + query + "','" + begin + "','" + end + "','" + status + "','" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    return QueryUtil.query(qo, totalsql, sql, true, jdbcDao);
}

######


public IPageList list_xsfp(QueryObject qo, String query, String begin, String end, String status) {
    String sql = "execute list_xsfp '" + query + "','" + begin + "','" + end + "','" + status + "','" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    String totalsql = "execute list_xsfp_count '" + query + "','" + begin + "','" + end + "','" + status + "','" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    return QueryUtil.query(qo, totalsql, sql, true, jdbcDao);
}

######


public IPageList list_scrw(QueryObject qo, String query, String begin, String end, String status) {
    String sql = "execute list_scrw '" + query + "','" + begin + "','" + end + "','" + status + "','" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    String totalsql = "execute list_scrw_count '" + query + "','" + begin + "','" + end + "','" + status + "','" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    return QueryUtil.query(qo, totalsql, sql, true, jdbcDao);
}

######


public IPageList list_scrw_wja(QueryObject qo, String query, String begin, String end) {
    String sql = "execute list_scrw_wja '" + query + "','" + begin + "','" + end + "','" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    String totalsql = "execute list_scrw_wja_count '" + query + "','" + begin + "','" + end + "','" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    return QueryUtil.query(qo, totalsql, sql, true, jdbcDao);
}

######


public IPageList list_scrw_tqja(QueryObject qo) {
    String sql = "execute list_scrw_tqja ";
    String totalsql = "execute list_scrw_tqja_count ";
    return QueryUtil.query(qo, totalsql, sql, true, jdbcDao);
}

######


public IPageList list_jskc_lhbz(QueryObject qo, String query) {
    String sql = "execute list_jskc_lhbz '" + query + "'";
    String totalsql = "execute list_jskc_lhbz_count '" + query + "'";
    return QueryUtil.query(qo, totalsql, sql, true, jdbcDao);
}

######


public IPageList list_aqkc(QueryObject qo, String query, String month, String state) {
    String sql = "execute list_aqkc '" + query + "','" + month + "','" + state + "','" + qo.getOrderBy() + "','" + qo.getOrderType() + "'";
    String totalsql = "select count(FItemID) from t_ICItem where 1=1 and FSecInv<>0  and FDeleted=0";
    return QueryUtil.query(qo, totalsql, sql, true, jdbcDao);
}

######


public List chart_aqkc(String FItemID, String begin, String end) {
    String sql = "execute chart_aqkc '" + FItemID + "','" + begin + "','" + end + "'";
    return kingdeeDao.queryForList(sql);
}

######


public List chart_column_xsck(String begin, String end, String wldm, String wldw) {
    String sql = "execute chart_column_xsck '" + begin + "','" + end + "','" + wldm + "','" + wldw + "'";
    return kingdeeDao.queryForList(sql);
}

######


public List chart_pie_xsck(String begin, String end, String huizong) {
    String sql = "execute chart_pie_xsck '" + begin + "','" + end + "'," + huizong + "";
    return kingdeeDao.queryForList(sql);
}

######


public List print_coc(String FBillNo) {
    String sql = "execute print_coc '" + FBillNo + "'";
    return kingdeeDao.queryForList(sql);
}

######


public List print_coc_scrw(String FBillNo) {
    String sql = "execute print_coc_scrw '" + FBillNo + "'";
    return kingdeeDao.queryForList(sql);
}

######


public List print_coc_lzk(String FBillNo) {
    String sql = "execute print_coc_lzk '" + FBillNo + "'";
    return kingdeeDao.queryForList(sql);
}

######


public List print_coc_wldm(String wldm) {
    String sql = "execute print_coc_wldm '" + wldm + "'";
    return kingdeeDao.queryForList(sql);
}

######


public List print_bom(String FBillNo) {
    String sql = "execute print_bom '" + FBillNo + "'";
    return kingdeeDao.queryForList(sql);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButton4ActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jPanel12 = new javax.swing.JPanel();
    jLabel2 = new javax.swing.JLabel();
    jTextYazarAdi = new javax.swing.JTextField();
    jTextYazarSoyad = new javax.swing.JTextField();
    jLabel3 = new javax.swing.JLabel();
    jTextKitapAdi = new javax.swing.JTextField();
    jLabel4 = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    jTextYayinEvi = new javax.swing.JTextField();
    jButton4 = new javax.swing.JButton();
    jComboBox1 = new javax.swing.JComboBox<>();
    jLabel6 = new javax.swing.JLabel();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    jLabel2.setText("yazar Adi");
    jLabel3.setText("yazar soyadı");
    jLabel4.setText("kitap adi");
    jLabel5.setText("yayın evı");
    jButton4.setText("ekle");
    jButton4.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButton4ActionPerformed(evt);
        }
    });
    jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Hikaye", "Roman", "Ansiklopedi", "Ders Kitabı", "Diger" }));
    jLabel6.setText("kitap türü");
    javax.swing.GroupLayout jPanel12Layout = new javax.swing.GroupLayout(jPanel12);
    jPanel12.setLayout(jPanel12Layout);
    jPanel12Layout.setHorizontalGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel12Layout.createSequentialGroup().addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel12Layout.createSequentialGroup().addGap(34, 34, 34).addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false).addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel12Layout.createSequentialGroup().addComponent(jLabel3).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(jTextYazarSoyad, javax.swing.GroupLayout.PREFERRED_SIZE, 331, javax.swing.GroupLayout.PREFERRED_SIZE)).addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel12Layout.createSequentialGroup().addComponent(jLabel2).addGap(59, 59, 59).addComponent(jTextYazarAdi, javax.swing.GroupLayout.PREFERRED_SIZE, 331, javax.swing.GroupLayout.PREFERRED_SIZE)))).addGroup(jPanel12Layout.createSequentialGroup().addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel12Layout.createSequentialGroup().addContainerGap().addComponent(jLabel6)).addGroup(jPanel12Layout.createSequentialGroup().addGap(34, 34, 34).addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel5).addComponent(jLabel4)))).addGap(62, 62, 62).addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jTextKitapAdi, javax.swing.GroupLayout.PREFERRED_SIZE, 331, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addGroup(jPanel12Layout.createSequentialGroup().addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(jButton4, javax.swing.GroupLayout.PREFERRED_SIZE, 81, javax.swing.GroupLayout.PREFERRED_SIZE)).addComponent(jTextYayinEvi, javax.swing.GroupLayout.PREFERRED_SIZE, 331, javax.swing.GroupLayout.PREFERRED_SIZE))))).addContainerGap(57, Short.MAX_VALUE)));
    jPanel12Layout.setVerticalGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel12Layout.createSequentialGroup().addGap(20, 20, 20).addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel2).addComponent(jTextYazarAdi, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(20, 20, 20).addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel3).addComponent(jTextYazarSoyad, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(20, 20, 20).addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel4).addComponent(jTextKitapAdi, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(20, 20, 20).addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel5).addComponent(jTextYayinEvi, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 19, Short.MAX_VALUE).addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel6).addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jButton4, javax.swing.GroupLayout.DEFAULT_SIZE, 33, Short.MAX_VALUE)).addGap(12, 12, 12)));
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 547, Short.MAX_VALUE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(jPanel12, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 360, Short.MAX_VALUE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(39, 39, 39).addComponent(jPanel12, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(97, Short.MAX_VALUE))));
    pack();
}

######


public void kitapEkle() {
    boolean kontrol = true;
    String hata = "";
    HataAyiklama hk = new HataAyiklama();
    String yazarAdi = jTextYazarAdi.getText();
    if (!hk.bosMu(yazarAdi)) {
        kontrol = false;
        hata += "Ofis Adı boş bırakılamaz \n";
    }
    String yazarSoyad = jTextYazarSoyad.getText();
    if (!hk.bosMu(yazarSoyad)) {
        kontrol = false;
        hata += "Ofis Adı boş bırakılamaz \n";
    }
    String kitapAdi = jTextKitapAdi.getText();
    if (!hk.bosMu(kitapAdi)) {
        kontrol = false;
        hata += "Ofis Adı boş bırakılamaz \n";
    }
    String yayinEvi = jTextYayinEvi.getText();
    if (!hk.bosMu(yayinEvi)) {
        kontrol = false;
        hata += "Ofis Adı boş bırakılamaz \n";
    }
    String kitapTur = (String) jComboBox1.getSelectedItem();
    if (!hk.bosMu(yayinEvi)) {
        kontrol = false;
        hata += "Ofis Adı boş bırakılamaz \n";
    }
    if (kontrol) {
        DB db = new DB();
        String query = "INSERT INTO kitaplar VALUES (null, '" + kitapAdi + "', '" + yazarAdi + "','" + yazarSoyad + "','" + yayinEvi + "','" + kitapTur + "')";
        try {
            int ekle = db.baglan().executeUpdate(query);
            if (ekle > 0) {
                JOptionPane.showMessageDialog(this, "Ekleme işlemi başarılı");
            }
        } catch (SQLException ex) {
            Logger.getLogger(KitapKayit.class.getName()).log(Level.SEVERE, null, ex);
        }
    } else {
        JOptionPane.showMessageDialog(this, hata);
    }
}

######


private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {
    kitapEkle();
    jTextKitapAdi.setText("");
    jTextYayinEvi.setText("");
    jTextYazarSoyad.setText("");
    jTextYazarAdi.setText("");
}

######


public void run() {
    new KitapKayit().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(KitapKayit.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(KitapKayit.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(KitapKayit.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(KitapKayit.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new KitapKayit().setVisible(true);
        }
    });
}

######


public boolean GirisKontrol(UyelerProperti kul) {
    String query = "select count(*) as eslesme from uyeler where " + UyelerEnum.kulAdi + "='" + kul.getKulAdi() + "' " + "and " + UyelerEnum.sifre + "='" + kul.getSifre() + "'";
    try {
        ResultSet rs = db.baglan().executeQuery(query);
        System.out.println(query);
        System.out.println(rs.getString("eslesme"));
        if (Integer.valueOf(rs.getString("eslesme")) > 0) {
            return true;
        } else {
            return false;
        }
    } catch (Exception e) {
    }
    return false;
}

######


private Connection getConnection() {
    try {
        Class.forName(this.mysqlDataSourceProperties.getDriverClassName());
    } catch (ClassNotFoundException e) {
        log.error(StringUtil.getTrace(e));
    }
    Connection conn = null;
    try {
        conn = DriverManager.getConnection(this.mysqlDataSourceProperties.getUrl(), this.mysqlDataSourceProperties.getUsername(), this.mysqlDataSourceProperties.getPassword());
    } catch (SQLException e) {
        log.error(StringUtil.getTrace(e));
    }
    return conn;
}

######


public ResponseVO executeQuery(String username, int pageNo, int pageSize) {
    Connection conn = getConnection();
    PreparedStatement stat = null;
    ResultSet rs = null;
    int count = 0;
    try {
        conn.setAutoCommit(false);
        String sql_sum = "select count(*) from sqlstable where username = ? order by createtime desc limit 100";
        stat = conn.prepareStatement(sql_sum);
        stat.setString(1, username);
        rs = stat.executeQuery();
        while (rs.next()) {
            count = rs.getInt(1);
        }
        List<String> count_list = new ArrayList<>();
        count_list.add(String.valueOf(count));
        conn.commit();
        rs.close();
        stat.close();
        int start = (pageNo - 1) * pageSize;
        if (pageNo > 10) {
            return ResponseVO.builder().success(false).errorMsg("没有更多数据").build();
        }
        String sql = "select * from sqlstable where username = ? order by createtime desc limit ?,?";
        stat = (PreparedStatement) conn.prepareStatement(sql);
        stat.setString(1, username);
        stat.setInt(2, start);
        stat.setInt(3, pageSize);
        rs = stat.executeQuery();
        ResultSetMetaData md = rs.getMetaData();
        int columnCount = md.getColumnCount();
        List<String> columns = new ArrayList<>();
        for (int i = 1; i <= columnCount; i++) {
            columns.add(md.getColumnLabel(i));
        }
        List<Map<String, Object>> result = new ArrayList<Map<String, Object>>();
        Map<String, Object> rowData = null;
        int batchNum = 0;
        while (rs.next()) {
            rowData = new LinkedHashMap<>(columnCount);
            for (String column : columns) {
                rowData.put(column, rs.getObject(column));
            }
            result.add(rowData);
            batchNum++;
        }
        conn.commit();
        log.info("get latestsqls ResultSet'size " + batchNum);
        return ResponseVO.builder().columns(count_list).data(result).success(true).errorMsg("").build();
    } catch (SQLException e) {
        log.error(StringUtil.getTrace(e));
        return ResponseVO.builder().success(false).errorMsg(StringUtil.getTrace(e)).build();
    } finally {
        DBConnection.close(rs, stat, conn);
    }
}

######


public ResponseVO insert(RequestVO requestVO) {
    Connection conn = getConnection();
    PreparedStatement stat = null;
    String sql = "insert into sqlstable (username,createtime,dbEngine,sqlStr) values (?,?,?,?) ";
    try {
        java.util.Date nowdate = new java.util.Date();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String format = sdf.format(nowdate);
        Long t = sdf.parse(format).getTime();
        stat = conn.prepareStatement(sql);
        stat.setString(1, requestVO.getUsername());
        stat.setString(2, format);
        stat.setString(3, requestVO.getDbEngine());
        stat.setString(4, requestVO.getSql());
        int res = stat.executeUpdate();
        if (res == 0) {
            return ResponseVO.builder().columns(null).data(null).success(false).errorMsg("insert error sql is " + requestVO.getSql()).build();
        }
    } catch (Exception e) {
        log.error(StringUtil.getTrace(e));
        return ResponseVO.builder().success(false).errorMsg(StringUtil.getTrace(e)).build();
    } finally {
        DBConnection.close(stat, conn);
    }
    return ResponseVO.builder().columns(null).data(null).success(true).errorMsg("").build();
}

######


private static Lesson resultSetToLesson(ResultSet rs) throws SQLException {
    int id = rs.getInt("id");
    int userID = rs.getInt("userID");
    int courseID = rs.getInt("courseID");
    Date date = rs.getDate("date");
    int slot = rs.getInt("slot");
    String status = rs.getString("status");
    int subjectID = rs.getInt("subjectID");
    int teacherID = rs.getInt("teacherID");
    String subjectName = rs.getString("subjectName");
    String teacherSurname = rs.getString("teacherSurname");
    String teacherName = rs.getString("teacherName");
    return new Lesson(id, userID, courseID, date, slot, status, subjectID, teacherID, subjectName, teacherSurname + " " + teacherName);
}

######


public static boolean book(int subjectID, int teacherID, int userID, String date, int slot) throws SQLException {
    Connection connection = ManagerDAO.connect();
    boolean result = true;
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_insertLesson);
            preparedStatement.setInt(1, userID);
            preparedStatement.setInt(2, teacherID);
            preparedStatement.setInt(3, subjectID);
            preparedStatement.setString(4, date);
            preparedStatement.setInt(5, slot);
            preparedStatement.setString(6, "booked");
            int rows = preparedStatement.executeUpdate();
            if (rows == 0) {
                result = false;
            }
        } catch (SQLException e) {
            String error = e.getMessage();
            System.err.println(error);
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return result;
}

######


public static List<Lesson> getLessonsByUserID(int userID) throws SQLException {
    List<Lesson> lessons = new ArrayList<>();
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_getLessonsByUserID);
            preparedStatement.setInt(1, userID);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                lessons.add(resultSetToLesson(resultSet));
            }
        } catch (SQLException e) {
            e.getMessage();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return lessons;
}

######


public static boolean delete(int lessonID) throws SQLException {
    Connection connection = ManagerDAO.connect();
    boolean success = true;
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_deleteLesson);
            preparedStatement.setInt(1, lessonID);
            int resultSet = preparedStatement.executeUpdate();
            if (resultSet == 0) {
                success = false;
            }
        } catch (SQLException e) {
            e.getMessage();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return success;
}

######


public static Lesson getLessonsByLessonID(int lessonID) throws SQLException {
    Lesson lesson = null;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_getLessonsByLessonID);
            preparedStatement.setInt(1, lessonID);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                lesson = resultSetToLesson(resultSet);
            }
        } catch (SQLException e) {
            e.getMessage();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return lesson;
}

######


public static List<Lesson> getLessonsAll() throws SQLException {
    List<Lesson> lessons = new ArrayList<>();
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_getLessonsAll);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                lessons.add(resultSetToLesson(resultSet));
            }
        } catch (SQLException e) {
            e.getMessage();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return lessons;
}

######


public static void deleteLessonByCourse(int id) throws SQLException {
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_deleteLessonByCourse);
            preparedStatement.setInt(1, id);
            preparedStatement.executeUpdate();
        } catch (SQLException e) {
            e.getMessage();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
}

######


@Override
public Libro doRetriveById(Object... id) {
    String titolo = (String) id[0];
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveByTitolo);
        prst.setString(1, titolo);
        try {
            ResultSet rs = prst.executeQuery();
            con.commit();
            Libro book = null;
            if (rs.next()) {
                book = new Libro(rs.getString("Genere"), rs.getString("Tipo"), rs.getString("CodVolume"), titolo, rs.getInt("Edizione"), rs.getString("DataPubblicazione"), rs.getInt("DurataMaxPrestito"), rs.getString("Lingua"), rs.getString("DenominazioneEditore"), rs.getString("CittaEditore"));
                String isbn = rs.getString("CodVolume");
                book.setAutori(new AutoreDAO().doRetriveByLibro(isbn));
                book.setCollana(new CollanaDAO().doRetriveById(isbn));
                book.setCopie(new CopiaDAO().doRetriveAll());
            }
            rs.close();
            return book;
        } catch (SQLException e) {
            con.rollback();
            return null;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
        return null;
    }
}

######


@Override
public int doInsert(Libro libro) {
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doInsertQuery, PreparedStatement.RETURN_GENERATED_KEYS);
        prst.setString(1, libro.getCodice());
        prst.setString(2, libro.getGenere());
        prst.setString(3, libro.getTipo());
        try {
            prst.execute();
            con.commit();
            ResultSet rs = prst.getGeneratedKeys();
            return 1;
        } catch (SQLException e) {
            con.rollback();
            e.printStackTrace();
            return -1;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException e) {
        return -1;
    }
}

######


@Override
public int doUpdate(Libro entity) {
    throw new UnsupportedOperationException("Not supported yet.");
}

######


@Override
public List<Libro> doRetriveAll() {
    List<Libro> libri = new ArrayList<>();
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveAllWithPosition);
        try {
            ResultSet rs = prst.executeQuery();
            while (rs.next()) {
                Libro book = new Libro(rs.getString("genere"), rs.getString("tipo"), rs.getString("Codice"), rs.getString("Titolo"), rs.getInt("Edizione"), rs.getString("DataPubblicazione"), rs.getInt("DurataMaxPrestito"), rs.getString("Lingua"), rs.getString("DenominazioneEditore"), rs.getString("CittaEditore"));
                String isbn = rs.getString("Codice");
                book.setAutori(new AutoreDAO().doRetriveByLibro(isbn));
                book.setCollana(new CollanaDAO().doRetriveById(isbn));
                book.setCopie(new CopiaDAO().doRetriveAllById(isbn));
                libri.add(book);
            }
            rs.close();
        } catch (SQLException e) {
            con.rollback();
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
    }
    return libri;
}

######


@SqlUpdate("create table likes (idCible integer, idUtilisateur integer, typeCible varchar(10), aime boolean)")
public void createLikeTable();

######


@SqlUpdate("insert into likes (idCible, idUtilisateur, typeCible, aime) values (:idCible, :idUtilisateur, :typeCible, :aime)")
@GetGeneratedKeys
public int insert(@BindBean Like l);

######


@SqlUpdate("update likes set idCible = :idCible, idUtilisateur = :idUtilisateur, aime = :aime")
public void update(@BindBean Like l);

######


@SqlQuery("select count(*) from likes where idCible = :idCible and typeCible = :typeCible")
public int nbVues(@Bind("idCible") int idCible, @Bind("typeCible") String typeCible);

######


@SqlQuery("select count(*) from likes where idCible = :idCible and typeCible=:typeCible and aime = 1")
public int nbLikes(@Bind("idCible") int idCible, @Bind("typeCible") String typeCible);

######


@SqlQuery("select count(*) from likes where idCible = :idCible and typeCible=:typeCible and aime = 0")
public int nbDislikes(@Bind("idCible") int idCible, @Bind("typeCible") String typeCible);

######


@SqlQuery("select * from likes where idUtilisateur = :idUtilisateur and aime = :aime")
@RegisterMapperFactory(BeanMapperFactory.class)
public List<Like> findByUtilisateur(@Bind("idUtilisateur") int idUtilisateur, @Bind("aime") boolean aime);

######


@SqlUpdate("delete from likes where idCible = :idCible and idUtilisateur = :idUtilisateur")
public int deleteLike(@Bind("idUtilisateur") int idUtilisateur, @Bind("idCible") int idCible);

######


@SqlUpdate("drop table if exists likes")
public void dropLikeTable();

######


public void close();

######


public String toJson() {
    return new JSONSerializer().exclude("*.class").serialize(this);
}

######


public static LoanShark fromJsonToLoanShark(String json) {
    return new JSONDeserializer<LoanShark>().use(null, LoanShark.class).deserialize(json);
}

######


public static String toJsonArray(Collection<LoanShark> collection) {
    return new JSONSerializer().exclude("*.class").serialize(collection);
}

######


public static Collection<LoanShark> fromJsonArrayToLoanSharks(String json) {
    return new JSONDeserializer<List<LoanShark>>().use(null, ArrayList.class).use("values", LoanShark.class).deserialize(json);
}

######


public Long getId() {
    return this.id;
}

######


public void setId(Long id) {
    this.id = id;
}

######


public Integer getVersion() {
    return this.version;
}

######


public void setVersion(Integer version) {
    this.version = version;
}

######


@Transactional
public void persist() {
    if (this.entityManager == null) {
        this.entityManager = entityManager();
    }
    this.entityManager.persist(this);
}

######


@Transactional
public void remove() {
    if (this.entityManager == null) {
        this.entityManager = entityManager();
    }
    if (this.entityManager.contains(this)) {
        this.entityManager.remove(this);
    } else {
        LoanShark attached = this.entityManager.find(this.getClass(), this.id);
        this.entityManager.remove(attached);
    }
}

######


@Transactional
public void flush() {
    if (this.entityManager == null) {
        this.entityManager = entityManager();
    }
    this.entityManager.flush();
}

######


@Transactional
public LoanShark merge() {
    if (this.entityManager == null) {
        this.entityManager = entityManager();
    }
    LoanShark merged = this.entityManager.merge(this);
    this.entityManager.flush();
    return merged;
}

######


public static final EntityManager entityManager() {
    EntityManager em = new LoanShark().entityManager;
    if (em == null) {
        throw new IllegalStateException("Entity manager has not been injected (is the Spring Aspects JAR configured as an AJC/AJDT aspects library?)");
    }
    return em;
}

######


public static long countLoanSharks() {
    return ((Number) entityManager().createQuery("select count(o) from LoanShark o").getSingleResult()).longValue();
}

######


@SuppressWarnings("unchecked")
public static List<LoanShark> findAllLoanSharks() {
    return entityManager().createQuery("select o from LoanShark o").getResultList();
}

######


public static LoanShark findLoanShark(Long id) {
    if (id == null)
        return null;
    return entityManager().find(LoanShark.class, id);
}

######


@SuppressWarnings("unchecked")
public static List<LoanShark> findLoanSharkEntries(int firstResult, int maxResults) {
    return entityManager().createQuery("select o from LoanShark o").setFirstResult(firstResult).setMaxResults(maxResults).getResultList();
}

######


public String getName() {
    return this.name;
}

######


public void setName(String name) {
    this.name = name;
}

######


public Long getCounter() {
    return this.counter;
}

######


public void setCounter(Long counter) {
    this.counter = counter;
}

######


public Double getAverageRate() {
    return this.averageRate;
}

######


public void setAverageRate(Double averageRate) {
    this.averageRate = averageRate;
}

######


public static Query findLoanSharksByName(String name) {
    if (name == null || name.length() == 0) {
        throw new IllegalArgumentException("The name argument is required");
    }
    EntityManager em = LoanShark.entityManager();
    Query q = em.createQuery("SELECT LoanShark FROM LoanShark AS loanshark WHERE loanshark.name = :name");
    q.setParameter("name", name);
    return q;
}

######


public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("Id: ").append(getId()).append(", ");
    sb.append("Version: ").append(getVersion()).append(", ");
    sb.append("Name: ").append(getName()).append(", ");
    sb.append("Counter: ").append(getCounter()).append(", ");
    sb.append("AverageRate: ").append(getAverageRate());
    return sb.toString();
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType("text/html");
    int empid = Integer.parseInt(request.getParameter("empid"));
    int empty = 0;
    try {
        empty = Integer.parseInt(request.getParameter("empty"));
    } catch (NumberFormatException e) {
    }
    if (empty == 1) {
        try {
            HttpSession session = request.getSession();
            calculateBasic(session, request, response);
        } catch (SQLException e) {
            e.printStackTrace();
            if (empid == 11) {
                RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
                ReqDis.forward(request, response);
            } else {
                RequestDispatcher ReqDis = request.getRequestDispatcher("error.jsp");
                ReqDis.forward(request, response);
            }
        }
    } else {
        try {
            HttpSession session = request.getSession();
            NearbyLocations(request, session, response);
        } catch (Exception e) {
            e.printStackTrace();
            if (empid == 11) {
                RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
                ReqDis.forward(request, response);
            } else {
                RequestDispatcher ReqDis = request.getRequestDispatcher("error.jsp");
                ReqDis.forward(request, response);
            }
        }
    }
}

######


@SuppressWarnings({ "null", "unused" })
private void NearbyLocations(HttpServletRequest request, HttpSession session, HttpServletResponse response) throws ServletException, IOException, SQLException {
    float distance = Float.parseFloat(request.getParameter("distance"));
    int empid = Integer.parseInt(request.getParameter("empid"));
    String truckType = request.getParameter("Capacity");
    String type = request.getParameter("good");
    String start = request.getParameter("start");
    String end = request.getParameter("end");
    session.setAttribute("start", start);
    session.setAttribute("end", end);
    double lat = Double.parseDouble(request.getParameter("lat"));
    double lon = Double.parseDouble(request.getParameter("long"));
    double lat1 = 0, lon1 = 0;
    String origin = null;
    Connection con = Connect.getconnection();
    PreparedStatement ps = con.prepareStatement("SELECT * FROM mckc.autoparam WHERE `typeofgood`= ? order by lat");
    ps.setString(1, truckType);
    ResultSet rs = ps.executeQuery();
    while (rs.next()) {
        lat1 = rs.getDouble("lat");
        lon1 = rs.getDouble("long");
        float dist = calculateDistance(lat, lon, lat1, lon1);
        PreparedStatement ps1 = con.prepareStatement("UPDATE mckc.autoparam SET `distance`=? WHERE `typeofgood`=? And `lat`=? And `long`=?");
        ps1.setFloat(1, dist);
        ps1.setString(2, truckType);
        ps1.setDouble(3, lat1);
        ps1.setDouble(4, lon1);
        ps1.executeUpdate();
    }
    float dista = 0;
    PreparedStatement ps2 = con.prepareStatement("SELECT * FROM mckc.autoparam a, priorityslab p WHERE p.Pirority=a.Pirority and a.typeofgood=? order by distance ASC,`Volume Rating` Desc,a.Pirority ASC");
    ps2.setString(1, truckType);
    ResultSet rset = ps2.executeQuery();
    while (rset.next()) {
        if (rset.getInt("a.Pirority") == 1 && rset.getInt("a.Volume Rating") == 3) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 2 && rset.getInt("a.Volume Rating") == 3) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 3 && rset.getInt("a.Volume Rating") == 3) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 1 && rset.getInt("a.Volume Rating") == 2) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 2 && rset.getInt("a.Volume Rating") == 2) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 3 && rset.getInt("a.Volume Rating") == 2) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 1 && rset.getInt("a.Volume Rating") == 1) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 2 && rset.getInt("a.Volume Rating") == 1) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 3 && rset.getInt("a.Volume Rating") == 1) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 1) {
            origin = rset.getString("Origin");
            dista = rset.getFloat("distance");
            break;
        }
    }
    PreparedStatement ps0 = con.prepareStatement("SELECT DistanceFactor FROM mckc.Distance_Factor WHERE `long0`< ? and `long2` > ? and `lat2`< ? and `lat0`> ?");
    ps0.setDouble(1, lon);
    ps0.setDouble(2, lon);
    ps0.setDouble(3, lat);
    ps0.setDouble(4, lat);
    ResultSet rs0 = ps0.executeQuery();
    float DistFact = 0;
    while (rs0.next()) {
        DistFact = (float) (rs0.getDouble("DistanceFactor") / 100);
    }
    dista = (float) Math.max(distance * DistFact, dista);
    session.setAttribute("distance", distance + dista);
    session.setAttribute("backstart", origin);
    RequestDispatcher ReqDis = request.getRequestDispatcher("Auto");
    ReqDis.forward(request, response);
}

######


@SuppressWarnings("unused")
private float calculateDistance(double lat, double lon, double lat0, double lon0) {
    float lat1 = (float) lat;
    float lon1 = (float) lon;
    float lat2 = (float) lat0;
    float lon2 = (float) lon0;
    float radlat1 = (float) (Math.PI * lat1 / 180);
    float radlat2 = (float) (Math.PI * lat2 / 180);
    float radlon1 = (float) (Math.PI * lon1 / 180);
    float radlon2 = (float) (Math.PI * lon2 / 180);
    float theta = lon1 - lon2;
    float radtheta = (float) (Math.PI * theta / 180);
    float dist = (float) (Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta));
    dist = (float) Math.acos(dist);
    dist = (float) (dist * 180 / Math.PI);
    dist = (float) (dist * 60 * 1.1515 * 1.609344);
    return dist;
}

######


private void calculateBasic(HttpSession session, HttpServletRequest request, HttpServletResponse response) throws SQLException, ServletException, IOException {
    PrintWriter out = response.getWriter();
    DecimalFormat df = new DecimalFormat("#.##");
    float distance = Float.parseFloat(request.getParameter("distance"));
    int empid = Integer.parseInt(request.getParameter("empid"));
    String truckType = request.getParameter("Capacity");
    String param = request.getParameter("param");
    float backhaul = 0;
    String start = org.apache.commons.lang3.StringUtils.capitalize(request.getParameter("start"));
    String end = org.apache.commons.lang3.StringUtils.capitalize(request.getParameter("end"));
    session.setAttribute("start", start);
    session.setAttribute("end", end);
    session.setAttribute("distance", distance);
    session.setAttribute("cap", truckType);
    session.setAttribute("param", param);
    session.setAttribute("back", backhaul);
    float intrest1 = 0, costOfTyre = 0, costOfTruck = 0, loan = 0, noOfYears = 0, residualValue = 0, noOfTyre = 0, costOfTyreUsed = 0, tyreLife = 0, tyreLifeUsed = 0, mileage = 0, noTrips = 0;
    float mileageWithLoad = 0, diesel = 0, roi = 0;
    int cap = 0;
    Connection con = Connect.getconnection();
    PreparedStatement ps = con.prepareStatement("select * from truckparam where typeofgood=?");
    ps.setString(1, truckType);
    ResultSet rs = ps.executeQuery();
    while (rs.next()) {
        costOfTruck = rs.getFloat("costoftruck");
        loan = rs.getFloat("loanpercentage");
        intrest1 = rs.getFloat("rateofintrest");
        roi = rs.getFloat("flatroi");
        costOfTyre = rs.getFloat("tyrecost");
        noOfYears = rs.getFloat("yearsemi");
        residualValue = rs.getFloat("residualvalueoftruck");
        noOfTyre = rs.getFloat("tyres");
        costOfTyreUsed = rs.getFloat("reusedtyrecost");
        tyreLife = rs.getFloat("tyrelife");
        tyreLifeUsed = rs.getFloat("reusedtyrelife");
        mileage = rs.getFloat("dieselmileage");
        mileageWithLoad = rs.getFloat("diesealmileagewithload");
        diesel = rs.getFloat("dieselcost");
        cap = rs.getInt("capacity");
    }
    PreparedStatement ps0 = con.prepareStatement("select `NoofTrip` from `slabtable` WHERE `Min Distance` <= ? AND `Max Distance` >?");
    ps0.setInt(1, (int) distance);
    ps0.setInt(2, (int) distance);
    ResultSet rs0 = ps0.executeQuery();
    while (rs0.next()) {
        noTrips = rs0.getFloat("NoofTrip");
    }
    float cost = calculateTyreCostPerKM(noOfTyre, costOfTyre, costOfTyreUsed, tyreLife, tyreLifeUsed);
    float loanamount = calculateLoanAmount(loan, costOfTruck);
    float paid = calculatePaid(costOfTruck, loanamount);
    float residualValueTruck = calulateResidualValueOfTruck(residualValue, costOfTruck);
    float depreciation = calculateDepreciation(costOfTruck, residualValueTruck, noOfYears);
    float interestcost = calculateInterestCostPerMonth(roi, loanamount);
    float netMileage = calculateNetMilage(mileageWithLoad, backhaul, mileage);
    float roundtrip = calculateRoundTrip(distance);
    float distanceTravled = calculateKmRunPerMonthAvg(roundtrip, noTrips);
    PreparedStatement ps1 = con.prepareStatement("UPDATE truckparam SET loanamount=" + loanamount + ",amountpaid=" + paid + ",kmrunpermonthaverage=" + distanceTravled + ",tyrecostperkm=" + cost + ",roundTrip=" + roundtrip + "WHERE typeofgood=?");
    ps1.setString(1, truckType);
    ps1.executeUpdate();
    float Salary = 0, batta = 0, maintenance = 0, Admin = 0, tarpaulin = 0;
    float expense = 0, totaltoll = 0, insurancepercent = 0, permit = 0, tax = 0;
    float maintenancePerKm = 0, loading = 0;
    float pro = 0;
    PreparedStatement ps2 = con.prepareStatement("select * from routeparam where typeofgood=?");
    ps2.setString(1, truckType);
    ResultSet rs1 = ps2.executeQuery();
    while (rs1.next()) {
        expense = rs1.getFloat("routeexpenses");
        totaltoll = rs1.getFloat("toll");
        insurancepercent = rs1.getFloat("insuranceaspercentageofvechiclecost");
        permit = rs1.getFloat("roadpermityear");
        tax = rs1.getFloat("roadtaxyear");
        Salary = rs1.getFloat("driver/cleaner salary");
        batta = rs1.getFloat("driver/cleaner bhatta");
        maintenance = rs1.getFloat("maintenancepermonth");
        Admin = rs1.getFloat("admin costs");
        maintenancePerKm = rs1.getFloat("maintenancecostperkm");
        tarpaulin = rs1.getFloat("tarpaulin");
        loading = rs1.getFloat("loadingcharges");
        pro = rs1.getInt("profitmargin");
    }
    float toll = calculateTollPerKm(totaltoll, distance);
    float unloading = calculateUnloadingCharges(cap);
    float unloadingloading = unloading + loading;
    float dieselCost = calculateDieselCostPerKm(diesel, netMileage);
    float variableCost = calculateVaribleCostperKm(dieselCost, toll, cost, maintenancePerKm, expense);
    float variable = calculateVaribleCostperMonth(variableCost, distanceTravled, unloadingloading);
    float insuranceMonth = calculateInsurancePerMonth(costOfTruck, insurancepercent);
    float roadPermit = calculateRoadPermitPerMonth(permit);
    float roadTax = calculateRoadTaxPerMonth(tax);
    float fixedcostperMonth = calculatefixedCostPerMonth(roadTax, roadPermit, insuranceMonth, Salary, batta, maintenance, Admin, tarpaulin, depreciation, interestcost);
    float monthlyoperating = calculateMonthlyOperatingCost(fixedcostperMonth, variable);
    float profit = calculateProfitMargin(fixedcostperMonth, pro);
    double perKmCost = calculatePerKmCost(profit, monthlyoperating, distanceTravled);
    float monthlyTon = calculateMonthlyTons(cap, backhaul, noTrips);
    float fixedPTPK = calculateFixedPTPK(fixedcostperMonth, roundtrip, cap, noTrips, backhaul);
    float variablePTPK = calculateVariablePTPK(variable, roundtrip, cap, noTrips, backhaul);
    float profitPTPK = calculateProfitPTPK(profit, roundtrip, cap, noTrips, backhaul);
    float totalPTPK = calculateTotalPTPK(profitPTPK, variablePTPK, fixedPTPK);
    float freightPerTon = calculateFreightPerTon(totalPTPK, distance);
    float emi = 0;
    float cashInflow = 0;
    float cashFlowPerMonth = 0;
    float irr = 0;
    float workingCapital = 0;
    session.setAttribute("fixedptpk", fixedPTPK);
    session.setAttribute("variableptpk", variablePTPK);
    session.setAttribute("profitptpk", profitPTPK);
    session.setAttribute("ptpk", totalPTPK);
    session.setAttribute("freightPerTon", freightPerTon);
    PreparedStatement ps3 = con.prepareStatement("UPDATE routeparam SET backhaul='" + backhaul + "',distance='" + distance + "',unloadingchages='" + unloading + "',loadingunloadingcharges='" + unloadingloading + "',variblecostperkm='" + variableCost + "',variblecostpermonth='" + variable + "',insurancepermonth='" + insuranceMonth + "',workingcapitalinterestcost='" + workingCapital + "',roadpermitmonth='" + roadPermit + "',roadtaxmonth='" + roadTax + "',monthlyoperatingcost='" + monthlyoperating + "',perkmcost='" + perKmCost + "',monthlytons='" + monthlyTon + "',fixedptpk='" + fixedPTPK + "',variableptpk='" + variablePTPK + "', profitptpk='" + profitPTPK + "', totalptpk='" + totalPTPK + "', freightperton='" + freightPerTon + "' WHERE typeofgood=?");
    PreparedStatement ps31 = con.prepareStatement("UPDATE routeparam SET origin=? ,destination=? WHERE typeofgood=?");
    ps3.setString(1, truckType);
    ps3.executeUpdate();
    ps31.setString(1, start);
    ps31.setString(2, end);
    ps31.setString(3, truckType);
    ps31.executeUpdate();
    float costs = cap * distance * totalPTPK;
    session.setAttribute("cost", costs);
    session.setAttribute("profitkm", df.format(profit / distanceTravled));
    session.setAttribute("variablekm", variableCost);
    session.setAttribute("fixedkm", df.format((fixedcostperMonth + profit) / distanceTravled));
    session.setAttribute("variableton", df.format(variable / monthlyTon));
    session.setAttribute("profitton", df.format(profit / monthlyTon));
    session.setAttribute("fixedton", df.format((fixedcostperMonth + profit) / monthlyTon));
    session.setAttribute("dep", df.format(depreciation));
    session.setAttribute("intres", df.format(interestcost));
    session.setAttribute("salr", df.format(Salary));
    session.setAttribute("insu", df.format(insuranceMonth));
    session.setAttribute("rota", df.format(roadTax));
    session.setAttribute("dies", df.format(dieselCost));
    session.setAttribute("tole", df.format(totaltoll));
    session.setAttribute("tyres", df.format(cost));
    session.setAttribute("routes", df.format(expense));
    session.setAttribute("maint", df.format(maintenancePerKm));
    if (empid == 11) {
        RequestDispatcher ReqDis = request.getRequestDispatcher("AdminResultBasic_1.jsp");
        ReqDis.forward(request, response);
    } else {
        RequestDispatcher ReqDis = request.getRequestDispatcher("ResultBasic_1.jsp");
        ReqDis.forward(request, response);
    }
}

######


private float calculateProfitMargin(float fixedcostperMonth, float pro) {
    return (fixedcostperMonth * pro) / 100;
}

######


private float calculateProfit(float monthlyoperating) {
    return (float) ((0.0752688172043011) * monthlyoperating);
}

######


private float calculateKmRunPerMonthAvg(float roundtrip, float noTrips) {
    return (roundtrip * noTrips);
}

######


private float calculateVaribleCostperMonth(float variableCost, float distanceTravled, float unloadingloading) {
    return ((variableCost * distanceTravled) + unloadingloading);
}

######


private float calculateTotalPTPK(float profitPTPK, float variablePTPK, float fixedPTPK) {
    return (profitPTPK + variablePTPK + fixedPTPK);
}

######


private float calculateProfitPTPK(float profit, float roundtrip, int cap, float noTrips, float backhaul) {
    return (profit / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateVariablePTPK(float variable, float roundtrip, int cap, float noTrips, float backhaul) {
    return (variable / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateFixedPTPK(float fixedcostperMonth, float roundtrip, int cap, float noTrips, float backhaul) {
    return (fixedcostperMonth / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateFreightPerTon(float totalPTPK, float distance) {
    return (totalPTPK * distance);
}

######


private float calculateRoundTrip(float distance) {
    return (distance * 2);
}

######


private float calculateTotalCostPerTon(float totalPTPK, float distance, int cap) {
    return (totalPTPK * distance * cap);
}

######


private float calculateMonthlyTons(int cap, float backhaul, float noTrips) {
    return (noTrips * cap * (1 + (backhaul / 100)));
}

######


private float calculatePerKmCost(float profitMargin, float monthlyoperating, float distanceTravled) {
    return ((profitMargin + monthlyoperating) / distanceTravled);
}

######


private float calculateMonthlyOperatingCost(float fixedcostperMonth, float variable) {
    return (fixedcostperMonth + variable);
}

######


private float calculatefixedCostPerMonth(float roadTax, float roadPermit, float insuranceMonth, float salary, float batta, float maintenance, float admin, float tarpaulin, float depreciation, float interestcost) {
    return (admin + batta + insuranceMonth + maintenance + roadPermit + roadTax + salary + tarpaulin + depreciation + interestcost);
}

######


private float calculateRoadTaxPerMonth(float tax) {
    return (tax / 12);
}

######


private float calculateRoadPermitPerMonth(float permit) {
    return (permit / 12);
}

######


private float calculateInsurancePerMonth(float costOfTruck, float insurancepercent) {
    return ((costOfTruck * insurancepercent) / 1200);
}

######


private float calculateVaribleCostperKm(float dieselCost, float toll, float cost, float maintenancePerKm, float route) {
    return (dieselCost + toll + cost + maintenancePerKm + route);
}

######


private float calculateRouteExpence(float expense, float distance) {
    return (expense / distance);
}

######


private float calculateUnloadingCharges(int cap) {
    return (45 * cap);
}

######


private float calculateDieselCostPerKm(float diesel, float netMileage) {
    return (diesel / netMileage);
}

######


private float calculateNetMilage(float mileageWithLoad, float backhaul, float mileage) {
    return (((mileageWithLoad * 100 + (mileageWithLoad * backhaul)) + (mileage) * (100 - backhaul)) / 200);
}

######


private float calculateTollPerKm(float totaltoll, float distance) {
    return (totaltoll / distance);
}

######


private float calulateResidualValueOfTruck(float residualValue, float costOfTruck) {
    return (costOfTruck * residualValue / 100);
}

######


private float calculateInterestCostPerMonth(float roi, float loanamount) {
    return ((roi * loanamount) / 1200);
}

######


private float calculateDepreciation(float costOfTruck, float residualValue, float noOfYears) {
    return (((costOfTruck - residualValue) / noOfYears) / 12);
}

######


private float calculatePaid(float costOfTruck, float loanamount) {
    return (costOfTruck - loanamount);
}

######


private float calculateLoanAmount(float loan, float costOfTruck) {
    return ((costOfTruck * loan) / 100);
}

######


private float calculateTyreCostPerKM(float noOfTyre, float costOfTyre, float costOfTyreUsed, float tyreLife, float tyreLifeUsed) {
    return (noOfTyre * (costOfTyre + costOfTyreUsed) / (tyreLife + tyreLifeUsed));
}

######


protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String userid = request.getParameter("userid");
    String pwd = request.getParameter("pwd");
    try {
        Class.forName("com.mysql.jdbc.Driver");
        con = DriverManager.getConnection("jdbc:mysql://localhost:3306/userVerificationdb", "root", "root");
        Statement st = con.createStatement();
        ResultSet rs;
        rs = st.executeQuery("select username from account where username='" + userid + "'");
        if (rs.next()) {
            ResultSet rs2 = st.executeQuery("select password from account where username='" + userid + "'");
            if (rs2.next()) {
                String pwd1 = rs2.getString("password");
                check = Hashing.validatePassword(pwd, pwd1);
            }
            if (check) {
                HttpSession session = request.getSession();
                session.setAttribute("userid", userid);
                session.setMaxInactiveInterval(30 * 60);
                Cookie userName = new Cookie("userid", userid);
                userName.setMaxAge(30 * 60);
                response.addCookie(userName);
                response.sendRedirect("loginsuccess.jsp");
            } else {
                JOptionPane.showMessageDialog(null, "no match");
                response.sendRedirect("InvalidUserNPass.jsp");
            }
        } else {
            JOptionPane.showMessageDialog(null, "no user");
            response.sendRedirect("InvalidUserNPass.jsp");
        }
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (SQLException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (InvalidKeySpecException e) {
        e.printStackTrace();
    } finally {
        try {
            con.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

######


protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String userid = request.getParameter("userid");
    String pwd = request.getParameter("pwd");
    try {
        Class.forName("com.mysql.jdbc.Driver");
        con = DriverManager.getConnection("jdbc:mysql://localhost:3306/userVerificationdb", "root", "root");
        Statement st = con.createStatement();
        ResultSet rs;
        rs = st.executeQuery("select username from account where username='" + userid + "'");
        if (rs.next()) {
            ResultSet rs2 = st.executeQuery("select password from account where username='" + userid + "'");
            if (rs2.next()) {
                String pwd1 = rs2.getString("password");
                check = Hashing.validatePassword(pwd, pwd1);
            }
            if (check) {
                HttpSession session = request.getSession();
                session.setAttribute("userid", userid);
                session.setMaxInactiveInterval(30 * 60);
                Cookie userName = new Cookie("userid", userid);
                userName.setMaxAge(30 * 60);
                response.addCookie(userName);
                response.sendRedirect("loginsuccess.jsp");
            } else {
                JOptionPane.showMessageDialog(null, "no match");
                response.sendRedirect("InvalidUserNPass.jsp");
            }
        } else {
            JOptionPane.showMessageDialog(null, "no user");
            response.sendRedirect("InvalidUserNPass.jsp");
        }
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (SQLException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (InvalidKeySpecException e) {
        e.printStackTrace();
    } finally {
        try {
            con.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

######


private Connection getConnection() throws SQLException {
    java.sql.Connection con;
    con = ConnectionFactory.getInstance().getConnection();
    return con;
}

######


public String login() throws SQLException, ClassNotFoundException {
    loginUserName = getLoginUserName();
    loginPassword = getLoginPassword();
    connection = getConnection();
    checkDuplicate = connection.prepareStatement("SELECT username, password FROM user WHERE username=? AND password= ?");
    checkDuplicate.setString(1, loginUserName);
    checkDuplicate.setString(2, loginPassword);
    ResultSet results = checkDuplicate.executeQuery();
    System.out.println("#result" + results);
    if (results.next()) {
        System.out.println("hey gals");
        Map session = ActionContext.getContext().getSession();
        session.put("logined", "true");
        session.put("user", loginUserName);
        return "success";
    } else {
        return "failure";
    }
}

######


public void setSession(Map m) {
    this.m = m;
}

######


public void setLoginUserName(String loginUserName) {
    this.loginUserName = loginUserName;
}

######


public String getLoginUserName() {
    return this.loginUserName;
}

######


public void setLoginPassword(String loginPassword) {
    this.loginPassword = loginPassword;
}

######


public String getLoginPassword() {
    return this.loginPassword;
}

######


@Override
public void onClick(View v) {
    isValidateTrue = true;
    if (textEmail.getText().toString().isEmpty() || textPassword.getText().toString().isEmpty()) {
        CharSequence textToast = "Tolong isi Email dan Password dengan benar";
        Toast.makeText(getApplicationContext(), textToast, Toast.LENGTH_SHORT).show();
        isValidateTrue = false;
    }
    if (isValidateTrue) {
        String email = textEmail.getText().toString();
        if (!email.contains("@") && !email.contains(".")) {
            isValidateTrue = false;
            CharSequence textToast = "Tolong isikan alamat email dengan benar";
            Toast.makeText(getApplicationContext(), textToast, Toast.LENGTH_SHORT).show();
        }
    }
    if (isValidateTrue) {
        if (ContextCompat.checkSelfPermission(getApplicationContext(), Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED && ContextCompat.checkSelfPermission(getApplicationContext(), android.Manifest.permission.ACCESS_NETWORK_STATE) != PackageManager.PERMISSION_GRANTED) {
            return;
        }
        loginToServer loginUser = new loginToServer();
        loginUser.setIpServer(ipServer);
        loginUser.setActivity(LoginActivity.this);
        loginUser.setEmail(textEmail.getText().toString());
        loginUser.setPassword(textPassword.getText().toString());
        loginUser.setContext(getApplicationContext());
        loginUser.execute();
    }
}

######


@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.login);
    textEmail = (EditText) findViewById(R.id.text_email);
    textPassword = (EditText) findViewById(R.id.text_password);
    SharedPreferences sh = getSharedPreferences("ReUse_Variable", Context.MODE_PRIVATE);
    editorSharedPreference = sh.edit();
    final String ipServer = sh.getString("IpAddress", "");
    dbh = new DatabaseHelper(getApplicationContext());
    db = dbh.getWritableDatabase();
    try {
        userDao = dbh.getUserDao();
    } catch (SQLException e) {
        Log.e("Insert Error", e.toString());
    }
    login = (Button) findViewById(R.id.login_button);
    login.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            isValidateTrue = true;
            if (textEmail.getText().toString().isEmpty() || textPassword.getText().toString().isEmpty()) {
                CharSequence textToast = "Tolong isi Email dan Password dengan benar";
                Toast.makeText(getApplicationContext(), textToast, Toast.LENGTH_SHORT).show();
                isValidateTrue = false;
            }
            if (isValidateTrue) {
                String email = textEmail.getText().toString();
                if (!email.contains("@") && !email.contains(".")) {
                    isValidateTrue = false;
                    CharSequence textToast = "Tolong isikan alamat email dengan benar";
                    Toast.makeText(getApplicationContext(), textToast, Toast.LENGTH_SHORT).show();
                }
            }
            if (isValidateTrue) {
                if (ContextCompat.checkSelfPermission(getApplicationContext(), Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED && ContextCompat.checkSelfPermission(getApplicationContext(), android.Manifest.permission.ACCESS_NETWORK_STATE) != PackageManager.PERMISSION_GRANTED) {
                    return;
                }
                loginToServer loginUser = new loginToServer();
                loginUser.setIpServer(ipServer);
                loginUser.setActivity(LoginActivity.this);
                loginUser.setEmail(textEmail.getText().toString());
                loginUser.setPassword(textPassword.getText().toString());
                loginUser.setContext(getApplicationContext());
                loginUser.execute();
            }
        }
    });
}

######


private void insertUser() throws SQLException {
    Statement stat = connect.createStatement();
    String Data = "insert into users (_nome, _senha, _sexo) values ('" + user + "','" + pass + "','" + sexo + "');";
    stat.execute(Data);
    connect.close();
}

######


@FXML
protected void on_btn_close_clicked(MouseEvent event) {
    Platform.exit();
}

######


@Override
public void initialize(URL location, ResourceBundle resources) {
    btn_register.setOnAction(e -> createRegistrationForm());
    btn_login.setOnAction(e -> signUp());
}

######


@Override
public MainWinController call() throws Exception {
    return new MainWinController(login_text.getText());
}

######


@Override
public Object call(Class<?> param) {
    Callable<?> callable = creators.get(param);
    if (callable == null) {
        try {
            return param.newInstance();
        } catch (InstantiationException | IllegalAccessException ex) {
            throw new IllegalStateException(ex);
        }
    } else {
        try {
            return callable.call();
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
    }
}

######


private void signUp() {
    String query = "select count(*) from mupp_user where login=\"" + login_text.getText() + "\"" + " and pass=\"" + password_text.getText() + "\";";
    System.out.println(query);
    try {
        String result = TCPConnection.getInstance().sendAndRecieve(query);
        System.out.println(result);
        Object resultJson = new JSONParser().parse(result);
        JSONObject resultObject = (JSONObject) resultJson;
        JSONArray resultsArray = (JSONArray) resultObject.get("result");
        JSONObject countObj = (JSONObject) resultsArray.get(0);
        String countStr = (String) countObj.get("count(*)");
        int count = Integer.parseInt(countStr);
        if (count == 0) {
            System.out.println("NO SUCH USER");
        }
        if (count == 1) {
            System.out.println("SIGNED UP");
            Stage mainWindow = new Stage();
            mainWindow.setTitle("Project Manager");
            Map<Class, Callable<?>> creators = new HashMap<>();
            creators.put(MainWinController.class, new Callable<MainWinController>() {

                @Override
                public MainWinController call() throws Exception {
                    return new MainWinController(login_text.getText());
                }
            });
            FXMLLoader loader = new FXMLLoader(getClass().getResource("../Main/MainWinForm.fxml"));
            loader.setControllerFactory(new Callback<Class<?>, Object>() {

                @Override
                public Object call(Class<?> param) {
                    Callable<?> callable = creators.get(param);
                    if (callable == null) {
                        try {
                            return param.newInstance();
                        } catch (InstantiationException | IllegalAccessException ex) {
                            throw new IllegalStateException(ex);
                        }
                    } else {
                        try {
                            return callable.call();
                        } catch (Exception ex) {
                            throw new IllegalStateException(ex);
                        }
                    }
                }
            });
            Parent root = loader.load();
            mainWindow.setScene(new Scene(root, 864, 566));
            mainWindow.show();
            Stage primary = (Stage) btn_login.getScene().getWindow();
            primary.close();
        }
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ParseException e) {
        e.printStackTrace();
    }
}

######


private void createRegistrationForm() {
    try {
        Stage regWin = new Stage();
        regWin.initModality(Modality.APPLICATION_MODAL);
        regWin.setTitle("Регистрация");
        regWin.setWidth(300);
        regWin.setHeight(500);
        Parent root = FXMLLoader.load(getClass().getResource("../Registration/RegistrationForm.fxml"));
        regWin.setScene(new Scene(root, 300, 520));
        regWin.show();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

######


public Login login(Login l) {
    Login result = null;
    String sql = "SELECT id, name_, phone, email, regDate FROM loginInfoView WHERE id=? AND pw=?";
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = MySQLConnection.connect();
        pstmt = conn.prepareStatement(sql);
        pstmt.setString(1, l.getId());
        pstmt.setString(2, l.getPw());
        ResultSet rs = pstmt.executeQuery();
        while (rs.next()) {
            String id = rs.getString("id");
            String name_ = rs.getString("name_");
            String phone = rs.getString("phone");
            String email = rs.getString("email");
            result = new Login();
            result.setId(id);
            result.setName_(name_);
            result.setPhone(phone);
            result.setEmail(email);
        }
        rs.close();
    } catch (SQLException se) {
        System.out.println(se.getMessage());
    } catch (Exception e) {
        System.out.println(e.getMessage());
    } finally {
        try {
            if (pstmt != null)
                pstmt.close();
        } catch (SQLException se) {
        }
        try {
            MySQLConnection.close();
        } catch (SQLException se) {
            System.out.println(se.getMessage());
        }
    }
    return result;
}

######


public Login login(Login l) {
    Login result = null;
    String sql = "SELECT id, name_, phone, email, regDate FROM loginInfoView WHERE id=? AND pw=?";
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = MySQLConnection.connect();
        pstmt = conn.prepareStatement(sql);
        pstmt.setString(1, l.getId());
        pstmt.setString(2, l.getPw());
        ResultSet rs = pstmt.executeQuery();
        while (rs.next()) {
            String id = rs.getString("id");
            String name_ = rs.getString("name_");
            String phone = rs.getString("phone");
            String email = rs.getString("email");
            result = new Login();
            result.setId(id);
            result.setName_(name_);
            result.setPhone(phone);
            result.setEmail(email);
        }
        rs.close();
    } catch (SQLException se) {
        System.out.println(se.getMessage());
    } catch (Exception e) {
        System.out.println(e.getMessage());
    } finally {
        try {
            if (pstmt != null)
                pstmt.close();
        } catch (SQLException se) {
        }
        try {
            MySQLConnection.close();
        } catch (SQLException se) {
            System.out.println(se.getMessage());
        }
    }
    return result;
}

######


public boolean isDbConnected() {
    try {
        return !connection.isClosed();
    } catch (Exception e) {
        return false;
    }
}

######


public boolean isLogin(String user, String pass) throws SQLException {
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    String q = "select * from ADMIN where User = ? and Pass = ?";
    try {
        preparedStatement = connection.prepareStatement(q);
        preparedStatement.setString(1, user);
        preparedStatement.setString(2, pass);
        resultSet = preparedStatement.executeQuery();
        if (resultSet.next()) {
            return true;
        } else
            return false;
    } catch (Exception e) {
        return false;
    } finally {
        preparedStatement.close();
        resultSet.close();
    }
}

######


@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    HttpSession session = req.getSession();
    if (req.getParameter("logout") != null) {
        session.invalidate();
        resp.sendRedirect("login");
        return;
    }
    req.setAttribute("loginFailed", false);
    req.getRequestDispatcher("/WEB-INF/jsp/view/login.jsp").forward(req, resp);
}

######


@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String login = req.getParameter("login");
    String password = req.getParameter("password");
    if (loginPasswordCorrect(login, password)) {
        req.getSession().setAttribute("username", login);
        req.changeSessionId();
        resp.sendRedirect("page");
    } else {
        req.setAttribute("loginFailed", true);
        req.getRequestDispatcher("/WEB-INF/jsp/view/login.jsp").forward(req, resp);
    }
}

######


private boolean loginPasswordCorrect(String login, String password) throws ServletException {
    if (login == null || password == null) {
        return false;
    } else if (users.containsKey(login) && users.get(login).equals(password)) {
        return true;
    } else {
        EntityManager em = JPASessionUtil.getEntityManager();
        try {
            TypedQuery<User> query = em.createQuery("select u from User as u where u.name=:login", User.class);
            query.setParameter("login", login);
            List<User> result = query.getResultList();
            if (result.size() != 1) {
                return false;
            }
            User user = result.get(0);
            return password.equals(user.getPassword());
        } catch (Exception e) {
            throw new ServletException(e);
        } finally {
            em.close();
        }
    }
}

######


public Long getId() {
    return id;
}

######


public void setId(Long id) {
    this.id = id;
}

######


public String getKodeLokasi() {
    return kodeLokasi;
}

######


public void setKodeLokasi(String kodeLokasi) {
    this.kodeLokasi = kodeLokasi;
}

######


public String getNamaKota() {
    return namaKota;
}

######


public void setNamaKota(String namaKota) {
    this.namaKota = namaKota;
}

######


public String getNamaPropinsi() {
    return namaPropinsi;
}

######


public void setNamaPropinsi(String namaPropinsi) {
    this.namaPropinsi = namaPropinsi;
}

######


@Override
public int hashCode() {
    int hash = 0;
    hash += (id != null ? id.hashCode() : 0);
    return hash;
}

######


@Override
public String toString() {
    return "apdol.entity.Lokasi[ id=" + id + " ]";
}

######


public boolean isKodeNoChange(String kode) {
    if (kode.equalsIgnoreCase(this.kodeLokasi)) {
        return true;
    } else {
        return false;
    }
}

######


public boolean isNamaNoChange(String nama) {
    if (nama.equalsIgnoreCase(this.namaKota)) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public void initialize(URL location, ResourceBundle resources) {
    formatdayPicker();
    try {
        fillComboxLop();
        fillComboBox();
    } catch (Exception e) {
        e.printStackTrace();
    }
    filTer();
    tableItemClick();
    btnRefLp.setOnAction(e -> {
        try {
            dataInputLop();
        } catch (SQLException e1) {
            e1.printStackTrace();
        }
    });
    btnXoaLp.setOnAction(e -> {
        deleteSinhVien();
    });
}

######


private void fillComboxLop() {
    Connection connbox = SQLiteConnection.connector();
    PreparedStatement precombox;
    ResultSet rscbox;
    String khoadb = "select DISTINCT MaLop from SINHVIEN order by MaLop asc";
    try {
        precombox = connbox.prepareStatement(khoadb);
        rscbox = precombox.executeQuery();
        while (rscbox.next()) {
            comboxhienthisv.add(rscbox.getString("MaLop"));
        }
        rscbox.close();
        precombox.close();
    } catch (Exception e) {
    }
    comHienThilp.setItems(comboxhienthisv);
}

######


private void dataInputLop() throws SQLException {
    obsv.clear();
    Connection conn = sample.LoginApp.database.SQLiteConnection.connector();
    ResultSet rs = null;
    PreparedStatement preparedStatement = null;
    String qr = "select * from SINHVIEN where MaLop=?";
    try {
        preparedStatement = conn.prepareStatement(qr);
        preparedStatement.setString(1, comHienThilp.getSelectionModel().getSelectedItem());
        rs = preparedStatement.executeQuery();
        while (rs.next()) {
            obsv.add(new SinhVienModel(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4), rs.getString(5), rs.getString(6), rs.getString(7), rs.getString(8)));
        }
    } catch (Exception n) {
        n.printStackTrace();
    } finally {
        try {
            rs.close();
        } catch (SQLException e1) {
            e1.printStackTrace();
        }
        try {
            preparedStatement.close();
        } catch (SQLException e1) {
            e1.printStackTrace();
        }
    }
    clmalp.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("IdSv"));
    clholp.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("HoSv"));
    cltenlp.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("TenSv"));
    clngaysinhlp.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("NgaysinhSv"));
    clsexlp.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("SexSv"));
    clphonelp.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("PhoneSv"));
    cldiachilp.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("DiachiSv"));
    cllopl.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("Lopsv"));
    tablesv.setItems(obsv);
}

######


public void filTer() {
    FilteredList<SinhVienModel> filter = new FilteredList<>(obsv, e -> true);
    txtFindlp.setOnAction(e -> {
        txtFindlp.textProperty().addListener(((observable, oldValue, newValue) -> {
            filter.setPredicate((Predicate<? super SinhVienModel>) sv -> {
                if (newValue == null || newValue.isEmpty()) {
                    return true;
                }
                String lowerCase = newValue.toLowerCase();
                if (sv.getIdSv().toLowerCase().contains(lowerCase)) {
                    return true;
                } else if (sv.getTenSv().toLowerCase().contains(lowerCase)) {
                    return true;
                } else if (sv.getHoSv().toLowerCase().contains(lowerCase)) {
                    return true;
                }
                return false;
            });
        }));
        SortedList<SinhVienModel> sort = new SortedList<>(filter);
        sort.comparatorProperty().bind(tablesv.comparatorProperty());
        tablesv.setItems(sort);
    });
}

######


public boolean radioCheck() {
    if (radNamlp.isSelected() || radNulp.isSelected()) {
        return false;
    } else
        return true;
}

######


@Override
public String toString(LocalDate date) {
    if (date != null) {
        return dateFormatter.format(date);
    } else {
        return "";
    }
}

######


@Override
public LocalDate fromString(String string) {
    if (string != null && !string.isEmpty()) {
        return LocalDate.parse(string, dateFormatter);
    } else {
        return null;
    }
}

######


public void formatdayPicker() {
    bDatelp.setConverter(new StringConverter<LocalDate>() {

        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(pattern);

        {
            bDatelp.setPromptText("Ngày sinh");
        }

        @Override
        public String toString(LocalDate date) {
            if (date != null) {
                return dateFormatter.format(date);
            } else {
                return "";
            }
        }

        @Override
        public LocalDate fromString(String string) {
            if (string != null && !string.isEmpty()) {
                return LocalDate.parse(string, dateFormatter);
            } else {
                return null;
            }
        }
    });
}

######


public boolean emtyFeild() {
    if (txtMalp.getText().isEmpty() | txtHolp.getText().isEmpty() | txtTenlp.getText().isEmpty() | txtPhonelp.getText().isEmpty() | txtDiachilp.getText().isEmpty()) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị nhập đầy đủ thông tin!!");
        alert.showAndWait();
        return false;
    }
    if (bDatelp.getEditor().getText().isEmpty()) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị nhập Ngày Sinh");
        alert.showAndWait();
        return false;
    }
    if (radioCheck()) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị chọn Giới Tính!");
        alert.showAndWait();
        return false;
    }
    if (comLopl.getValue() == null) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị chọn Lớp!");
        alert.showAndWait();
        return false;
    }
    return true;
}

######


public void tableItemClick() {
    tablesv.setOnMouseClicked(e -> {
        if (tablesv.getSelectionModel().getSelectedItem() != null) {
            try {
                SinhVienModel sv = tablesv.getSelectionModel().getSelectedItem();
                String qr = "select * from SINHVIEN where ID=?";
                Connection conn = SQLiteConnection.connector();
                PreparedStatement pre;
                ResultSet rs;
                pre = conn.prepareStatement(qr);
                pre.setString(1, sv.getIdSv());
                rs = pre.executeQuery();
                while (rs.next()) {
                    txtMalp.setText(rs.getString(1));
                    txtHolp.setText(rs.getString(2));
                    txtTenlp.setText(rs.getString(3));
                    bDatelp.getEditor().setText(rs.getString(4));
                    if (rs.getString(5).equals("Nam")) {
                        radNamlp.setSelected(true);
                    } else
                        radNulp.setSelected(true);
                    txtPhonelp.setText(rs.getString(6));
                    txtDiachilp.setText(rs.getString(7));
                }
                rs.close();
                pre.close();
                conn.close();
            } catch (Exception m) {
                m.printStackTrace();
            }
        }
    });
}

######


public void fillComboBox() {
    Connection connbox = SQLiteConnection.connector();
    PreparedStatement precombox;
    ResultSet rscbox;
    String khoadb = "select DISTINCT MaLop from SINHVIEN order by MaLop asc";
    try {
        precombox = connbox.prepareStatement(khoadb);
        rscbox = precombox.executeQuery();
        while (rscbox.next()) {
            comboxsv.add(rscbox.getString("MaLop"));
        }
        rscbox.close();
        precombox.close();
    } catch (Exception e) {
    }
    comLopl.setItems(comboxsv);
}

######


public void clearText() {
    txtHolp.clear();
    txtDiachilp.clear();
    txtTenlp.clear();
    txtMalp.clear();
    txtPhonelp.clear();
    bDatelp.setValue(null);
    radNulp.setSelected(false);
    radNamlp.setSelected(false);
}

######


public void editEnableTxt() {
    txtMalp.setEditable(true);
    txtHolp.setEditable(true);
    txtTenlp.setEditable(true);
    txtPhonelp.setEditable(true);
    txtDiachilp.setEditable(true);
    radNulp.setDisable(false);
    radNamlp.setDisable(false);
    bDatelp.setDisable(false);
    comLopl.setDisable(false);
    btnUpdateLp.setDisable(false);
    btnAddLop.setDisable(false);
}

######


public void editDisableTxt() {
    txtMalp.setEditable(false);
    txtHolp.setEditable(false);
    txtTenlp.setEditable(false);
    txtPhonelp.setEditable(false);
    txtDiachilp.setEditable(false);
    radNulp.setDisable(true);
    radNamlp.setDisable(true);
    bDatelp.setDisable(true);
    comLopl.setDisable(true);
    btnUpdateLp.setDisable(true);
    btnAddLop.setDisable(true);
}

######


public boolean maSvisCheck() throws SQLException {
    PreparedStatement preCk = null;
    ResultSet rsCk = null;
    Connection connection = SQLiteConnection.connector();
    String gvstr1 = "select ? from SINHVIEN";
    try {
        preCk = connection.prepareStatement(gvstr1);
        preCk.setString(1, txtMalp.getText());
        rsCk = preCk.executeQuery();
        if (rsCk.next()) {
            return true;
        } else {
            Alert alert = new Alert(Alert.AlertType.ERROR);
            alert.setTitle("Lỗi");
            alert.setHeaderText(null);
            alert.setContentText("Không tìm thấy Mã Sinh Viên!");
            alert.showAndWait();
            return false;
        }
    } catch (Exception e) {
        return false;
    } finally {
        rsCk.close();
        preCk.close();
    }
}

######


public void themSinhVien() throws SQLException {
    if (emtyFeild()) {
        if (radNamlp.isSelected()) {
            lblsex = radNamlp.getText();
        } else if (radNulp.isSelected()) {
            lblsex = radNulp.getText();
        }
        Connection conngv = SQLiteConnection.connector();
        PreparedStatement preparegv1 = null;
        String gvstr1 = "insert into SINHVIEN (ID,HoSV,TenSV,NgaySinhSV,GioiTinhSV,PhoneSV,DiaChiSV,MaLop) values (?,?,?,?,?,?,?,?)";
        try {
            preparegv1 = conngv.prepareStatement(gvstr1);
            preparegv1.setString(1, txtMalp.getText());
            preparegv1.setString(2, txtHolp.getText());
            preparegv1.setString(3, txtTenlp.getText());
            preparegv1.setString(4, bDatelp.getEditor().getText());
            preparegv1.setString(5, lblsex);
            preparegv1.setString(6, txtPhonelp.getText());
            preparegv1.setString(7, txtDiachilp.getText());
            preparegv1.setString(8, comLopl.getSelectionModel().getSelectedItem());
            preparegv1.executeUpdate();
            dataInputLop();
            clearText();
            preparegv1.close();
            conngv.close();
        } catch (Exception e) {
        } finally {
        }
    }
}

######


public void deleteSinhVien() {
    if (!txtMalp.getText().isEmpty()) {
        Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
        alert.setHeaderText(null);
        alert.setContentText("Bạn có muốn xoá " + txtHolp.getText() + " " + txtTenlp.getText() + "\nKhỏi danh sách?");
        Optional<ButtonType> action = alert.showAndWait();
        Connection conn = SQLiteConnection.connector();
        PreparedStatement pred = null;
        if (action.get() == ButtonType.OK) {
            try {
                String qr = "delete from SINHVIEN where ID=?";
                pred = conn.prepareStatement(qr);
                pred.setString(1, txtMalp.getText());
                pred.executeUpdate();
                pred.close();
                dataInputLop();
                clearText();
                editDisableTxt();
                conn.close();
            } catch (Exception x) {
                x.printStackTrace();
            }
        }
    } else {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setHeaderText(null);
        alert.setContentText("Chọn trong danh sách để xoá!");
        alert.showAndWait();
    }
}

######


public void suaSinhVien() throws SQLException {
    if (emtyFeild()) {
        if (radNamlp.isSelected()) {
            lblsex = radNamlp.getText();
        } else if (radNulp.isSelected()) {
            lblsex = radNulp.getText();
        }
        Connection conngv = SQLiteConnection.connector();
        PreparedStatement preparegvs = null;
        String str2 = "update SINHVIEN set HoSV = ?,TenSV = ?,NgaySinhSV = ?,GioiTinhSV = ?,PhoneSV = ?,DiaChiSV = ?,MaLop = ? where ID = ?";
        try {
            preparegvs = conngv.prepareStatement(str2);
            preparegvs.setString(1, txtHolp.getText());
            preparegvs.setString(2, txtTenlp.getText());
            preparegvs.setString(3, bDatelp.getEditor().getText());
            preparegvs.setString(4, lblsex);
            preparegvs.setString(5, txtPhonelp.getText());
            preparegvs.setString(6, txtDiachilp.getText());
            preparegvs.setString(7, comLopl.getSelectionModel().getSelectedItem());
            preparegvs.setString(8, txtMalp.getText());
            preparegvs.executeUpdate();
            dataInputLop();
            preparegvs.close();
            conngv.close();
            clearText();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
        }
    }
}

######


@FXML
void onThemSuaSvlp(ActionEvent event) {
    if (event.getSource() == btnSuaLp) {
        editEnableTxt();
        btnAddLop.setDisable(true);
        btnUpdateLp.setOnAction(e -> {
            try {
                if (maSvisCheck()) {
                    suaSinhVien();
                    editDisableTxt();
                }
            } catch (SQLException s) {
                s.printStackTrace();
            }
        });
    }
    if (event.getSource() == btnThemLp) {
        clearText();
        editEnableTxt();
        btnUpdateLp.setDisable(true);
        btnAddLop.setOnAction(e -> {
            try {
                themSinhVien();
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
            editDisableTxt();
        });
    }
}

######


@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    SQLiteDatabase AppointmentDatabase = getBaseContext().openOrCreateDatabase("appointment.db", MODE_PRIVATE, null);
    Cursor query = AppointmentDatabase.rawQuery("SELECT * from contacts", null);
    if (query.moveToFirst()) {
        String name = query.getString(0);
        Integer phone = query.getInt(1);
        String email = query.getString(2);
        Integer cardnum = query.getInt(3);
        Integer cardexp = query.getInt(4);
        Integer sessions = query.getInt(5);
        customerList.add(new Customer(name, phone, email, cardnum, cardexp, sessions));
    } else {
        AppointmentDatabase.execSQL("CREATE TABLE customers(name TEXT, phone INTEGER, email TEXT, cardnum INTEGER, cardexp INTEGER, sessions INTEGER);");
        AppointmentDatabase.execSQL("INSERT INTO customers VALUES('John Smith', 5551212, 'jsmith@fakemail/com', 1234567891011121, 0520, 0)");
        AppointmentDatabase.execSQL("INSERT INTO customers VALUES('Jane Nemo', 5552232, 'jnemo@fakemail/com', 1817161514131211, 0819, 0)");
    }
    AppointmentDatabase.close();
    mRecyclerView = (RecyclerView) findViewById(R.id.recycler_view);
    mRecyclerView.setHasFixedSize(true);
    mLayoutManager = new LinearLayoutManager(this);
    mRecyclerView.setLayoutManager(mLayoutManager);
    mAdapter = new MyAdapter(customerList);
    mRecyclerView.setAdapter(mAdapter);
}

######


@Override
public CustomerHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    LayoutInflater layoutInflater = LayoutInflater.from(getApplicationContext());
    return new CustomerHolder(layoutInflater, parent);
}

######


@Override
public void onBindViewHolder(CustomerHolder holder, int position) {
}

######


@Override
public int getItemCount() {
    return mCustomerList.size();
}

######


@Override
public void initialize(URL location, ResourceBundle resources) {
    label_fio.setText(getFIO());
    btn_showTasks.setOnAction(e -> showTasksScene());
    btn_showProjects.setOnAction(e -> showProjectsScene());
}

######


private void showProjectsScene() {
    try {
        Parent root = FXMLLoader.load(getClass().getResource("ProjectScreen/ProjectScreen.fxml"));
        borderPane_root.setCenter(root);
    } catch (IOException e) {
        e.printStackTrace();
    }
}

######


private void showTasksScene() {
    System.out.println("Show tasks!");
    try {
        Parent root = FXMLLoader.load(getClass().getResource("TaskScreen/TaskScreen.fxml"));
        borderPane_root.setCenter(root);
    } catch (IOException e) {
        e.printStackTrace();
    }
}

######


private String getFIO() {
    String loginStr = "User";
    String query = "select * from mupp_user where login=\"" + user_login + "\";";
    try {
        String result = TCPConnection.getInstance().sendAndRecieve(query);
        Object resultJson = null;
        try {
            resultJson = new JSONParser().parse(result);
            JSONObject resultObject = (JSONObject) resultJson;
            JSONArray resultsArray = (JSONArray) resultObject.get("result");
            JSONObject loginObj = (JSONObject) resultsArray.get(0);
            currentUser = UserModel.fromJson(loginObj);
            loginStr = currentUser.getUserFullname();
        } catch (ParseException e) {
            e.printStackTrace();
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
    return loginStr;
}

######


public String getUser_login() {
    return user_login;
}

######


protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setContentType("text/html;charset=utf-8");
    String userToken = request.getParameter("userToken");
    String account = request.getParameter("account");
    if (userToken == null) {
        userToken = "";
    }
    if (account == null) {
        account = "";
    }
    Status status = new Status();
    JSONObject jsonRet;
    if (userToken.equals("") || account.equals("")) {
        status.setStatus(false);
        status.setInfo("空参数");
        jsonRet = JSONObject.fromObject(status);
        Course[] courses = new Course[0];
        jsonRet.put("courses", courses);
        PrintWriter out = response.getWriter();
        out.print(jsonRet.toString());
        return;
    }
    boolean isTeacher = false;
    DBConnect dbConnect = new DBConnect();
    String querySting;
    PreparedStatement preparedStatement;
    try {
        querySting = "SELECT * FROM course WHERE teacherid = ?";
        preparedStatement = dbConnect.prepareStatement(querySting);
        preparedStatement.setString(1, account);
        ResultSet rs = preparedStatement.executeQuery();
        List<Course> courses = new ArrayList<Course>();
        status.setStatus(true);
        status.setInfo("获取信息成功");
        jsonRet = JSONObject.fromObject(status);
        while (rs.next()) {
            Course course = new Course();
            course.setCourseID(rs.getInt("id"));
            course.setCourseName(rs.getString("name"));
            course.setCourseInfo(rs.getString("info"));
            course.setCoursePlan(rs.getString("plan"));
            courses.add(course);
        }
        jsonRet.put("courses", courses);
        isTeacher = courses.size() > 0;
    } catch (SQLException e) {
        status.setStatus(false);
        status.setInfo("数据库查询错误 " + e.getMessage());
        jsonRet = JSONObject.fromObject(status);
        Course[] courses = new Course[0];
        jsonRet.put("courses", courses);
        PrintWriter out = response.getWriter();
        out.print(jsonRet.toString());
        return;
    }
    if (isTeacher) {
        PrintWriter out = response.getWriter();
        out.print(jsonRet.toString());
        return;
    }
    try {
        querySting = "SELECT c.id AS id, c.name AS name, c.info AS info, c.plan AS plan" + " FROM course AS c, selection AS s" + " WHERE s.studentid = ? AND s.courseid = c.id";
        preparedStatement = dbConnect.prepareStatement(querySting);
        preparedStatement.setString(1, account);
        ResultSet rs = preparedStatement.executeQuery();
        List<Course> courses = new ArrayList<Course>();
        while (rs.next()) {
            Course course = new Course();
            course.setCourseID(rs.getInt("id"));
            course.setCourseName(rs.getString("name"));
            course.setCourseInfo(rs.getString("info"));
            course.setCoursePlan(rs.getString("plan"));
            courses.add(course);
        }
        status.setStatus(true);
        status.setInfo("获取信息成功");
        jsonRet = JSONObject.fromObject(status);
        jsonRet.put("courses", courses);
    } catch (SQLException e) {
        status.setStatus(false);
        status.setInfo("数据库查询错误 " + e.getMessage());
        jsonRet = JSONObject.fromObject(status);
        Course[] courses = new Course[0];
        jsonRet.put("courses", courses);
    }
    PrintWriter out = response.getWriter();
    out.print(jsonRet.toString());
}

######


protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
}

######


public List<Manager> findByNameAndPass(Manager mgr) {
    return find("select m from Manager m where m.name = ?0 and m.pass=?1", mgr.getName(), mgr.getPass());
}

######


public Manager findByName(String name) {
    List<Manager> ml = find("select m from Manager m where m.name=?0", name);
    if (ml != null && ml.size() > 0) {
        return ml.get(0);
    }
    return null;
}

######


public List<Collana> getCollane() {
    List<Collana> toReturn;
    CollanaDAO collanaDAO = new CollanaDAO();
    toReturn = collanaDAO.doRetriveAll();
    return toReturn;
}

######


public int insertVolume(Volume volume) {
    VolumeDAO volumeDAO = new VolumeDAO();
    return volumeDAO.doInsert(volume);
}

######


public int insertLibro(Libro libro) {
    LibroDAO lDAO = new LibroDAO();
    return lDAO.doInsert(libro);
}

######


public int insertManuale(Manuale manuale) {
    ManualeDAO mDAO = new ManualeDAO();
    return mDAO.doInsert(manuale);
}

######


public int insertPeriodico(Periodico periodico) {
    PeriodicoDAO pDAO = new PeriodicoDAO();
    return pDAO.doInsert(periodico);
}

######


public boolean insertVolumeInCollana(Volume v, Collana c) {
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement("INSERT INTO appartiene(CodVolume,NomeCollana,NumeroOrdineCollana)" + "VALUES(?,?,?);", PreparedStatement.RETURN_GENERATED_KEYS);
        prst.setString(1, v.getCodice());
        prst.setString(2, c.getNomeCollana());
        prst.setInt(3, Integer.parseInt(c.getNumeroOrdineCollana()));
        try {
            prst.execute();
            con.commit();
            ResultSet rs = prst.getGeneratedKeys();
            return true;
        } catch (SQLException e) {
            con.rollback();
            e.printStackTrace();
            return false;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
            return true;
        }
    } catch (SQLException e) {
        return false;
    }
}

######


public boolean insertAutoreDiVolume(Volume v, Autore a) {
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement("INSERT INTO scritto(CodAutore,CodVolume)" + "VALUES(?,?);", PreparedStatement.RETURN_GENERATED_KEYS);
        prst.setString(1, a.getCodFiscale());
        prst.setString(2, v.getCodice());
        try {
            prst.execute();
            con.commit();
            ResultSet rs = prst.getGeneratedKeys();
            return true;
        } catch (SQLException e) {
            con.rollback();
            e.printStackTrace();
            return false;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException e) {
        return false;
    }
}

######


public Collection<Libro> cercaLibro(Criterio c) {
    List<Libro> listToReturn = new ArrayList<>();
    List<Libro> allBooks = libroDAO.doRetriveAll();
    if (allBooks == null || allBooks.isEmpty()) {
        return null;
    }
    for (int i = 0; i < allBooks.size(); i++) {
        if (c.isValid(allBooks.get(i))) {
            listToReturn.add(allBooks.get(i));
        }
    }
    return listToReturn;
}

######


public Collection<Manuale> cercaManuale(Criterio c) {
    List<Manuale> listToReturn = new ArrayList<>();
    List<Manuale> allManuale = manualeDAO.doRetriveAll();
    if (allManuale == null || allManuale.isEmpty()) {
        return null;
    }
    for (int i = 0; i < allManuale.size(); i++) {
        if (c.isValid(allManuale.get(i))) {
            listToReturn.add(allManuale.get(i));
        }
    }
    return listToReturn;
}

######


public Collection<Periodico> cercaPeriodico(Criterio c) {
    List<Periodico> listToReturn = new ArrayList<>();
    List<Periodico> allPeriodico = periodicoDAO.doRetriveAll();
    if (allPeriodico == null || allPeriodico.isEmpty()) {
        return null;
    }
    for (int i = 0; i < allPeriodico.size(); i++) {
        if (c.isValid(allPeriodico.get(i))) {
            listToReturn.add(allPeriodico.get(i));
        }
    }
    return listToReturn;
}

######


public List<CasaEditrice> getCaseEditrici() {
    CasaEditriceDAO ceDAO = new CasaEditriceDAO();
    return ceDAO.doRetriveAll();
}

######


public List<Autore> getAutori() {
    AutoreDAO aDAO = new AutoreDAO();
    return aDAO.doRetriveAll();
}

######


public List<Volume> getVolumi() {
    VolumeDAO vDAO = new VolumeDAO();
    return vDAO.doRetriveAll();
}

######


public List<Copia> getCopie() {
    CopiaDAO cDAO = new CopiaDAO();
    return cDAO.doRetriveAll();
}

######


public List<Volume> getVolumiNonPosizionati() {
    VolumeDAO vDAO = new VolumeDAO();
    return vDAO.doRetriveNoPositioned();
}

######


public int insertCopia(Copia copia) {
    CopiaDAO cDAO = new CopiaDAO();
    return cDAO.doInsert(copia);
}

######


public boolean removeCopia(String idVolume) {
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement("DELETE FROM copia WHERE CodiceVolume=?", PreparedStatement.RETURN_GENERATED_KEYS);
        prst.setString(1, idVolume);
        try {
            prst.execute();
            con.commit();
            return true;
        } catch (SQLException e) {
            con.rollback();
            e.printStackTrace();
            return false;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException e) {
        return false;
    }
}

######


@BeforeClass
public static void setUpClass() {
    try {
        con = new DriverManagerConnectionPool().getConnection();
        managerGestioneLibri = new ManagerGestioneLibri();
        volume = new Volume();
        volume.setCodice("VVV");
        volume.setTitolo("yyy");
        volume.setEdizione(1);
        volume.setDataPubblicazione("25-12-2018");
        volume.setLingua("italiano");
        copia = new Copia();
        copia.setNumeroRegistrazione("CCC");
        copia.setNumeroScaffale("Z");
        copia.setPosizione(99);
        copia.setDisponibilita(true);
        copia.setCodiceVolume("ManualeAutori");
        managerGestioneLibri.insertCopia(copia);
        System.out.println("\nUNIT TEST - ManagerGestioneLibri");
    } catch (SQLException ex) {
        Logger.getLogger(ManagerGestioneLibriTest.class.getName()).log(Level.SEVERE, null, ex);
    }
}

######


@AfterClass
public static void tearDownClass() {
    PreparedStatement prst, prst2, prst3, prst4, prst5, prst6;
    try {
        prst = con.prepareStatement("delete from volume where Codice = ?");
        prst.setString(1, "VVV");
        prst.execute();
        prst2 = con.prepareStatement("delete from libro where CodVolume = ?");
        prst2.setString(1, "LLL");
        prst2.execute();
        prst3 = con.prepareStatement("delete from manuale where CodVolume = ?");
        prst3.setString(1, "MMM");
        prst3.execute();
        prst4 = con.prepareStatement("delete from periodico where CodVolume = ?");
        prst4.setString(1, "PPP");
        prst4.execute();
        prst5 = con.prepareStatement("delete from appartiene where CodVolume = ? and NomeCollana=? and NumeroOrdineCollana=?");
        prst5.setString(1, "Manuale");
        prst5.setString(2, "collana1");
        prst5.setInt(3, 10);
        prst5.execute();
        prst6 = con.prepareStatement("delete from scritto where CodVolume = ? and CodAutore=?");
        prst6.setString(1, "Manuale");
        prst6.setString(2, "AAA");
        ;
        prst6.execute();
        managerGestioneLibri.removeCopia(copia.getCodiceVolume());
        con.commit();
        prst.close();
        DriverManagerConnectionPool.releaseConnection(con);
        System.out.println("Database cleared");
    } catch (SQLException ex) {
        Logger.getLogger(ManagerGestioneLibriTest.class.getName()).log(Level.SEVERE, null, ex);
    }
}

######


@Before
public void setUp() {
}

######


@After
public void tearDown() {
}

######


@Test
public void testGetCollane() {
    System.out.println("getCollane");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 5;
    CollanaDAOStub cDAOS = new CollanaDAOStub();
    List<Collana> result = cDAOS.doRetriveAll();
    assertEquals(expResult, result.size());
}

######


@Test
public void testInsertVolume() {
    System.out.println("insertVolume");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 1;
    int result = instance.insertVolume(volume);
    assertEquals(expResult, result);
}

######


@Test
public void testInsertLibro() {
    System.out.println("insertLibro");
    Libro libro = new Libro();
    libro.setCodice("LLL");
    libro.setGenere("prova");
    libro.setTipo("a");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 1;
    int result = instance.insertLibro(libro);
    assertEquals(expResult, result);
}

######


@Test
public void testInsertManuale() {
    System.out.println("insertManuale");
    Manuale manuale = new Manuale();
    manuale.setCodice("MMM");
    manuale.setCategoria("prova");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 1;
    int result = instance.insertManuale(manuale);
    assertEquals(expResult, result);
}

######


@Test
public void testInsertPeriodico() {
    System.out.println("insertPeriodico");
    Periodico periodico = new Periodico();
    periodico.setCodice("PPP");
    periodico.setFrequenza("settimanale");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 1;
    int result = instance.insertPeriodico(periodico);
    assertEquals(expResult, result);
}

######


@Test
public void testInsertVolumeInCollana() {
    System.out.println("insertVolumeInCollana");
    Collana c = new Collana("collana1");
    c.setNumeroOrdineCollana("10");
    Volume v = new Volume();
    v.setCodice("Manuale");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    boolean expResult = true;
    boolean result = instance.insertVolumeInCollana(v, c);
    assertEquals(expResult, result);
}

######


@Test
public void testInsertAutoreDiVolume() {
    System.out.println("insertAutoreDiVolume");
    Volume v = new Volume();
    v.setCodice("Manuale");
    Autore a = new Autore();
    a.setCodFiscale("AAA");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    boolean expResult = true;
    boolean result = instance.insertAutoreDiVolume(v, a);
    assertEquals(expResult, result);
}

######


@Test
public void testCercaLibro() {
    System.out.println("cercaLibro");
    CriterioPerTitolo c = new CriterioPerTitolo("a");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 0;
    Collection<Libro> result = instance.cercaLibro(c);
    assertEquals(expResult, result.size());
}

######


@Test
public void testCercaManuale() {
    System.out.println("cercaManuale");
    CriterioPerTitolo c = new CriterioPerTitolo("mm");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 1;
    Collection<Manuale> result = instance.cercaManuale(c);
    assertEquals(expResult, result.size());
}

######


@Test
public void testCercaPeriodico() {
    System.out.println("cercaPeriodico");
    CriterioPerTitolo c = new CriterioPerTitolo("periodico");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 2;
    Collection<Periodico> result = instance.cercaPeriodico(c);
    assertEquals(expResult, result.size());
}

######


@Test
public void testGetCaseEditrici() {
    System.out.println("getCaseEditrici");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 2;
    List<CasaEditrice> result = instance.getCaseEditrici();
    assertEquals(expResult, result.size());
}

######


@Test
public void testGetAutori() {
    System.out.println("getAutori");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 4;
    List<Autore> result = instance.getAutori();
    assertEquals(expResult, result.size());
}

######


@Test
public void testGetVolumi() {
    System.out.println("getVolumi");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 8;
    List<Volume> result = instance.getVolumi();
    assertEquals(expResult, result.size());
}

######


@Test
public void testGetCopie() {
    System.out.println("getCopie");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 5;
    List<Copia> result = instance.getCopie();
    assertEquals(expResult, result.size());
}

######


@Test
public void testGetVolumiNonPosizionati() {
    System.out.println("getVolumiNonPosizionati");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 4;
    List<Volume> result = instance.getVolumiNonPosizionati();
    assertEquals(expResult, result.size());
}

######


@Test
public void testInsertCopia() {
    System.out.println("insertCopia");
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    int expResult = 1;
    int result = instance.insertCopia(copia);
    assertEquals(expResult, result);
}

######


@Test
public void testRemoveCopia() {
    System.out.println("removeCopia");
    String idVolume = "ManualeAutori";
    ManagerGestioneLibri instance = new ManagerGestioneLibri();
    boolean expResult = true;
    boolean result = instance.removeCopia(idVolume);
    assertEquals(expResult, result);
}

######


@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getSupportActionBar().hide();
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
    setContentView(R.layout.manager_login_layout);
    initViews();
    dbHelper = MydatabaseHelper.getInstance(this);
}

######


public void initViews() {
    manager_name = findViewById(R.id.manager_login_name_input);
    manager_pass = findViewById(R.id.manager_login_pass_input);
    btn_login = findViewById(R.id.manager_login);
    forgetNum = findViewById(R.id.manager_login_activity_forgetNum);
    registe = findViewById(R.id.manager_login_activity_register);
    Intent intent = getIntent();
    String username = intent.getStringExtra("username");
    manager_name.setText(username);
}

######


public void login(View v) {
    String name_info = manager_name.getText().toString().trim();
    String pass_info = manager_pass.getText().toString().trim();
    SQLiteDatabase db = dbHelper.getReadableDatabase();
    Cursor cursor = db.rawQuery("select password from manager where name=?", new String[] { name_info });
    String pi = null;
    if (cursor.moveToNext()) {
        pi = cursor.getString(cursor.getColumnIndex("password"));
    }
    if (pass_info.equals(pi)) {
        Intent intent = new Intent(this, Manager_Activity.class);
        startActivity(intent);
        cursor.close();
    } else {
        Toast.makeText(this, "用户名或密码错误", Toast.LENGTH_SHORT).show();
    }
}

######


public void register(View v) {
    Intent intent = new Intent(this, Manager_register_activity.class);
    startActivity(intent);
}

######


public void forget(View v) {
    Toast.makeText(this, "此功能暂不开放", Toast.LENGTH_LONG).show();
}

######


public String getStudentLimt(String table, String student_flag, String student) {
    String result = "";
    DBHelper db = new DBHelper();
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    String[] filed = { "student_age_class", "student_class", "student_major" };
    try {
        conn = db.getConnetion();
        stmt = conn.prepareStatement("select * from " + table + " where " + student_flag + "=\"" + student + "\" ;");
        rs = stmt.executeQuery();
        while (rs.next()) {
            for (int a = 0; a < filed.length; a++) {
                if (!rs.getString(filed[a]).equals("*")) {
                    result += " and " + filed[a] + "=\"" + rs.getString(filed[a]) + "\" ";
                }
                ;
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        if (rs != null) {
            try {
                rs.close();
                rs = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        if (stmt != null) {
            try {
                stmt.close();
                stmt = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        try {
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    return result;
}

######


public ArrayList<Item_student> getStudent(String user_number, String limit2) {
    ArrayList<Item_student> items = new ArrayList<Item_student>();
    Manager_op mp = new Manager_op();
    String limit = mp.getStudentLimt("manager_form", "user_number", user_number);
    DBHelper db = new DBHelper();
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    String sql = "select * from student as a,student_basic_news as b where a.user_number=b.user_number " + limit + limit2 + " ;";
    try {
        conn = db.getConnetion();
        stmt = conn.prepareStatement(sql);
        rs = stmt.executeQuery();
        while (rs.next()) {
            Item_student item = new Item_student();
            item.setAccess(rs.getInt("access"));
            item.setStudent_number(rs.getString("user_number"));
            item.setStudent_name(rs.getString("user_name"));
            item.setStudent_class(rs.getString("student_class"));
            item.setStudent_age_class(rs.getString("student_age_class"));
            DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            item.setTime(rs.getTimestamp("time"));
            item.setStudent_sum_mark(rs.getInt("student_sum_mark"));
            item.setExamin(rs.getInt("examine"));
            items.add(item);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        if (rs != null) {
            try {
                rs.close();
                rs = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        if (stmt != null) {
            try {
                stmt.close();
                stmt = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        try {
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    return items;
}

######


public boolean judgeStudentExist(String user_number1, String user_number2) {
    Manager_op mp = new Manager_op();
    String limit = mp.getStudentLimt("manager_form", "user_number", user_number1);
    boolean result = false;
    DBHelper db = new DBHelper();
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    String sql = "select count(*) from student where user_number=" + user_number2 + " " + limit + " ;";
    try {
        conn = db.getConnetion();
        stmt = conn.prepareStatement(sql);
        rs = stmt.executeQuery();
        while (rs.next()) {
            if (rs.getInt(1) != 0) {
                result = true;
            }
            ;
        }
    } catch (SQLException e) {
        e.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        if (rs != null) {
            try {
                rs.close();
                rs = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        if (stmt != null) {
            try {
                stmt.close();
                stmt = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        try {
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    return result;
}

######


public double calculateSumMark(String table, String studentNumber) {
    double sum = 0;
    DBHelper db = new DBHelper();
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    try {
        conn = db.getConnetion();
        stmt = conn.prepareStatement("select * from " + table + " where user_number=\"" + studentNumber + "\" ;");
        rs = stmt.executeQuery();
        while (rs.next()) {
            for (int b = 1; b <= rs.getMetaData().getColumnCount(); b++) {
                boolean flag = (boolean) (rs.getMetaData().getColumnName(b).equalsIgnoreCase("user_number"));
                if (!flag) {
                    String temp = rs.getString(rs.getMetaData().getColumnName(b));
                    if (temp != null)
                        sum += Double.parseDouble(temp);
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        if (rs != null) {
            try {
                rs.close();
                rs = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        if (stmt != null) {
            try {
                stmt.close();
                stmt = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        try {
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    return sum;
}

######


public boolean creatUser(Map newUser) {
    String key = "";
    String values = "";
    int start = 0;
    for (Object obj : newUser.keySet()) {
        Object value = newUser.get(obj);
        if (start == 0) {
            key += (String) obj;
            values += "\"" + (String) value + "\"";
            start++;
        } else {
            key += "," + (String) obj;
            values += ",\"" + (String) value + "\"";
        }
    }
    String sql = "insert into manager_form (" + key + ") values(" + values + ") ;";
    Mysql_operation mop = new Mysql_operation();
    if (mop.sql_opWord(sql))
        return true;
    else
        return false;
}

######


public boolean deletUser(String flag) {
    String sql = "delete from manager_form where user_number = '" + flag + "'";
    Mysql_operation mop = new Mysql_operation();
    if (mop.sql_opWord(sql))
        return true;
    else
        return false;
}

######


public ArrayList<String> getSelectValues(String manager, String fieled) {
    ArrayList<String> selectV = new ArrayList<String>();
    DBHelper db = new DBHelper();
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    String sql = "select " + fieled + " from manager_form where user_number=" + manager + ";";
    try {
        conn = db.getConnetion();
        stmt = conn.prepareStatement(sql);
        rs = stmt.executeQuery();
        while (rs.next()) {
            String temp = (String) rs.getString(fieled);
            if (temp.equals("*")) {
                Manager_op mp = new Manager_op();
                String limit = mp.getStudentLimt("manager_form", "user_number", manager);
                sql = "select distinct " + fieled + " from student where id=id " + limit + ";";
                stmt = conn.prepareStatement(sql);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    selectV.add(rs.getString(fieled));
                }
            } else {
                selectV.add(temp);
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        if (rs != null) {
            try {
                rs.close();
                rs = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        if (stmt != null) {
            try {
                stmt.close();
                stmt = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        try {
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    return selectV;
}

######


public boolean deletUser(String[] flag) {
    String value = "";
    int start = 0;
    for (int a = 0; a < flag.length; a++) {
        if (start == 0) {
            value += "'" + flag[a] + "'";
            start++;
        } else
            value += ",'" + flag[a] + "'";
    }
    String sql = "delete from manager_form where user_number in (" + value + ") ;";
    Mysql_operation mop = new Mysql_operation();
    if (mop.sql_opWord(sql))
        return true;
    else
        return false;
}

######


public boolean deletStu(String[] flag) {
    String value = "";
    int start = 0;
    for (int a = 0; a < flag.length; a++) {
        if (start == 0) {
            value += "'" + flag[a] + "'";
            start++;
        } else
            value += ",'" + flag[a] + "'";
    }
    String sql = "delete from student where user_number in (" + value + ") ;";
    String sql2 = "delete from student_basic_news where user_number in (" + value + ") ;";
    String sql3 = "delete from student_marks where user_number in (" + value + ") ;";
    boolean a;
    boolean b;
    boolean c;
    Mysql_operation mop = new Mysql_operation();
    if (mop.sql_opWord(sql))
        a = true;
    else
        a = false;
    if (mop.sql_opWord(sql))
        a = true;
    else
        a = false;
    if (mop.sql_opWord(sql2))
        b = true;
    else
        b = false;
    if (mop.sql_opWord(sql3))
        c = true;
    else
        c = false;
    if (a && b && c)
        return true;
    else
        return false;
}

######


public static void main(String[] aggs) {
    Manager_op mop = new Manager_op();
    mop.getStudentLimt("manager_form", "user_number", "123456");
    ArrayList<String> a = null;
    a = mop.getSelectValues("123456", "student_major");
    for (int b = 0; b < a.size(); b++) {
    }
}

######


@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getSupportActionBar().hide();
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
    setContentView(R.layout.manager_register_layout);
    initViews();
}

######


public void initViews() {
    code = findViewById(R.id.manafer_register_info);
    name = findViewById(R.id.manager_register_name);
    firstPassword = findViewById(R.id.manager_register_first_password);
    secondPassword = findViewById(R.id.manager_register_second_password);
}

######


public void register(View v) {
    String codeinfo = code.getText().toString().trim();
    if (codeinfo.equals("10086")) {
        String nameinfo = name.getText().toString().trim();
        String firstpassinfo = firstPassword.getText().toString().trim();
        String secondpassinfo = secondPassword.getText().toString().trim();
        dbHelper = MydatabaseHelper.getInstance(this);
        SQLiteDatabase db = dbHelper.getReadableDatabase();
        if (firstpassinfo.matches("[0-9]{6}")) {
            if (firstpassinfo.equals(secondpassinfo)) {
                Cursor cursor = db.rawQuery("select name from manager where name=? ", new String[] { nameinfo });
                if (cursor.moveToNext()) {
                    Toast.makeText(this, "用户名已存在", Toast.LENGTH_LONG).show();
                } else {
                    db.execSQL("insert into manager (name,password) values(?,?)", new String[] { nameinfo, firstpassinfo });
                    Intent intent = new Intent(this, Manager_login_Activity.class);
                    intent.putExtra("username", nameinfo);
                    startActivity(intent);
                    Toast.makeText(this, "注册成功!", Toast.LENGTH_LONG).show();
                }
            } else {
                Toast.makeText(this, "两次密码不相同", Toast.LENGTH_LONG).show();
            }
        } else {
            Toast.makeText(this, "密码为6个纯数字", Toast.LENGTH_LONG).show();
        }
    } else {
        Toast.makeText(this, "注册码错误", Toast.LENGTH_LONG).show();
    }
}

######


@Override
public Manuale doRetriveById(Object... id) {
    String titolo = (String) id[0];
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveByTitoloQuery);
        prst.setString(1, titolo);
        try {
            ResultSet rs = prst.executeQuery();
            con.commit();
            Manuale manuale = null;
            if (rs.next()) {
                manuale = new Manuale(rs.getString("CodVolume"), rs.getString("Titolo"), rs.getInt("Edizione"), rs.getString("DataPubblicazione"), rs.getInt("DurataMaxPrestito"), rs.getString("Lingua"), rs.getString("DenominazioneEditore"), rs.getString("CittaEditore"), rs.getString("Categoria"));
            }
            rs.close();
            return manuale;
        } catch (SQLException e) {
            con.rollback();
            return null;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
        return null;
    }
}

######


@Override
public List<Manuale> doRetriveAll() {
    List<Manuale> manuali = new ArrayList<>();
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveAllQuery);
        try {
            ResultSet rs = prst.executeQuery();
            while (rs.next()) {
                Manuale man = new Manuale(rs.getString("Codice"), rs.getString("Titolo"), rs.getInt("Edizione"), rs.getString("DataPubblicazione"), rs.getInt("DurataMaxPrestito"), rs.getString("Lingua"), rs.getString("DenominazioneEditore"), rs.getString("CittaEditore"), rs.getString("categoria"));
                String isbn = rs.getString("Codice");
                man.setAutori(new AutoreDAO().doRetriveByLibro(isbn));
                man.setCopie(new CopiaDAO().doRetriveAllById(isbn));
                manuali.add(man);
            }
            rs.close();
        } catch (SQLException e) {
            con.rollback();
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
    }
    return manuali;
}

######


@Override
public int doInsert(Manuale manuale) {
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doInsertQuery, PreparedStatement.RETURN_GENERATED_KEYS);
        prst.setString(1, manuale.getCodice());
        prst.setString(2, manuale.getCategoria());
        try {
            prst.execute();
            con.commit();
            ResultSet rs = prst.getGeneratedKeys();
            return 1;
        } catch (SQLException e) {
            con.rollback();
            e.printStackTrace();
            return -1;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException e) {
        return -1;
    }
}

######


@Override
public int doUpdate(Manuale entity) {
    throw new UnsupportedOperationException("Not supported yet.");
}

######


@Select("select * from users where id = #{foo}")
User getUserById(Integer id);

######


@Select("select * from users where id = #{id} and name = #{name}")
User getUserByIdAndName(Integer id, String name);

######


List<User> getUsersByIdList(List<Integer> ids);

######


List<User> getUsersByIdListAndName(List<Integer> ids, String name);

######


@Override
User getUserXML();

######


@Override
@Select("select * from users where id = 2")
User getUserAnnotated();

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("datatypesTest", "type_longvarchar TEXT NULL");
    createTable("mysqlcompatibilitytest", "id int not null primary key auto_increment, test bit(1)");
}

######


@Test
public void datatypesTest() throws SQLException {
    try (Statement stmt = sharedConnection.createStatement()) {
        try (PreparedStatement preparedStmt = sharedConnection.prepareStatement("INSERT INTO `datatypesTest` (`type_longvarchar`) VALUES ( ? )")) {
            preparedStmt.setObject(1, "longvarcharTest", Types.LONGVARCHAR);
            preparedStmt.executeUpdate();
        }
        ResultSet rs = stmt.executeQuery("SELECT * FROM datatypesTest");
        stmt.close();
        if (rs.next()) {
            assertEquals("longvarcharTest", rs.getString(1));
        } else {
            fail();
        }
    }
}

######


@Test
public void testBitConj102() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("insert into mysqlcompatibilitytest values(null, b'0')");
    stmt.execute("insert into mysqlcompatibilitytest values(null, b'1')");
    ResultSet rs = stmt.executeQuery("select * from mysqlcompatibilitytest");
    assertTrue(rs.next());
    assertTrue("0".equalsIgnoreCase(rs.getString(2)));
    assertTrue(rs.next());
    assertTrue("1".equalsIgnoreCase(rs.getString(2)));
}

######


@Test
public void testResetDatabase() throws SQLException {
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=1")) {
        try (Connection connection = pool.getConnection()) {
            Statement statement = connection.createStatement();
            statement.execute("CREATE DATABASE IF NOT EXISTS testingReset");
            connection.setCatalog("testingReset");
        }
        try (Connection connection = pool.getConnection()) {
            assertEquals(database, connection.getCatalog());
            Statement statement = connection.createStatement();
            statement.execute("DROP DATABASE testingReset");
        }
    }
}

######


@Test
public void testResetSessionVariable() throws SQLException {
    testResetSessionVariable(false);
    if ((isMariadbServer() && minVersion(10, 2)) || (!isMariadbServer() && minVersion(5, 7))) {
        testResetSessionVariable(true);
    }
}

######


private void testResetSessionVariable(boolean useResetConnection) throws SQLException {
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=1&useResetConnection=" + useResetConnection)) {
        long nowMillis;
        int initialWaitTimeout;
        try (Connection connection = pool.getConnection()) {
            Statement statement = connection.createStatement();
            nowMillis = getNowTime(statement);
            initialWaitTimeout = getWaitTimeout(statement);
            statement.execute("SET @@timestamp=UNIX_TIMESTAMP('1970-10-01 01:00:00'), @@wait_timeout=2000");
            long newNowMillis = getNowTime(statement);
            int waitTimeout = getWaitTimeout(statement);
            assertTrue(nowMillis - newNowMillis > 23_587_200_000L);
            assertEquals(2_000, waitTimeout);
        }
        try (Connection connection = pool.getConnection()) {
            Statement statement = connection.createStatement();
            long newNowMillis = getNowTime(statement);
            int waitTimeout = getWaitTimeout(statement);
            if (useResetConnection) {
                assertTrue(nowMillis - newNowMillis < 10L);
                assertEquals(initialWaitTimeout, waitTimeout);
            } else {
                assertTrue(nowMillis - newNowMillis > 23_587_200_000L);
                assertEquals(2_000, waitTimeout);
            }
        }
    }
}

######


private long getNowTime(Statement statement) throws SQLException {
    ResultSet rs = statement.executeQuery("SELECT NOW()");
    assertTrue(rs.next());
    return rs.getTimestamp(1).getTime();
}

######


private int getWaitTimeout(Statement statement) throws SQLException {
    ResultSet rs = statement.executeQuery("SELECT @@wait_timeout");
    assertTrue(rs.next());
    return rs.getInt(1);
}

######


@Test
public void testResetUserVariable() throws SQLException {
    testResetUserVariable(false);
    if ((isMariadbServer() && minVersion(10, 2)) || (!isMariadbServer() && minVersion(5, 7))) {
        testResetUserVariable(true);
    }
}

######


private void testResetUserVariable(boolean useResetConnection) throws SQLException {
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=1&useResetConnection=" + useResetConnection)) {
        long nowMillis;
        try (Connection connection = pool.getConnection()) {
            Statement statement = connection.createStatement();
            assertNull(getUserVariableStr(statement));
            statement.execute("SET @str = '123'");
            assertEquals("123", getUserVariableStr(statement));
        }
        try (Connection connection = pool.getConnection()) {
            Statement statement = connection.createStatement();
            if (useResetConnection) {
                assertNull(getUserVariableStr(statement));
            } else {
                assertEquals("123", getUserVariableStr(statement));
            }
        }
    }
}

######


private String getUserVariableStr(Statement statement) throws SQLException {
    ResultSet rs = statement.executeQuery("SELECT @str");
    assertTrue(rs.next());
    return rs.getString(1);
}

######


@Test
public void testNetworkTimeout() throws SQLException {
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=1&socketTimeout=10000")) {
        try (Connection connection = pool.getConnection()) {
            assertEquals(10_000, connection.getNetworkTimeout());
            connection.setNetworkTimeout(null, 5_000);
        }
        try (Connection connection = pool.getConnection()) {
            assertEquals(10_000, connection.getNetworkTimeout());
        }
    }
}

######


@Test
public void testResetReadOnly() throws SQLException {
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=1")) {
        try (Connection connection = pool.getConnection()) {
            assertFalse(connection.isReadOnly());
            connection.setReadOnly(true);
            assertTrue(connection.isReadOnly());
        }
        try (Connection connection = pool.getConnection()) {
            assertFalse(connection.isReadOnly());
        }
    }
}

######


@Test
public void testResetAutoCommit() throws SQLException {
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=1")) {
        try (Connection connection = pool.getConnection()) {
            assertTrue(connection.getAutoCommit());
            connection.setAutoCommit(false);
            assertFalse(connection.getAutoCommit());
        }
        try (Connection connection = pool.getConnection()) {
            assertTrue(connection.getAutoCommit());
        }
    }
}

######


@Test
public void testResetAutoCommitOption() throws SQLException {
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=1&autocommit=false&poolName=PoolTest")) {
        try (Connection connection = pool.getConnection()) {
            assertFalse(connection.getAutoCommit());
            connection.setAutoCommit(true);
            assertTrue(connection.getAutoCommit());
        }
        try (Connection connection = pool.getConnection()) {
            assertFalse(connection.getAutoCommit());
        }
    }
}

######


@Test
public void testResetTransactionIsolation() throws SQLException {
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=1")) {
        try (Connection connection = pool.getConnection()) {
            assertEquals(Connection.TRANSACTION_REPEATABLE_READ, connection.getTransactionIsolation());
            connection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
            assertEquals(Connection.TRANSACTION_SERIALIZABLE, connection.getTransactionIsolation());
        }
        try (Connection connection = pool.getConnection()) {
            assertEquals(Connection.TRANSACTION_REPEATABLE_READ, connection.getTransactionIsolation());
        }
    }
}

######


@Test
public void testJmx() throws Exception {
    MBeanServer server = ManagementFactory.getPlatformMBeanServer();
    ObjectName filter = new ObjectName("org.mariadb.jdbc.pool:type=PoolTestJmx-*");
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=5&minPoolSize=0&poolName=PoolTestJmx")) {
        try (Connection connection = pool.getConnection()) {
            Set<ObjectName> objectNames = server.queryNames(filter, null);
            assertEquals(1, objectNames.size());
            ObjectName name = objectNames.iterator().next();
            MBeanInfo info = server.getMBeanInfo(name);
            assertEquals(4, info.getAttributes().length);
            checkJmxInfo(server, name, 1, 1, 0, 0);
            try (Connection connection2 = pool.getConnection()) {
                checkJmxInfo(server, name, 2, 2, 0, 0);
            }
            checkJmxInfo(server, name, 1, 2, 1, 0);
        }
    }
}

######


@Test
public void testNoMinConnection() throws Exception {
    MBeanServer server = ManagementFactory.getPlatformMBeanServer();
    ObjectName filter = new ObjectName("org.mariadb.jdbc.pool:type=testNoMinConnection-*");
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=5&poolName=testNoMinConnection")) {
        try (Connection connection = pool.getConnection()) {
            Set<ObjectName> objectNames = server.queryNames(filter, null);
            assertEquals(1, objectNames.size());
            ObjectName name = objectNames.iterator().next();
            MBeanInfo info = server.getMBeanInfo(name);
            assertEquals(4, info.getAttributes().length);
            try {
                Thread.sleep(sharedIsAurora() ? 10_000 : 500);
            } catch (InterruptedException interruptEx) {
            }
            checkJmxInfo(server, name, 1, 5, 4, 0);
            try (Connection connection2 = pool.getConnection()) {
                checkJmxInfo(server, name, 2, 5, 3, 0);
            }
            checkJmxInfo(server, name, 1, 5, 4, 0);
        }
    }
}

######


@Test
public void testIdleTimeout() throws Throwable {
    Assume.assumeTrue(System.getenv("MAXSCALE_VERSION") == null && System.getenv("APPVEYOR_BUILD_WORKER_IMAGE") == null);
    MBeanServer server = ManagementFactory.getPlatformMBeanServer();
    ObjectName filter = new ObjectName("org.mariadb.jdbc.pool:type=testIdleTimeout-*");
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=5&minPoolSize=3&poolName=testIdleTimeout")) {
        pool.testForceMaxIdleTime(sharedIsAurora() ? 10 : 3);
        Thread.sleep(sharedIsAurora() ? 5_000 : 1_000);
        Set<ObjectName> objectNames = server.queryNames(filter, null);
        ObjectName name = objectNames.iterator().next();
        checkJmxInfo(server, name, 0, 3, 3, 0);
        List<Long> initialThreadIds = pool.testGetConnectionIdleThreadIds();
        Thread.sleep(sharedIsAurora() ? 12_000 : 3_500);
        checkJmxInfo(server, name, 0, 3, 3, 0);
        List<Long> threadIds = pool.testGetConnectionIdleThreadIds();
        assertEquals(initialThreadIds.size(), threadIds.size());
        for (Long initialThread : initialThreadIds) {
            assertFalse(threadIds.contains(initialThread));
        }
    }
}

######


@Test
public void testMinConnection() throws Throwable {
    MBeanServer server = ManagementFactory.getPlatformMBeanServer();
    ObjectName filter = new ObjectName("org.mariadb.jdbc.pool:type=testMinConnection-*");
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=5&minPoolSize=3&poolName=testMinConnection")) {
        try (Connection connection = pool.getConnection()) {
            Set<ObjectName> objectNames = server.queryNames(filter, null);
            assertEquals(1, objectNames.size());
            ObjectName name = objectNames.iterator().next();
            MBeanInfo info = server.getMBeanInfo(name);
            assertEquals(4, info.getAttributes().length);
            Thread.sleep(sharedIsAurora() ? 5000 : 500);
            checkJmxInfo(server, name, 1, 3, 2, 0);
            try (Connection connection2 = pool.getConnection()) {
                checkJmxInfo(server, name, 2, 3, 1, 0);
            }
            checkJmxInfo(server, name, 1, 3, 2, 0);
        }
    }
}

######


private void checkJmxInfo(MBeanServer server, ObjectName name, long expectedActive, long expectedTotal, long expectedIdle, long expectedRequest) throws Exception {
    assertEquals(expectedActive, ((Long) server.getAttribute(name, "ActiveConnections")).longValue());
    assertEquals(expectedTotal, ((Long) server.getAttribute(name, "TotalConnections")).longValue());
    assertEquals(expectedIdle, ((Long) server.getAttribute(name, "IdleConnections")).longValue());
    assertEquals(expectedRequest, ((Long) server.getAttribute(name, "ConnectionRequests")).longValue());
}

######


@Test
public void testJmxDisable() throws Exception {
    MBeanServer server = ManagementFactory.getPlatformMBeanServer();
    ObjectName filter = new ObjectName("org.mariadb.jdbc.pool:type=PoolTest-*");
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=2&registerJmxPool=false&poolName=PoolTest")) {
        try (Connection connection = pool.getConnection()) {
            Set<ObjectName> objectNames = server.queryNames(filter, null);
            assertEquals(0, objectNames.size());
        }
    }
}

######


@Test
public void testResetRollback() throws SQLException {
    createTable("testResetRollback", "id int not null primary key auto_increment, test varchar(20)");
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=1")) {
        try (Connection connection = pool.getConnection()) {
            Statement stmt = connection.createStatement();
            stmt.executeUpdate("INSERT INTO testResetRollback (test) VALUES ('heja')");
            connection.setAutoCommit(false);
            stmt.executeUpdate("INSERT INTO testResetRollback (test) VALUES ('japp')");
        }
        try (Connection connection = pool.getConnection()) {
            Statement stmt = connection.createStatement();
            ResultSet rs = stmt.executeQuery("SELECT count(*) FROM testResetRollback");
            assertTrue(rs.next());
            assertEquals(1, rs.getInt(1));
        }
    }
}

######


@Test
public void ensureUsingPool() throws Exception {
    ThreadPoolExecutor connectionAppender = new ThreadPoolExecutor(50, 5000, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<>(5000), new MariaDbThreadFactory("testPool"));
    final long start = System.currentTimeMillis();
    Set<Integer> threadIds = new HashSet<>();
    for (int i = 0; i < 500; i++) {
        connectionAppender.execute(() -> {
            try (Connection connection = DriverManager.getConnection(connUri + "&pool&staticGlobal&poolName=PoolEnsureUsingPool&log=true")) {
                Statement stmt = connection.createStatement();
                ResultSet rs = stmt.executeQuery("SELECT CONNECTION_ID()");
                rs.next();
                Integer connectionId = rs.getInt(1);
                threadIds.add(connectionId);
                stmt.execute("SELECT * FROM mysql.user");
            } catch (SQLException e) {
                e.printStackTrace();
            }
        });
    }
    connectionAppender.shutdown();
    connectionAppender.awaitTermination(sharedIsAurora() ? 200 : 30, TimeUnit.SECONDS);
    int numberOfConnection = 0;
    for (Integer integer : threadIds) {
        System.out.println("Connection id : " + integer);
        numberOfConnection++;
    }
    System.out.println("Size : " + threadIds.size() + " " + numberOfConnection);
    assertTrue("connection ids must be less than 8 : " + numberOfConnection, numberOfConnection <= 8);
    assertTrue(System.currentTimeMillis() - start < (sharedIsAurora() ? 120_000 : 5_000));
    Pools.close("PoolTest");
}

######


@Test
public void ensureClosed() throws Throwable {
    Thread.sleep(500);
    int initialConnection = getCurrentConnections();
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=10&minPoolSize=1")) {
        try (Connection connection = pool.getConnection()) {
            connection.isValid(10_000);
        }
        assertTrue(getCurrentConnections() > initialConnection);
        try (Connection connection = pool.getConnection()) {
            connection.isValid(10_000);
        }
        Thread.sleep(500);
        assertTrue(getCurrentConnections() > initialConnection);
    }
    Thread.sleep(500);
    assertEquals(initialConnection, getCurrentConnections());
}

######


@Test
public void wrongUrlHandling() throws SQLException {
    int initialConnection = getCurrentConnections();
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource("jdbc:mariadb://unknownHost/db?user=wrong&maxPoolSize=10&connectTimeout=500")) {
        pool.initialize();
        long start = System.currentTimeMillis();
        try (Connection connection = pool.getConnection()) {
            fail();
        } catch (SQLException sqle) {
            assertTrue("timeout does not correspond to option. Elapsed time:" + (System.currentTimeMillis() - start), (System.currentTimeMillis() - start) >= 500 && (System.currentTimeMillis() - start) < 700);
            assertTrue(sqle.getMessage().contains("No connection available within the specified time (option 'connectTimeout': 500 ms)"));
        }
    }
}

######


@Test
public void testPrepareReset() throws SQLException {
    try (MariaDbPoolDataSource pool = new MariaDbPoolDataSource(connUri + "&maxPoolSize=1&useServerPrepStmts=true&useResetConnection")) {
        try (Connection connection = pool.getConnection()) {
            PreparedStatement preparedStatement = connection.prepareStatement("SELECT ?");
            preparedStatement.setString(1, "1");
            preparedStatement.execute();
        }
        try (Connection connection = pool.getConnection()) {
            PreparedStatement preparedStatement = connection.prepareStatement("SELECT ?");
            preparedStatement.setString(1, "1");
            preparedStatement.execute();
        }
    }
}

######


public Long getId() {
    return id;
}

######


public void setId(Long id) {
    this.id = id;
}

######


@Override
public int hashCode() {
    int hash = 0;
    hash += (id != null ? id.hashCode() : 0);
    return hash;
}

######


public boolean isKodeNoChange(String kode) {
    if (kode.equalsIgnoreCase(this.kodeMataAnggaran)) {
        return true;
    } else {
        return false;
    }
}

######


public boolean isNamaNoChange(String nama) {
    if (nama.equalsIgnoreCase(this.namaMataAnggaran)) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public String toString() {
    return "apdol.entity.MataAnggaran[ id=" + id + " ]";
}

######


public String getKodeMataAnggaran() {
    return kodeMataAnggaran;
}

######


public void setKodeMataAnggaran(String kode) {
    this.kodeMataAnggaran = kode;
}

######


public String getNamaMataAnggaran() {
    return namaMataAnggaran;
}

######


public void setNamaMataAnggaran(String nama) {
    this.namaMataAnggaran = nama;
}

######


public String getNamaBKPK() {
    return namaBKPK;
}

######


public void setNamaBKPK(String nama) {
    this.namaBKPK = nama;
}

######


@Query("select m from messages m where m.user_id = ?1 and m.status=false")
List<Message> findByUserId(Long userId);

######


@Query("select m from messages m where m.id = ?1 and m.status=false")
Message findByMsgId(Long userId);

######


public static Model getInstance() {
    if (Model.instance == null) {
        Model.instance = new Model();
    }
    return Model.instance;
}

######


public List<User> getUserList() {
    userList.clear();
    try {
        String statement = "SELECT * FROM User";
        PreparedStatement preparedStatement = connection.prepareStatement(statement);
        ResultSet resultset = preparedStatement.executeQuery();
        while (resultset.next()) {
            User user = new User();
            user.setFirstname(resultset.getString("Firstname"));
            user.setLastname(resultset.getString("Lastname"));
            user.setPassword(resultset.getString("Password"));
            user.setEmail(resultset.getString("Email"));
            user.setUserID(resultset.getInt("UserID"));
            userList.add(user);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return userList;
}

######


public void createUser(String firstname, String lastname, String email, String password) {
    String statement = "INSERT INTO User(Firstname, Lastname, Email, Password)" + "VALUES(?,?,?,?)";
    try {
        PreparedStatement preparedStatement = connection.prepareStatement(statement);
        preparedStatement.setString(1, firstname);
        preparedStatement.setString(2, lastname);
        preparedStatement.setString(3, email);
        preparedStatement.setString(4, password);
        preparedStatement.execute();
        System.out.println("Folgender User wurde in DB erstelle: " + firstname + " " + lastname);
    } catch (SQLException e) {
        System.out.println("User: " + firstname + " " + lastname + " konnte nicht erstellt werden!!");
        e.printStackTrace();
    }
}

######


public void deleteUser(String email, String password) {
    User user = new User();
    user.setEmail(email);
    int id = 0;
    try {
        id = getUserIdByEmail(user);
    } catch (SQLException e1) {
        e1.printStackTrace();
    }
    user.setUserID(id);
    List<Advert> userAdvert = getUserAdvertList(id);
    for (Advert advert : userAdvert) {
        deleteAdvert(advert.getId(), user.getUserID());
        System.out.println("Loscht Anzeige des Users: " + advert.getCategory());
    }
    if (id != 0) {
        try {
            String statement = "DELETE FROM User WHERE Email = ? AND Password = ?";
            PreparedStatement preparedStatement = connection.prepareStatement(statement);
            preparedStatement.setString(1, email);
            preparedStatement.setString(2, password);
            preparedStatement.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

######


public void setUserList(List<User> userList) {
    Model.getInstance().userList = userList;
}

######


public void setUserAdvertList(List<Advert> userAdvertList) {
    Model.getInstance().userAdvertList = userAdvertList;
}

######


public User getUserById(String id) {
    PreparedStatement preparedStatement;
    try {
        String statement = "SELECT * FROM User WHERE UserId = ?";
        preparedStatement = connection.prepareStatement(statement);
        preparedStatement.setString(1, id);
        ResultSet resultset = preparedStatement.executeQuery();
        User user;
        while (resultset.next()) {
            user = new User();
            user.setEmail(resultset.getString("Email"));
            user.setFirstname(resultset.getString("Firstname"));
            user.setLastname(resultset.getString("Lastname"));
            return user;
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return null;
}

######


public int getUserIdByEmail(User user) throws SQLException {
    String statement = "SELECT UserID FROM User WHERE Email = ?";
    int id = 0;
    String email = user.getEmail();
    PreparedStatement preparedStatement = connection.prepareStatement(statement);
    preparedStatement.setString(1, email);
    ResultSet resultset = preparedStatement.executeQuery();
    while (resultset.next()) {
        id = resultset.getInt("UserId");
    }
    return id;
}

######


public List<Advert> getAdvertList() {
    advertList.clear();
    try {
        String statement = "SELECT * FROM Advert Order BY AdvertId DESC";
        PreparedStatement preparedStatement = connection.prepareStatement(statement);
        ResultSet resultset = preparedStatement.executeQuery();
        while (resultset.next()) {
            Advert advert = new Advert();
            advert.setKind(resultset.getString("Kind"));
            advert.setCategory(resultset.getString("Category"));
            advert.setUser(getUserById(resultset.getString("AdvertUserID")));
            advert.setDescription(resultset.getString("Description"));
            advert.setId(resultset.getInt("AdvertID"));
            advert.setAddress(getAddress(advert.getId()));
            advert.setDate(resultset.getString("Date"));
            advertList.add(advert);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return advertList;
}

######


public List<Advert> getAdvertList(String category) {
    advertList.clear();
    try {
        String statement = "SELECT * FROM Advert WHERE Category = ? Order BY AdvertId DESC";
        PreparedStatement preparedStatement = connection.prepareStatement(statement);
        preparedStatement.setString(1, category);
        ResultSet resultset = preparedStatement.executeQuery();
        while (resultset.next()) {
            Advert advert = new Advert();
            advert.setKind(resultset.getString("Kind"));
            advert.setCategory(resultset.getString("Category"));
            advert.setUser(getUserById(resultset.getString("AdvertUserID")));
            advert.setDescription(resultset.getString("Description"));
            advert.setId(resultset.getInt("AdvertID"));
            advert.setAddress(getAddress(advert.getId()));
            advert.setDate(resultset.getString("Date"));
            advertList.add(advert);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return advertList;
}

######


private Address getAddress(int advertID) {
    String statement = "SELECT ad.Street, ad.Postcode, ad.City, ad.Country, aa.Address FROM Address ad, AdvertAddress aa WHERE aa.Advert = ? AND aa.Address = ad.AddressID";
    try {
        PreparedStatement preparedStatement = connection.prepareStatement(statement);
        preparedStatement.setInt(1, advertID);
        ResultSet resultSet = preparedStatement.executeQuery();
        while (resultSet.next()) {
            Address address = new Address();
            address.setStreet(resultSet.getString("Street"));
            address.setPostcode(resultSet.getString("Postcode"));
            address.setCity(resultSet.getString("City"));
            address.setCountry(resultSet.getString("Country"));
            return address;
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return null;
}

######


public List<Advert> getUserAdvertList(int userId) {
    userAdvertList.clear();
    try {
        String statement = "SELECT * FROM Advert WHERE AdvertUserID = ? Order BY AdvertId DESC";
        PreparedStatement preparedStatement = connection.prepareStatement(statement);
        preparedStatement.setInt(1, userId);
        ResultSet resultset = preparedStatement.executeQuery();
        while (resultset.next()) {
            Advert advert = new Advert();
            advert.setKind(resultset.getString("Kind"));
            advert.setCategory(resultset.getString("Category"));
            advert.setUser(getUserById(resultset.getString("AdvertUserID")));
            advert.setDescription(resultset.getString("Description"));
            advert.setId(resultset.getInt("AdvertID"));
            advert.setDate(resultset.getString("Date"));
            userAdvertList.add(advert);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return userAdvertList;
}

######


public void createAdvert(String optradio, String kategorie, String comment, User user, String street, String postcode, String city, String country) {
    try {
        int addressID = address(street, postcode, city, country);
        int advertID = advert(user, optradio, kategorie, comment);
        advertAddress(addressID, advertID);
        System.out.println("Folgendes Angebot wurde erstellt " + user.getFirstname() + "  " + street);
    } catch (SQLException e) {
        System.out.println("Fehler beim erstellen");
        e.printStackTrace();
    }
}

######


public static void setAdvertList(List<Advert> advertList) {
    Model.getInstance().advertList = advertList;
}

######


private void advertAddress(int addressID, int advertID) throws SQLException {
    String statement = "INSERT INTO AdvertAddress(Address, Advert)" + "VALUES(?,?)";
    PreparedStatement preparedStatement;
    preparedStatement = connection.prepareStatement(statement);
    preparedStatement.setInt(1, addressID);
    preparedStatement.setInt(2, advertID);
    preparedStatement.executeUpdate();
}

######


private int address(String street, String postcode, String city, String country) throws SQLException {
    String statement = "INSERT INTO ADDRESS (Street, Postcode, City, Country)" + "VALUES(?,?,?,?)";
    PreparedStatement preparedStatement = connection.prepareStatement(statement);
    preparedStatement.setString(1, street);
    preparedStatement.setString(2, postcode);
    preparedStatement.setString(3, city);
    preparedStatement.setString(4, country);
    preparedStatement.executeUpdate();
    int id;
    statement = "SELECT * FROM Address ORDER BY AddressID DESC LIMIT 1";
    preparedStatement = connection.prepareStatement(statement);
    ResultSet resultset = preparedStatement.executeQuery();
    while (resultset.next()) {
        id = resultset.getInt("AddressID");
        return id;
    }
    return 0;
}

######


private int advert(User user, String optradio, String kategorie, String comment) throws SQLException {
    String statement = "INSERT INTO Advert (AdvertUserID, Date, Kind, Category, Description)" + "VALUES(?,?,?,?,?)";
    PreparedStatement preparedStatement = connection.prepareStatement(statement);
    preparedStatement.setInt(1, getUserIdByEmail(user));
    preparedStatement.setString(2, createCurrentDate());
    preparedStatement.setString(3, optradio);
    preparedStatement.setString(4, kategorie);
    preparedStatement.setString(5, comment);
    preparedStatement.executeUpdate();
    int id;
    statement = "SELECT * FROM Advert ORDER BY AdvertID DESC LIMIT 1";
    preparedStatement = connection.prepareStatement(statement);
    ResultSet resultset = preparedStatement.executeQuery();
    while (resultset.next()) {
        id = resultset.getInt("AdvertID");
        return id;
    }
    return 0;
}

######


private String createCurrentDate() {
    GregorianCalendar calendar = new GregorianCalendar();
    DateFormat df = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM);
    System.out.println(df.format(calendar.getTime()));
    return df.format(calendar.getTime());
}

######


public void deleteAdvert(int id, int userID) {
    boolean allowed = false;
    try {
        allowed = checkAuthorization(id, userID);
    } catch (SQLException e1) {
        e1.printStackTrace();
    }
    if (allowed) {
        try {
            int addressID = getAddressID(id);
            String statement1 = "DELETE FROM Advert WHERE AdvertID = ?";
            PreparedStatement preparedStatement1 = connection.prepareStatement(statement1);
            preparedStatement1.setInt(1, id);
            preparedStatement1.executeUpdate();
            String statement2 = "DELETE FROM AdvertAddress WHERE Advert = ?";
            PreparedStatement preparedStatement2 = connection.prepareStatement(statement2);
            preparedStatement2.setInt(1, id);
            preparedStatement2.executeUpdate();
            String statement3 = "DELETE FROM Address WHERE AddressID = ?";
            PreparedStatement preparedStatement3 = connection.prepareStatement(statement3);
            preparedStatement3.setInt(1, addressID);
            preparedStatement3.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    } else {
        System.out.println("User not authorized");
    }
}

######


private int getAddressID(int id) throws SQLException {
    String statement = "SELECT Address FROM AdvertAddress WHERE Advert = ?";
    PreparedStatement preparedStatement = connection.prepareStatement(statement);
    preparedStatement.setInt(1, id);
    ResultSet resultset = preparedStatement.executeQuery();
    while (resultset.next()) {
        id = resultset.getInt("Address");
        return id;
    }
    return 0;
}

######


public boolean checkAuthorization(int id, int userID) throws SQLException {
    String statement = "SELECT * FROM Advert WHERE AdvertId = ? AND AdvertUserID = ?";
    PreparedStatement preparedStatement = connection.prepareStatement(statement);
    preparedStatement.setInt(1, id);
    preparedStatement.setInt(2, userID);
    ResultSet resultset = preparedStatement.executeQuery();
    if (resultset != null) {
        return true;
    } else {
        return false;
    }
}

######


public void initDatabase() {
    try {
        PreparedStatement preparedStatement = connection.prepareStatement("SELECT * FROM User");
        PreparedStatement preparedStatement2 = connection.prepareStatement("SELECT * FROM Advert");
        PreparedStatement preparedStatement3 = connection.prepareStatement("SELECT * FROM Address");
        PreparedStatement preparedStatement4 = connection.prepareStatement("SELECT * FROM AdvertAddress");
        preparedStatement.execute();
        preparedStatement2.execute();
        preparedStatement3.execute();
        preparedStatement4.execute();
        System.out.println(dbExist);
        dbExist = true;
    } catch (SQLException e) {
        dbExist = false;
    }
    if (!dbExist) {
        System.out.println("Call initTables()");
        initTables(createUserStatement);
        initTables(createAdvertStatement);
        initTables(createAddressStatement);
        initTables(createAdvertAddressStatement);
        createDummyData();
        dbExist = true;
    } else {
        System.out.println("Database already exists!");
    }
}

######


private void createDummyData() {
    User user = new User();
    user.setFirstname("User");
    user.setLastname("User");
    user.setEmail("user.user@gmail.com");
    user.setPassword(BCrypt.hashpw("user", BCrypt.gensalt()));
    createUser(user.getFirstname(), user.getLastname(), user.getEmail(), user.getPassword());
    System.out.println("Dummy user Created: " + user.getEmail());
    createAdvert("Gesuch", "Gartengeräte", "Ich suche einen Rasenmäher", user, "Brauneggerstrasse 55", "78462", "Konstanz", "Deutschland");
    createAdvert("Angebot", "Fahrzeuge", "Ich biete meinen VW Bus an. Wenn jemand umziehen möchte", user, "Rheingutstrasse 4", "78462", "Konstanz", "Deutschland");
    System.out.println("Dummy advert created:");
}

######


private void initTables(String tablename) {
    try {
        PreparedStatement preparedStatement = connection.prepareStatement(tablename);
        preparedStatement.executeUpdate();
        System.out.println("Create " + tablename + " in given Database");
    } catch (SQLException e) {
        System.out.println("tables already exist");
    }
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
}

######


public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException {
    final java.lang.String _jspx_method = request.getMethod();
    if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method) && !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET POST or HEAD");
        return;
    }
    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;
    try {
        response.setContentType("text/html");
        pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true);
        _jspx_page_context = pageContext;
        application = pageContext.getServletContext();
        config = pageContext.getServletConfig();
        session = pageContext.getSession();
        out = pageContext.getOut();
        _jspx_out = out;
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        int j = Integer.parseInt(request.getParameter("no"));
        for (int i = 0; i < j; i++) {
            String typeofgood = request.getParameter("type_");
            int cap = Integer.parseInt(request.getParameter("cap_"));
            int costoftruck = Integer.parseInt(request.getParameter("cost_"));
            float residualvalueoftruck = Float.parseFloat(request.getParameter("residual_"));
            int yearsemi = Integer.parseInt(request.getParameter("years_"));
            float loanpercentage = Float.parseFloat(request.getParameter("loan_"));
            float rateofintrest = Float.parseFloat(request.getParameter("roi_"));
            float flatroi = Float.parseFloat(request.getParameter("flatroi_"));
            String sql = "Update `truckparam`  Set capacity=" + cap + ",costoftruck=" + costoftruck + ",residualvalueoftruck=" + residualvalueoftruck + ",yearsemi=" + yearsemi + ",loanpercentage=" + loanpercentage + ",rateofintrest=" + rateofintrest + ",flatroi=" + flatroi + "where typeofgood=?";
            try {
                Connection con = Connect.getconnection();
                PreparedStatement ps = con.prepareStatement(sql);
                ps.setString(1, typeofgood);
                ps.executeUpdate();
            } catch (Exception e) {
                e.printStackTrace();
                RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
                ReqDis.forward(request, response);
            }
        }
        RequestDispatcher ReqDis = request.getRequestDispatcher("adminCapex.jsp");
        ReqDis.forward(request, response);
    } catch (java.lang.Throwable t) {
        if (!(t instanceof javax.servlet.jsp.SkipPageException)) {
            out = _jspx_out;
            if (out != null && out.getBufferSize() != 0)
                try {
                    if (response.isCommitted()) {
                        out.flush();
                    } else {
                        out.clearBuffer();
                    }
                } catch (java.io.IOException e) {
                }
            if (_jspx_page_context != null)
                _jspx_page_context.handlePageException(t);
            else
                throw new ServletException(t);
        }
    } finally {
        _jspxFactory.releasePageContext(_jspx_page_context);
    }
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
}

######


public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException {
    final java.lang.String _jspx_method = request.getMethod();
    if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method) && !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET POST or HEAD");
        return;
    }
    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;
    try {
        response.setContentType("text/html");
        pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true);
        _jspx_page_context = pageContext;
        application = pageContext.getServletContext();
        config = pageContext.getServletConfig();
        session = pageContext.getSession();
        out = pageContext.getOut();
        _jspx_out = out;
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        int j = Integer.parseInt(request.getParameter("no"));
        for (int i = 0; i < j; i++) {
            String typeofgood = request.getParameter("type");
            int salary = Integer.parseInt(request.getParameter("salary"));
            int bhatta = Integer.parseInt(request.getParameter("bhatta"));
            int month = Integer.parseInt(request.getParameter("month"));
            int roadtax = Integer.parseInt(request.getParameter("roadtax"));
            int permit = Integer.parseInt(request.getParameter("roadpermit"));
            float insurance = Float.parseFloat(request.getParameter("insurance"));
            int admin = Integer.parseInt(request.getParameter("admin"));
            int tarpaulin = Integer.parseInt(request.getParameter("tarpaulin"));
            int profit = Integer.parseInt(request.getParameter("profit"));
            int loading = Integer.parseInt(request.getParameter("loading"));
            String sql = "UPDATE routeparam SET `driver/cleaner salary`= ?, `driver/cleaner bhatta`= ?, `admin costs`=? WHERE typeofgood=?";
            String sql1 = "UPDATE routeparam SET loadingcharges=?, insuranceaspercentageofvechiclecost=?, maintenancepermonth= ?, roadpermityear=?, roadtaxyear=?, tarpaulin=? WHERE typeofgood=?";
            try {
                Connection con = Connect.getconnection();
                PreparedStatement ps = con.prepareStatement(sql1);
                PreparedStatement ps1 = con.prepareStatement(sql);
                ps.setInt(1, loading);
                ps.setFloat(2, insurance);
                ps.setInt(3, month);
                ps.setInt(4, roadtax);
                ps.setInt(5, permit);
                ps.setInt(6, tarpaulin);
                ps.setString(7, typeofgood);
                ps.executeUpdate();
                ps1.setInt(1, salary);
                ps1.setInt(2, bhatta);
                ps1.setInt(3, admin);
                ps1.setString(4, typeofgood);
                ps1.executeUpdate();
            } catch (Exception e) {
                e.printStackTrace();
                RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
                ReqDis.forward(request, response);
            }
        }
        RequestDispatcher ReqDis = request.getRequestDispatcher("adminfixed.jsp");
        ReqDis.forward(request, response);
    } catch (java.lang.Throwable t) {
        if (!(t instanceof javax.servlet.jsp.SkipPageException)) {
            out = _jspx_out;
            if (out != null && out.getBufferSize() != 0)
                try {
                    if (response.isCommitted()) {
                        out.flush();
                    } else {
                        out.clearBuffer();
                    }
                } catch (java.io.IOException e) {
                }
            if (_jspx_page_context != null)
                _jspx_page_context.handlePageException(t);
            else
                throw new ServletException(t);
        }
    } finally {
        _jspxFactory.releasePageContext(_jspx_page_context);
    }
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
}

######


public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType("text/html");
    int empid = Integer.parseInt(request.getParameter("empid"));
    try {
        HttpSession session = request.getSession();
        UpdateValues(request, response, session);
    } catch (Exception e) {
        e.printStackTrace();
        if (empid == 11) {
            RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
            ReqDis.forward(request, response);
        } else {
            RequestDispatcher ReqDis = request.getRequestDispatcher("error.jsp");
            ReqDis.forward(request, response);
        }
    }
}

######


private void UpdateValues(HttpServletRequest request, HttpServletResponse response, HttpSession session) throws IOException, SQLException, ServletException {
    int empid = Integer.parseInt(request.getParameter("empid"));
    PrintWriter out = response.getWriter();
    Connection con = Connect.getconnection();
    int cap = Integer.parseInt(request.getParameter("cap"));
    int costofTruck = Integer.parseInt(request.getParameter("cost"));
    String Good = request.getParameter("good");
    float residual = Float.parseFloat(request.getParameter("residual"));
    float loan = Float.parseFloat(request.getParameter("loan"));
    int yearsemi = Integer.parseInt(request.getParameter("emi"));
    float roi = Float.parseFloat(request.getParameter("roi"));
    float flatroi = Float.parseFloat(request.getParameter("flatroi"));
    float insurance = Float.parseFloat(request.getParameter("insurance"));
    int tyrelife = Integer.parseInt(request.getParameter("newtyre"));
    int usedtyrelife = Integer.parseInt(request.getParameter("oldtyre"));
    int tyrecost = Integer.parseInt(request.getParameter("newtyrecost"));
    int usedtyrecost = Integer.parseInt(request.getParameter("oldtyrecost"));
    int tyres = Integer.parseInt(request.getParameter("notyre"));
    float dieselcost = Float.parseFloat(request.getParameter("dieselcost"));
    float mileage = Float.parseFloat(request.getParameter("mileage"));
    float mileagewithload = Float.parseFloat(request.getParameter("mileagewithload"));
    int notrip = Integer.parseInt(request.getParameter("notrip"));
    int salary = Integer.parseInt(request.getParameter("salary"));
    int bhatta = Integer.parseInt(request.getParameter("bhatta"));
    float maintenanceMonth = Float.parseFloat(request.getParameter("maintenace"));
    float roadtaxyearly = Float.parseFloat(request.getParameter("roadtax"));
    float roadpermityearly = Float.parseFloat(request.getParameter("roadpermit"));
    int admin = Integer.parseInt(request.getParameter("admincost"));
    int tarpaulin = Integer.parseInt(request.getParameter("tarpaulin"));
    float loading = Float.parseFloat(request.getParameter("loading"));
    float toll = Float.parseFloat(request.getParameter("toll"));
    float routeexpences = Float.parseFloat(request.getParameter("routeexpences"));
    float maintanecekm = Float.parseFloat(request.getParameter("maintanecekm"));
    PreparedStatement ps = con.prepareStatement("UPDATE truckparam SET typeofgood=?, costoftruck=?, residualvalueoftruck=?, loanpercentage=?, yearsemi=?, rateofintrest=?, flatroi=?, tyrelife=?, reusedtyrelife=?, tyrecost=?, reusedtyrecost=?, tyres=?, dieselcost=?, dieselmileage=?, diesealmileagewithload=?,noofTrips=? WHERE Emp_id=? And capacity=?");
    ps.setString(1, Good);
    ps.setInt(2, costofTruck);
    ps.setFloat(3, residual);
    ps.setFloat(4, loan);
    ps.setInt(5, yearsemi);
    ps.setFloat(6, roi);
    ps.setFloat(7, flatroi);
    ps.setInt(8, tyrelife);
    ps.setInt(9, usedtyrelife);
    ps.setInt(10, tyrecost);
    ps.setInt(11, usedtyrecost);
    ps.setInt(12, tyres);
    ps.setFloat(13, dieselcost);
    ps.setFloat(14, mileage);
    ps.setFloat(15, mileagewithload);
    ps.setFloat(16, notrip);
    ps.setInt(17, empid);
    ps.setInt(18, cap);
    ps.executeUpdate();
    PreparedStatement ps1 = con.prepareStatement("UPDATE routeparam SET loadingcharges=?, routeexpenses=?, toll=?, maintenancecostperkm=?, insuranceaspercentageofvechiclecost=?, maintenancepermonth= ?, roadpermityear=?, roadtaxyear=?, tarpaulin=? WHERE Emp_id=? And capacity=?");
    ps1.setFloat(1, loading);
    ps1.setFloat(2, routeexpences);
    ps1.setFloat(3, toll);
    ps1.setFloat(4, maintanecekm);
    ps1.setFloat(5, insurance);
    ps1.setFloat(6, maintenanceMonth);
    ps1.setFloat(7, roadpermityearly);
    ps1.setFloat(8, roadtaxyearly);
    ps1.setFloat(9, tarpaulin);
    ps1.setInt(10, empid);
    ps1.setInt(11, cap);
    ps1.executeUpdate();
    PreparedStatement ps2 = con.prepareStatement("UPDATE routeparam SET driver/cleaner salary= ?, driver/cleaner bhatta= ?, admin costs=? WHERE Emp_id=? And capacity=?");
    ps2.setFloat(1, salary);
    ps2.setFloat(2, bhatta);
    ps2.setInt(3, empid);
    ps2.setInt(4, cap);
    RequestDispatcher ReqDis = request.getRequestDispatcher("Advanced.jsp");
    ReqDis.forward(request, response);
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
}

######


public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
}

######


public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException {
    final java.lang.String _jspx_method = request.getMethod();
    if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method) && !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET POST or HEAD");
        return;
    }
    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;
    try {
        response.setContentType("text/html");
        pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true);
        _jspx_page_context = pageContext;
        application = pageContext.getServletContext();
        config = pageContext.getServletConfig();
        session = pageContext.getSession();
        out = pageContext.getOut();
        _jspx_out = out;
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        int j = Integer.parseInt(request.getParameter("no"));
        for (int i = 0; i < j; i++) {
            String typeofgood = request.getParameter("type");
            int tyrelife = Integer.parseInt(request.getParameter("tyrelife"));
            int reusedtyrelife = Integer.parseInt(request.getParameter("usedtyrelife"));
            int tyrecost = Integer.parseInt(request.getParameter("tyrecost"));
            int reusedtyrecost = Integer.parseInt(request.getParameter("usedtyrecost"));
            int tyres = Integer.parseInt(request.getParameter("tyres"));
            float diesel = Float.parseFloat(request.getParameter("diesel"));
            float mileage = Float.parseFloat(request.getParameter("mileage"));
            float mileagewithload = Float.parseFloat(request.getParameter("mileagewithload"));
            float toll = Float.parseFloat(request.getParameter("toll"));
            float routeexpense = Float.parseFloat(request.getParameter("routeexpense"));
            float maintenance = Float.parseFloat(request.getParameter("maintenance"));
            String sql = "UPDATE truckparam SET tyrelife=?,reusedtyrelife=?,tyrecost=?,reusedtyrecost=?,tyres=?,dieselcost=?,dieselmileage=?,diesealmileagewithload=? where typeofgood=?";
            String sql1 = "UPDATE routeparam SET toll=?,routeexpenses=?,maintenancecostperkm=? where typeofgood=?";
            try {
                Connection con = Connect.getconnection();
                PreparedStatement ps = con.prepareStatement(sql);
                PreparedStatement ps1 = con.prepareStatement(sql1);
                ps.setInt(1, tyrelife);
                ps.setInt(2, reusedtyrelife);
                ps.setInt(3, tyrecost);
                ps.setInt(4, reusedtyrecost);
                ps.setInt(5, tyres);
                ps.setFloat(6, diesel);
                ps.setFloat(7, mileage);
                ps.setFloat(8, mileagewithload);
                ps.setString(9, typeofgood);
                ps1.setFloat(1, toll);
                ps1.setFloat(2, routeexpense);
                ps1.setFloat(3, maintenance);
                ps1.setString(4, typeofgood);
                ps.executeUpdate();
                ps1.executeUpdate();
            } catch (Exception e) {
                e.printStackTrace();
                RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
                ReqDis.forward(request, response);
            }
        }
        RequestDispatcher ReqDis = request.getRequestDispatcher("adminvariable.jsp");
        ReqDis.forward(request, response);
    } catch (java.lang.Throwable t) {
        if (!(t instanceof javax.servlet.jsp.SkipPageException)) {
            out = _jspx_out;
            if (out != null && out.getBufferSize() != 0)
                try {
                    if (response.isCommitted()) {
                        out.flush();
                    } else {
                        out.clearBuffer();
                    }
                } catch (java.io.IOException e) {
                }
            if (_jspx_page_context != null)
                _jspx_page_context.handlePageException(t);
            else
                throw new ServletException(t);
        }
    } finally {
        _jspxFactory.releasePageContext(_jspx_page_context);
    }
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
}

######


public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


public void setModuleDao(IModuleDAO moduleDao) {
    this.moduleDao = moduleDao;
}

######


public Long addModule(Module module) {
    updateLevel(module);
    this.moduleDao.save(module);
    if (module != null && module.getId() != null) {
        return module.getId();
    }
    return null;
}

######


public Module getModule(Long id) {
    Module module = this.moduleDao.get(id);
    return module;
}

######


public boolean delModule(Long id) {
    Module module = this.getModule(id);
    if (module != null) {
        this.moduleDao.remove(id);
        return true;
    }
    return false;
}

######


public boolean batchDelModules(List<Serializable> moduleIds) {
    for (Serializable id : moduleIds) {
        delModule((Long) id);
    }
    return true;
}

######


public IPageList getModuleBy(IQueryObject queryObject) {
    return QueryUtil.query(queryObject, Module.class, this.moduleDao);
}

######


public boolean updateModule(Long id, Module module) {
    if (id != null) {
        module.setId(id);
    } else {
        return false;
    }
    updateLevel(module);
    this.moduleDao.update(module);
    return true;
}

######


public String loadTree(Integer currentNodeId) {
    String result = "[";
    String sql;
    if (new Integer(0).equals(currentNodeId))
        sql = "select o from Module o where o.parent is null and o.disabled=0";
    else
        sql = "select o from Module o where o.parent.id=" + currentNodeId + " and o.disabled=0";
    List list = moduleDao.query(sql, null, 0, AppContext.RESULTSIZE);
    for (int i = 0; i < list.size(); i++) {
        Module bean = (Module) list.get(i);
        Long id = bean.getId();
        result += "{id:" + id + ",text:'" + bean.getName() + "(" + bean.getCode() + ")',";
        if (isLeaf(id))
            result += "leaf:true}";
        else
            result += "leaf:false}";
        if (i < list.size() - 1)
            result += ",";
    }
    return result + "]";
}

######


private boolean isLeaf(Long nodeId) {
    String sql = "select o from Module o where o.parent.id=" + nodeId + " and o.disabled=false";
    List list = moduleDao.query(sql, null, 0, 1);
    return list.isEmpty();
}

######


private void updateLevel(Module module) {
    Module parent = module.getParent();
    if (null != parent)
        module.setLevel(parent.getLevel() + "-" + module.getCode());
    else
        module.setLevel(module.getCode());
}

######


@BeforeClass()
public static void beforeClass2() {
    Assume.assumeTrue(initialUrl != null);
}

######


@Before
public void init() {
    Assume.assumeTrue(initialUrl != null);
    defaultUrl = initialUrl;
    currentType = HaMode.NONE;
}

######


@Test
public void checkClosedConnectionAfterFailover() throws Throwable {
    try (Connection connection = getNewConnection("&retriesAllDown=6", true)) {
        Statement st = connection.createStatement();
        int masterServerId = getServerId(connection);
        stopProxy(masterServerId);
        try {
            st.execute("SELECT 1");
            fail();
        } catch (SQLException e) {
        }
        assertTrue(st.isClosed());
        restartProxy(masterServerId);
        try {
            st = connection.createStatement();
            st.execute("SELECT 1");
        } catch (SQLException e) {
            fail();
        }
    }
}

######


@Test
public void checkErrorAfterDeconnection() throws Throwable {
    try (Connection connection = getNewConnection("&retriesAllDown=6", true)) {
        Statement st = connection.createStatement();
        int masterServerId = getServerId(connection);
        stopProxy(masterServerId);
        try {
            st.execute("SELECT 1");
            fail();
        } catch (SQLException e) {
        }
        restartProxy(masterServerId);
        try {
            st.execute("SELECT 1");
            fail();
        } catch (SQLException e) {
        }
        assertTrue(connection.isClosed());
    }
}

######


@Test
public void checkAutoReconnectDeconnection() throws Throwable {
    try (Connection connection = getNewConnection("&retriesAllDown=6", true)) {
        Statement st = connection.createStatement();
        int masterServerId = getServerId(connection);
        stopProxy(masterServerId);
        try {
            st.execute("SELECT 1");
            fail();
        } catch (SQLException e) {
        }
        restartProxy(masterServerId);
        try {
            st = connection.createStatement();
            st.execute("SELECT 1");
        } catch (SQLException e) {
            fail();
        }
        assertFalse(connection.isClosed());
    }
}

######


@Test
public void isValidConnectionThatIsKilledExternally() throws Throwable {
    try (Connection connection = getNewConnection()) {
        connection.setCatalog("mysql");
        Protocol protocol = getProtocolFromConnection(connection);
        try (Connection killerConnection = getNewConnection()) {
            Statement killerStatement = killerConnection.createStatement();
            long threadId = protocol.getServerThreadId();
            killerStatement.execute("KILL CONNECTION " + threadId);
            boolean isValid = connection.isValid(0);
            assertFalse(isValid);
        }
    }
}

######


@Test
public void checkPrepareStatement() throws Throwable {
    try (Connection connection = getNewConnection("&retriesAllDown=6", true)) {
        Statement stmt = connection.createStatement();
        stmt.execute("drop table  if exists failt1");
        stmt.execute("create table failt1 (id int not null primary key auto_increment, tt int)");
        PreparedStatement preparedStatement = connection.prepareStatement("insert into failt1(id, tt) values (?,?)");
        int masterServerId = getServerId(connection);
        stopProxy(masterServerId);
        preparedStatement.setInt(1, 1);
        preparedStatement.setInt(2, 1);
        preparedStatement.addBatch();
        try {
            preparedStatement.executeBatch();
            fail();
        } catch (SQLException e) {
        }
        restartProxy(masterServerId);
    }
}

######


public static synchronized MostAndRecentPlayTableHelper getInstance(Context context) {
    if (mInstance == null) {
        mInstance = new MostAndRecentPlayTableHelper(context);
    }
    return mInstance;
}

######


public void inserSong(SongDetail songDetail) {
    try {
        if (isSongExist(songDetail.getId())) {
            return;
        }
        sampleDB = dbHelper.getDB();
        sampleDB.beginTransaction();
        String sql = "Insert or Replace into " + TABLENAME + " values(?,?,?,?,?,?,?,?,?,?,?);";
        SQLiteStatement insert = sampleDB.compileStatement(sql);
        try {
            if (songDetail != null) {
                insert.clearBindings();
                insert.bindLong(1, songDetail.getId());
                insert.bindLong(2, songDetail.getAlbum_id());
                insert.bindString(3, songDetail.getArtist());
                insert.bindString(4, songDetail.getTitle());
                insert.bindString(5, songDetail.getDisplay_name());
                insert.bindString(6, songDetail.getDuration());
                insert.bindString(7, songDetail.getPath());
                insert.bindString(8, songDetail.audioProgress + "");
                insert.bindString(9, songDetail.audioProgressSec + "");
                insert.bindString(10, System.currentTimeMillis() + "");
                insert.bindLong(11, 1);
                insert.execute();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        sampleDB.setTransactionSuccessful();
    } catch (Exception e) {
        Log.e("XML:", e.toString());
    } finally {
        sampleDB.endTransaction();
    }
}

######


private boolean isSongExist(int id_) {
    Cursor mCursor = null;
    boolean isExist = false;
    try {
        String sqlQuery = "select * from " + TABLENAME + " where " + ID + "=" + id_;
        sampleDB = dbHelper.getDB();
        mCursor = sampleDB.rawQuery(sqlQuery, null);
        if (mCursor != null && mCursor.getCount() >= 1) {
            mCursor.moveToNext();
            long count = mCursor.getLong(mCursor.getColumnIndex(PLAYCOUNT));
            count++;
            updateStatus_(count, id_);
            isExist = true;
        }
        closeCurcor(mCursor);
    } catch (Exception e) {
        closeCurcor(mCursor);
        e.printStackTrace();
    }
    return isExist;
}

######


public void updateStatus_(long count, int musicid) {
    try {
        ContentValues values = new ContentValues();
        values.put(PLAYCOUNT, count);
        long success = sampleDB.update(TABLENAME, values, ID + "=?", new String[] { String.valueOf(musicid) });
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


private void closeCurcor(Cursor cursor) {
    if (cursor != null) {
        cursor.close();
        cursor = null;
    }
}

######


public Cursor getMostPlay() {
    Cursor mCursor = null;
    try {
        String sqlQuery = "Select * from " + TABLENAME + " where " + PLAYCOUNT + ">=2 order by " + LastPlayTime + " ASC limit 20";
        sampleDB = dbHelper.getDB();
        mCursor = sampleDB.rawQuery(sqlQuery, null);
    } catch (Exception e) {
        closeCurcor(mCursor);
        e.printStackTrace();
    }
    return mCursor;
}

######


@Query("SELECT * FROM movie")
LiveData<List<Movie>> loadAllMovies();

######


@Insert
void insertMovie(Movie movie);

######


@Update(onConflict = OnConflictStrategy.REPLACE)
void updateMovie(Movie movie);

######


@Delete()
void deleteMovie(Movie movie);

######


@Query("delete from movie where movie_id = :movieId")
void deleteByMovieId(String movieId);

######


@Query("SELECT * FROM movie WHERE movie_id = :movieId")
LiveData<Movie> getMovieByMovieId(String movieId);

######


static UriMatcher buildUriMatcher() {
    final UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);
    final String authority = MovieContract.CONTENT_AUTHORITY;
    matcher.addURI(authority, MovieContract.PATH_MOVIE, MOVIE);
    matcher.addURI(authority, MovieContract.PATH_MOVIE + "/#", MOVIE_TITLE);
    return matcher;
}

######


@Override
public boolean onCreate() {
    mMovieDbHelper = new MovieDbHelper(getContext());
    return true;
}

######


@Override
public String getType(Uri uri) {
    final int match = sUriMatcher.match(uri);
    switch(match) {
        case MOVIE:
            return MovieContract.MovieEntry.CONTENT_TYPE;
        case MOVIE_TITLE:
            return MovieContract.MovieEntry.CONTENT_ITEM_TYPE;
        default:
            throw new UnsupportedOperationException("Unknown uri: " + uri);
    }
}

######


@Override
public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
    Cursor retCursor;
    switch(sUriMatcher.match(uri)) {
        case MOVIE:
            retCursor = mMovieDbHelper.getReadableDatabase().query(MovieContract.MovieEntry.TABLE_NAME, projection, selection, selectionArgs, null, null, sortOrder);
            break;
        case MOVIE_TITLE:
            retCursor = mMovieDbHelper.getReadableDatabase().query(MovieContract.MovieEntry.TABLE_NAME, projection, MovieContract.MovieEntry._ID + " = ? ", new String[] { String.valueOf(ContentUris.parseId(uri)) }, null, null, sortOrder);
            break;
        default:
            throw new UnsupportedOperationException("Unknown uri: " + uri);
    }
    retCursor.setNotificationUri(getContext().getContentResolver(), uri);
    return retCursor;
}

######


@Override
public Uri insert(Uri uri, ContentValues values) {
    final SQLiteDatabase db = mMovieDbHelper.getWritableDatabase();
    final int match = sUriMatcher.match(uri);
    Uri returnUri;
    switch(match) {
        case MOVIE:
            long _id = db.insert(MovieContract.MovieEntry.TABLE_NAME, null, values);
            if (_id > 0)
                returnUri = MovieContract.MovieEntry.buildMovieUri(_id);
            else
                throw new SQLException("Failed to insert row into " + uri);
            break;
        default:
            throw new UnsupportedOperationException("Unknown uri: " + uri);
    }
    getContext().getContentResolver().notifyChange(uri, null);
    return returnUri;
}

######


@Override
public int delete(Uri uri, String selection, String[] selectionArgs) {
    final SQLiteDatabase db = mMovieDbHelper.getWritableDatabase();
    final int match = sUriMatcher.match(uri);
    int rowsDeleted;
    switch(match) {
        case MOVIE:
            rowsDeleted = db.delete(MovieContract.MovieEntry.TABLE_NAME, selection, selectionArgs);
            db.execSQL("DELETE FROM SQLITE_SEQUENCE WHERE NAME = '" + MovieContract.MovieEntry.TABLE_NAME + "'");
            break;
        case MOVIE_TITLE:
            rowsDeleted = db.delete(MovieContract.MovieEntry.TABLE_NAME, MovieContract.MovieEntry._ID + " = ?", new String[] { String.valueOf(ContentUris.parseId(uri)) });
            db.execSQL("DELETE FROM SQLITE_SEQUENCE WHERE NAME = '" + MovieContract.MovieEntry.TABLE_NAME + "'");
            break;
        default:
            throw new UnsupportedOperationException("Unknown uri: " + uri);
    }
    return rowsDeleted;
}

######


@Override
public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
    final SQLiteDatabase db = mMovieDbHelper.getWritableDatabase();
    final int match = sUriMatcher.match(uri);
    int rowsUpdated;
    if (values == null) {
        throw new IllegalArgumentException("Cannot have null content values");
    }
    switch(match) {
        case MOVIE:
            rowsUpdated = db.update(MovieContract.MovieEntry.TABLE_NAME, values, selection, selectionArgs);
            break;
        case MOVIE_TITLE:
            rowsUpdated = db.update(MovieContract.MovieEntry.TABLE_NAME, values, MovieContract.MovieEntry._ID + " = ?", new String[] { String.valueOf(ContentUris.parseId(uri)) });
            break;
        default:
            throw new UnsupportedOperationException("Unknown uri: " + uri);
    }
    if (rowsUpdated != 0) {
        getContext().getContentResolver().notifyChange(uri, null);
    }
    return rowsUpdated;
}

######


@Override
public void validateBuild() throws IndexerException {
    Long numFound = getDocumentCount(mpCore);
    if (numFound <= MINIMUM_DOCUMENT_COUNT)
        throw new IndexerException(new ValidationException("Actual mp document count is " + numFound + "."));
    if (numFound != documentCount)
        logger.warn("WARNING: Added " + documentCount + " mp documents but SOLR reports " + numFound + " documents.");
    else
        logger.info("validateBuild(): Indexed " + documentCount + " mp documents.");
}

######


@Override
public void run() throws IndexerException {
    logger.info("Starting MP Indexer...");
    initializeSolrCores();
    initializeDatabaseConnections();
    initialiseSupportingBeans();
    int count = 0;
    logger.info("Starting indexing loop");
    try {
        mpCore.deleteByQuery("*:*");
        mpCore.commit();
        String q = "select 'mp' as dataType, ti.term_id, ti.name, ti.definition from mp_term_infos ti where ti.term_id !='MP:0000001' order by ti.term_id";
        PreparedStatement ps = ontoDbConnection.prepareStatement(q);
        ResultSet rs = ps.executeQuery();
        while (rs.next()) {
            String termId = rs.getString("term_id");
            MpDTO mp = new MpDTO();
            mp.setDataType(rs.getString("dataType"));
            mp.setMpId(termId);
            mp.setMpTerm(rs.getString("name"));
            mp.setMpDefinition(rs.getString("definition"));
            addMpHpTerms(mp, mphpBeans.get(termId));
            mp.setMpNodeId(termNodeIds.get(termId));
            buildNodes(mp);
            mp.setOntologySubset(ontologySubsets.get(termId));
            mp.setMpTermSynonym(mpTermSynonyms.get(termId));
            mp.setGoId(goIds.get(termId));
            addMaRelationships(mp, termId);
            addPhenotype1(mp);
            mp.setPhenoCalls(sumPhenotypingCalls(termId));
            addPhenotype2(mp);
            logger.debug("{}: Built MP DTO {}", count, termId);
            count++;
            documentCount++;
            mpCore.addBean(mp, 60000);
        }
        mpCore.commit();
    } catch (SQLException | SolrServerException | IOException e) {
        throw new IndexerException(e);
    }
    logger.info("Indexed {} beans", count);
    logger.info("MP Indexer complete!");
}

######


private int sumPhenotypingCalls(String mpId) throws SolrServerException {
    List<SolrServer> ss = new ArrayList<>();
    ss.add(preqcCore);
    ss.add(genotypePhenotypeCore);
    int calls = 0;
    for (int i = 0; i < ss.size(); i++) {
        SolrServer solrSvr = ss.get(i);
        SolrQuery query = new SolrQuery();
        query.setQuery("mp_term_id:\"" + mpId + "\" OR intermediate_mp_term_id:\"" + mpId + "\" OR top_level_mp_term_id:\"" + mpId + "\"");
        query.setRows(0);
        QueryResponse response = solrSvr.query(query);
        calls += response.getResults().getNumFound();
    }
    return calls;
}

######


private void populateGene2MpCalls() throws SQLException {
    String qry = "select mp_acc, count(*) as calls from phenotype_call_summary where p_value < 0.0001 group by mp_acc";
    PreparedStatement ps = komp2DbConnection.prepareStatement(qry);
    ResultSet rs = ps.executeQuery();
    while (rs.next()) {
        String mpAcc = rs.getString("mp_acc");
        int calls = rs.getInt("calls");
        mpCalls.put(mpAcc, calls);
    }
    logger.info("Finished creating a mapping of MP to postqc phenotyping calls");
}

######


private void initializeDatabaseConnections() throws IndexerException {
    try {
        komp2DbConnection = komp2DataSource.getConnection();
        ontoDbConnection = ontodbDataSource.getConnection();
    } catch (SQLException e) {
        throw new IndexerException(e);
    }
}

######


private void initializeSolrCores() {
    final String PHENODIGM_URL = config.get("phenodigm.solrserver");
    if (System.getProperty("externalProxyHost") != null && System.getProperty("externalProxyPort") != null) {
        String PROXY_HOST = System.getProperty("externalProxyHost");
        Integer PROXY_PORT = Integer.parseInt(System.getProperty("externalProxyPort"));
        HttpHost proxy = new HttpHost(PROXY_HOST, PROXY_PORT);
        DefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);
        CloseableHttpClient client = HttpClients.custom().setRoutePlanner(routePlanner).build();
        logger.info("Using Proxy Settings: " + PROXY_HOST + " on port: " + PROXY_PORT);
        this.phenodigmCore = new HttpSolrServer(PHENODIGM_URL, client);
    } else {
        this.phenodigmCore = new HttpSolrServer(PHENODIGM_URL);
    }
}

######


private void initialiseSupportingBeans() throws IndexerException {
    try {
        mphpBeans = getMPHPBeans();
        termNodeIds = getNodeIds();
        topLevelTerms = getTopLevelTerms();
        intermediateNodeIds = getIntermediateNodeIds();
        childNodeIds = getChildNodeIds();
        intermediateTerms = getIntermediateTerms();
        parentNodeIds = getParentNodeIds();
        mpTermSynonyms = getMPTermSynonyms();
        ontologySubsets = getOntologySubsets();
        goIds = getGOIds();
        maTermNodes = getMATermNodes();
        maTopLevelNodes = getMaTopLevelNodes();
        maChildLevelNodes = getMAChildLevelNodes();
        maTermSynonyms = getMATermSynonyms();
        alleles = IndexerMap.getGeneToAlleles(alleleCore);
        phenotypes1 = getPhenotypeCallSummary1();
        impcBeans = getImpcPipe();
        legacyBeans = getLegacyPipe();
        phenotypes2 = getPhenotypeCallSummary2();
        strains = getStrains();
        pppBeans = getPPPBeans();
    } catch (SQLException e) {
        throw new IndexerException(e);
    }
}

######


private Map<String, List<MPHPBean>> getMPHPBeans() throws IndexerException {
    Map<String, List<MPHPBean>> beans = new HashMap<>();
    int count;
    try {
        SolrQuery query = new SolrQuery("*:*");
        query.addFilterQuery("type:mp_hp");
        query.setFields("mp_id", "hp_id", "hp_term");
        query.setRows(5000);
        QueryResponse response = phenodigmCore.query(query);
        List<MPHPBean> docs = response.getBeans(MPHPBean.class);
        count = 0;
        for (MPHPBean doc : docs) {
            if (!beans.containsKey(doc.getMpId())) {
                beans.put(doc.getMpId(), new ArrayList<MPHPBean>());
            }
            beans.get(doc.getMpId()).add(doc);
            count++;
        }
    } catch (SolrServerException e) {
        throw new IndexerException(e);
    }
    logger.debug("Loaded {} mphp docs", count);
    return beans;
}

######


private Map<String, List<Integer>> getNodeIds() throws SQLException {
    Map<String, List<Integer>> beans = new HashMap<>();
    String q = "select nt.node_id, ti.term_id from mp_term_infos ti, mp_node2term nt where ti.term_id=nt.term_id and ti.term_id !='MP:0000001'";
    PreparedStatement ps = ontoDbConnection.prepareStatement(q);
    ResultSet rs = ps.executeQuery();
    int count = 0;
    while (rs.next()) {
        String tId = rs.getString("term_id");
        int nId = rs.getInt("node_id");
        if (!beans.containsKey(tId)) {
            beans.put(tId, new ArrayList<Integer>());
        }
        beans.get(tId).add(nId);
        count++;
    }
    logger.debug("Loaded {} node Ids", count);
    return beans;
}

######


private Map<Integer, List<MPTopLevelTermBean>> getTopLevelTerms() throws SQLException {
    Map<Integer, List<MPTopLevelTermBean>> beans = new HashMap<>();
    String q = "select lv.node_id as mp_node_id, ti.term_id, ti.name, ti.definition, concat(ti.name, '___', ti.term_id) as top_level_mp_term_id from mp_node_top_level lv inner join mp_node2term nt on lv.top_level_node_id=nt.node_id inner join mp_term_infos ti on nt.term_id=ti.term_id and ti.term_id!='MP:0000001'";
    PreparedStatement ps = ontoDbConnection.prepareStatement(q);
    ResultSet rs = ps.executeQuery();
    int count = 0;
    while (rs.next()) {
        int nId = rs.getInt("mp_node_id");
        MPTopLevelTermBean bean = new MPTopLevelTermBean();
        bean.setTermId(rs.getString("term_id"));
        bean.setName(rs.getString("name"));
        bean.setDefinition(rs.getString("definition"));
        bean.setTopLevelMPTermId(rs.getString("top_level_mp_term_id"));
        if (!beans.containsKey(nId)) {
            beans.put(nId, new ArrayList<MPTopLevelTermBean>());
        }
        beans.get(nId).add(bean);
        count++;
    }
    logger.debug("Loaded {} top level terms", count);
    return beans;
}

######


private Map<Integer, List<Integer>> getIntermediateNodeIds() throws SQLException {
    Map<Integer, List<Integer>> beans = new HashMap<>();
    String q = "select node_id, child_node_id from mp_node_subsumption_fullpath";
    PreparedStatement ps = ontoDbConnection.prepareStatement(q);
    ResultSet rs = ps.executeQuery();
    int count = 0;
    while (rs.next()) {
        int childId = rs.getInt("child_node_id");
        int nodeId = rs.getInt("node_id");
        if (!beans.containsKey(childId)) {
            beans.put(childId, new ArrayList<Integer>());
        }
        beans.get(childId).add(nodeId);
        count++;
    }
    logger.debug("Loaded {} intermediate node Ids", count);
    return beans;
}

######


private Map<Integer, List<Integer>> getChildNodeIds() throws SQLException {
    Map<Integer, List<Integer>> beans = new HashMap<>();
    String q = "select node_id, child_node_id from mp_node_subsumption_fullpath";
    PreparedStatement ps = ontoDbConnection.prepareStatement(q);
    ResultSet rs = ps.executeQuery();
    int count = 0;
    while (rs.next()) {
        int nId = rs.getInt("node_id");
        int childId = rs.getInt("child_node_id");
        if (!beans.containsKey(nId)) {
            beans.put(nId, new ArrayList<Integer>());
        }
        beans.get(nId).add(childId);
        count++;
    }
    logger.debug("Loaded {} child node Ids", count);
    return beans;
}

######


private Map<Integer, List<MPTermNodeBean>> getIntermediateTerms() throws SQLException {
    Map<Integer, List<MPTermNodeBean>> beans = new HashMap<>();
    String q = "select nt.node_id, ti.term_id, ti.name, ti.definition from mp_term_infos ti, mp_node2term nt where ti.term_id=nt.term_id and ti.term_id !='MP:0000001'";
    PreparedStatement ps = ontoDbConnection.prepareStatement(q);
    ResultSet rs = ps.executeQuery();
    int count = 0;
    while (rs.next()) {
        int nId = rs.getInt("node_id");
        MPTermNodeBean bean = new MPTermNodeBean();
        bean.setTermId(rs.getString("term_id"));
        bean.setName(rs.getString("name"));
        bean.setDefinition(rs.getString("definition"));
        if (!beans.containsKey(nId)) {
            beans.put(nId, new ArrayList<MPTermNodeBean>());
        }
        beans.get(nId).add(bean);
        count++;
    }
    logger.debug("Loaded {} intermediate level terms", count);
    return beans;
}

######


private Map<Integer, List<Integer>> getParentNodeIds() throws SQLException {
    Map<Integer, List<Integer>> beans = new HashMap<>();
    String q = "select parent_node_id, child_node_id from mp_parent_children";
    PreparedStatement ps = ontoDbConnection.prepareStatement(q);
    ResultSet rs = ps.executeQuery();
    int count = 0;
    while (rs.next()) {
        int nId = rs.getInt("child_node_id");
        int parentId = rs.getInt("parent_node_id");
        if (!beans.containsKey(nId)) {
            beans.put(nId, new ArrayList<Integer>());
        }
        beans.get(nId).add(parentId);
        count++;
    }
    logger.debug("Loaded {} parent node Ids", count);
    return beans;
}

######


private Map<String, List<String>> getMPTermSynonyms() throws SQLException {
    Map<String, List<String>> beans = new HashMap<>();
    String q = "select term_id, syn_name from mp_synonyms";
    PreparedStatement ps = ontoDbConnection.prepareStatement(q);
    ResultSet rs = ps.executeQuery();
    int count = 0;
    while (rs.next()) {
        String tId = rs.getString("term_id");
        String syn = rs.getString("syn_name");
        if (!beans.containsKey(tId)) {
            beans.put(tId, new ArrayList<String>());
        }
        beans.get(tId).add(syn);
        count++;
    }
    logger.debug("Loaded {} MP term synonyms", count);
    return beans;
}

######


private Map<String, List<MPTermNodeBean>> getMATermNodes() throws SQLException {
    Map<String, List<MPTermNodeBean>> beans = new HashMap<>();
    String q = "select mp.term_id, ti.term_id as ma_term_id, ti.name as ma_term_name from mp_mappings mp inner join ma_term_infos ti on mp.mapped_term_id=ti.term_id and mp.ontology='MA'";
    PreparedStatement ps = ontoDbConnection.prepareStatement(q);
    ResultSet rs = ps.executeQuery();
    int count = 0;
    while (rs.next()) {
        String tId = rs.getString("term_id");
        String maTermId = rs.getString("ma_term_id");
        String maTermName = rs.getString("ma_term_name");
        MPTermNodeBean bean = new MPTermNodeBean();
        bean.setTermId(maTermId);
        bean.setName(maTermName);
        if (!beans.containsKey(tId)) {
            beans.put(tId, new ArrayList<MPTermNodeBean>());
        }
        beans.get(tId).add(bean);
        count++;
    }
    logger.debug("Loaded {} MA term nodes", count);
    return beans;
}

######


public static Map<String, List<String>> getMaTopLevelNodes() throws SQLException {
    Map<String, List<String>> beans = new HashMap<>();
    String q = "select distinct ti.term_id, ti.name from ma_node2term nt, ma_node_2_selected_top_level_mapping m, ma_term_infos ti where nt.node_id=m.node_id and m.top_level_term_id=ti.term_id";
    PreparedStatement ps = ontoDbConnection.prepareStatement(q);
    ResultSet rs = ps.executeQuery();
    int count = 0;
    while (rs.next()) {
        String tId = rs.getString("term_id");
        String name = rs.getString("name");
        if (!beans.containsKey(tId)) {
            beans.put(tId, new ArrayList<String>());
        }
        beans.get(tId).add(name);
        count++;
    }
    logger.debug("Loaded {} inferred selected MA term nodes", count);
    return beans;
}

######


private Map<String, List<MPTermNodeBean>> getMAChildLevelNodes() throws SQLException {
    Map<String, List<MPTermNodeBean>> beans = new HashMap<>();
    String q = "select ti.term_id as parent_ma_id, ti2.term_id as child_ma_id, ti2.name as child_ma_term from ma_term_infos ti inner join ma_node2term nt on ti.term_id=nt.term_id inner join ma_parent_children pc on nt.node_id=pc.parent_node_id inner join ma_node2term nt2 on pc.child_node_id=nt2.node_id inner join ma_term_infos ti2 on nt2.term_id=ti2.term_id";
    PreparedStatement ps = ontoDbConnection.prepareStatement(q);
    ResultSet rs = ps.executeQuery();
    int count = 0;
    while (rs.next()) {
        String tId = rs.getString("parent_ma_id");
        String maTermId = rs.getString("child_ma_id");
        String maTermName = rs.getString("child_ma_term");
        MPTermNodeBean bean = new MPTermNodeBean();
        bean.setTermId(maTermId);
        bean.setName(maTermName);
        if (!beans.containsKey(tId)) {
            beans.put(tId, new ArrayList<MPTermNodeBean>());
        }
        beans.get(tId).add(bean);
        count++;
    }
    logger.debug("Loaded {} MA child term nodes", count);
    return beans;
}

######


private Map<String, List<String>> getMATermSynonyms() throws SQLException {
    Map<String, List<String>> beans = new HashMap<>();
    String q = "select term_id, syn_name from ma_synonyms";
    PreparedStatement ps = ontoDbConnection.prepareStatement(q);
    ResultSet rs = ps.executeQuery();
    int count = 0;
    while (rs.next()) {
        String tId = rs.getString("term_id");
        String syn = rs.getString("syn_name");
        if (!beans.containsKey(tId)) {
            beans.put(tId, new ArrayList<String>());
        }
        beans.get(tId).add(syn);
        count++;
    }
    logger.debug("Loaded {} MA term synonyms", count);
    return beans;
}

######


private Map<String, List<String>> getOntologySubsets() throws SQLException {
    Map<String, List<String>> beans = new HashMap<>();
    String q = "select term_id, subset from mp_term_subsets";
    PreparedStatement ps = ontoDbConnection.prepareStatement(q);
    ResultSet rs = ps.executeQuery();
    int count = 0;
    while (rs.next()) {
        String tId = rs.getString("term_id");
        String subset = rs.getString("subset");
        if (!beans.containsKey(tId)) {
            beans.put(tId, new ArrayList<String>());
        }
        beans.get(tId).add(subset);
        count++;
    }
    logger.debug("Loaded {} subsets", count);
    return beans;
}

######


public SkinTable getSkinData(String tableName) throws Exception {
    SkinTable sTable = new SkinTable();
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY1);
        pstmt.setString(1, tableName);
        GCmLog.writeLog(" MsBoardDAOImpl::getSkinData : " + QUERY1);
        rs = pstmt.executeQuery();
        if (rs.next()) {
            sTable.setSkin(rs.getString("skin"));
            sTable.setTbTitle(rs.getString("tbTitle"));
            sTable.setAttach_key(rs.getString("attach_key"));
            sTable.setEditmode(rs.getString("editmode"));
            sTable.setImage_allow(rs.getString("image_allow"));
            sTable.setTbCnt(rs.getInt("tbCnt"));
            sTable.setTbInfoStatus(rs.getString("tbInfoStatus"));
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
        }
        conn.close();
    }
    return sTable;
}

######


public List getListData(String tableName, int gotoPage, int pageSize, int recordCount) throws Exception {
    int start = pageSize * gotoPage;
    if (start > recordCount)
        pageSize -= (start - recordCount);
    StringBuffer query = new StringBuffer();
    query.append("select seq,name,title,email,readnum,writeday,re_level,relativeCnt from (select top ");
    query.append(pageSize + " seq,name,title,email,readnum,writeday,re_level,relativeCnt,re_step from (select top ");
    query.append(start + " seq,name,title,email,readnum,writeday,re_level,relativeCnt,re_step from " + tableName);
    query.append(" order by re_step desc) as DERIVEDTBL order by re_step)as DERIVEDTBL order by re_step desc");
    List listData = new ArrayList();
    BoardTable bTable = null;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(query.toString());
        GCmLog.writeLog(" MsBoardDAOImpl::getListData : " + query);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            bTable = new BoardTable();
            bTable.setSeq(rs.getInt("seq"));
            bTable.setName(rs.getString("name"));
            bTable.setTitle(Utility.getTitleLimit(ReplaceUtil.encodeHTMLSpecialChar(rs.getString("title"), 14), 40, rs.getInt("re_level")));
            bTable.setEmail(rs.getString("email"));
            bTable.setReadnum(rs.getInt("readnum"));
            bTable.setWriteday(rs.getTimestamp("writeday"));
            bTable.setRe_level(rs.getInt("re_level"));
            bTable.setRelativeCnt(rs.getInt("relativeCnt"));
            listData.add(bTable);
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
        }
        conn.close();
    }
    return listData;
}

######


public List getListData(String tableName, int gotoPage, int pageSize) throws Exception {
    int start = pageSize * (gotoPage - 1) + 1;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    String query = "select min(re_step) AS Expr1 from (select top " + start + " re_step from " + tableName + " order by re_step desc) as DERIVEDTBL";
    int pageTopNum = 0;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        GCmLog.writeLog(" MsBoardDAOImpl::getListData : " + query);
        pstmt = conn.prepareStatement(query);
        rs = pstmt.executeQuery();
        if (rs.next())
            pageTopNum = rs.getInt("Expr1");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
        }
        conn.close();
    }
    List listData = new ArrayList();
    BoardTable bTable = null;
    query = "select top " + pageSize + " seq,name,title,email,readnum,writeday,re_level,relativeCnt from " + tableName + " where re_step <= ? order by re_step desc";
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(query);
        pstmt.setInt(1, pageTopNum);
        GCmLog.writeLog(" MsBoardDAOImpl::getListData : " + query);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            bTable = new BoardTable();
            bTable.setSeq(rs.getInt("seq"));
            bTable.setName(rs.getString("name"));
            bTable.setTitle(Utility.getTitleLimit(ReplaceUtil.encodeHTMLSpecialChar(rs.getString("title"), 14), 40, rs.getInt("re_level")));
            bTable.setEmail(rs.getString("email"));
            bTable.setReadnum(rs.getInt("readnum"));
            bTable.setWriteday(rs.getTimestamp("writeday"));
            bTable.setRe_level(rs.getInt("re_level"));
            bTable.setRelativeCnt(rs.getInt("relativeCnt"));
            listData.add(bTable);
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
        }
        conn.close();
    }
    return listData;
}

######


public void plusNewCount(CountTable cTable) throws Exception {
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    synchronized (this) {
        try {
            conn = GCmDbManager.getInstance().getConnection();
            conn.setAutoCommit(false);
            pstmt = conn.prepareStatement(QUERY1);
            pstmt.setInt(1, cTable.getCdate());
            pstmt.setInt(2, cTable.getCtime());
            pstmt.setInt(3, cTable.getDayofweek());
            pstmt.setString(4, cTable.getIp());
            pstmt.setString(5, cTable.getReferer());
            pstmt.setString(6, cTable.getBrowser());
            pstmt.setString(7, cTable.getOs());
            pstmt.executeUpdate();
        } finally {
            try {
                pstmt.close();
                conn.commit();
            } catch (SQLException e) {
                GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
            }
            conn.close();
        }
    }
}

######


public CountManager getStatistics(int makeToday) throws Exception {
    CountManager cm = new CountManager();
    int today = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY2);
        pstmt.setInt(1, makeToday);
        rs = pstmt.executeQuery();
        if (rs.next())
            today = rs.getInt("today");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    int totalSum = 0;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY3);
        rs = pstmt.executeQuery();
        if (rs.next())
            totalSum = rs.getInt("totalSum");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    cm.setToday(today);
    cm.setTotalSum(totalSum);
    return cm;
}

######


public int getTotal() throws Exception {
    int returnValue = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY4);
        rs = pstmt.executeQuery();
        if (rs != null && rs.next())
            returnValue = rs.getInt("idx");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return returnValue;
}

######


public int getToday(int makeToday) throws Exception {
    int returnValue = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY5);
        pstmt.setInt(1, makeToday);
        rs = pstmt.executeQuery();
        if (rs != null && rs.next())
            returnValue = rs.getInt("todayIdx");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return returnValue;
}

######


public int getPrevDay(int makeToday, int makePrevDay) throws Exception {
    int returnValue = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY6);
        pstmt.setInt(1, makeToday);
        pstmt.setInt(2, makePrevDay);
        rs = pstmt.executeQuery();
        if (rs != null && rs.next())
            returnValue = rs.getInt("prevDayIdx");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return returnValue;
}

######


public PlotData getBrowser(int sdate, int edate) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    String exceptionvalue = "";
    PlotData data = new PlotData();
    DataItem d = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY7);
        pstmt.setInt(1, sdate);
        pstmt.setInt(2, edate);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            exceptionvalue = rs.getString("browser");
            if ((exceptionvalue != null) && (!exceptionvalue.equals(""))) {
                d = new DataItem(exceptionvalue, rs.getInt("cnt"));
                data.addElement(d);
            }
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return data;
}

######


public PlotData getOs(int sdate, int edate) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    String exceptionvalue = "";
    PlotData data = new PlotData();
    DataItem d = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY8);
        pstmt.setInt(1, sdate);
        pstmt.setInt(2, edate);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            exceptionvalue = rs.getString("os");
            if ((exceptionvalue != null) && (!exceptionvalue.equals(""))) {
                d = new DataItem(exceptionvalue, rs.getInt("cnt"));
                data.addElement(d);
            }
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return data;
}

######


public PlotData getIpData(int sdate, int edate) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    String exceptionvalue = "";
    PlotData data = new PlotData();
    DataItem d = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY9);
        pstmt.setInt(1, sdate);
        pstmt.setInt(2, edate);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            exceptionvalue = rs.getString("ip");
            if ((exceptionvalue != null) && (!exceptionvalue.equals(""))) {
                d = new DataItem(exceptionvalue, rs.getInt("cnt"));
                data.addElement(d);
            }
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return data;
}

######


public PlotData getRefererData(int sdate, int edate) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    String exceptionvalue = "";
    PlotData data = new PlotData();
    DataItem d = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY10);
        pstmt.setInt(1, sdate);
        pstmt.setInt(2, edate);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            exceptionvalue = rs.getString("referer");
            if ((exceptionvalue != null) && (!exceptionvalue.equals(""))) {
                d = new DataItem(exceptionvalue, rs.getInt("cnt"));
                data.addElement(d);
            }
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return data;
}

######


public PlotData getYearData(int SINCE_YEAR, int NOW_YEAR) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    PlotData data = new PlotData();
    DataItem d = null;
    int tmpPrevYearCnt = 0;
    for (int k = SINCE_YEAR; k <= NOW_YEAR; k++) {
        try {
            conn = GCmDbManager.getInstance().getConnection();
            conn.setAutoCommit(false);
            pstmt = conn.prepareStatement(QUERY11);
            pstmt.setInt(1, (k + 1) * 10000);
            rs = pstmt.executeQuery();
            if (rs.next()) {
                d = new DataItem(Integer.toString(k), rs.getInt("maxIdx") - tmpPrevYearCnt);
                data.addElement(d);
                tmpPrevYearCnt = rs.getInt("maxIdx");
            }
        } finally {
            try {
                pstmt.close();
                conn.commit();
            } catch (SQLException e) {
                GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
            }
            conn.close();
        }
    }
    return data;
}

######


public PlotData getMonthData(int thisYear, int startMonth, int endMonth) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    PlotData data = new PlotData();
    DataItem d = null;
    int monthCnt = 0;
    int tmpPrevMonthCnt = 0;
    int prevYearCnt = getPrevYearCnt(thisYear);
    for (int k = startMonth; k <= endMonth; k++) {
        try {
            conn = GCmDbManager.getInstance().getConnection();
            conn.setAutoCommit(false);
            pstmt = conn.prepareStatement(QUERY12);
            pstmt.setInt(1, (thisYear * 10000) + ((k) * 100));
            pstmt.setInt(2, (thisYear * 10000) + ((k + 1) * 100));
            rs = pstmt.executeQuery();
            if (rs.next()) {
                if (rs.getInt("cnt") > 0) {
                    if (k == startMonth)
                        monthCnt = rs.getInt("cnt") - prevYearCnt;
                    else
                        monthCnt = rs.getInt("cnt") - tmpPrevMonthCnt;
                    tmpPrevMonthCnt = rs.getInt("cnt");
                    d = new DataItem(Integer.toString(k), monthCnt);
                    data.addElement(d);
                } else {
                    d = new DataItem(Integer.toString(k), 0);
                    data.addElement(d);
                }
            }
        } finally {
            try {
                pstmt.close();
                conn.commit();
            } catch (SQLException e) {
                GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
            }
            conn.close();
        }
    }
    return data;
}

######


public int getPrevYearCnt(int thisYear) throws Exception {
    int returnValueInt = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY13);
        pstmt.setInt(1, (thisYear - 1) * 10000 + 1231);
        rs = pstmt.executeQuery();
        if (rs.next())
            returnValueInt = rs.getInt("cnt");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return returnValueInt;
}

######


public PlotData getDayData(int thisYear, int thisMonth) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    PlotData data = new PlotData();
    DataItem d = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY14);
        pstmt.setInt(1, (thisYear * 10000) + (thisMonth * 100));
        pstmt.setInt(2, (thisYear * 10000) + (thisMonth * 100) + 99);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            d = new DataItem(rs.getString("cdate").substring(6, 8), rs.getInt("cnt"));
            data.addElement(d);
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return data;
}

######


public int getTotalSum(int cmakeToday) throws Exception {
    int returnValue = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY15);
        pstmt.setInt(1, cmakeToday);
        rs = pstmt.executeQuery();
        if (rs != null && rs.next())
            returnValue = rs.getInt("cnt");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return returnValue;
}

######


public String getInfo(int cmakeToday, int gotoPage, int pageSize, int recordCount) throws Exception {
    String ctime = "";
    String referer = "";
    String alterTime = "";
    String linkReferer = "";
    int trimStart = 0;
    int trimEnd = 0;
    int start = pageSize * gotoPage;
    if (start > recordCount)
        pageSize -= (start - recordCount);
    StringBuffer query = new StringBuffer();
    query.append("select ctime,ip,referer,browser,os from (select top ");
    query.append(pageSize + " ctime,ip,referer,browser,os,idx from (select top ");
    query.append(start + " ctime,ip,referer,browser,os,idx from count");
    query.append(" where (cdate = ?) order by idx desc) as DERIVEDTBL order by idx)as DERIVEDTBL order by idx desc");
    StringBuffer html = new StringBuffer();
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(query.toString());
        pstmt.setInt(1, cmakeToday);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            ctime = ParamUtil.getReqParameter(rs.getString("ctime"), "00");
            referer = ParamUtil.getReqParameter(rs.getString("referer"));
            if (ctime.length() == 3)
                alterTime = "0" + ctime;
            else if (ctime.length() == 2)
                alterTime = "00" + ctime;
            else if (ctime.length() == 1)
                alterTime = "000" + ctime;
            else
                alterTime = ctime;
            alterTime = alterTime.substring(0, 2) + ":" + alterTime.substring(2, 4);
            linkReferer = referer;
            trimStart = referer.indexOf("http://");
            if (trimStart != -1)
                referer = referer.substring(trimStart + 7);
            trimEnd = referer.indexOf("/");
            if (trimEnd != -1)
                referer = "http://" + referer.substring(0, trimEnd);
            html.append("<TR>\n");
            html.append("   <TD>" + alterTime + "</TD>\n");
            html.append("   <TD>" + ParamUtil.getReqParameter(rs.getString("ip")) + "</TD>\n");
            html.append("   <TD><a href='" + linkReferer + "' target=_blank class='ref'>" + referer + "</a></TD>\n");
            html.append("   <TD>" + ParamUtil.getReqParameter(rs.getString("browser")) + "</TD>\n");
            html.append("   <TD style='padding-left:5'>" + ParamUtil.getReqParameter(rs.getString("os")) + "</TD>\n");
            html.append("</TR>\n");
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return html.toString();
}

######


public PlotData getWeeklyCnt() throws Exception {
    String[] weekNameStr = { "��", "��", "��", "�", "��", "��", "��" };
    PlotData data = new PlotData();
    DataItem d = null;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY17);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            d = new DataItem(weekNameStr[(rs.getInt("dayofweek") - 1)], rs.getInt("cnt"));
            data.addElement(d);
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return data;
}

######


public SkinTable getSkinData(String tableName) throws Exception {
    SkinTable sTable = new SkinTable();
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY1);
        pstmt.setString(1, tableName);
        GCmLog.writeLog(" MsInfoBoardDAOImpl ::getSkinData : " + QUERY1);
        rs = pstmt.executeQuery();
        if (rs != null && rs.next()) {
            sTable.setSkin(rs.getString("skin"));
            sTable.setTbTitle(rs.getString("tbTitle"));
            sTable.setAttach_key(rs.getString("attach_key"));
            sTable.setEditmode(rs.getString("editmode"));
            sTable.setImage_allow(rs.getString("image_allow"));
            sTable.setTbCnt(rs.getInt("tbCnt"));
            sTable.setTbInfoStatus(rs.getString("tbInfoStatus"));
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" MsInfoBoardDAOImpl::getSkinData : " + e.getMessage());
        }
        conn.close();
    }
    return sTable;
}

######


public int getListCount(String tableName) throws Exception {
    int recordCount = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY2);
        pstmt.setString(1, tableName);
        GCmLog.writeLog(" MsInfoBoardDAOImpl ::getListCount : " + QUERY2);
        rs = pstmt.executeQuery();
        if (rs.next())
            recordCount = rs.getInt("cnt");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" MsInfoBoardDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return recordCount;
}

######


public List getListData(String tableName, int gotoPage, int pageSize) throws Exception {
    int start = pageSize * (gotoPage - 1) + 1;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    String query = "select min(seq) AS Expr1 from (select top " + start + " seq from tablemnginfo where tbName = ? order by seq desc) as DERIVEDTBL";
    int pageTopNum = 0;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(query);
        pstmt.setString(1, tableName);
        GCmLog.writeLog(" MsInfoBoardDAOImpl ::getListData : " + query);
        rs = pstmt.executeQuery();
        if (rs.next())
            pageTopNum = rs.getInt("Expr1");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" MsInfoBoardDAOImpl ::getListData : " + e.getMessage());
        }
        conn.close();
    }
    List listData = new ArrayList();
    InfoTable iTable = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY3);
        pstmt.setString(1, tableName);
        pstmt.setInt(2, pageTopNum);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            iTable = new InfoTable();
            iTable.setSeq(rs.getInt("seq"));
            iTable.setReadnum(rs.getInt("readnum"));
            iTable.setWriteday(rs.getTimestamp("writeday"));
            iTable.setViewSelect(rs.getString("viewSelect"));
            iTable.setTitle(Utility.getTitleLimit(ReplaceUtil.encodeHTMLSpecialChar(rs.getString("title"), 14), 38));
            listData.add(iTable);
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" MsInfoBoardDAOImpl::getListData : " + e.getMessage());
        }
        conn.close();
    }
    return listData;
}

######


public List getListData(String tableName, int gotoPage, int pageSize, int recordCount) throws Exception {
    int start = pageSize * gotoPage;
    if (start > recordCount)
        pageSize -= (start - recordCount);
    StringBuffer query = new StringBuffer();
    query.append("select seq,readnum,writeday,viewSelect,title from (select top ");
    query.append(pageSize + " seq,readnum,writeday,viewSelect,title from (select top ");
    query.append(start + " seq,readnum,writeday,viewSelect,title from tablemnginfo");
    query.append(" where tbName = ? order by seq desc) as DERIVEDTBL order by seq)as DERIVEDTBL order by seq desc");
    List listData = new ArrayList();
    InfoTable iTable = null;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(query.toString());
        pstmt.setString(1, tableName);
        GCmLog.writeLog(" MsInfoBoardDAOImpl ::getListData : " + query.toString());
        rs = pstmt.executeQuery();
        while (rs.next()) {
            iTable = new InfoTable();
            iTable.setSeq(rs.getInt("seq"));
            iTable.setReadnum(rs.getInt("readnum"));
            iTable.setWriteday(rs.getTimestamp("writeday"));
            iTable.setViewSelect(rs.getString("viewSelect"));
            iTable.setTitle(Utility.getTitleLimit(ReplaceUtil.encodeHTMLSpecialChar(rs.getString("title"), 14), 38));
            listData.add(iTable);
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" MsInfoBoardDAOImpl::getListData : " + e.getMessage());
        }
        conn.close();
    }
    return listData;
}

######


public int getListCount(int idxKey) throws Exception {
    int returnValue = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        pstmt = conn.prepareStatement(QUERY1);
        pstmt.setInt(1, idxKey);
        rs = pstmt.executeQuery();
        if (rs.next())
            returnValue = rs.getInt("cnt");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" MsPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return returnValue;
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("MultiTestt1", "id int, test varchar(100)");
    createTable("MultiTestt2", "id int, test varchar(100)");
    createTable("MultiTestt3", "message text");
    createTable("MultiTestt4", "id int, test varchar(100), PRIMARY KEY (`id`)");
    createTable("MultiTestt5", "id int, test varchar(100)");
    createTable("MultiTestt6", "id int, test varchar(100)");
    createTable("MultiTestt7", "id int, test varchar(100)");
    createTable("MultiTestt8", "id int, test varchar(100)");
    createTable("MultiTestt10", "id int");
    createTable("MultiTestreWriteDuplicateTestTable", "id int, name varchar(100), PRIMARY KEY (`id`)");
    createTable("MultiTesttselect1", "LAST_UPDATE_DATETIME TIMESTAMP , nn int");
    createTable("MultiTesttselect2", "nn int");
    createTable("MultiTesttselect3", "LAST_UPDATE_DATETIME TIMESTAMP , nn int");
    createTable("MultiTesttselect4", "nn int");
    createTable("MultiTestt3_dupp", "col1 int, pkey int NOT NULL, col2 int, col3 int, col4 int, PRIMARY KEY " + "(`pkey`)");
    createTable("MultiTesttest_table", "col1 VARCHAR(32), col2 VARCHAR(32), col3 VARCHAR(32), col4 VARCHAR(32), " + "col5 VARCHAR(32)");
    createTable("MultiTesttest_table2", "col1 VARCHAR(32), col2 VARCHAR(32), col3 VARCHAR(32), col4 VARCHAR(32), " + "col5 VARCHAR(32)");
    createTable("MultiTestValues", "col1 VARCHAR(32), col2 VARCHAR(32)");
    createTable("MultiTestprepsemi", "id int not null primary key auto_increment, text text");
    createTable("MultiTestA", "data varchar(10)");
    createTable("testMultiGeneratedKey", "id int not null primary key auto_increment, text text");
    if (testSingleHost) {
        Statement st = sharedConnection.createStatement();
        st.execute("insert into MultiTestt1 values(1,'a'),(2,'a')");
        st.execute("insert into MultiTestt2 values(1,'a'),(2,'a')");
        st.execute("insert into MultiTestt5 values(1,'a'),(2,'a'),(2,'b')");
    }
}

######


@Test
public void rewriteSelectQuery() throws Throwable {
    Statement st = sharedConnection.createStatement();
    st.execute("INSERT INTO MultiTesttselect2 VALUES (1)");
    PreparedStatement ps = sharedConnection.prepareStatement("/*CLIENT*/ insert into MultiTesttselect1 " + "(LAST_UPDATE_DATETIME, nn) select ?, nn from MultiTesttselect2");
    ps.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
    ps.executeUpdate();
    ResultSet rs = st.executeQuery("SELECT * FROM MultiTesttselect1");
    assertTrue(rs.next());
    assertEquals(rs.getInt(2), 1);
}

######


@Test
public void rewriteParsingDoubleSlash() throws Throwable {
    parsingDoubleSlash(sharedConnection);
    try (Connection conn = setConnection("&rewriteBatchedStatements=true")) {
        parsingDoubleSlash(conn);
        Statement stmt = conn.createStatement();
        stmt.execute("CREATE TEMPORARY TABLE rewriteSlash(t varchar(50))");
        stmt.addBatch("insert into rewriteSlash values ('\\\\')");
        stmt.executeBatch();
        ResultSet rs = stmt.executeQuery("SELECT * FROM rewriteSlash");
        assertTrue(rs.next());
        assertEquals(rs.getString(1), "\\");
    }
}

######


private void parsingDoubleSlash(Connection conn) throws SQLException {
    try (PreparedStatement p = conn.prepareStatement("SELECT '\\\\', ?")) {
        p.setString(1, "\\\\");
        ResultSet rs = p.executeQuery();
        assertTrue(rs.next());
        assertEquals(rs.getString(1), "\\");
        assertEquals(rs.getString(2), "\\\\");
    }
}

######


@Test
public void rewriteSelectQueryServerPrepared() throws Throwable {
    Statement st = sharedConnection.createStatement();
    st.execute("INSERT INTO MultiTesttselect4 VALUES (1)");
    PreparedStatement ps = sharedConnection.prepareStatement("insert into MultiTesttselect3 (LAST_UPDATE_DATETIME," + " nn) select ?, nn from MultiTesttselect4");
    ps.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
    ps.executeUpdate();
    ResultSet rs = st.executeQuery("SELECT * FROM MultiTesttselect3");
    assertTrue(rs.next());
    assertEquals(rs.getInt(2), 1);
}

######


@Test
public void basicTest() throws SQLException {
    try (Connection connection = setConnection("&allowMultiQueries=true")) {
        Statement statement = connection.createStatement();
        ResultSet rs = statement.executeQuery("select * from MultiTestt1;select * from MultiTestt2;");
        int count = 0;
        while (rs.next()) {
            count++;
        }
        assertTrue(count > 0);
        assertTrue(statement.getMoreResults());
        rs = statement.getResultSet();
        count = 0;
        while (rs.next()) {
            count++;
        }
        assertTrue(count > 0);
        assertFalse(statement.getMoreResults());
    }
}

######


@Test
public void updateTest() throws SQLException {
    try (Connection connection = setConnection("&allowMultiQueries=true")) {
        Statement statement = connection.createStatement();
        statement.execute("update MultiTestt5 set test='a " + System.currentTimeMillis() + "' where id = 2;select * from MultiTestt2;update MultiTestt5 set test='a2 " + System.currentTimeMillis() + "' where id = 1;");
        assertNull(statement.getResultSet());
        assertEquals(2, statement.getUpdateCount());
        assertTrue(statement.getMoreResults());
        assertEquals(-1, statement.getUpdateCount());
        ResultSet rs = statement.getResultSet();
        int count = 0;
        while (rs.next()) {
            count++;
        }
        assertTrue(count > 0);
        assertFalse(statement.getMoreResults());
        assertEquals(1, statement.getUpdateCount());
        assertNull(statement.getResultSet());
        assertFalse(statement.getMoreResults());
        assertEquals(-1, statement.getUpdateCount());
    }
}

######


@Test
public void updateTest2() throws SQLException {
    try (Connection connection = setConnection("&allowMultiQueries=true")) {
        Statement statement = connection.createStatement();
        statement.execute("select * from MultiTestt2;update MultiTestt5 set test='a " + System.currentTimeMillis() + "' where id = 2;");
        ResultSet rs = statement.getResultSet();
        int count = 0;
        while (rs.next()) {
            count++;
        }
        assertTrue(count == 2);
        statement.getMoreResults();
        int updateNb = statement.getUpdateCount();
        assertEquals(2, updateNb);
    }
}

######


@Test
public void selectTest() throws SQLException {
    try (Connection connection = setConnection("&allowMultiQueries=true")) {
        Statement statement = connection.createStatement();
        statement.execute("select * from MultiTestt2;select * from MultiTestt1;");
        ResultSet rs = statement.getResultSet();
        int count = 0;
        while (rs.next()) {
            count++;
        }
        assertTrue(count > 0);
        rs = statement.executeQuery("select * from MultiTestt1");
        count = 0;
        while (rs.next()) {
            count++;
        }
        assertTrue(count > 0);
    }
}

######


@Test
public void setMaxRowsMulti() throws Exception {
    try (Connection connection = setConnection("&allowMultiQueries=true")) {
        Statement st = connection.createStatement();
        assertEquals(0, st.getMaxRows());
        st.setMaxRows(1);
        assertEquals(1, st.getMaxRows());
        ResultSet rs = st.executeQuery("select 1 union select 2;select 1 union select 2");
        int cnt = 0;
        while (rs.next()) {
            cnt++;
        }
        rs.close();
        assertEquals(1, cnt);
        assertTrue(st.getMoreResults());
        rs = st.getResultSet();
        cnt = 0;
        while (rs.next()) {
            cnt++;
        }
        rs.close();
        assertEquals(1, cnt);
    }
}

######


@Test
public void rewriteBatchedStatementsDisabledInsertionTest() throws SQLException {
    verifyInsertBehaviorBasedOnRewriteBatchedStatements(Boolean.FALSE, 3000);
}

######


@Test
public void rewriteBatchedMaxAllowedSizeTest() throws SQLException {
    createTable("MultiTestt6", "id int, test varchar(10000)");
    Assume.assumeTrue(checkMaxAllowedPacketMore8m("rewriteBatchedMaxAllowedSizeTest"));
    Statement st = sharedConnection.createStatement();
    ResultSet rs = st.executeQuery("select @@max_allowed_packet");
    if (rs.next()) {
        long maxAllowedPacket = rs.getInt(1);
        Assume.assumeTrue(maxAllowedPacket < 512 * 1024 * 1024L);
        int totalInsertCommands = (int) Math.ceil(maxAllowedPacket / 10050);
        verifyInsertBehaviorBasedOnRewriteBatchedStatements(Boolean.TRUE, totalInsertCommands);
    } else {
        fail();
    }
}

######


@Test
public void rewriteBatchedWithoutParam() throws SQLException {
    try (Connection connection = setConnection("&rewriteBatchedStatements=true")) {
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO MultiTestt10 VALUES (1)");
        for (int i = 0; i < 100; i++) {
            preparedStatement.addBatch();
        }
        preparedStatement.executeBatch();
        ResultSet rs = connection.createStatement().executeQuery("SELECT COUNT(*) FROM MultiTestt10");
        assertTrue(rs.next());
        assertEquals(100, rs.getInt(1));
    }
}

######


@Test
public void rewriteStatementWithoutParameter() throws SQLException {
    try (Connection connection = setConnection("&rewriteBatchedStatements=true")) {
        try (PreparedStatement statement = connection.prepareStatement("SELECT 1")) {
            statement.executeQuery();
        }
    }
}

######


@Test
public void rewriteMonoQueryStatementWithParameter() throws SQLException {
    try (Connection connection = setConnection("&rewriteBatchedStatements=true")) {
        String failingQuery1 = "SELECT (1=? AND 2=2)";
        String failingQuery2 = "SELECT (1=?) AND 2=2";
        String workingQuery = "SELECT 1=? AND (2=2)";
        try (PreparedStatement statement = connection.prepareStatement(failingQuery1)) {
            checkResult(statement);
        }
        try (PreparedStatement statement = connection.prepareStatement(failingQuery2)) {
            checkResult(statement);
        }
        try (PreparedStatement statement = connection.prepareStatement(workingQuery)) {
            checkResult(statement);
        }
    }
}

######


private void checkResult(PreparedStatement statement) throws SQLException {
    statement.setInt(1, 1);
    statement.executeQuery();
    ResultSet rs = statement.executeQuery();
    assertTrue(rs.next());
    assertTrue(rs.getBoolean(1));
}

######


@Test
public void testServerPrepareMeta() throws Throwable {
    try (Connection connection = setConnection("&rewriteBatchedStatements=true")) {
        createTable("insertSelectTable1", "tt int");
        createTable("insertSelectTable2", "tt int");
        Statement stmt = connection.createStatement();
        stmt.execute("INSERT INTO insertSelectTable2(tt) VALUES (1),(2),(1)");
        PreparedStatement ps = connection.prepareStatement("INSERT INTO insertSelectTable1 " + "SELECT a1.tt FROM insertSelectTable2 a1 " + "WHERE a1.tt = ? ");
        ps.setInt(1, 1);
        ps.addBatch();
        ps.setInt(1, 2);
        ps.addBatch();
        ps.executeBatch();
        ResultSet rs = stmt.executeQuery("SELECT count(*) FROM insertSelectTable1");
        assertTrue(rs.next());
        assertEquals(3, rs.getInt(1));
    }
}

######


private void verifyInsertBehaviorBasedOnRewriteBatchedStatements(Boolean rewriteBatchedStatements, int totalInsertCommands) throws SQLException {
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", rewriteBatchedStatements.toString());
    props.setProperty("allowMultiQueries", "true");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        verifyInsertCount(tmpConnection, 0);
        Statement statement = tmpConnection.createStatement();
        for (int i = 0; i < totalInsertCommands; i++) {
            statement.addBatch("INSERT INTO MultiTestt6 VALUES (" + i + ", 'testValue" + i + "')");
        }
        int[] updateCounts = statement.executeBatch();
        assertEquals(totalInsertCommands, updateCounts.length);
        int totalUpdates = 0;
        for (int updateCount : updateCounts) {
            assertEquals(1, updateCount);
            totalUpdates += updateCount;
        }
        assertEquals(totalInsertCommands, totalUpdates);
        verifyInsertCount(tmpConnection, totalInsertCommands);
    }
}

######


private void verifyInsertCount(Connection tmpConnection, int insertCount) throws SQLException {
    assertEquals(insertCount, retrieveSessionVariableFromServer(tmpConnection, "Com_insert"));
}

######


private int retrieveSessionVariableFromServer(Connection tmpConnection, String variable) throws SQLException {
    Statement statement = tmpConnection.createStatement();
    try (ResultSet resultSet = statement.executeQuery("SHOW STATUS LIKE '" + variable + "'")) {
        if (resultSet.next()) {
            return resultSet.getInt(2);
        }
    }
    throw new SQLException("Unable to retrieve, variable value from Server " + variable);
}

######


@Test
public void rewriteBatchedStatementsWithQueryFirstAndLAst() throws SQLException {
    try (Connection connection = setConnection("&rewriteBatchedStatements=true")) {
        PreparedStatement sqlInsert = connection.prepareStatement("INSERT INTO MultiTestt3_dupp(col1, pkey,col2," + "col3,col4) VALUES (9, ?, 5, ?, 8) ON DUPLICATE KEY UPDATE pkey=pkey+10");
        sqlInsert.setInt(1, 1);
        sqlInsert.setInt(2, 2);
        sqlInsert.addBatch();
        sqlInsert.setInt(1, 2);
        sqlInsert.setInt(2, 5);
        sqlInsert.addBatch();
        sqlInsert.setInt(1, 7);
        sqlInsert.setInt(2, 6);
        sqlInsert.addBatch();
        sqlInsert.executeBatch();
    }
}

######


@Test
public void rewriteBatchedStatementsSemicolon() throws SQLException {
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", "true");
    props.setProperty("allowMultiQueries", "true");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        final int currentInsert = retrieveSessionVariableFromServer(tmpConnection, "Com_insert");
        PreparedStatement sqlInsert = tmpConnection.prepareStatement("INSERT INTO MultiTestt3 (message) VALUES (?)");
        sqlInsert.setString(1, "aa");
        sqlInsert.addBatch();
        sqlInsert.setString(1, "b;b");
        sqlInsert.addBatch();
        sqlInsert.setString(1, ";ccccccc");
        sqlInsert.addBatch();
        sqlInsert.setString(1, "ddddddddddddddd;");
        sqlInsert.addBatch();
        sqlInsert.setString(1, ";eeeeeee;;eeeeeeeeee;eeeeeeeeee;");
        sqlInsert.addBatch();
        int[] updateCounts = sqlInsert.executeBatch();
        assertEquals(5, updateCounts.length);
        assertEquals(Statement.SUCCESS_NO_INFO, updateCounts[0]);
        assertEquals(Statement.SUCCESS_NO_INFO, updateCounts[1]);
        assertEquals(Statement.SUCCESS_NO_INFO, updateCounts[2]);
        assertEquals(Statement.SUCCESS_NO_INFO, updateCounts[3]);
        assertEquals(Statement.SUCCESS_NO_INFO, updateCounts[4]);
        assertEquals(1, retrieveSessionVariableFromServer(tmpConnection, "Com_insert") - currentInsert);
        int[] realUpdateCount = ((ClientSidePreparedStatement) sqlInsert).getServerUpdateCounts();
        assertEquals(1, realUpdateCount.length);
        assertEquals(5, realUpdateCount[0]);
        final int secondCurrentInsert = retrieveSessionVariableFromServer(tmpConnection, "Com_insert");
        sqlInsert = tmpConnection.prepareStatement("INSERT INTO MultiTestt3 (message) VALUES (?); " + "INSERT INTO MultiTestt3 (message) VALUES ('multiple')");
        sqlInsert.setString(1, "aa");
        sqlInsert.addBatch();
        sqlInsert.setString(1, "b;b");
        sqlInsert.addBatch();
        try {
            updateCounts = sqlInsert.executeBatch();
            assertEquals(4, updateCounts.length);
            assertEquals(1, updateCounts[0]);
            assertEquals(1, updateCounts[1]);
            assertEquals(1, updateCounts[2]);
            assertEquals(1, updateCounts[3]);
            assertEquals(4, retrieveSessionVariableFromServer(tmpConnection, "Com_insert") - secondCurrentInsert);
        } catch (BatchUpdateException bue) {
            if ((sharedOptions().useBulkStmts && isMariadbServer() && minVersion(10, 2))) {
                assertTrue(bue.getMessage().contains("You have an error in your SQL syntax"));
            } else {
                fail(bue.getMessage());
            }
        }
    }
}

######


private PreparedStatement prepareStatementBatch(Connection tmpConnection, int size) throws SQLException {
    PreparedStatement preparedStatement = tmpConnection.prepareStatement("INSERT INTO MultiTestt7 VALUES (?, ?)");
    for (int i = 0; i < size; i++) {
        preparedStatement.setInt(1, i);
        preparedStatement.setString(2, "testValue" + i);
        preparedStatement.addBatch();
        preparedStatement.setInt(1, i);
        preparedStatement.setString(2, "testSecn" + i);
        preparedStatement.addBatch();
    }
    return preparedStatement;
}

######


@Test
public void semicolonTest() throws SQLException {
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", "true");
    props.setProperty("allowMultiQueries", "true");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        Statement sqlInsert = tmpConnection.createStatement();
        verifyInsertCount(tmpConnection, 0);
        for (int i = 0; i < 100; i++) {
            sqlInsert.addBatch("insert into MultiTestprepsemi (text) values ('This is a test" + i + "');");
        }
        sqlInsert.executeBatch();
        verifyInsertCount(tmpConnection, 100);
        for (int i = 0; i < 100; i++) {
            sqlInsert.addBatch("insert into MultiTestprepsemi (text) values ('This is a test" + i + "')");
        }
        sqlInsert.executeBatch();
        verifyInsertCount(tmpConnection, 200);
    }
}

######


@Test
public void rewriteBatchedStatementsUpdateTest() throws SQLException {
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", "true");
    props.setProperty("allowMultiQueries", "true");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        tmpConnection.setClientInfo(props);
        verifyUpdateCount(tmpConnection, 0);
        int cycles = 1000;
        prepareStatementBatch(tmpConnection, cycles).executeBatch();
        PreparedStatement preparedStatement = tmpConnection.prepareStatement("UPDATE MultiTestt7 SET test = ? WHERE id = ?");
        for (int i = 0; i < cycles; i++) {
            preparedStatement.setString(1, "updated testValue" + i);
            preparedStatement.setInt(2, i);
            preparedStatement.addBatch();
        }
        int[] updateCounts = preparedStatement.executeBatch();
        assertEquals(cycles, updateCounts.length);
        for (int updateCount : updateCounts) {
            assertTrue(updateCount == 2 || updateCount == Statement.SUCCESS_NO_INFO);
        }
        verifyUpdateCount(tmpConnection, cycles);
    }
}

######


@Test
public void testMultipleExecuteBatch() throws SQLException {
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", "true");
    props.setProperty("allowMultiQueries", "true");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        tmpConnection.setClientInfo(props);
        verifyUpdateCount(tmpConnection, 0);
        tmpConnection.createStatement().execute("insert into MultiTestt8 values(1,'a'),(2,'a')");
        PreparedStatement preparedStatement = tmpConnection.prepareStatement("UPDATE MultiTestt8 SET test = ? WHERE id = ?");
        preparedStatement.setString(1, "executebatch");
        preparedStatement.setInt(2, 1);
        preparedStatement.addBatch();
        preparedStatement.setString(1, "executebatch2");
        preparedStatement.setInt(2, 3);
        preparedStatement.addBatch();
        int[] updateCounts = preparedStatement.executeBatch();
        assertEquals(2, updateCounts.length);
        preparedStatement.setString(1, "executebatch3");
        preparedStatement.setInt(2, 1);
        preparedStatement.addBatch();
        updateCounts = preparedStatement.executeBatch();
        assertEquals(1, updateCounts.length);
    }
}

######


@Test
public void rewriteBatchedStatementsInsertWithDuplicateRecordsTest() throws SQLException {
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", "true");
    props.setProperty("allowMultiQueries", "true");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        verifyInsertCount(tmpConnection, 0);
        Statement statement = tmpConnection.createStatement();
        for (int i = 0; i < 100; i++) {
            int newId = i % 20;
            String roleTxt = "VAMPIRE" + newId;
            statement.addBatch("INSERT IGNORE  INTO MultiTestreWriteDuplicateTestTable VALUES (" + newId + ", '" + roleTxt + "')");
        }
        int[] updateCounts = statement.executeBatch();
        assertEquals(100, updateCounts.length);
        for (int i = 0; i < updateCounts.length; i++) {
            assertEquals((i < 20) ? 1 : 0, updateCounts[i]);
        }
        verifyInsertCount(tmpConnection, 100);
        verifyUpdateCount(tmpConnection, 0);
    }
}

######


@Test
public void updateCountTest() throws SQLException {
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", "true");
    props.setProperty("allowMultiQueries", "true");
    props.setProperty("useBulkStmts", "false");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        PreparedStatement sqlInsert = tmpConnection.prepareStatement("INSERT IGNORE INTO MultiTestt4 (id,test) VALUES (?,?)");
        sqlInsert.setInt(1, 1);
        sqlInsert.setString(2, "value1");
        sqlInsert.addBatch();
        sqlInsert.setInt(1, 1);
        sqlInsert.setString(2, "valuenull");
        sqlInsert.addBatch();
        sqlInsert.setInt(1, 2);
        sqlInsert.setString(2, "value2");
        sqlInsert.addBatch();
        sqlInsert.setInt(1, 3);
        sqlInsert.setString(2, "value2");
        sqlInsert.addBatch();
        int[] insertCounts = sqlInsert.executeBatch();
        assertEquals(4, insertCounts.length);
        assertEquals(Statement.SUCCESS_NO_INFO, insertCounts[0]);
        assertEquals(Statement.SUCCESS_NO_INFO, insertCounts[1]);
        assertEquals(Statement.SUCCESS_NO_INFO, insertCounts[2]);
        assertEquals(Statement.SUCCESS_NO_INFO, insertCounts[3]);
        PreparedStatement sqlUpdate = tmpConnection.prepareStatement("UPDATE MultiTestt4 SET test = ? WHERE test = ?");
        sqlUpdate.setString(1, "value1 - updated");
        sqlUpdate.setString(2, "value1");
        sqlUpdate.addBatch();
        sqlUpdate.setString(1, "value3 - updated");
        sqlUpdate.setString(2, "value3");
        sqlUpdate.addBatch();
        sqlUpdate.setString(1, "value2 - updated");
        sqlUpdate.setString(2, "value2");
        sqlUpdate.addBatch();
        int[] updateCounts = sqlUpdate.executeBatch();
        assertEquals(3, updateCounts.length);
        assertEquals(1, updateCounts[0]);
        assertEquals(0, updateCounts[1]);
        assertEquals(2, updateCounts[2]);
    }
}

######


private void verifyUpdateCount(Connection tmpConnection, int updateCount) throws SQLException {
    assertEquals(updateCount, retrieveSessionVariableFromServer(tmpConnection, "Com_update"));
}

######


@Test
public void testInsertWithLeadingConstantValue() throws Exception {
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", "true");
    props.setProperty("allowMultiQueries", "true");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        PreparedStatement insertStmt = tmpConnection.prepareStatement("INSERT INTO MultiTesttest_table (col1, col2," + " col3, col4, col5) values('some value', ?, 'other value', ?, 'third value')");
        insertStmt.setString(1, "a1");
        insertStmt.setString(2, "a2");
        insertStmt.addBatch();
        insertStmt.setString(1, "b1");
        insertStmt.setString(2, "b2");
        insertStmt.addBatch();
        insertStmt.executeBatch();
    }
}

######


@Test
public void testInsertWithoutFirstContent() throws Exception {
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", "true");
    props.setProperty("allowMultiQueries", "true");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        PreparedStatement insertStmt = tmpConnection.prepareStatement("INSERT INTO MultiTesttest_table2 " + "(col2, col3, col4, col5) values(?, 'other value', ?, 'third value')");
        insertStmt.setString(1, "a1");
        insertStmt.setString(2, "a2");
        insertStmt.addBatch();
        insertStmt.setString(1, "b1");
        insertStmt.setString(2, "b2");
        insertStmt.addBatch();
        insertStmt.executeBatch();
    }
}

######


@Test
public void testduplicate() throws Exception {
    createTable("SOME_TABLE", "ID INT(11) not null, FOO INT(11), PRIMARY KEY (ID), UNIQUE INDEX `FOO` (`FOO`)");
    String sql = "insert into `SOME_TABLE` (`ID`, `FOO`) values (?, ?) " + "on duplicate key update `SOME_TABLE`.`FOO` = ?";
    PreparedStatement st = sharedConnection.prepareStatement(sql);
    st.setInt(1, 1);
    st.setInt(2, 1);
    st.setInt(3, 1);
    st.addBatch();
    st.setInt(1, 2);
    st.setInt(2, 1);
    st.setInt(3, 2);
    st.addBatch();
    st.executeBatch();
    sql = "/*CLIENT*/" + sql;
    st = sharedConnection.prepareStatement(sql);
    st.setInt(1, 4);
    st.setInt(2, 4);
    st.setInt(3, 5);
    st.addBatch();
    st.setInt(1, 5);
    st.setInt(2, 4);
    st.setInt(3, 8);
    st.addBatch();
    st.executeBatch();
}

######


@Test
public void valuesWithoutSpace() throws Exception {
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", "true");
    props.setProperty("allowMultiQueries", "true");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        PreparedStatement insertStmt = tmpConnection.prepareStatement("INSERT INTO MultiTestValues (col1, col2)VALUES (?, ?)");
        insertStmt.setString(1, "a");
        insertStmt.setString(2, "b");
        insertStmt.addBatch();
        insertStmt.setString(1, "c");
        insertStmt.setString(2, "d");
        insertStmt.addBatch();
        insertStmt.executeBatch();
    }
}

######


@Test
public void valuesWithoutSpacewithoutRewrite() throws Exception {
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", "true");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        PreparedStatement insertStmt = tmpConnection.prepareStatement("INSERT INTO MultiTestValues (col1, col2)VALUES (?, ?)");
        insertStmt.setString(1, "a");
        insertStmt.setString(2, "b");
        insertStmt.addBatch();
        insertStmt.setString(1, "c");
        insertStmt.setString(2, "d");
        insertStmt.addBatch();
        insertStmt.executeBatch();
    }
}

######


@Test
public void continueOnBatchError() throws SQLException {
    for (int i = 0; i < 16; i++) {
        continueOnBatchError(i % 16 < 8, i % 8 < 4, i % 4 < 2, i % 2 == 0);
    }
}

######


private void continueOnBatchError(boolean continueBatch, boolean serverPrepare, boolean rewrite, boolean batchMulti) throws SQLException {
    System.out.println("continueBatch:" + continueBatch + " serverPrepare:" + serverPrepare + " rewrite:" + rewrite + " batchMulti:" + batchMulti);
    createTable("MultiTestt9", "id int not null primary key, test varchar(10)");
    Assume.assumeTrue(!batchMulti || !sharedIsAurora());
    try (Connection connection = setBlankConnection("&useServerPrepStmts=" + serverPrepare + "&useBatchMultiSend=" + batchMulti + "&continueBatchOnError=" + continueBatch + "&rewriteBatchedStatements=" + rewrite)) {
        PreparedStatement pstmt = connection.prepareStatement("INSERT INTO MultiTestt9 (id, test) VALUES (?, ?)");
        for (int i = 0; i < 10; i++) {
            pstmt.setInt(1, (i == 5) ? 0 : i);
            pstmt.setString(2, String.valueOf(i));
            pstmt.addBatch();
        }
        try {
            pstmt.executeBatch();
            fail("Must have thrown SQLException");
        } catch (BatchUpdateException e) {
            int[] updateCount = e.getUpdateCounts();
            assertEquals(10, updateCount.length);
            if (rewrite) {
                assertEquals(Statement.EXECUTE_FAILED, updateCount[0]);
                assertEquals(Statement.EXECUTE_FAILED, updateCount[1]);
                assertEquals(Statement.EXECUTE_FAILED, updateCount[2]);
                assertEquals(Statement.EXECUTE_FAILED, updateCount[3]);
                assertEquals(Statement.EXECUTE_FAILED, updateCount[4]);
                assertEquals(Statement.EXECUTE_FAILED, updateCount[5]);
                assertEquals(Statement.EXECUTE_FAILED, updateCount[6]);
                assertEquals(Statement.EXECUTE_FAILED, updateCount[7]);
                assertEquals(Statement.EXECUTE_FAILED, updateCount[8]);
                assertEquals(Statement.EXECUTE_FAILED, updateCount[9]);
            } else {
                assertEquals(1, updateCount[0]);
                assertEquals(1, updateCount[1]);
                assertEquals(1, updateCount[2]);
                assertEquals(1, updateCount[3]);
                assertEquals(1, updateCount[4]);
                assertEquals(Statement.EXECUTE_FAILED, updateCount[5]);
                if (continueBatch) {
                    assertEquals(1, updateCount[6]);
                    assertEquals(1, updateCount[7]);
                    assertEquals(1, updateCount[8]);
                    assertEquals(1, updateCount[9]);
                } else {
                    if (batchMulti) {
                        assertEquals(1, updateCount[6]);
                        assertEquals(1, updateCount[7]);
                        assertEquals(1, updateCount[8]);
                        assertEquals(1, updateCount[9]);
                    } else {
                        assertEquals(Statement.EXECUTE_FAILED, updateCount[6]);
                        assertEquals(Statement.EXECUTE_FAILED, updateCount[7]);
                        assertEquals(Statement.EXECUTE_FAILED, updateCount[8]);
                        assertEquals(Statement.EXECUTE_FAILED, updateCount[9]);
                    }
                }
            }
            ResultSet rs = connection.createStatement().executeQuery("SELECT * FROM MultiTestt9");
            if (!rewrite) {
                checkNextData(0, rs);
                checkNextData(1, rs);
                checkNextData(2, rs);
                checkNextData(3, rs);
                checkNextData(4, rs);
                if (continueBatch || batchMulti) {
                    checkNextData(6, rs);
                    checkNextData(7, rs);
                    checkNextData(8, rs);
                    checkNextData(9, rs);
                }
            }
            assertFalse(rs.next());
        }
    }
}

######


private void checkNextData(int value, ResultSet rs) throws SQLException {
    assertTrue(rs.next());
    assertEquals(value, rs.getInt(1));
    assertEquals(String.valueOf(value), rs.getString(2));
}

######


@Test
public void testCloseStatementWithoutQuery() throws SQLException {
    final Statement statement = sharedConnection.createStatement();
    statement.setFetchSize(Integer.MIN_VALUE);
    for (int count = 1; count <= 10; count++) {
        statement.close();
    }
}

######


@Test
public void testClosePrepareStatementWithoutQuery() throws SQLException {
    final PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT 1");
    preparedStatement.setFetchSize(Integer.MIN_VALUE);
    for (int count = 1; count <= 10; count++) {
        preparedStatement.close();
    }
}

######


@Test
public void testCloseStatement() throws SQLException {
    createTable("testStatementClose", "id int");
    final Statement statement = sharedConnection.createStatement();
    statement.setFetchSize(1);
    statement.execute("INSERT INTO testStatementClose (id) VALUES (1)");
    for (int count = 1; count <= 10; count++) {
        statement.close();
    }
}

######


@Test
public void testClosePrepareStatement() throws SQLException {
    createTable("testPrepareStatementClose", "id int");
    sharedConnection.createStatement().execute("INSERT INTO testPrepareStatementClose(id) VALUES (1),(2),(3)");
    final PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT * FROM testPrepareStatementClose");
    preparedStatement.execute();
    preparedStatement.setFetchSize(1);
    for (int count = 1; count <= 10; count++) {
        preparedStatement.close();
    }
}

######


@Test
public void rewriteErrorRewriteValues() throws SQLException {
    prepareBatchUpdateException(true, true);
}

######


@Test
public void rewriteErrorRewriteMulti() throws SQLException {
    prepareBatchUpdateException(false, true);
}

######


@Test
public void rewriteErrorStandard() throws SQLException {
    prepareBatchUpdateException(false, false);
}

######


private void prepareBatchUpdateException(Boolean rewriteBatchedStatements, Boolean allowMultiQueries) throws SQLException {
    createTable("batchUpdateException", "i int,PRIMARY KEY (i)");
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", rewriteBatchedStatements.toString());
    props.setProperty("allowMultiQueries", allowMultiQueries.toString());
    props.setProperty("useServerPrepStmts", "false");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        verifyInsertCount(tmpConnection, 0);
        PreparedStatement ps = tmpConnection.prepareStatement("insert into batchUpdateException values(?)");
        ps.setInt(1, 1);
        ps.addBatch();
        ps.setInt(1, 2);
        ps.addBatch();
        ps.setInt(1, 1);
        ps.addBatch();
        ps.setInt(1, 3);
        ps.addBatch();
        try {
            ps.executeBatch();
            fail("exception should be throw above");
        } catch (BatchUpdateException bue) {
            int[] updateCounts = bue.getUpdateCounts();
            if (rewriteBatchedStatements || (sharedOptions().useBulkStmts && isMariadbServer() && minVersion(10, 2))) {
                assertEquals(4, updateCounts.length);
                assertEquals(Statement.EXECUTE_FAILED, updateCounts[0]);
                assertEquals(Statement.EXECUTE_FAILED, updateCounts[1]);
                assertEquals(Statement.EXECUTE_FAILED, updateCounts[2]);
                assertEquals(Statement.EXECUTE_FAILED, updateCounts[3]);
                verifyInsertCount(tmpConnection, 1);
            } else {
                assertEquals(4, updateCounts.length);
                assertEquals(1, updateCounts[0]);
                assertEquals(1, updateCounts[1]);
                assertEquals(Statement.EXECUTE_FAILED, updateCounts[2]);
                assertEquals(1, updateCounts[3]);
                verifyInsertCount(tmpConnection, 4);
            }
            assertTrue(bue.getCause() instanceof SQLIntegrityConstraintViolationException);
        }
    }
}

######


@Test
public void testLastPrepareDiscarded() throws Throwable {
    PreparedStatement preparedStatement1 = sharedConnection.prepareStatement("INSERT INTO MultiTestA (data) VALUES (?)");
    preparedStatement1.setString(1, "A");
    preparedStatement1.execute();
    PreparedStatement preparedStatement2 = sharedConnection.prepareStatement("select * from (select ? `field1` from dual) as tt");
    preparedStatement2.setString(1, "B");
    try {
        preparedStatement2.execute();
    } catch (Exception e) {
        ResultSet rs = sharedConnection.createStatement().executeQuery("SELECT * FROM MultiTestA");
        assertTrue(rs.next());
        assertEquals("A", rs.getString(1));
        assertFalse(rs.next());
    }
}

######


@Test
public void testMultiGeneratedKeyRewrite() throws Throwable {
    Assume.assumeFalse(isGalera());
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", "true");
    props.setProperty("allowMultiQueries", "true");
    props.setProperty("useServerPrepStmts", "false");
    props.setProperty("sessionVariables", "auto_increment_increment=3");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        checkResults(tmpConnection);
        checkResultsPrepare(tmpConnection);
        checkResultsPrepareMulti(tmpConnection);
        checkResultsPrepareBatch(tmpConnection);
    }
}

######


@Test
public void testMultiGeneratedKey() throws Throwable {
    Assume.assumeFalse(isGalera());
    Properties props = new Properties();
    props.setProperty("rewriteBatchedStatements", "false");
    props.setProperty("allowMultiQueries", "true");
    props.setProperty("useServerPrepStmts", "true");
    props.setProperty("sessionVariables", "auto_increment_increment=3");
    try (Connection tmpConnection = openNewConnection(connUri, props)) {
        checkResults(tmpConnection);
        checkResultsPrepare(tmpConnection);
        checkResultsPrepareMulti(tmpConnection);
        checkResultsPrepareBatch(tmpConnection);
    }
}

######


private void checkResultsPrepareBatch(Connection connection) throws SQLException {
    try (Statement stmt = connection.createStatement()) {
        stmt.executeQuery("truncate table testMultiGeneratedKey");
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO testMultiGeneratedKey (text) VALUES (?)", Statement.RETURN_GENERATED_KEYS);
        preparedStatement.setString(1, "data1");
        preparedStatement.addBatch();
        preparedStatement.setString(1, "data2");
        preparedStatement.addBatch();
        int[] updates = preparedStatement.executeBatch();
        assertEquals(2, updates.length);
        ResultSet rs = preparedStatement.getGeneratedKeys();
        assertTrue(rs.next());
        assertEquals(1, rs.getInt(1));
        assertTrue(rs.next());
        assertEquals(4, rs.getInt(1));
        assertFalse(rs.next());
        assertFalse(preparedStatement.getMoreResults());
        assertEquals(1, updates[0]);
        assertEquals(1, updates[1]);
    }
}

######


private void checkResultsPrepare(Connection connection) throws SQLException {
    try (Statement stmt = connection.createStatement()) {
        stmt.executeQuery("truncate table testMultiGeneratedKey");
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO testMultiGeneratedKey (text) VALUES (?)", Statement.RETURN_GENERATED_KEYS);
        preparedStatement.setString(1, "data1");
        int update = preparedStatement.executeUpdate();
        assertEquals(1, update);
        ResultSet rs = preparedStatement.getGeneratedKeys();
        assertTrue(rs.next());
        assertEquals(1, rs.getInt(1));
        assertFalse(rs.next());
    }
}

######


private void checkResultsPrepareMulti(Connection connection) throws SQLException {
    try (Statement stmt = connection.createStatement()) {
        stmt.executeQuery("truncate table testMultiGeneratedKey");
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO testMultiGeneratedKey (text) VALUES (?);" + "INSERT INTO testMultiGeneratedKey (text) VALUES (?)", Statement.RETURN_GENERATED_KEYS);
        preparedStatement.setString(1, "data1");
        preparedStatement.setString(2, "data2");
        int update = preparedStatement.executeUpdate();
        assertEquals(1, update);
        ResultSet rs = preparedStatement.getGeneratedKeys();
        assertTrue(rs.next());
        assertEquals(1, rs.getInt(1));
        assertFalse(rs.next());
        assertFalse(preparedStatement.getMoreResults());
        assertEquals(1, preparedStatement.getUpdateCount());
        rs = preparedStatement.getGeneratedKeys();
        assertTrue(rs.next());
        assertEquals(4, rs.getInt(1));
        assertFalse(rs.next());
        assertFalse(preparedStatement.getMoreResults());
    }
}

######


private void checkResults(Connection connection) throws SQLException {
    try (Statement stmt = connection.createStatement()) {
        stmt.executeQuery("truncate table testMultiGeneratedKey");
        int update = stmt.executeUpdate("INSERT INTO testMultiGeneratedKey (text) VALUES ('data1'), ('data2'), ('data3');" + "INSERT INTO testMultiGeneratedKey (text) VALUES ('data4'), ('data5')", Statement.RETURN_GENERATED_KEYS);
        assertEquals(3, update);
        ResultSet rs = stmt.getGeneratedKeys();
        assertTrue(rs.next());
        assertEquals(1, rs.getInt(1));
        assertTrue(rs.next());
        assertEquals(4, rs.getInt(1));
        assertTrue(rs.next());
        assertEquals(7, rs.getInt(1));
        assertFalse(rs.next());
        assertFalse(stmt.getMoreResults());
        assertEquals(2, stmt.getUpdateCount());
        rs = stmt.getGeneratedKeys();
        assertTrue(rs.next());
        assertEquals(10, rs.getInt(1));
        assertTrue(rs.next());
        assertEquals(13, rs.getInt(1));
        assertFalse(rs.next());
        assertFalse(stmt.getMoreResults());
        assertEquals(-1, stmt.getUpdateCount());
        update = stmt.executeUpdate("INSERT INTO testMultiGeneratedKey (text) VALUES ('data11')", Statement.RETURN_GENERATED_KEYS);
        assertEquals(1, update);
        rs = stmt.getGeneratedKeys();
        assertTrue(rs.next());
        assertEquals(16, rs.getInt(1));
        assertFalse(rs.next());
        assertFalse(stmt.getMoreResults());
        update = stmt.executeUpdate("SELECT * FROM testMultiGeneratedKey", Statement.RETURN_GENERATED_KEYS);
        assertEquals(0, update);
        rs = stmt.getGeneratedKeys();
        assertFalse(rs.next());
        assertFalse(stmt.getMoreResults());
        stmt.executeQuery("truncate table testMultiGeneratedKey");
        stmt.addBatch("INSERT INTO testMultiGeneratedKey (text) VALUES ('data0');INSERT INTO testMultiGeneratedKey (text) VALUES ('data1')");
        stmt.addBatch("INSERT INTO testMultiGeneratedKey (text) VALUES ('data2')");
        stmt.addBatch("INSERT INTO testMultiGeneratedKey (text) VALUES ('data3')");
        int[] updates = stmt.executeBatch();
        assertEquals(4, updates.length);
        assertEquals(1, updates[0]);
        assertEquals(1, updates[1]);
        assertEquals(1, updates[2]);
        assertEquals(1, updates[3]);
        rs = stmt.getGeneratedKeys();
        for (int i = 0; i < 4; i++) {
            assertTrue(rs.next());
            assertEquals(1 + i * 3, rs.getInt(1));
        }
        assertFalse(rs.next());
        assertFalse(stmt.getMoreResults());
        stmt.addBatch("INSERT INTO testMultiGeneratedKey (text) VALUES ('data11')");
        stmt.executeBatch();
        rs = stmt.getGeneratedKeys();
        assertTrue(rs.next());
        assertEquals(13, rs.getInt(1));
        assertFalse(rs.next());
    }
}

######


@Test
public void testInsertSelectBulk() throws SQLException {
    try (Statement statement = sharedConnection.createStatement()) {
        statement.execute("DROP TABLE IF EXISTS testInsertSelectBulk");
        statement.execute("DROP TABLE IF EXISTS testInsertSelectBulk2");
        statement.execute("CREATE TABLE testInsertSelectBulk(col int, val int)");
        statement.execute("CREATE TABLE testInsertSelectBulk2(col int, val int)");
        statement.execute("INSERT INTO testInsertSelectBulk(col, val) VALUES (0,1), (2,3)");
        try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO testInsertSelectBulk2(col, val) VALUES " + "(?, (SELECT val FROM testInsertSelectBulk where col = ?))")) {
            preparedStatement.setInt(1, 4);
            preparedStatement.setInt(2, 0);
            preparedStatement.addBatch();
            preparedStatement.setInt(1, 5);
            preparedStatement.setInt(2, 2);
            preparedStatement.addBatch();
            preparedStatement.executeBatch();
        }
        ResultSet rs = statement.executeQuery("SELECT * from testInsertSelectBulk2");
        assertTrue(rs.next());
        assertEquals(4, rs.getInt(1));
        assertEquals(1, rs.getInt(2));
        assertTrue(rs.next());
        assertEquals(5, rs.getInt(1));
        assertEquals(3, rs.getInt(2));
    }
}

######


@Test
public void testAffectedRow() throws SQLException {
    createTable("testAffectedRow", "id int");
    testAffectedRow(false);
    testAffectedRow(true);
}

######


private void testAffectedRow(boolean useAffectedRows) throws SQLException {
    try (Connection con = setConnection(useAffectedRows ? "&useAffectedRows" : "")) {
        Statement stmt = con.createStatement();
        stmt.execute("TRUNCATE testAffectedRow");
        stmt.execute("INSERT INTO testAffectedRow values (1), (1), (2), (3)");
        int rowCount = stmt.executeUpdate("UPDATE testAffectedRow set id = 1");
        assertEquals(useAffectedRows ? 2 : 4, rowCount);
    }
}

######


private void extractCurrPtInfo() {
    mCurrPtX = mCurrPt.getX();
    mCurrPtY = mCurrPt.getY();
    mCurrPtDiam = Math.max(MIN_MULTITOUCH_SEPARATION * .71f, !mCurrXform.updateScale ? 0.0f : mCurrPt.getMultiTouchDiameter());
    mCurrPtWidth = Math.max(MIN_MULTITOUCH_SEPARATION, !mCurrXform.updateScaleXY ? 0.0f : mCurrPt.getMultiTouchWidth());
    mCurrPtHeight = Math.max(MIN_MULTITOUCH_SEPARATION, !mCurrXform.updateScaleXY ? 0.0f : mCurrPt.getMultiTouchHeight());
    mCurrPtAng = !mCurrXform.updateAngle ? 0.0f : mCurrPt.getMultiTouchAngle();
}

######


protected void setHandleSingleTouchEvents(boolean handleSingleTouchEvents) {
    this.handleSingleTouchEvents = handleSingleTouchEvents;
}

######


protected boolean getHandleSingleTouchEvents() {
    return handleSingleTouchEvents;
}

######


public boolean onTouchEvent(MotionEvent event) {
    try {
        int pointerCount = multiTouchSupported ? (Integer) m_getPointerCount.invoke(event) : 1;
        if (DEBUG)
            Log.i("MultiTouch", "Got here 1 - " + multiTouchSupported + " " + mMode + " " + handleSingleTouchEvents + " " + pointerCount);
        if (mMode == MODE_NOTHING && !handleSingleTouchEvents && pointerCount == 1)
            return false;
        if (DEBUG)
            Log.i("MultiTouch", "Got here 2");
        int action = event.getAction();
        int histLen = event.getHistorySize() / pointerCount;
        for (int histIdx = 0; histIdx <= histLen; histIdx++) {
            boolean processingHist = histIdx < histLen;
            if (!multiTouchSupported || pointerCount == 1) {
                if (DEBUG)
                    Log.i("MultiTouch", "Got here 3");
                xVals[0] = processingHist ? event.getHistoricalX(histIdx) : event.getX();
                yVals[0] = processingHist ? event.getHistoricalY(histIdx) : event.getY();
                pressureVals[0] = processingHist ? event.getHistoricalPressure(histIdx) : event.getPressure();
            } else {
                if (DEBUG)
                    Log.i("MultiTouch", "Got here 4");
                int numPointers = Math.min(pointerCount, MAX_TOUCH_POINTS);
                if (DEBUG && pointerCount > MAX_TOUCH_POINTS)
                    Log.i("MultiTouch", "Got more pointers than MAX_TOUCH_POINTS");
                for (int ptrIdx = 0; ptrIdx < numPointers; ptrIdx++) {
                    int ptrId = (Integer) m_getPointerId.invoke(event, ptrIdx);
                    pointerIds[ptrIdx] = ptrId;
                    xVals[ptrIdx] = (Float) (processingHist ? m_getHistoricalX.invoke(event, ptrIdx, histIdx) : m_getX.invoke(event, ptrIdx));
                    yVals[ptrIdx] = (Float) (processingHist ? m_getHistoricalY.invoke(event, ptrIdx, histIdx) : m_getY.invoke(event, ptrIdx));
                    pressureVals[ptrIdx] = (Float) (processingHist ? m_getHistoricalPressure.invoke(event, ptrIdx, histIdx) : m_getPressure.invoke(event, ptrIdx));
                }
            }
            decodeTouchEvent(pointerCount, xVals, yVals, pressureVals, pointerIds, processingHist ? MotionEvent.ACTION_MOVE : action, processingHist ? true : action != MotionEvent.ACTION_UP && (action & ((1 << ACTION_POINTER_INDEX_SHIFT) - 1)) != ACTION_POINTER_UP && action != MotionEvent.ACTION_CANCEL, processingHist ? event.getHistoricalEventTime(histIdx) : event.getEventTime());
        }
        return true;
    } catch (Exception e) {
        Log.e("MultiTouchController", "onTouchEvent() failed", e);
        return false;
    }
}

######


private void decodeTouchEvent(int pointerCount, float[] x, float[] y, float[] pressure, int[] pointerIds, int action, boolean down, long eventTime) {
    if (DEBUG)
        Log.i("MultiTouch", "Got here 5 - " + pointerCount + " " + action + " " + down);
    PointInfo tmp = mPrevPt;
    mPrevPt = mCurrPt;
    mCurrPt = tmp;
    mCurrPt.set(pointerCount, x, y, pressure, pointerIds, action, down, eventTime);
    multiTouchController();
}

######


private void anchorAtThisPositionAndScale() {
    if (selectedObject == null)
        return;
    objectCanvas.getPositionAndScale(selectedObject, mCurrXform);
    float currScaleInv = 1.0f / (!mCurrXform.updateScale ? 1.0f : mCurrXform.scale == 0.0f ? 1.0f : mCurrXform.scale);
    extractCurrPtInfo();
    startPosX = (mCurrPtX - mCurrXform.xOff) * currScaleInv;
    startPosY = (mCurrPtY - mCurrXform.yOff) * currScaleInv;
    startScaleOverPinchDiam = mCurrXform.scale / mCurrPtDiam;
    startScaleXOverPinchWidth = mCurrXform.scaleX / mCurrPtWidth;
    startScaleYOverPinchHeight = mCurrXform.scaleY / mCurrPtHeight;
    startAngleMinusPinchAngle = mCurrXform.angle - mCurrPtAng;
}

######


private void performDragOrPinch() {
    if (selectedObject == null)
        return;
    float currScale = !mCurrXform.updateScale ? 1.0f : mCurrXform.scale == 0.0f ? 1.0f : mCurrXform.scale;
    extractCurrPtInfo();
    float newPosX = mCurrPtX - startPosX * currScale;
    float newPosY = mCurrPtY - startPosY * currScale;
    float newScale = startScaleOverPinchDiam * mCurrPtDiam;
    float newScaleX = startScaleXOverPinchWidth * mCurrPtWidth;
    float newScaleY = startScaleYOverPinchHeight * mCurrPtHeight;
    float newAngle = startAngleMinusPinchAngle + mCurrPtAng;
    mCurrXform.set(newPosX, newPosY, newScale, newScaleX, newScaleY, newAngle);
    boolean success = objectCanvas.setPositionAndScale(selectedObject, mCurrXform, mCurrPt);
    if (!success)
        ;
}

######


private void multiTouchController() {
    if (DEBUG)
        Log.i("MultiTouch", "Got here 6 - " + mMode + " " + mCurrPt.getNumTouchPoints() + " " + mCurrPt.isDown() + mCurrPt.isMultiTouch());
    switch(mMode) {
        case MODE_NOTHING:
            if (mCurrPt.isDown()) {
                selectedObject = objectCanvas.getDraggableObjectAtPoint(mCurrPt);
                if (selectedObject != null) {
                    mMode = MODE_DRAG;
                    objectCanvas.selectObject(selectedObject, mCurrPt);
                    anchorAtThisPositionAndScale();
                    mSettleStartTime = mSettleEndTime = mCurrPt.getEventTime();
                }
            }
            break;
        case MODE_DRAG:
            if (!mCurrPt.isDown()) {
                mMode = MODE_NOTHING;
                objectCanvas.selectObject((selectedObject = null), mCurrPt);
            } else if (mCurrPt.isMultiTouch()) {
                mMode = MODE_PINCH;
                anchorAtThisPositionAndScale();
                mSettleStartTime = mCurrPt.getEventTime();
                mSettleEndTime = mSettleStartTime + EVENT_SETTLE_TIME_INTERVAL;
            } else {
                if (mCurrPt.getEventTime() < mSettleEndTime) {
                    anchorAtThisPositionAndScale();
                } else {
                    performDragOrPinch();
                }
            }
            break;
        case MODE_PINCH:
            if (!mCurrPt.isMultiTouch() || !mCurrPt.isDown()) {
                if (!mCurrPt.isDown()) {
                    mMode = MODE_NOTHING;
                    objectCanvas.selectObject((selectedObject = null), mCurrPt);
                } else {
                    mMode = MODE_DRAG;
                    anchorAtThisPositionAndScale();
                    mSettleStartTime = mCurrPt.getEventTime();
                    mSettleEndTime = mSettleStartTime + EVENT_SETTLE_TIME_INTERVAL;
                }
            } else {
                if (Math.abs(mCurrPt.getX() - mPrevPt.getX()) > MAX_MULTITOUCH_POS_JUMP_SIZE || Math.abs(mCurrPt.getY() - mPrevPt.getY()) > MAX_MULTITOUCH_POS_JUMP_SIZE || Math.abs(mCurrPt.getMultiTouchWidth() - mPrevPt.getMultiTouchWidth()) * .5f > MAX_MULTITOUCH_DIM_JUMP_SIZE || Math.abs(mCurrPt.getMultiTouchHeight() - mPrevPt.getMultiTouchHeight()) * .5f > MAX_MULTITOUCH_DIM_JUMP_SIZE) {
                    anchorAtThisPositionAndScale();
                    mSettleStartTime = mCurrPt.getEventTime();
                    mSettleEndTime = mSettleStartTime + EVENT_SETTLE_TIME_INTERVAL;
                } else if (mCurrPt.eventTime < mSettleEndTime) {
                    anchorAtThisPositionAndScale();
                } else {
                    performDragOrPinch();
                }
            }
            break;
    }
    if (DEBUG)
        Log.i("MultiTouch", "Got here 7 - " + mMode + " " + mCurrPt.getNumTouchPoints() + " " + mCurrPt.isDown() + mCurrPt.isMultiTouch());
}

######


private void set(int numPoints, float[] x, float[] y, float[] pressure, int[] pointerIds, int action, boolean isDown, long eventTime) {
    if (DEBUG)
        Log.i("MultiTouch", "Got here 8 - " + +numPoints + " " + x[0] + " " + y[0] + " " + (numPoints > 1 ? x[1] : x[0]) + " " + (numPoints > 1 ? y[1] : y[0]) + " " + action + " " + isDown);
    this.eventTime = eventTime;
    this.action = action;
    this.numPoints = numPoints;
    for (int i = 0; i < numPoints; i++) {
        this.xs[i] = x[i];
        this.ys[i] = y[i];
        this.pressures[i] = pressure[i];
        this.pointerIds[i] = pointerIds[i];
    }
    this.isDown = isDown;
    this.isMultiTouch = numPoints >= 2;
    if (isMultiTouch) {
        xMid = (x[0] + x[1]) * .5f;
        yMid = (y[0] + y[1]) * .5f;
        pressureMid = (pressure[0] + pressure[1]) * .5f;
        dx = Math.abs(x[1] - x[0]);
        dy = Math.abs(y[1] - y[0]);
    } else {
        xMid = x[0];
        yMid = y[0];
        pressureMid = pressure[0];
        dx = dy = 0.0f;
    }
    diameterSqIsCalculated = diameterIsCalculated = angleIsCalculated = false;
}

######


public void set(PointInfo other) {
    this.numPoints = other.numPoints;
    for (int i = 0; i < numPoints; i++) {
        this.xs[i] = other.xs[i];
        this.ys[i] = other.ys[i];
        this.pressures[i] = other.pressures[i];
        this.pointerIds[i] = other.pointerIds[i];
    }
    this.xMid = other.xMid;
    this.yMid = other.yMid;
    this.pressureMid = other.pressureMid;
    this.dx = other.dx;
    this.dy = other.dy;
    this.diameter = other.diameter;
    this.diameterSq = other.diameterSq;
    this.angle = other.angle;
    this.isDown = other.isDown;
    this.action = other.action;
    this.isMultiTouch = other.isMultiTouch;
    this.diameterIsCalculated = other.diameterIsCalculated;
    this.diameterSqIsCalculated = other.diameterSqIsCalculated;
    this.angleIsCalculated = other.angleIsCalculated;
    this.eventTime = other.eventTime;
}

######


public boolean isMultiTouch() {
    return isMultiTouch;
}

######


public float getMultiTouchWidth() {
    return isMultiTouch ? dx : 0.0f;
}

######


public float getMultiTouchHeight() {
    return isMultiTouch ? dy : 0.0f;
}

######


private int julery_isqrt(int val) {
    int temp, g = 0, b = 0x8000, bshft = 15;
    do {
        if (val >= (temp = (((g << 1) + b) << bshft--))) {
            g += b;
            val -= temp;
        }
    } while ((b >>= 1) > 0);
    return g;
}

######


public float getMultiTouchDiameterSq() {
    if (!diameterSqIsCalculated) {
        diameterSq = (isMultiTouch ? dx * dx + dy * dy : 0.0f);
        diameterSqIsCalculated = true;
    }
    return diameterSq;
}

######


public float getMultiTouchDiameter() {
    if (!diameterIsCalculated) {
        if (!isMultiTouch) {
            diameter = 0.0f;
        } else {
            float diamSq = getMultiTouchDiameterSq();
            diameter = (diamSq == 0.0f ? 0.0f : (float) julery_isqrt((int) (256 * diamSq)) / 16.0f);
            if (diameter < dx)
                diameter = dx;
            if (diameter < dy)
                diameter = dy;
        }
        diameterIsCalculated = true;
    }
    return diameter;
}

######


public float getMultiTouchAngle() {
    if (!angleIsCalculated) {
        if (!isMultiTouch)
            angle = 0.0f;
        else
            angle = (float) Math.atan2(ys[1] - ys[0], xs[1] - xs[0]);
        angleIsCalculated = true;
    }
    return angle;
}

######


public int getNumTouchPoints() {
    return numPoints;
}

######


public float getX() {
    return xMid;
}

######


public float[] getXs() {
    return xs;
}

######


public float getY() {
    return yMid;
}

######


public float[] getYs() {
    return ys;
}

######


public int[] getPointerIds() {
    return pointerIds;
}

######


public float getPressure() {
    return pressureMid;
}

######


public float[] getPressures() {
    return pressures;
}

######


public boolean isDown() {
    return isDown;
}

######


public int getAction() {
    return action;
}

######


public long getEventTime() {
    return eventTime;
}

######


public void set(float xOff, float yOff, boolean updateScale, float scale, boolean updateScaleXY, float scaleX, float scaleY, boolean updateAngle, float angle) {
    this.xOff = xOff;
    this.yOff = yOff;
    this.updateScale = updateScale;
    this.scale = scale == 0.0f ? 1.0f : scale;
    this.updateScaleXY = updateScaleXY;
    this.scaleX = scaleX == 0.0f ? 1.0f : scaleX;
    this.scaleY = scaleY == 0.0f ? 1.0f : scaleY;
    this.updateAngle = updateAngle;
    this.angle = angle;
}

######


protected void set(float xOff, float yOff, float scale, float scaleX, float scaleY, float angle) {
    this.xOff = xOff;
    this.yOff = yOff;
    this.scale = scale == 0.0f ? 1.0f : scale;
    this.scaleX = scaleX == 0.0f ? 1.0f : scaleX;
    this.scaleY = scaleY == 0.0f ? 1.0f : scaleY;
    this.angle = angle;
}

######


public float getXOff() {
    return xOff;
}

######


public float getYOff() {
    return yOff;
}

######


public float getScale() {
    return !updateScale ? 1.0f : scale;
}

######


public float getScaleX() {
    return !updateScaleXY ? 1.0f : scaleX;
}

######


public float getScaleY() {
    return !updateScaleXY ? 1.0f : scaleY;
}

######


public float getAngle() {
    return !updateAngle ? 0.0f : angle;
}

######


public T getDraggableObjectAtPoint(PointInfo touchPoint);

######


public void getPositionAndScale(T obj, PositionAndScale objPosAndScaleOut);

######


public boolean setPositionAndScale(T obj, PositionAndScale newObjPosAndScale, PointInfo touchPoint);

######


public void selectObject(T obj, PointInfo touchPoint);

######


@RequestMapping("/toHome")
public String toHome() {
    return "home";
}

######


@RequestMapping("/register")
public String spitters(Model model) {
    User user = new User();
    model.addAttribute(user);
    return "register";
}

######


@RequestMapping(value = "addUser", method = RequestMethod.POST)
public String addUser(@Valid User user, Errors errors) {
    if (errors.hasErrors()) {
        return "register";
    }
    String sql = "insert into user(firstName,lastName,email,username,password) values(?,?,?,?,?)";
    List param = new ArrayList();
    param.add(user.getFirstName());
    param.add(user.getLastName());
    param.add(user.getEmail());
    param.add(user.getUserName());
    param.add(user.getPassword());
    boolean flag = dataSouceFactory.executeDML(sql, param);
    return "success";
}

######


private <T extends MyEntity> ArrayList<T> getAllEntitiesList(Class<T> clazz, boolean include0) {
    Query<T> q = createQuery(clazz);
    q.where(include0 ? Expressions.gte("id", 0) : Expressions.gt("id", 0));
    q.asc("title");
    Cursor c = q.execute();
    try {
        T e0 = null;
        ArrayList<T> list = new ArrayList<T>();
        while (c.moveToNext()) {
            T e = EntityManager.loadFromCursor(c, clazz);
            if (e.id == 0) {
                e0 = e;
            } else {
                list.add(e);
            }
        }
        if (e0 != null) {
            list.add(0, e0);
        }
        return list;
    } finally {
        c.close();
    }
}

######


private <T extends MyEntity> ArrayList<T> getAllEntitiesList(Class<T> clazz, boolean include0, boolean onlyActive) {
    Query<T> q = createQuery(clazz);
    Expression include0Ex = include0 ? Expressions.gte("id", 0) : Expressions.gt("id", 0);
    if (onlyActive) {
        q.where(Expressions.and(include0Ex, Expressions.eq("isActive", 1)));
    } else {
        q.where(include0Ex);
    }
    q.asc("title");
    Cursor c = q.execute();
    try {
        T e0 = null;
        ArrayList<T> list = new ArrayList<T>();
        while (c.moveToNext()) {
            T e = EntityManager.loadFromCursor(c, clazz);
            if (e.id == 0) {
                e0 = e;
            } else {
                list.add(e);
            }
        }
        if (e0 != null) {
            list.add(0, e0);
        }
        return list;
    } finally {
        c.close();
    }
}

######


public TransactionInfo getTransactionInfo(long transactionId) {
    return get(TransactionInfo.class, transactionId);
}

######


public List<TransactionAttributeInfo> getAttributesForTransaction(long transactionId) {
    Query<TransactionAttributeInfo> q = createQuery(TransactionAttributeInfo.class).asc("name");
    q.where(Expressions.and(Expressions.eq("transactionId", transactionId), Expressions.gte("attributeId", 0)));
    Cursor c = q.execute();
    try {
        List<TransactionAttributeInfo> list = new LinkedList<TransactionAttributeInfo>();
        while (c.moveToNext()) {
            TransactionAttributeInfo ti = loadFromCursor(c, TransactionAttributeInfo.class);
            list.add(ti);
        }
        return list;
    } finally {
        c.close();
    }
}

######


public TransactionAttributeInfo getSystemAttributeForTransaction(SystemAttribute sa, long transactionId) {
    Query<TransactionAttributeInfo> q = createQuery(TransactionAttributeInfo.class);
    q.where(Expressions.and(Expressions.eq("transactionId", transactionId), Expressions.eq("attributeId", sa.id)));
    Cursor c = q.execute();
    try {
        if (c.moveToFirst()) {
            return loadFromCursor(c, TransactionAttributeInfo.class);
        }
        return null;
    } finally {
        c.close();
    }
}

######


public Account getAccount(long id) {
    return get(Account.class, id);
}

######


public Cursor getAccountsForTransaction(Transaction t) {
    return getAllAccounts(true, t.fromAccountId, t.toAccountId);
}

######


public Cursor getAllActiveAccounts() {
    return getAllAccounts(true);
}

######


public Cursor getAllAccounts() {
    return getAllAccounts(false);
}

######


private Cursor getAllAccounts(boolean isActiveOnly, long... includeAccounts) {
    AccountSortOrder sortOrder = MyPreferences.getAccountSortOrder(context);
    Query<Account> q = createQuery(Account.class);
    if (isActiveOnly) {
        int count = includeAccounts.length;
        if (count > 0) {
            Expression[] ee = new Expression[count + 1];
            for (int i = 0; i < count; i++) {
                ee[i] = Expressions.eq("id", includeAccounts[i]);
            }
            ee[count] = Expressions.eq("isActive", 1);
            q.where(Expressions.or(ee));
        } else {
            q.where(Expressions.eq("isActive", 1));
        }
    }
    q.desc("isActive");
    if (sortOrder.asc) {
        q.asc(sortOrder.property);
    } else {
        q.desc(sortOrder.property);
    }
    return q.asc("title").execute();
}

######


public long saveAccount(Account account) {
    return saveOrUpdate(account);
}

######


public List<Account> getAllAccountsList() {
    return getAllAccountsList(false);
}

######


public List<Account> getAllAccountsList(boolean activeOnly) {
    List<Account> list = new ArrayList<Account>();
    Cursor c = getAllAccounts(activeOnly);
    try {
        while (c.moveToNext()) {
            Account a = EntityManager.loadFromCursor(c, Account.class);
            list.add(a);
        }
    } finally {
        c.close();
    }
    return list;
}

######


public LongSparseArray<Account> getAllAccountsMap() {
    LongSparseArray<Account> accountsMap = new LongSparseArray<Account>();
    List<Account> list = getAllAccountsList(false);
    for (Account account : list) {
        accountsMap.put(account.id, account);
    }
    return accountsMap;
}

######


public long saveOrUpdate(Currency currency) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        if (currency.isDefault) {
            db.execSQL(UPDATE_DEFAULT_FLAG);
        }
        long id = super.saveOrUpdate(currency);
        db.setTransactionSuccessful();
        return id;
    } finally {
        db.endTransaction();
    }
}

######


public int deleteCurrency(long id) {
    String sid = String.valueOf(id);
    Currency c = load(Currency.class, id);
    writeDeleteLog(CURRENCY_TABLE, c.remoteKey);
    return db().delete(CURRENCY_TABLE, "_id=? AND NOT EXISTS (SELECT 1 FROM " + ACCOUNT_TABLE + " WHERE " + AccountColumns.CURRENCY_ID + "=?)", new String[] { sid, sid });
}

######


public Cursor getAllCurrencies(String sortBy) {
    Query<Currency> q = createQuery(Currency.class);
    return q.desc("isDefault").asc(sortBy).execute();
}

######


public List<Currency> getAllCurrenciesList() {
    return getAllCurrenciesList("name");
}

######


public List<Currency> getAllCurrenciesList(String sortBy) {
    Query<Currency> q = createQuery(Currency.class);
    return q.desc("isDefault").asc(sortBy).list();
}

######


public Map<String, Currency> getAllCurrenciesByTtitleMap() {
    return entitiesAsTitleMap(getAllCurrenciesList("name"));
}

######


public Project getProject(long id) {
    return get(Project.class, id);
}

######


public ArrayList<Project> getAllProjectsList(boolean includeNoProject) {
    return getAllEntitiesList(Project.class, includeNoProject);
}

######


public ArrayList<Project> getActiveProjectsList(boolean includeNoProject) {
    return getAllEntitiesList(Project.class, includeNoProject, true);
}

######


public Map<String, Project> getAllProjectsByTitleMap(boolean includeNoProject) {
    return entitiesAsTitleMap(getAllProjectsList(includeNoProject));
}

######


public LongSparseArray<Project> getAllProjectsByIdMap(boolean includeNoProject) {
    return entitiesAsIdMap(getAllProjectsList(includeNoProject));
}

######


public long insertBudget(Budget budget) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        if (budget.id > 0) {
            deleteBudget(budget.id);
        }
        long id = 0;
        Recur recur = RecurUtils.createFromExtraString(budget.recur);
        Period[] periods = RecurUtils.periods(recur);
        for (int i = 0; i < periods.length; i++) {
            Period p = periods[i];
            budget.id = -1;
            budget.parentBudgetId = id;
            budget.recurNum = i;
            budget.startDate = p.start;
            budget.endDate = p.end;
            long bid = super.saveOrUpdate(budget);
            if (i == 0) {
                id = bid;
            }
        }
        db.setTransactionSuccessful();
        return id;
    } finally {
        db.endTransaction();
    }
}

######


public void deleteBudget(long id) {
    SQLiteDatabase db = db();
    Budget b = load(Budget.class, id);
    writeDeleteLog(BUDGET_TABLE, b.remoteKey);
    db.delete(BUDGET_TABLE, "_id=?", new String[] { String.valueOf(id) });
    String sql = "select remote_key from " + BUDGET_TABLE + " where parent_budget_id=" + id + "";
    Cursor cursorCursor = db.rawQuery(sql, null);
    if (cursorCursor.moveToFirst()) {
        do {
            String rKey = cursorCursor.getString(0);
            writeDeleteLog(BUDGET_TABLE, rKey);
        } while (cursorCursor.moveToNext());
    }
    cursorCursor.close();
    db.delete(BUDGET_TABLE, "parent_budget_id=?", new String[] { String.valueOf(id) });
}

######


public void deleteBudgetOneEntry(long id) {
    SQLiteDatabase db = db();
    Budget b = load(Budget.class, id);
    writeDeleteLog(BUDGET_TABLE, b.remoteKey);
    db.delete(BUDGET_TABLE, "_id=?", new String[] { String.valueOf(id) });
}

######


public ArrayList<Budget> getAllBudgets(WhereFilter filter) {
    Query<Budget> q = createQuery(Budget.class);
    Criteria c = filter.get(BlotterFilter.DATETIME);
    if (c != null) {
        long start = c.getLongValue1();
        long end = c.getLongValue2();
        q.where(Expressions.and(Expressions.lte("startDate", end), Expressions.gte("endDate", start)));
    }
    Cursor cursor = q.execute();
    try {
        ArrayList<Budget> list = new ArrayList<Budget>();
        while (cursor.moveToNext()) {
            Budget b = MyEntityManager.loadFromCursor(cursor, Budget.class);
            list.add(b);
        }
        return list;
    } finally {
        cursor.close();
    }
}

######


public void deleteProject(long id) {
    SQLiteDatabase db = db();
    db.beginTransaction();
    try {
        delete(Project.class, id);
        ContentValues values = new ContentValues();
        values.put("project_id", 0);
        db.update("transactions", values, "project_id=?", new String[] { String.valueOf(id) });
        db.setTransactionSuccessful();
    } finally {
        db.endTransaction();
    }
}

######


public ArrayList<TransactionInfo> getAllScheduledTransactions() {
    Query<TransactionInfo> q = createQuery(TransactionInfo.class);
    q.where(Expressions.and(Expressions.eq("isTemplate", 2), Expressions.eq("parentId", 0)));
    return (ArrayList<TransactionInfo>) q.list();
}

######


public ArrayList<Category> getAllCategoriesList(boolean includeNoCategory) {
    return getAllEntitiesList(Category.class, includeNoCategory);
}

######


public Payee insertPayee(String payee) {
    if (Utils.isEmpty(payee)) {
        return Payee.EMPTY;
    } else {
        Payee p = getPayee(payee);
        if (p == null) {
            p = new Payee();
            p.title = payee;
            p.id = saveOrUpdate(p);
        }
        return p;
    }
}

######


public Payee getPayee(String payee) {
    Query<Payee> q = createQuery(Payee.class);
    q.where(Expressions.eq("title", payee));
    return q.uniqueResult();
}

######


public Cursor getAllPayees() {
    Query<Payee> q = createQuery(Payee.class);
    return q.asc("title").execute();
}

######


public List<Payee> getAllPayeeList() {
    return getAllEntitiesList(Payee.class, true);
}

######


public Map<String, Payee> getAllPayeeByTitleMap() {
    return entitiesAsTitleMap(getAllPayeeList());
}

######


public LongSparseArray<Payee> getAllPayeeByIdMap() {
    return entitiesAsIdMap(getAllPayeeList());
}

######


@Override
protected String getDuplicateKeyErrorCode() {
    return MYSQL_DUPLICATE_KEY_ERROR_CODE;
}

######


@Override
protected String getSelectOpenoutputsSQL() {
    return SELECT_OPENOUTPUTS_SQL;
}

######


@Override
protected String getInsertOpenoutputsSQL() {
    return INSERT_OPENOUTPUTS_SQL;
}

######


@Override
protected String getDeleteOpenoutputsSQL() {
    return DELETE_OPENOUTPUTS_SQL;
}

######


@Override
protected String getTrasactionOutputSelectSQL() {
    return SELECT_TRANSACTION_OUTPUTS_SQL;
}

######


@Override
protected List<String> getCreateTablesSQL() {
    List<String> sqlStatements = new ArrayList<String>();
    sqlStatements.add(CREATE_SETTINGS_TABLE);
    sqlStatements.add(CREATE_HEADERS_TABLE);
    sqlStatements.add(CREATE_UNDOABLE_TABLE);
    sqlStatements.add(CREATE_OPEN_OUTPUT_TABLE);
    return sqlStatements;
}

######


@Override
protected List<String> getCreateIndexesSQL() {
    List<String> sqlStatements = new ArrayList<String>();
    sqlStatements.add(CREATE_UNDOABLE_TABLE_INDEX);
    sqlStatements.add(CREATE_OUTPUTS_ADDRESS_MULTI_INDEX);
    sqlStatements.add(CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX);
    sqlStatements.add(CREATE_OUTPUTS_HASH_INDEX);
    sqlStatements.add(CREATE_OUTPUTS_TOADDRESS_INDEX);
    return sqlStatements;
}

######


@Override
protected List<String> getCreateSchemeSQL() {
    return Collections.emptyList();
}

######


@Override
protected String getDatabaseDriverClass() {
    return DATABASE_DRIVER_CLASS;
}

######


public static String getUserInfo(int uid) {
    return "SELECT * FROM user_info WHERE uid='" + uid + "'";
}

######


public static String getInfo(int uid) {
    return "SELECT * FROM player WHERE uid='" + uid + "'";
}

######


public static String shareInfo(int uid, String chat) {
    return "UPDATE player SET " + chat + " WHERE uid='" + uid + "'";
}

######


public static String setUserInfo(String pass, int uid) {
    return "UPDATE user_info SET dyn_pass = '" + pass + "', l_date = '" + TimeUtil.getDefTime() + "' WHERE uid='" + uid + "'";
}

######


public void mysqlQuery() {
    String driver = "com.mysql.jdbc.Driver";
    String url = "jdbc:mysql:// rm-bp131v4sa3q248h9q342.mysql.rds.aliyuncs.com:3008/calm_gld";
    String user = "qgd_stf_wt_qa";
    String password = "PhEG6KP2nHsCnOz9jRfE";
    try {
        Class.forName(driver);
        java.sql.Connection conn = DriverManager.getConnection(url, user, password);
        if (!conn.isClosed())
            System.out.println("Succeeded connecting to the Database!");
        java.sql.Statement statement = conn.createStatement();
        String sql = "SELECT distinct brandId FROM customer " + "WHERE mobile IS NOT NULL " + "AND IFNULL(commercialID, upgradeCommercialId) IS NOT NULL " + "AND updatorId IS NOT NULL " + "ORDER BY	brandId DESC limit 10000;";
        ResultSet rs = statement.executeQuery(sql);
        List<String> brandIdList = new ArrayList<String>();
        String getSqlPrefix = "select brandId,commercialID from customer where brandID=";
        String getSqlPostfix = " and mobile IS NOT NULL and IFNULL(commercialID,upgradeCommercialId) is not null AND updatorId is not null limit 1";
        StringBuilder getSqlSb = new StringBuilder();
        ResultSet getSqlRs = null;
        while (rs.next()) {
            brandIdList.add(rs.getString("brandId"));
        }
        BufferedWriter wb = new BufferedWriter(new FileWriter(new File("C:\\Users\\Administrator\\Desktop\\test_data\\loyalty-importOrExport\\testData\\loyalty_brandIDAndShopId.txt")));
        StringBuilder lineSb = new StringBuilder();
        String lineSeparator = System.getProperty("line.separator");
        int count = 0;
        for (String brandId : brandIdList) {
            getSqlSb.append(getSqlPrefix).append(brandId).append(getSqlPostfix);
            getSqlRs = statement.executeQuery(getSqlSb.toString());
            while (getSqlRs.next()) {
                lineSb.append(getSqlRs.getString("brandId")).append(",").append(getSqlRs.getString("commercialID")).append(lineSeparator);
                wb.write(lineSb.toString());
                lineSb.delete(0, lineSb.length());
                if (++count % 100 == 0)
                    System.out.println("count:" + count);
            }
            getSqlSb.delete(0, getSqlSb.length());
        }
        wb.close();
        getSqlRs.close();
        rs.close();
        conn.close();
    } catch (ClassNotFoundException e) {
        System.out.println("Sorry,can`t find the Driver!");
        e.printStackTrace();
    } catch (SQLException e) {
        e.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public String getTable() {
    return table;
}

######


public void setTable(String table) {
    this.table = table;
}

######


public ArrayList<Map<String, String>> getTable(String table) throws Exception {
    ArrayList<Map<String, String>> temp = new ArrayList<Map<String, String>>();
    DBHelper db = new DBHelper();
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    String sql = "Select * From " + table + ";";
    try {
        conn = db.getConnetion();
        stmt = conn.prepareStatement(sql);
        rs = stmt.executeQuery();
        while (rs.next()) {
            Map<String, String> dataMap = new HashMap<String, String>();
            for (int b = 1; b <= rs.getMetaData().getColumnCount(); b++) {
                String name = rs.getMetaData().getColumnName(b);
                String value = rs.getString(name);
                dataMap.put(name, value);
            }
            temp.add(dataMap);
        }
        return temp;
    } catch (SQLException e) {
        e.printStackTrace();
        Map<String, String> dataMap = null;
        dataMap.put("错误", "00000");
        temp.add(dataMap);
        return temp;
    }
}

######


public void destoryDB() {
    if (rs != null) {
        try {
            rs.close();
            rs = null;
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
    if (stmt != null) {
        try {
            stmt.close();
            stmt = null;
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
    try {
        conn.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public int alter_value(String update_string, String limit) {
    try {
        conn = ConnUtils.getConnection();
        String sql = "update " + table + " set " + update_string + " " + limit + ";";
        System.out.println("准备修改");
        System.out.println(sql);
        stmt = conn.prepareStatement(sql);
        stmt.executeUpdate(sql);
        System.out.println("修改成功！");
    } catch (Exception e) {
        e.printStackTrace();
        System.out.println("333333333333333333");
        return 0;
    }
    return 1;
}

######


public boolean sql_opWord(String sql) {
    try {
        conn = ConnUtils.getConnection();
        System.out.println("准备修改");
        stmt = conn.prepareStatement(sql);
        stmt.executeUpdate(sql);
        System.out.println("修改成功！");
    } catch (Exception e) {
        e.printStackTrace();
        System.out.println("333333333333333333");
        return false;
    }
    return true;
}

######


public static void main(String[] args) {
    ArrayList test = new ArrayList();
    Mysql_operation opt = new Mysql_operation();
    try {
        test = opt.getTable("student");
    } catch (Exception e) {
        e.printStackTrace();
    }
    for (int a = 0; a < test.size(); a++) {
        Map temp1 = (Map) test.get(a);
        System.out.print(temp1.get("student_number") + "\n");
    }
    opt.setTable("student");
    opt.alter_value("Sfill_access='1'", "where user_number='201321091074'");
}

######


public static void main(String[] args) {
    NativeSQLTest test = new NativeSQLTest();
    test.beanQuery();
    HibernateUtil.sessionFactory.close();
}

######


public void scalarQuery() {
    Session session = HibernateUtil.currentSession();
    Transaction tx = session.beginTransaction();
    String sqlString = "select stu.* from student_inf as stu";
    List list = session.createSQLQuery(sqlString).addScalar("name", StandardBasicTypes.STRING).addScalar("student_id", StandardBasicTypes.INTEGER).list();
    for (Object ele : list) {
        Object[] row = (Object[]) ele;
        System.out.println(row[0] + "\t" + row[1]);
    }
    tx.commit();
    HibernateUtil.closeSession();
}

######


public void entityQuery() {
    Session session = HibernateUtil.currentSession();
    Transaction tx = session.beginTransaction();
    String sqlString = "select * from enrolment_inf where year=?1";
    List list = session.createSQLQuery(sqlString).addEntity(Enrolment.class).setInteger("1", 2005).list();
    for (Object ele : list) {
        Enrolment e = (Enrolment) ele;
        System.out.println(e.getStudent().getName() + "\t" + e.getCourse().getName());
    }
    tx.commit();
    HibernateUtil.closeSession();
}

######


public void multiEntityQuery() {
    Session session = HibernateUtil.currentSession();
    Transaction tx = session.beginTransaction();
    String sqlString = "select s.*,e.*,c.* " + "from student_inf s,enrolment_inf e,course_inf c " + "where s.student_id = e.student_id " + "and e.course_code = c.course_code";
    List list = session.createSQLQuery(sqlString).addEntity("s", Student.class).addEntity("e", Enrolment.class).addEntity("c", Course.class).list();
    tx.commit();
    HibernateUtil.closeSession();
    for (Object ele : list) {
        Object[] objs = (Object[]) ele;
        Student s = (Student) objs[0];
        Enrolment e = (Enrolment) objs[1];
        Course c = (Course) objs[2];
        System.out.println(s.getName() + "\t" + e.getYear() + "\t" + e.getSemester() + "\t" + c.getName());
    }
}

######


public void beanQuery() {
    Session session = HibernateUtil.currentSession();
    Transaction tx = session.beginTransaction();
    String sqlString = "select s.name stuName, c.name courseName " + "from student_inf s,enrolment_inf e,course_inf c " + "where s.student_id = e.student_id " + "and e.course_code = c.course_code ";
    List list = session.createSQLQuery(sqlString).setResultTransformer(Transformers.aliasToBean(StudentCourse.class)).list();
    tx.commit();
    HibernateUtil.closeSession();
    for (Object ele : list) {
        StudentCourse sc = (StudentCourse) ele;
        System.out.println(sc.getStuName() + "\t" + sc.getCourseName());
    }
}

######


public void joinQuery() {
    Session session = HibernateUtil.currentSession();
    Transaction tx = session.beginTransaction();
    String sqlString = "select s.* , e.* from student_inf s , " + "enrolment_inf e where s.student_id=e.student_id";
    List list = session.createSQLQuery(sqlString).addEntity("s", Student.class).addJoin("e", "s.enrolments").list();
    tx.commit();
    HibernateUtil.closeSession();
    for (Object ele : list) {
        Object[] objs = (Object[]) ele;
        Student s = (Student) objs[0];
        Enrolment e = (Enrolment) objs[1];
        System.out.println(s.getName() + "\t" + e.getYear());
    }
}

######


@Override
public void initialize(URL location, ResourceBundle resources) {
    managerId = MainWinController.currentUser.getUserId();
    btn_projectNew.setOnAction(e -> createProject());
}

######


private void createProject() {
    String insertQuery = "insert into mupp_project(project_name,project_description,project_percent,manager,git_url) " + "values(\"" + tf_projName.getText() + "\",\"" + ta_projectDesc.getText() + "\",0," + managerId + ",\"" + tf_projectGit.getText() + "\");";
    try {
        TCPConnection.getInstance().send(insertQuery);
        Stage stage = (Stage) btn_projectNew.getScene().getWindow();
        stage.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

######


public void setId(Integer id) {
    this.id = id;
}

######


public Integer getId() {
    return this.id;
}

######


public void setTitle(String title) {
    this.title = title;
}

######


public String getTitle() {
    return this.title;
}

######


public void setContent(String content) {
    this.content = content;
}

######


public String getContent() {
    return this.content;
}

######


public void setDs(DataSource ds) {
    this.ds = ds;
}

######


public void insert(String title, String content) {
    JdbcTemplate jt = new JdbcTemplate(ds);
    jt.update("insert into news_inf" + " values(null , ? , ?)", title, content);
    jt.update("insert into news_inf" + " values(null , ? , ?)", title, content);
}

######


@Override
public void initialize(URL location, ResourceBundle resources) {
    btn_addTask.setOnAction(e -> createTask());
}

######


private void createTask() {
    String insertQuery = "insert into mupp_task(name,description,project_id,assignee,start_date,finish_date) " + "values(\"" + tf_name.getText() + "\",\"" + ta_desc.getText() + "\"," + tf_projId.getText() + "," + tf_assignee.getText() + "," + (int) LocalDate.now().toEpochDay() + "," + tf_finishDate.getText() + ");";
    try {
        TCPConnection.getInstance().send(insertQuery);
        Stage stage = (Stage) btn_addTask.getScene().getWindow();
        stage.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

######


public void insert(NotebookData data) {
    String sql = "insert into " + DatabaseHelper.NOTE_TABLE_NAME;
    sql += "(_id, iid, time, date, content, color) values(?, ?, ?, ?, ?, ?)";
    SQLiteDatabase sqlite = dbHelper.getWritableDatabase();
    sqlite.execSQL(sql, new String[] { data.getId() + "", data.getIid() + "", data.getUnixTime() + "", data.getDate(), data.getContent(), data.getColor() + "" });
    sqlite.close();
}

######


public void delete(int id) {
    SQLiteDatabase sqlite = dbHelper.getWritableDatabase();
    String sql = ("delete from " + DatabaseHelper.NOTE_TABLE_NAME + " where _id=?");
    sqlite.execSQL(sql, new Integer[] { id });
    sqlite.close();
}

######


public void update(NotebookData data) {
    SQLiteDatabase sqlite = dbHelper.getWritableDatabase();
    String sql = ("update " + DatabaseHelper.NOTE_TABLE_NAME + " set iid=?, time=?, date=?, content=?, color=? where _id=?");
    sqlite.execSQL(sql, new String[] { data.getIid() + "", data.getUnixTime() + "", data.getDate(), data.getContent(), data.getColor() + "", data.getId() + "" });
    sqlite.close();
}

######


public List<NotebookData> query() {
    return query(" ");
}

######


public List<NotebookData> query(String where) {
    SQLiteDatabase sqlite = dbHelper.getReadableDatabase();
    ArrayList<NotebookData> data = null;
    data = new ArrayList<NotebookData>();
    Cursor cursor = sqlite.rawQuery("select * from " + DatabaseHelper.NOTE_TABLE_NAME + where, null);
    for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {
        NotebookData notebookData = new NotebookData();
        notebookData.setId(cursor.getInt(0));
        notebookData.setIid(cursor.getInt(1));
        notebookData.setUnixTime(cursor.getString(2));
        notebookData.setDate(cursor.getString(3));
        notebookData.setContent(cursor.getString(4));
        notebookData.setColor(cursor.getInt(5));
        data.add(notebookData);
    }
    if (!cursor.isClosed()) {
        cursor.close();
    }
    sqlite.close();
    return data;
}

######


public void reset(List<NotebookData> datas) {
    if (datas != null) {
        SQLiteDatabase sqlite = dbHelper.getWritableDatabase();
        sqlite.execSQL("delete from " + DatabaseHelper.NOTE_TABLE_NAME);
        for (NotebookData data : datas) {
            insert(data);
        }
        sqlite.close();
    }
}

######


public void save(NotebookData data) {
    List<NotebookData> datas = query(" where _id=" + data.getId());
    if (datas != null && !datas.isEmpty()) {
        update(data);
    } else {
        insert(data);
    }
}

######


public void destroy() {
    dbHelper.close();
}

######


@Transactional(readOnly = true)
public List<Integer> getAllOrganisationIdsWithObservations() throws SQLException {
    List<Integer> ids = new ArrayList<Integer>();
    String query = "SELECT DISTINCT o.id" + " FROM organisation o" + " INNER JOIN biological_sample bs ON bs.organisation_id=o.id" + " INNER JOIN observation ob ON ob.biological_sample_id=bs.id";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            ids.add(resultSet.getInt("id"));
        }
    }
    return ids;
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<Organisation> getAllOrganisationsWithObservations() {
    return getCurrentSession().createQuery("select distinct org from Observation as o inner join o.sample as s inner join s.organisation org").list();
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<Parameter> getAllParametersWithObservations() {
    return getCurrentSession().createQuery("select distinct param from Observation as o inner join o.parameter as param").list();
}

######


@Transactional(readOnly = true)
public List<Integer> getAllParameterIdsWithObservationsByOrganisation(Organisation organisation) throws SQLException {
    List<Integer> parameterIds = new ArrayList<Integer>();
    String query = "SELECT DISTINCT p.id" + " FROM phenotype_parameter p" + " INNER JOIN observation o ON o.parameter_id=p.id" + " INNER JOIN biological_sample bs ON bs.id=o.biological_sample_id" + " WHERE bs.organisation_id=?";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        statement.setInt(1, organisation.getId());
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            parameterIds.add(resultSet.getInt("id"));
        }
    }
    return parameterIds;
}

######


@Transactional(readOnly = true)
public List<Integer> getAllCategoricalParameterIdsWithObservationsByOrganisation(Organisation organisation) throws SQLException {
    List<Integer> parameterIds = new ArrayList<Integer>();
    String query = "SELECT DISTINCT p.id" + " FROM phenotype_parameter p" + " INNER JOIN observation o ON o.parameter_id=p.id" + " INNER JOIN biological_sample bs ON bs.id=o.biological_sample_id" + " WHERE bs.organisation_id=?" + " AND o.observation_type='categorical'";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        statement.setInt(1, organisation.getId());
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            parameterIds.add(resultSet.getInt("id"));
        }
    }
    return parameterIds;
}

######


public List<Map<String, String>> getDistinctUnidimensionalOrgPipelineParamStrainZygosityGeneAccessionAlleleAccessionMetadata() throws SQLException {
    Set<Map<String, String>> candidates = new HashSet<>();
    String query = "SELECT bm.zygosity, bmstrain.strain_acc AS strain_accession_id, e.organisation_id AS phenotyping_center_id, pipeline_id, SUBSTRING_INDEX(e.procedure_stable_id, \"_\", 2) AS procedure_group, parameter_id, metadata_group, bma.allele_acc AS allele_accession_id, bmgf.gf_acc AS gene_accession_id " + "FROM observation o " + "INNER JOIN biological_sample bs ON (o.biological_sample_id=bs.id AND bs.sample_group='experimental') " + "INNER JOIN biological_model_sample bms ON bms.biological_sample_id=o.biological_sample_id " + "INNER JOIN biological_model bm ON bm.id = bms.biological_model_id " + "INNER JOIN biological_model_allele bma ON bma.biological_model_id = bms.biological_model_id " + "INNER JOIN biological_model_genomic_feature bmgf ON bmgf.biological_model_id = bms.biological_model_id " + "INNER JOIN biological_model_strain bmstrain ON bmstrain.biological_model_id = bms.biological_model_id " + "INNER JOIN experiment_observation eo ON eo.observation_id=o.id " + "INNER JOIN experiment e ON e.id=eo.experiment_id " + "WHERE o.observation_type='unidimensional' ";
    try (PreparedStatement statement = getConnection().prepareStatement(query, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY)) {
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            Map<String, String> candidate = new HashMap<>();
            candidate.put("zygosity", resultSet.getString("zygosity"));
            candidate.put("strain_accession_id", resultSet.getString("strain_accession_id"));
            candidate.put("phenotyping_center_id", resultSet.getString("phenotyping_center_id"));
            candidate.put("pipeline_id", resultSet.getString("pipeline_id"));
            candidate.put("procedure_group", resultSet.getString("procedure_group"));
            candidate.put("parameter_id", resultSet.getString("parameter_id"));
            candidate.put("metadata_group", (resultSet.getString("metadata_group") == null) ? "" : resultSet.getString("metadata_group"));
            candidate.put("allele_accession_id", resultSet.getString("allele_accession_id"));
            candidate.put("gene_accession_id", resultSet.getString("gene_accession_id"));
            candidates.add(candidate);
        }
    }
    return new ArrayList<>(candidates);
}

######


@Transactional(readOnly = true)
public Observation getObservationById(Integer obsId) {
    return (Observation) getCurrentSession().createQuery("select distinct o from Observation as o where o.id=?").setInteger(0, obsId).uniqueResult();
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<Observation> getAllObservationsByParameter(Parameter parameter) {
    return getCurrentSession().createQuery("select distinct o from Observation as o where o.parameterId=?").setInteger(1, parameter.getId()).list();
}

######


public void actionPerformed(ActionEvent e) {
    try {
        DbDao dd = new DbDao("com.mysql.jdbc.Driver", "jdbc:mysql://localhost:3306/online_inf", "root", "32147");
        ResultSet rs = dd.query("select * from online_inf", false);
        StringBuffer beRemove = new StringBuffer("(");
        while (rs.next()) {
            if ((System.currentTimeMillis() - rs.getLong(5)) > MAX_MILLIS) {
                beRemove.append("'");
                beRemove.append(rs.getString(1));
                beRemove.append("' , ");
            }
        }
        if (beRemove.length() > 3) {
            beRemove.setLength(beRemove.length() - 3);
            beRemove.append(")");
            dd.modify("delete from online_inf where session_id in " + beRemove.toString());
        }
        dd.closeConn();
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void contextInitialized(ServletContextEvent sce) {
    new javax.swing.Timer(1000 * 5, new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            try {
                DbDao dd = new DbDao("com.mysql.jdbc.Driver", "jdbc:mysql://localhost:3306/online_inf", "root", "32147");
                ResultSet rs = dd.query("select * from online_inf", false);
                StringBuffer beRemove = new StringBuffer("(");
                while (rs.next()) {
                    if ((System.currentTimeMillis() - rs.getLong(5)) > MAX_MILLIS) {
                        beRemove.append("'");
                        beRemove.append(rs.getString(1));
                        beRemove.append("' , ");
                    }
                }
                if (beRemove.length() > 3) {
                    beRemove.setLength(beRemove.length() - 3);
                    beRemove.append(")");
                    dd.modify("delete from online_inf where session_id in " + beRemove.toString());
                }
                dd.closeConn();
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }).start();
}

######


public void contextDestroyed(ServletContextEvent sce) {
}

######


public abstract OnlineUser findBySessionidAndOrgi(String paramString, String orgi);

######


public abstract List<OnlineUser> findByUseridAndOrgi(String userid, String orgi);

######


public abstract int countByUseridAndOrgi(String userid, String orgi);

######


public abstract Page<OnlineUser> findByUseridAndOrgi(String userid, String orgi, Pageable page);

######


public abstract OnlineUser findByOrgiAndSessionid(String orgi, String sessionid);

######


public abstract Page<OnlineUser> findByOrgiAndStatusAndCreatetimeLessThan(String orgi, String status, Date createtime, Pageable paramPageable);

######


public abstract Page<OnlineUser> findByStatusAndCreatetimeLessThan(String status, Date createtime, Pageable paramPageable);

######


public abstract Page<OnlineUser> findByOrgiAndStatus(String paramString1, String paramString2, Pageable paramPageable);

######


@Query("select invitestatus , count(id) as users from OnlineUser where orgi = ?1 and status = ?2 group by invitestatus")
List<Object> findByOrgiAndStatus(String orgi, String status);

######


@Query("select result , count(id) as records from InviteRecord where orgi = ?1 and agentno = ?2 and createtime > ?3 and createtime < ?4 group by result")
List<Object> findByOrgiAndAgentnoAndCreatetimeRange(String orgi, String agentno, Date start, Date end);

######


@Query("select result , count(id) as records from InviteRecord where orgi = ?1 and agentno = ?2 group by result")
List<Object> findByOrgiAndUserid(String orgi, String userid);

######


@Query("select count(id) from AgentService where orgi = ?1 and status = ?2 and agentno = ?3 and createtime > ?4 and createtime < ?5")
Long countByAgentForAgentUser(String orgi, String status, String agentno, Date start, Date end);

######


@Query("select count(id) from AgentService where orgi = ?1 and status = ?2 and agentno = ?3 and createtime > ?4 and createtime < ?5")
Long countByAgentForAgentService(String orgi, String status, String agentno, Date start, Date end);

######


@Query("select avg(sessiontimes) from AgentService where orgi = ?1 and status = ?2 and agentno = ?3 and createtime > ?4 and createtime < ?5")
Long countByAgentForAvagTime(String orgi, String status, String agentno, Date start, Date end);

######


@Query("select avg(sessiontimes) from AgentService where orgi = ?1 and status = ?2 and userid = ?3")
Long countByUserForAvagTime(String orgi, String status, String userid);

######


@Query("select createdate as dt, count(distinct ip) as ips ,  count(id) as records from UserHistory where orgi = ?1 and model = ?2 and createtime > ?3 and createtime < ?4 group by createdate order by dt asc")
List<Object> findByOrgiAndCreatetimeRange(String orgi, String model, Date start, Date end);

######


@Query("select createdate as dt, count(id) as users from AgentService where orgi = ?1 and createtime > ?2 and createtime < ?3 group by createdate order by dt asc")
List<Object> findByOrgiAndCreatetimeRangeForAgent(String orgi, Date start, Date end);

######


@Query("select osname, count(id) as users from AgentService where orgi = ?1 and createtime > ?2 and createtime < ?3 and channel = ?4 group by osname")
List<Object> findByOrgiAndCreatetimeRangeForClient(String orgi, Date start, Date end, String channel);

######


@Query("select browser, count(id) as users from AgentService where orgi = ?1 and createtime > ?2 and createtime < ?3 and channel = ?4 group by browser")
List<Object> findByOrgiAndCreatetimeRangeForBrowser(String orgi, Date start, Date end, String channel);

######


@Query("select agentno, count(id) as users from AgentService where orgi = ?1 and userid = ?2 group by agentno")
List<Object> findByOrgiForDistinctAgent(String orgi, String userid);

######


@Query("select count(id) from AgentService where orgi = ?1 and appid = ?2 and createtime > ?3 and createtime < ?4")
Long countByOrgiAndAppidForCount(String orgi, String appid, Date start, Date end);

######


@Query("select count(id) from StatusEvent where discaller = ?1 and orgi = ?2")
Long countByCallerFromCallCenter(String caller, String orgi);

######


@Query("select count(id) from StatusEvent where discalled = ?1 and orgi = ?2")
Long countByCalledFromCallCenter(String called, String orgi);

######


@Query("select count(id) from StatusEvent where (discaller = ?1 or discalled = ?1) and orgi = ?2")
Long countByAniFromCallCenter(String ani, String orgi);

######


@Query("select avg(ringduration) from StatusEvent where ( discaller = ?1 or discalled = ?1 ) and misscall = true  and orgi = ?2")
Long avgByRingDurationFromCallCenter(String ani, String orgi);

######


@Query("select avg(duration) from StatusEvent where ( discaller = ?1 or discalled = ?1 )  and misscall = false and orgi = ?2")
Long avgByDurationFromCallCenter(String ani, String orgi);

######


@Query("select sum(ringduration) from StatusEvent where ( discaller = ?1 or discalled = ?1 )  and misscall = true and orgi = ?2")
Long sumByRingDurationFromCallCenter(String ani, String orgi);

######


@Query("select sum(duration) from StatusEvent where ( discaller = ?1 or discalled = ?1 )  and misscall = false and orgi = ?2")
Long sumByDurationFromCallCenter(String ani, String orgi);

######


@Query("select hourstr as dt, count(id) as calls from StatusEvent where orgi = ?1 and datestr = ?2 group by hourstr order by dt asc")
List<Object> findByOrgiAndDatestrRangeForAgent(String orgi, String start);

######


@Query("select code as dt, count(id) as co from CallMonitor where orgi = ?1 group by code")
List<Object> findByOrgiAndStatusRangeForAgent(String orgi);

######


@Query("select s from StatusEvent s  where startrecord<= ?1 AND ORGI = ?2 AND (discalled = ?3 OR discaller= ?4 )")
List<Object> findByOrgiAndStartrecord(Date startrecord, String orgi, String discalled, String discaller);

######


@Query("delete from CallOutNames where actid = ?2 AND ORGI = ?1")
void deleteByOrgiAndActid(String orgi, String actid);

######


@Query("SELECT e from EkmExperts e WHERE orgi = ?1 AND (bustype = ?2 or bustype = ?3 )")
Page<Object> findByExperts(String orgi, String exp, String au, Pageable paramPageable);

######


@Query("select e from EkmKwSearch e where orgi = ?1 and badword = 0 and type = ?2  group by conditions order by count(id) desc")
List<Object> findByOrgiAndSearch(String orgi, String type);

######


@Query("select e from EkmKwSearchTag e where orgi = ?1  group by tag order by count(id) desc")
List<Object> findByOrgiAndTag(String orgi);

######


@Query("select topicid,title from ChatMessage c where orgi = ?1 and aiid = ?2 and chatype = 'aireply' and topicid is not null AND title is not null  group by topicid,title order by count(topicid) desc")
Page<Object> findByOrgiAndMessage(String orgi, String aiid, Pageable paramPageable);

######


@Query("select count(id) from StatusEvent where orgi = ?1 and ?2 < createtime and createtime < ?3")
Long countByToadyCalledFromStatusEvent(String orgi, Date begin, Date end);

######


@Query("select count(id) from StatusEvent where orgi = ?1 and misscall = ?2 and ?3 < createtime and createtime < ?4")
Long countByToadyMissCalledFromStatusEvent(String orgi, boolean misscall, Date begin, Date end);

######


@Query("select count(id) from StatusEvent where orgi = ?1 and calltype = ?2 and ?3 < createtime and createtime < ?4")
Long countByToadyDirectionFromStatusEvent(String orgi, String calltype, Date begin, Date end);

######


@Query("select count(id) from StatusEvent where orgi = ?1 and calltype = ?2 and discaller = ?3 and ?4 < createtime and createtime < ?5")
Long countByToadyAniFromStatusEvent(String orgi, String calltype, String ani, Date begin, Date end);

######


@Query("select count(id) from StatusEvent where orgi = ?1 and (discaller = ?2 or discalled = ?3) and ?4 < createtime and createtime < ?5")
Long countByToadyExtentionFromStatusEvent(String orgi, String ani, String called, Date begin, Date end);

######


@Query("select AVG(duration) from StatusEvent where orgi = ?1 and (discaller = ?2 or discalled = ?3) and ?4 < createtime and createtime < ?5 and misscall = false ")
Long countByToadyExtDurFromStatusEvent(String orgi, String ani, String called, Date begin, Date end);

######


@Query("select AVG(ringduration) from StatusEvent where orgi = ?1 and (discaller = ?2 or discalled = ?3) and ?4 < createtime and createtime < ?5 and misscall = true ")
Long countByToadyExtRingFromStatusEvent(String orgi, String ani, String called, Date begin, Date end);

######


@Query("select count(id) from QualityMissionHis where orgi = ?1 and qualityuser = ?2 and qualitystatus = ?3")
Long countByQualityuserAndQualitystatusFromQualityMissionHis(String orgi, String qualityuser, String qualitystatus);

######


@Query("select count(id) from QualityMissionHis where orgi = ?1 and qualityuser = ?2")
Long countByQualityuserFromQualityMissionHis(String orgi, String qualityuser);

######


@Query("select count(id) from QualityMissionHis where orgi = ?1 and qualitydisuser = ?2 and qualitystatus = ?3")
Long countByQualitydisuserAndQualitystatusFromQualityMissionHis(String orgi, String qualitydisuser, String qualitystatus);

######


@Query("select count(id) from QualityMissionHis where orgi = ?1 and qualitydisuser = ?2")
Long countByQualitydisuserFromQualityMissionHis(String orgi, String qualitydisuser);

######


@Query("select count(id) from QualityMissionHis where orgi = ?1 and qualityuser = ?2 and qualitypass = ?3")
Long countByQualityuserAndQualitypassFromQualityMissionHis(String orgi, String qualityuser, int qualitypass);

######


@Query("select count(id) from QualityMissionHis where orgi = ?1 and qualityuser = ?2 and qualityappeal = ?3 and qualityarbitrate = ?4")
Long countByQualityuserAndQualityappealAndQualityarbitrateFromQualityMissionHis(String orgi, String qualityuser, int qualityappeal, int qualityarbitrate);

######


@Query("select qualityorgan,count(id) as misscount from QualityMissionHis  where orgi = ?1  GROUP BY qualityorgan ")
List<Object> findGroupbyOrganFromQualityMissionHis(String orgi);

######


@Query("select qualityorgan,count(id) as passcount  from QualityMissionHis  where orgi = ?1 and qualitypass = ?2 GROUP BY qualityorgan ")
List<Object> findByQualitypassGroupbyOrganFromQualityMissionHis(String orgi, int qualitypass);

######


@Query("select qualityorgan,count(id) as passcount  from QualityMissionHis  where orgi = ?1 and qualitypass = ?2 and qualitytype=?3 GROUP BY qualityorgan ")
List<Object> findByQualitypassGroupbyOrganFromQualityMissionHis(String orgi, int qualitypass, String qualitytype);

######


public static void main(String[] args) {
    try {
        Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
    } catch (Exception e) {
        System.out.println("Class not found");
    }
    try {
        String url = "jdbc:odbc:SSRMS";
        Connection con = DriverManager.getConnection(url);
        System.out.println("Made connection");
        Statement stmt = con.createStatement();
        stmt.executeUpdate("CREATE TABLE emp(id int Primary key,name varchar(100),salary money)");
        stmt.executeUpdate("INSERT INTO emp VALUES('1','Sagar','75000')");
        stmt.executeUpdate("INSERT INTO emp VALUES('2','Shravan', '80000')");
        ResultSet rs = stmt.executeQuery("SELECT * FROM emp");
        while (rs.next()) System.out.println(rs.getString(1) + '\t' + rs.getString("name") + '\t' + rs.getString("salary"));
        stmt.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public String setRutas() {
    return System.getProperty("user.dir").toString();
}

######


public Connection conexion() {
    Connection conn = null;
    if (conn != null) {
        return conn;
    }
    try {
        Class.forName("org.sqlite.JDBC");
        conn = DriverManager.getConnection("jdbc:sqlite:" + System.getProperty("user.dir").toString() + "/sqlitedb/inventario.db");
    } catch (Exception e) {
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
        System.exit(0);
    }
    System.out.println("Opened database successfully");
    return conn;
}

######


public void registrarProd(int id_codigo, String nombre_cod) {
    Connection conn = null;
    Statement stmt = null;
    if (existeRegistro(id_codigo) < 1) {
        try {
            conn = conexion();
            conn.setAutoCommit(false);
            stmt = conn.createStatement();
            int z = stmt.executeUpdate(" INSERT INTO productos(ID_prod,nombre) VALUES ('" + id_codigo + "','" + nombre_cod + "')");
            if (z == 1) {
                JOptionPane.showMessageDialog(null, "Se agregó el registro de manera exitosa");
            } else {
                System.out.println("Ocurrio un problema al agregar el registro");
            }
            stmt.close();
            conn.commit();
            conn.close();
        } catch (Exception e) {
            System.err.println(e.getClass().getName() + ": " + e.getMessage());
        }
    } else {
        JOptionPane.showMessageDialog(null, "El Registro ya Existe intente de nuevo con otro codigo");
    }
}

######


public void operacion(int id_cod_prod, String nombre_op, int cant_Uni, int precio_uni) {
    Connection conn = null;
    Statement stmt = null;
    if (existeRegistro(id_cod_prod) == 1) {
        try {
            conn = conexion();
            conn.setAutoCommit(false);
            stmt = conn.createStatement();
            int z = stmt.executeUpdate(" INSERT INTO existencias (id_prod,cantidad_unid,precio_uni,nombre_oper) VALUES ('" + id_cod_prod + "','" + cant_Uni + "','" + precio_uni + "','" + nombre_op + "')");
            if (z == 1) {
                JOptionPane.showMessageDialog(null, "Se registró la operación con exito");
            } else {
                System.out.println("Ocurrio un problema al agregar el registro");
            }
            stmt.close();
            conn.commit();
            conn.close();
        } catch (Exception e) {
            System.err.println(e.getClass().getName() + ": " + e.getMessage());
        }
    } else {
        JOptionPane.showMessageDialog(null, "No existe el registro, intente con otro código");
    }
}

######


public int existeRegistro(int idCodigo) {
    Connection conn = null;
    conn = conexion();
    Statement st = null;
    ResultSet rs = null;
    int rowCount = 0;
    try {
        st = conn.createStatement();
        rs = st.executeQuery("Select * from productos where ID_prod =" + idCodigo);
        if (rs.next()) {
            rowCount += 1;
        }
        rs.close();
        st.close();
    } catch (SQLException ex) {
        Logger.getLogger(OperacionesDB.class.getName()).log(Level.SEVERE, null, ex);
    }
    JOptionPane.showMessageDialog(null, rowCount);
    return rowCount;
}

######


public String existeRegistro1(int idCodigo) {
    Connection conn = null;
    conn = conexion();
    String s = null;
    Statement st = null;
    ResultSet rs = null;
    try {
        st = conn.createStatement();
        rs = st.executeQuery("select * from existencias where id_prod =" + 1 + "order by id_exis DESC");
        if (rs.next()) {
            s = rs.getString(1);
        }
        rs.close();
        st.close();
    } catch (SQLException ex) {
        Logger.getLogger(OperacionesDB.class.getName()).log(Level.SEVERE, null, ex);
    }
    JOptionPane.showMessageDialog(null, s);
    return s;
}

######


public void setOperateLimitDao(IOperateLimitDAO operateLimitDao) {
    this.operateLimitDao = operateLimitDao;
}

######


public Long addOperateLimit(OperateLimit operateLimit) {
    updateLevel(operateLimit);
    this.operateLimitDao.save(operateLimit);
    if (operateLimit != null && operateLimit.getId() != null) {
        return operateLimit.getId();
    }
    return null;
}

######


public OperateLimit getOperateLimit(Long id) {
    OperateLimit operateLimit = this.operateLimitDao.get(id);
    return operateLimit;
}

######


public boolean delOperateLimit(Long id) {
    OperateLimit operateLimit = this.getOperateLimit(id);
    if (operateLimit != null) {
        this.operateLimitDao.remove(id);
        return true;
    }
    return false;
}

######


public boolean batchDelOperateLimits(List<Serializable> operateLimitIds) {
    for (Serializable id : operateLimitIds) {
        delOperateLimit((Long) id);
    }
    return true;
}

######


public IPageList getOperateLimitBy(IQueryObject queryObject) {
    return QueryUtil.query(queryObject, OperateLimit.class, this.operateLimitDao);
}

######


public boolean updateOperateLimit(Long id, OperateLimit operateLimit) {
    if (id != null) {
        operateLimit.setId(id);
    } else {
        return false;
    }
    updateLevel(operateLimit);
    this.operateLimitDao.update(operateLimit);
    return true;
}

######


public String loadTree(Integer currentNodeId) {
    String result = "[";
    String sql;
    if (new Integer(0).equals(currentNodeId))
        sql = "select o from OperateLimit o where o.module is null and o.disabled=0";
    else
        sql = "select o from OperateLimit o where o.module.id=" + currentNodeId + " and o.disabled=0";
    List list = operateLimitDao.query(sql, null, 0, AppContext.RESULTSIZE);
    for (int i = 0; i < list.size(); i++) {
        OperateLimit bean = (OperateLimit) list.get(i);
        Long id = bean.getId();
        result += "{id:" + id + ",text:'" + bean.getName() + "(" + bean.getCode() + ")',";
        result += "leaf:true}";
        if (i < list.size() - 1)
            result += ",";
    }
    return result + "]";
}

######


private void updateLevel(OperateLimit operateLimit) {
    Module module = operateLimit.getModule();
    operateLimit.setLevel(module.getLevel() + "-" + operateLimit.getCode());
}

######


public SkinTable getSkinData(String tableName) throws Exception {
    SkinTable sTable = new SkinTable();
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY1);
        pstmt.setString(1, tableName);
        rs = pstmt.executeQuery();
        if (rs.next()) {
            sTable.setSkin(rs.getString("skin"));
            sTable.setTbTitle(rs.getString("tbTitle"));
            sTable.setAttach_key(rs.getString("attach_key"));
            sTable.setEditmode(rs.getString("editmode"));
            sTable.setImage_allow(rs.getString("image_allow"));
            sTable.setTbCnt(rs.getInt("tbCnt"));
            sTable.setTbInfoStatus(rs.getString("tbInfoStatus"));
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return sTable;
}

######


public List getListData(String tableName, int gotoPage, int pageSize, int recordCount) throws Exception {
    int start = pageSize * gotoPage;
    if (start > recordCount)
        pageSize -= (start - recordCount);
    StringBuffer query = new StringBuffer();
    query.append("select seq,name,title,email,readnum,writeday,re_level,relativeCnt from (select ");
    query.append("/*+ index_desc(" + tableName + " " + tableName + "_pk_re_step) */ seq,name,title,email,");
    query.append("readnum,writeday,re_level,relativeCnt,rownum as rnum from " + tableName + " where ");
    query.append("rownum <= ? order by rnum desc) where rownum <= ? order by rnum");
    List listData = new ArrayList();
    BoardTable bTable = null;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(query.toString());
        pstmt.setInt(1, start);
        pstmt.setInt(2, pageSize);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            bTable = new BoardTable();
            bTable.setSeq(rs.getInt("seq"));
            bTable.setName(rs.getString("name"));
            bTable.setTitle(Utility.getTitleLimit(ReplaceUtil.encodeHTMLSpecialChar(rs.getString("title"), 14), 40, rs.getInt("re_level")));
            bTable.setEmail(rs.getString("email"));
            bTable.setReadnum(rs.getInt("readnum"));
            bTable.setWriteday(rs.getTimestamp("writeday"));
            bTable.setRe_level(rs.getInt("re_level"));
            bTable.setRelativeCnt(rs.getInt("relativeCnt"));
            listData.add(bTable);
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return listData;
}

######


public List getListData(String tableName, int gotoPage, int pageSize) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    int start = pageSize * (gotoPage - 1) + 1;
    int pageTopNum = 0;
    String query = "select min(re_step) re_step from (select /*+ index_desc(" + tableName + " " + tableName + "_pk_re_step) */ re_step from " + tableName + " where rownum <=?) DERIVEDTBL";
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(query);
        pstmt.setInt(1, start);
        rs = pstmt.executeQuery();
        if (rs.next())
            pageTopNum = rs.getInt("re_step");
        else
            pageTopNum = 0;
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    List listData = new ArrayList();
    query = "select /*+ index_desc(" + tableName + " " + tableName + "_pk_re_step) */ seq,name,title,email,readnum,writeday,re_level,relativeCnt from " + tableName + " where re_step <= ? and rownum <= ? ";
    BoardTable bTable = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(query);
        pstmt.setInt(1, pageTopNum);
        pstmt.setInt(2, pageSize);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            bTable = new BoardTable();
            bTable.setSeq(rs.getInt("seq"));
            bTable.setName(rs.getString("name"));
            bTable.setTitle(Utility.getTitleLimit(ReplaceUtil.encodeHTMLSpecialChar(rs.getString("title"), 14), 40, rs.getInt("re_level")));
            bTable.setEmail(rs.getString("email"));
            bTable.setReadnum(rs.getInt("readnum"));
            bTable.setWriteday(rs.getTimestamp("writeday"));
            bTable.setRe_level(rs.getInt("re_level"));
            bTable.setRelativeCnt(rs.getInt("relativeCnt"));
            listData.add(bTable);
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return listData;
}

######


public void plusNewCount(CountTable cTable) throws Exception {
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    synchronized (this) {
        try {
            conn = GCmDbManager.getInstance().getConnection();
            conn.setAutoCommit(false);
            pstmt = conn.prepareStatement(QUERY1);
            pstmt.setInt(1, getMaxIdx());
            pstmt.setInt(2, cTable.getCdate());
            pstmt.setInt(3, cTable.getCtime());
            pstmt.setInt(4, cTable.getDayofweek());
            pstmt.setString(5, cTable.getIp());
            pstmt.setString(6, cTable.getReferer());
            pstmt.setString(7, cTable.getBrowser());
            pstmt.setString(8, cTable.getOs());
            pstmt.executeUpdate();
        } finally {
            try {
                pstmt.close();
                conn.commit();
            } catch (SQLException e) {
                GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
            }
            conn.close();
        }
    }
}

######


public int getMaxIdx() throws Exception {
    int returnValue = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(" SELECT sq_count_idx.NEXTVAL RETCNT FROM DUAL ");
        rs = pstmt.executeQuery();
        if (rs != null && rs.next())
            returnValue = rs.getInt("RETCNT");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return returnValue;
}

######


public CountManager getStatistics(int makeToday) throws Exception {
    CountManager cm = new CountManager();
    int today = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY2);
        pstmt.setInt(1, makeToday);
        rs = pstmt.executeQuery();
        if (rs.next())
            today = rs.getInt("today");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    int totalSum = 0;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY3);
        rs = pstmt.executeQuery();
        if (rs.next())
            totalSum = rs.getInt("totalSum");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    cm.setToday(today);
    cm.setTotalSum(totalSum);
    return cm;
}

######


public int getTotal() throws Exception {
    int returnValue = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY4);
        rs = pstmt.executeQuery();
        if (rs != null && rs.next())
            returnValue = rs.getInt("idx");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return returnValue;
}

######


public int getToday(int makeToday) throws Exception {
    int returnValue = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY5);
        pstmt.setInt(1, makeToday);
        rs = pstmt.executeQuery();
        if (rs != null && rs.next())
            returnValue = rs.getInt("todayIdx");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return returnValue;
}

######


public int getPrevDay(int makeToday, int makePrevDay) throws Exception {
    int returnValue = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY6);
        pstmt.setInt(1, makeToday);
        pstmt.setInt(2, makePrevDay);
        rs = pstmt.executeQuery();
        if (rs != null && rs.next())
            returnValue = rs.getInt("prevDayIdx");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return returnValue;
}

######


public PlotData getBrowser(int sdate, int edate) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    String exceptionvalue = "";
    PlotData data = new PlotData();
    DataItem d = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY7);
        pstmt.setInt(1, sdate);
        pstmt.setInt(2, edate);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            exceptionvalue = rs.getString("browser");
            if ((exceptionvalue != null) && (!exceptionvalue.equals(""))) {
                d = new DataItem(exceptionvalue, rs.getInt("cnt"));
                data.addElement(d);
            }
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return data;
}

######


public PlotData getOs(int sdate, int edate) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    String exceptionvalue = "";
    PlotData data = new PlotData();
    DataItem d = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY8);
        pstmt.setInt(1, sdate);
        pstmt.setInt(2, edate);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            exceptionvalue = rs.getString("os");
            if ((exceptionvalue != null) && (!exceptionvalue.equals(""))) {
                d = new DataItem(exceptionvalue, rs.getInt("cnt"));
                data.addElement(d);
            }
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return data;
}

######


public PlotData getIpData(int sdate, int edate) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    String exceptionvalue = "";
    PlotData data = new PlotData();
    DataItem d = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY9);
        pstmt.setInt(1, sdate);
        pstmt.setInt(2, edate);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            exceptionvalue = rs.getString("ip");
            if ((exceptionvalue != null) && (!exceptionvalue.equals(""))) {
                d = new DataItem(exceptionvalue, rs.getInt("cnt"));
                data.addElement(d);
            }
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return data;
}

######


public PlotData getRefererData(int sdate, int edate) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    String exceptionvalue = "";
    PlotData data = new PlotData();
    DataItem d = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY10);
        pstmt.setInt(1, sdate);
        pstmt.setInt(2, edate);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            exceptionvalue = rs.getString("referer");
            if ((exceptionvalue != null) && (!exceptionvalue.equals(""))) {
                d = new DataItem(exceptionvalue, rs.getInt("cnt"));
                data.addElement(d);
            }
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return data;
}

######


public PlotData getYearData(int SINCE_YEAR, int NOW_YEAR) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    PlotData data = new PlotData();
    DataItem d = null;
    int tmpPrevYearCnt = 0;
    for (int k = SINCE_YEAR; k <= NOW_YEAR; k++) {
        try {
            conn = GCmDbManager.getInstance().getConnection();
            conn.setAutoCommit(false);
            pstmt = conn.prepareStatement(QUERY11);
            pstmt.setInt(1, (k + 1) * 10000);
            rs = pstmt.executeQuery();
            if (rs.next()) {
                d = new DataItem(Integer.toString(k), rs.getInt("maxIdx") - tmpPrevYearCnt);
                data.addElement(d);
                tmpPrevYearCnt = rs.getInt("maxIdx");
            }
        } finally {
            try {
                pstmt.close();
                conn.commit();
            } catch (SQLException e) {
                GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
            }
            conn.close();
        }
    }
    return data;
}

######


public PlotData getMonthData(int thisYear, int startMonth, int endMonth) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    PlotData data = new PlotData();
    DataItem d = null;
    int monthCnt = 0;
    int tmpPrevMonthCnt = 0;
    int prevYearCnt = getPrevYearCnt(thisYear);
    for (int k = startMonth; k <= endMonth; k++) {
        try {
            conn = GCmDbManager.getInstance().getConnection();
            conn.setAutoCommit(false);
            pstmt = conn.prepareStatement(QUERY12);
            pstmt.setInt(1, ((thisYear * 10000) + ((k) * 100)));
            pstmt.setInt(2, ((thisYear * 10000) + ((k + 1) * 100)));
            rs = pstmt.executeQuery();
            if (rs.next()) {
                if (rs.getInt("cnt") > 0) {
                    if (k == startMonth)
                        monthCnt = rs.getInt("cnt") - prevYearCnt;
                    else
                        monthCnt = rs.getInt("cnt") - tmpPrevMonthCnt;
                    tmpPrevMonthCnt = rs.getInt("cnt");
                    d = new DataItem(Integer.toString(k), monthCnt);
                    data.addElement(d);
                } else {
                    d = new DataItem(Integer.toString(k), 0);
                    data.addElement(d);
                }
            }
        } finally {
            try {
                pstmt.close();
                conn.commit();
            } catch (SQLException e) {
                GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
            }
            conn.close();
        }
    }
    return data;
}

######


public int getPrevYearCnt(int thisYear) throws Exception {
    int returnValueInt = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY13);
        pstmt.setInt(1, (thisYear - 1) * 10000 + 1231);
        rs = pstmt.executeQuery();
        if (rs.next())
            returnValueInt = rs.getInt("cnt");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return returnValueInt;
}

######


public PlotData getDayData(int thisYear, int thisMonth) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    PlotData data = new PlotData();
    DataItem d = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY14);
        pstmt.setInt(1, (thisYear * 10000) + (thisMonth * 100));
        pstmt.setInt(2, (thisYear * 10000) + (thisMonth * 100) + 99);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            d = new DataItem(rs.getString("cdate").substring(6, 8), rs.getInt("cnt"));
            data.addElement(d);
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return data;
}

######


public int getTotalSum(int cmakeToday) throws Exception {
    int returnValue = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY15);
        pstmt.setInt(1, cmakeToday);
        rs = pstmt.executeQuery();
        if (rs != null && rs.next())
            returnValue = rs.getInt("cnt");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return returnValue;
}

######


public String getInfo(int cmakeToday, int gotoPage, int pageSize, int recordCount) throws Exception {
    String ctime = "";
    String referer = "";
    String alterTime = "";
    String linkReferer = "";
    int trimStart = 0;
    int trimEnd = 0;
    int start = pageSize * gotoPage;
    if (start > recordCount)
        pageSize -= (start - recordCount);
    StringBuffer query = new StringBuffer();
    query.append("select ctime,ip,referer,browser,os from (select ");
    query.append("/*+ index_desc(count count_cdate_indx) */ ctime,ip,referer,browser,os,");
    query.append("rownum as rnum from count where ");
    query.append("(cdate = ?) and (rownum <= ?) order by rnum desc) where rownum <= ? order by rnum");
    StringBuffer html = new StringBuffer();
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(query.toString());
        pstmt.setInt(1, cmakeToday);
        pstmt.setInt(2, start);
        pstmt.setInt(3, pageSize);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            ctime = ParamUtil.getReqParameter(rs.getString("ctime"), "00");
            referer = ParamUtil.getReqParameter(rs.getString("referer"));
            if (ctime.length() == 3)
                alterTime = "0" + ctime;
            else if (ctime.length() == 2)
                alterTime = "00" + ctime;
            else if (ctime.length() == 1)
                alterTime = "000" + ctime;
            else
                alterTime = ctime;
            alterTime = alterTime.substring(0, 2) + ":" + alterTime.substring(2, 4);
            linkReferer = referer;
            trimStart = referer.indexOf("http://");
            if (trimStart != -1)
                referer = referer.substring(trimStart + 7);
            trimEnd = referer.indexOf("/");
            if (trimEnd != -1)
                referer = "http://" + referer.substring(0, trimEnd);
            html.append("<TR>\n");
            html.append("   <TD>" + alterTime + "</TD>\n");
            html.append("   <TD>" + ParamUtil.getReqParameter(rs.getString("ip")) + "</TD>\n");
            html.append("   <TD><a href='" + linkReferer + "' target=_blank class='ref'>" + referer + "</a></TD>\n");
            html.append("   <TD>" + ParamUtil.getReqParameter(rs.getString("browser")) + "</TD>\n");
            html.append("   <TD style='padding-left:5'>" + ParamUtil.getReqParameter(rs.getString("os")) + "</TD>\n");
            html.append("</TR>\n");
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return html.toString();
}

######


public PlotData getWeeklyCnt() throws Exception {
    String[] weekNameStr = { "��", "��", "��", "�", "��", "��", "��" };
    PlotData data = new PlotData();
    DataItem d = null;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY17);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            d = new DataItem(weekNameStr[(rs.getInt("dayofweek") - 1)], rs.getInt("cnt"));
            data.addElement(d);
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return data;
}

######


public SkinTable getSkinData(String tableName) throws Exception {
    SkinTable sTable = new SkinTable();
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY1);
        pstmt.setString(1, tableName);
        rs = pstmt.executeQuery();
        if (rs != null && rs.next()) {
            sTable.setSkin(rs.getString("skin"));
            sTable.setTbTitle(rs.getString("tbTitle"));
            sTable.setAttach_key(rs.getString("attach_key"));
            sTable.setEditmode(rs.getString("editmode"));
            sTable.setImage_allow(rs.getString("image_allow"));
            sTable.setTbCnt(rs.getInt("tbCnt"));
            sTable.setTbInfoStatus(rs.getString("tbInfoStatus"));
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return sTable;
}

######


public int getListCount(String tableName) throws Exception {
    int recordCount = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY2);
        pstmt.setString(1, tableName);
        rs = pstmt.executeQuery();
        if (rs.next())
            recordCount = rs.getInt("cnt");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return recordCount;
}

######


public List getListData(String tableName, int gotoPage, int pageSize) throws Exception {
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    int start = pageSize * (gotoPage - 1) + 1;
    int pageTopNum = 0;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY22);
        pstmt.setString(1, tableName);
        pstmt.setInt(2, start);
        rs = pstmt.executeQuery();
        if (rs.next())
            pageTopNum = rs.getInt("seq");
        else
            pageTopNum = 0;
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    List listData = new ArrayList();
    InfoTable iTable = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY23);
        pstmt.setString(1, tableName);
        pstmt.setInt(2, pageTopNum);
        pstmt.setInt(3, pageSize);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            iTable = new InfoTable();
            iTable.setSeq(rs.getInt("seq"));
            iTable.setReadnum(rs.getInt("readnum"));
            iTable.setWriteday(rs.getTimestamp("writeday"));
            iTable.setViewSelect(rs.getString("viewSelect"));
            iTable.setTitle(Utility.getTitleLimit(ReplaceUtil.encodeHTMLSpecialChar(rs.getString("title"), 14), 38));
            listData.add(iTable);
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return listData;
}

######


public List getListData(String tableName, int gotoPage, int pageSize, int recordCount) throws Exception {
    StringBuffer QUERY3 = new StringBuffer();
    QUERY3.append("select seq,readnum,writeday,viewSelect,title from (select ");
    QUERY3.append("/*+ index_desc(tablemnginfo tablemnginfo_indx) */ ");
    QUERY3.append("seq,readnum,writeday,viewSelect,title,rownum as rnum from tablemnginfo where ");
    QUERY3.append("tbName = ? and rownum <= ? order by rnum desc) where rownum <= ? order by rnum");
    int start = pageSize * gotoPage;
    if (start > recordCount)
        pageSize -= (start - recordCount);
    List listData = new ArrayList();
    InfoTable iTable = null;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY3.toString());
        pstmt.setString(1, tableName);
        pstmt.setInt(2, start);
        pstmt.setInt(3, pageSize);
        rs = pstmt.executeQuery();
        while (rs.next()) {
            iTable = new InfoTable();
            iTable.setSeq(rs.getInt("seq"));
            iTable.setReadnum(rs.getInt("readnum"));
            iTable.setWriteday(rs.getTimestamp("writeday"));
            iTable.setViewSelect(rs.getString("viewSelect"));
            iTable.setTitle(Utility.getTitleLimit(ReplaceUtil.encodeHTMLSpecialChar(rs.getString("title"), 14), 38));
            listData.add(iTable);
        }
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return listData;
}

######


public int getListCount(int idxKey) throws Exception {
    int returnValue = 0;
    ResultSet rs = null;
    PreparedStatement pstmt = null;
    GCmConnection conn = null;
    try {
        conn = GCmDbManager.getInstance().getConnection();
        conn.setAutoCommit(false);
        pstmt = conn.prepareStatement(QUERY1);
        pstmt.setInt(1, idxKey);
        rs = pstmt.executeQuery();
        if (rs.next())
            returnValue = rs.getInt("cnt");
    } finally {
        try {
            pstmt.close();
            conn.commit();
        } catch (SQLException e) {
            GCmLog.writeLog(" OraPhotoDAOImpl::getListCount : " + e.getMessage());
        }
        conn.close();
    }
    return returnValue;
}

######


public String buildGetUsersQuery(Map<String, Object> parameter) {
    @SuppressWarnings("unchecked") List<Integer> ids = (List<Integer>) parameter.get("list");
    StringBuilder sb = new StringBuilder();
    sb.append("select * from users where id in (");
    for (int i = 0; i < ids.size(); i++) {
        if (i > 0) {
            sb.append(",");
        }
        sb.append("#{list[");
        sb.append(i);
        sb.append("]}");
    }
    sb.append(") order by id");
    return sb.toString();
}

######


public String buildGetUserQuery(Number parameter) {
    return "select * from users where id = #{value}";
}

######


public String buildGetAllUsersQuery() {
    return "select * from users order by id";
}

######


public Long getId() {
    return id;
}

######


public void setId(Long id) {
    this.id = id;
}

######


public String getKodeOutput() {
    return kodeOutput;
}

######


public void setKodeOutput(String kodeOutput) {
    this.kodeOutput = kodeOutput;
}

######


public String getNamaOutput() {
    return namaOutput;
}

######


public void setNamaOutput(String namaOutput) {
    this.namaOutput = namaOutput;
}

######


@Override
public int hashCode() {
    int hash = 0;
    hash += (id != null ? id.hashCode() : 0);
    return hash;
}

######


@Override
public String toString() {
    return "apdol.entity.Output[ id=" + id + " ]";
}

######


public boolean isKodeNoChange(String kode) {
    if (kode.equalsIgnoreCase(this.kodeOutput)) {
        return true;
    } else {
        return false;
    }
}

######


public boolean isNamaNoChange(String nama) {
    if (nama.equalsIgnoreCase(this.namaOutput)) {
        return true;
    } else {
        return false;
    }
}

######


@Select("select * from users where id = #{id}")
User getUserById(Integer id);

######


default User defaultGetUser(Object... args) {
    return getUserById((Integer) args[0]);
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType("text/html");
    int empid = Integer.parseInt(request.getParameter("empid"));
    try {
        HttpSession session = request.getSession();
        InsertValues(request, response, session);
    } catch (Exception e) {
        e.printStackTrace();
        if (empid == 11) {
            RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
            ReqDis.forward(request, response);
        } else {
            RequestDispatcher ReqDis = request.getRequestDispatcher("error.jsp");
            ReqDis.forward(request, response);
        }
    }
}

######


@SuppressWarnings("unused")
private void InsertValues(HttpServletRequest request, HttpServletResponse response, HttpSession session) throws IOException, SQLException, ServletException {
    int empid = Integer.parseInt(request.getParameter("empid"));
    PrintWriter out = response.getWriter();
    Connection con = Connect.getconnection();
    String truckType = (String) session.getAttribute("truckType");
    String truckType1 = request.getParameter("truckType");
    if (truckType.equals(truckType1)) {
        int cap = (int) session.getAttribute("cap");
        int costofTruck = (int) session.getAttribute("cost");
        float residual = (float) session.getAttribute("residual") / 100;
        float loan = (float) session.getAttribute("loan");
        int yearsemi = (int) session.getAttribute("emi");
        float roi = (float) session.getAttribute("roi");
        float flatroi = (float) session.getAttribute("flatroi");
        float insurance = (float) session.getAttribute("insurance");
        int tyrelife = Integer.parseInt(request.getParameter("tyrelife"));
        int usedtyrelife = Integer.parseInt(request.getParameter("resusedtyrelife"));
        int tyrecost = Integer.parseInt(request.getParameter("tyrecost"));
        int usedtyrecost = Integer.parseInt(request.getParameter("reusedtyrecost"));
        int tyres = Integer.parseInt(request.getParameter("tyres"));
        float dieselcost = Float.parseFloat(request.getParameter("diesel"));
        float mileage = Float.parseFloat(request.getParameter("mileage"));
        float mileagewithload = Float.parseFloat(request.getParameter("mileageload"));
        int salary = (int) session.getAttribute("sal");
        ;
        int bhatta = (int) session.getAttribute("bhatta");
        int maintenanceMonth = (int) session.getAttribute("main");
        int roadtaxyearly = (int) session.getAttribute("roadtax");
        int roadpermityearly = (int) session.getAttribute("permit");
        int admin = (int) session.getAttribute("admin");
        int tarpaulin = (int) session.getAttribute("tarpaulin");
        int loading = (int) session.getAttribute("loading");
        int profit = (int) session.getAttribute("profit");
        float toll = Float.parseFloat(request.getParameter("toll"));
        float routeexpences = Float.parseFloat(request.getParameter("routeexpense"));
        float maintanecekm = Float.parseFloat(request.getParameter("maintkm"));
        PreparedStatement ps = con.prepareStatement("INSERT INTO truckparam (capacity,typeofgood,costoftruck, residualvalueoftruck, loanpercentage, yearsemi, rateofintrest, flatroi , tyrelife, reusedtyrelife, tyrecost, reusedtyrecost, tyres, dieselcost, dieselmileage, diesealmileagewithload)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
        ps.setInt(1, cap);
        ps.setString(2, truckType);
        ps.setInt(3, costofTruck);
        ps.setFloat(4, residual);
        ps.setFloat(5, loan);
        ps.setInt(6, yearsemi);
        ps.setFloat(7, roi);
        ps.setFloat(8, flatroi);
        ps.setInt(9, tyrelife);
        ps.setInt(10, usedtyrelife);
        ps.setInt(11, tyrecost);
        ps.setInt(12, usedtyrecost);
        ps.setInt(13, tyres);
        ps.setFloat(14, dieselcost);
        ps.setFloat(15, mileage);
        ps.setFloat(16, mileagewithload);
        ps.executeUpdate();
        PreparedStatement ps1 = con.prepareStatement("INSERT INTO routeparam (`capacity`, `loadingcharges`, `routeexpenses`, `toll`, `maintenancecostperkm`, `insuranceaspercentageofvechiclecost`, `driver/cleaner salary`, `driver/cleaner bhatta`, `maintenancepermonth`, `roadpermityear`, `roadtaxyear`, `admin costs`, `tarpaulin`,`profitmargin`,`typeofgood`) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) ");
        ps1.setInt(1, cap);
        ps1.setFloat(2, loading);
        ps1.setFloat(3, routeexpences);
        ps1.setFloat(4, toll);
        ps1.setFloat(5, maintanecekm);
        ps1.setFloat(6, insurance);
        ps1.setFloat(7, salary);
        ps1.setFloat(8, bhatta);
        ps1.setFloat(9, maintenanceMonth);
        ps1.setFloat(10, roadpermityearly);
        ps1.setFloat(11, roadtaxyearly);
        ps1.setFloat(12, admin);
        ps1.setFloat(13, tarpaulin);
        ps1.setInt(14, profit);
        ps1.setString(15, truckType);
        ps1.executeUpdate();
        if (empid == 11) {
            RequestDispatcher ReqDis = request.getRequestDispatcher("adminAuto.jsp");
            ReqDis.forward(request, response);
        }
    } else {
        RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
        ReqDis.forward(request, response);
    }
}

######


User getUserXML();

######


@Select("select * from users where id = 1")
User getUserAnnotated();

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("table1", "id1 int auto_increment primary key");
    createTable("table2", "id2 int auto_increment primary key");
}

######


@Test
public void poolVerification() throws Exception {
    ArrayList<HostAddress> hostAddresses = new ArrayList<>();
    hostAddresses.add(new HostAddress(hostname, port));
    UrlParser urlParser = new UrlParser(database, hostAddresses, DefaultOptions.defaultValues(HaMode.NONE), HaMode.NONE);
    urlParser.setUsername("USER");
    urlParser.setPassword("PWD");
    urlParser.parseUrl("jdbc:mariadb://localhost:3306/db");
    assertEquals("USER", urlParser.getUsername());
    assertEquals("PWD", urlParser.getPassword());
    MariaDbDataSource datasource = new MariaDbDataSource();
    datasource.setUser("USER");
    datasource.setPassword("PWD");
    datasource.setUrl("jdbc:mariadb://localhost:3306/db");
}

######


@Test
public void isMultiMaster() throws Exception {
    Properties emptyProps = new Properties();
    assertFalse(UrlParser.parse("jdbc:mariadb:replication://host1/", emptyProps).isMultiMaster());
    assertFalse(UrlParser.parse("jdbc:mariadb:failover://host1/", emptyProps).isMultiMaster());
    assertFalse(UrlParser.parse("jdbc:mariadb:aurora://host1/", emptyProps).isMultiMaster());
    assertFalse(UrlParser.parse("jdbc:mariadb:sequential://host1/", emptyProps).isMultiMaster());
    assertFalse(UrlParser.parse("jdbc:mariadb:loadbalance://host1/", emptyProps).isMultiMaster());
    assertFalse(UrlParser.parse("jdbc:mariadb:replication://host1,host2/", emptyProps).isMultiMaster());
    assertTrue(UrlParser.parse("jdbc:mariadb:failover://host1,host2/", emptyProps).isMultiMaster());
    assertFalse(UrlParser.parse("jdbc:mariadb:aurora://host1,host2/", emptyProps).isMultiMaster());
    assertTrue(UrlParser.parse("jdbc:mariadb:sequential://host1,host2/", emptyProps).isMultiMaster());
    assertFalse(UrlParser.parse("jdbc:mariadb:loadbalance://host1,host2/", emptyProps).isMultiMaster());
}

######


@Test
public void mysqlDatasourceVerification() throws Exception {
    MariaDbDataSource datasource = new MariaDbDataSource();
    datasource.setUser(username);
    datasource.setPassword(password);
    datasource.setUrl("jdbc:mysql://" + hostname + ":" + port + "/" + database);
    try (Connection connection = datasource.getConnection()) {
        Statement stmt = connection.createStatement();
        assertTrue(stmt.execute("SELECT 10"));
    }
}

######


@Test
public void libreOfficeBase() {
    String sql;
    try {
        Statement statement = sharedConnection.createStatement();
        sql = "INSERT INTO table1 VALUES (1),(2),(3),(4),(5),(6)";
        statement.execute(sql);
        sql = "INSERT INTO table2 VALUES (1),(2),(3),(4),(5),(6)";
        statement.execute(sql);
        sql = "SELECT table1.id1, table2.id2 FROM { OJ table1 LEFT OUTER JOIN table2 ON table1.id1 = table2.id2 }";
        ResultSet rs = statement.executeQuery(sql);
        for (int count = 1; count <= 6; count++) {
            assertTrue(rs.next());
            assertEquals(count, rs.getInt(1));
            assertEquals(count, rs.getInt(2));
        }
        sql = "SELECT table1.id1, table2.id2 FROM { oJ table1 LEFT OUTER JOIN table2 ON table1.id1 = table2.id2 }";
        rs = statement.executeQuery(sql);
        for (int count = 1; count <= 6; count++) {
            assertTrue(rs.next());
            assertEquals(count, rs.getInt(1));
            assertEquals(count, rs.getInt(2));
        }
    } catch (SQLException e) {
        fail();
    }
}

######


@Test
public void auroraClusterVerification() {
    try {
        DriverManager.getConnection("jdbc:mariadb:aurora://" + "1.somehex.us-east-1.rds.amazonaws.com," + "2.someOtherHex.us-east-1.rds.amazonaws.com/testj");
        fail("must have fail since not same cluster");
    } catch (Exception e) {
        assertEquals("Connection string must contain only one aurora cluster. " + "'2.someOtherHex.us-east-1.rds.amazonaws.com' doesn't correspond to DNS prefix " + "'somehex.us-east-1.rds.amazonaws.com'", e.getMessage());
    }
}

######


public DefaultTableModel pasarvalores(int codigo) {
    Connection connection1 = null;
    DefaultTableModel dtm = null;
    String[] filas = null;
    try {
        connection1 = coexion.conexion();
        Statement stmt = connection1.createStatement();
        ResultSet rs;
        rs = stmt.executeQuery("select * from productos, existencias where productos.id_prod=existencias.id_prod and productos.id_prod=" + codigo);
        String[] columnas = { "Codigo", "Nombre", "Movimiento", "Cantidad", "Valor" };
        dtm = new DefaultTableModel(null, columnas);
        while (rs.next()) {
            String[] filas1 = { Integer.toString(codigo), rs.getString("NOMBRE"), rs.getString("nombre_oper"), String.valueOf(rs.getInt("cantidad_unid")), String.valueOf(rs.getInt("precio_uni")) };
            filas = filas1;
            dtm.addRow(filas1);
            for (String pa : filas) {
                System.out.println(pa);
            }
        }
        stmt.close();
        connection1.close();
    } catch (Exception e) {
        System.out.println(e.getMessage());
        e.printStackTrace();
    }
    return dtm;
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    goActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    CPasswordTxtActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    go = new javax.swing.JButton();
    PasswordTxt = new javax.swing.JPasswordField();
    CPasswordTxt = new javax.swing.JPasswordField();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel1.setText("NewPassword");
    jLabel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel2.setText("ConfPassword");
    jLabel2.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    go.setText("Go");
    go.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            goActionPerformed(evt);
        }
    });
    PasswordTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    CPasswordTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    CPasswordTxt.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            CPasswordTxtActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, 96, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(PasswordTxt, javax.swing.GroupLayout.DEFAULT_SIZE, 204, Short.MAX_VALUE).addComponent(CPasswordTxt)).addGap(14, 14, 14)).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addGap(51, 51, 51).addComponent(go, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addGap(40, 40, 40)));
    layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] { jLabel1, jLabel2 });
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(20, 20, 20).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(PasswordTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, 42, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(CPasswordTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, 37, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(go, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addContainerGap()));
    layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] { jLabel1, jLabel2 });
    pack();
}

######


private void CPasswordTxtActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void goActionPerformed(java.awt.event.ActionEvent evt) {
    String passw = new String(PasswordTxt.getPassword());
    String cpassw = new String(CPasswordTxt.getPassword());
    if (passw.length() > 0 && passw.equals(cpassw)) {
        try {
            Client sclav = new Client();
            sclav.connectToServer();
            String SQL = "update users set password='" + passw + "' where user='" + User + "'";
            sclav.Query(SQL);
            int conf = sclav.confExec;
            Start JF = new Start();
            JF.setVisible(true);
            JF.setResizable(false);
            this.dispose();
        } catch (IOException ex) {
            Logger.getLogger(PasswordForm.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(PasswordForm.class.getName()).log(Level.SEVERE, null, ex);
        }
    } else {
        JOptionPane.showMessageDialog(null, "Invalid details", "Password Error", JOptionPane.ERROR_MESSAGE);
    }
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(PasswordForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(PasswordForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(PasswordForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(PasswordForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
}

######


public int getId() {
    return id;
}

######


public String getName() {
    return name;
}

######


public String getBirthday() {
    return birthday;
}

######


public void addDoctor(int doctor_id) {
    this.doctor_id = doctor_id;
    String sql = "UPDATE patients SET doctor_id = :doctor_id WHERE id = :id";
    try (Connection con = DB.sql2o.open()) {
        con.createQuery(sql).addParameter("doctor_id", doctor_id).addParameter("id", id).executeUpdate();
    }
}

######


public int getDoctorId() {
    return doctor_id;
}

######


@Override
public boolean equals(Object otherPatientInstance) {
    if (!(otherPatientInstance instanceof Patient)) {
        return false;
    } else {
        Patient newPatientInstance = (Patient) otherPatientInstance;
        return this.getName().equals(newPatientInstance.getName()) && this.getBirthday().equals(newPatientInstance.getBirthday()) && this.getDoctorId() == newPatientInstance.getDoctorId() && this.getId() == newPatientInstance.getId();
    }
}

######


public static List<Patient> all() {
    String sql = "SELECT * FROM patients";
    try (Connection con = DB.sql2o.open()) {
        return con.createQuery(sql).executeAndFetch(Patient.class);
    }
}

######


public void save() {
    try (Connection con = DB.sql2o.open()) {
        String sql = "INSERT INTO patients (name, birthday, doctor_id) VALUES (:name, :birthday, :doctor_id)";
        this.id = (int) con.createQuery(sql, true).addParameter("name", name).addParameter("birthday", birthday).addParameter("doctor_id", doctor_id).executeUpdate().getKey();
    }
}

######


public static Patient find(int id) {
    try (Connection con = DB.sql2o.open()) {
        String sql = "SELECT * FROM patients where id=:id";
        Patient patient = con.createQuery(sql).addParameter("id", id).executeAndFetchFirst(Patient.class);
        return patient;
    }
}

######


public void update(String newName) {
    name = newName;
    try (Connection con = DB.sql2o.open()) {
        String sql = "UPDATE patients SET name = :name WHERE id=:id";
        con.createQuery(sql).addParameter("name", name).addParameter("id", id).executeUpdate();
    }
}

######


public void delete() {
    try (Connection con = DB.sql2o.open()) {
        String sql = "DELETE FROM patients WHERE id = :id";
        con.createQuery(sql).addParameter("id", id).executeUpdate();
    }
}

######


public PatientModel loginPatient(PatientModel patientModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM PatientModel e WHERE e.tcNumber = :TC_NUMBER AND e.password = :PASSWORD");
    query.setParameter("TC_NUMBER", patientModel.getTcNumber()).setParameter("PASSWORD", Encryptor.encrypt(patientModel.getPassword()));
    if (query.getResultList().size() > 0) {
        return (PatientModel) query.getResultList().get(0);
    } else {
        return null;
    }
}

######


public List<AppointmentModel> getActiveAppointmentsOfPatient(PatientModel patientModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM AppointmentModel e WHERE e.appointmentStatus = :APPOINTMENT_STATUS" + " AND e.patient = :PATIENT AND e.isActive = :IS_ACTIVE ORDER BY e.appointmentDate");
    query.setParameter("APPOINTMENT_STATUS", AppointmentStatusEnum.RESERVED);
    query.setParameter("PATIENT", patientModel);
    query.setParameter("IS_ACTIVE", '1');
    return query.getResultList();
}

######


public boolean haveAnAppointmentForThatDay(PatientModel patientModel, Date date) {
    Query query = getEntitymanager().createQuery("SELECT e FROM AppointmentModel e WHERE e.appointmentStatus = :APPOINTMENT_STATUS" + " AND e.patient = :PATIENT AND e.isActive = :IS_ACTIVE AND e.appointmentDate BETWEEN :START_OF_DAY AND :END_OF_DAY");
    query.setParameter("APPOINTMENT_STATUS", AppointmentStatusEnum.RESERVED);
    query.setParameter("START_OF_DAY", DateUtil.getStartOfDay(date));
    query.setParameter("END_OF_DAY", DateUtil.getEndOfDay(date));
    query.setParameter("PATIENT", patientModel);
    query.setParameter("IS_ACTIVE", '1');
    return query.getResultList().size() > 0;
}

######


public List<AppointmentModel> getAppointmentHistory(PatientModel patientModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM AppointmentModel e WHERE e.patient = :PATIENT ORDER BY e.appointmentDate DESC");
    query.setParameter("PATIENT", patientModel);
    return query.getResultList();
}

######


public boolean haveUserRegistration(PatientModel patientModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM PatientModel e WHERE e.tcNumber = :TC_NUMBER OR e.email = :E_MAIL");
    query.setParameter("TC_NUMBER", patientModel.getTcNumber());
    query.setParameter("E_MAIL", patientModel.getEmail());
    return query.getResultList().size() > 0;
}

######


public PatientModel getUserByEmail(String email) {
    Query query = getEntitymanager().createQuery("SELECT e FROM PatientModel e WHERE e.email = :E_MAIL").setParameter("E_MAIL", email);
    if (query.getResultList().isEmpty()) {
        return null;
    } else {
        return (PatientModel) query.getResultList().get(0);
    }
}

######


public List<PatientAlergyRelModel> getPatientAlergies(PatientModel patientModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM PatientAlergyRelModel e WHERE e.patient = :PATIENT ORDER BY e.alergy.alergyName");
    query.setParameter("PATIENT", patientModel);
    return query.getResultList();
}

######


public List<PatientAssayRelModel> getPatientAssays(PatientModel patientModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM PatientAssayRelModel e WHERE e.patient = :PATIENT ORDER BY e.assay.assayName");
    query.setParameter("PATIENT", patientModel);
    return query.getResultList();
}

######


public List<PatientDiseaseRelModel> getPatientDiseases(PatientModel patientModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM PatientDiseaseRelModel e WHERE e.patient = :PATIENT ORDER BY e.disease.diseaseName");
    query.setParameter("PATIENT", patientModel);
    return query.getResultList();
}

######


@Query("SELECT p FROM PaymentCard p WHERE p.cardNumber = :cardNumber")
public PaymentCard findByCardNumber(@Param("cardNumber") String cardNumber);

######


@Query("SELECT p FROM PaymentCard p WHERE p.user = :user")
public PaymentCard findByUser(@Param("user") User user);

######


public List<Payment> findByEmp(Employee emp) {
    return find("select p from Payment as p where p.employee=?0", emp);
}

######


public Payment findByMonthAndEmp(String payMonth, Employee emp) {
    List<Payment> pays = find("select p from Payment as p where" + " p.employee=?0 and p.payMonth=?1", emp, payMonth);
    if (pays != null && pays.size() > 0) {
        return pays.get(0);
    }
    return null;
}

######


public boolean insetar(Consulta dts) {
    sSQL = " insert into consulta (idConsulta,fecha,nombre,cedula,edad,observaciones)" + "values(?,?,?,?,?,?)";
    try {
        PreparedStatement pst = cmd.prepareStatement(sSQL);
        pst.setInt(1, dts.getIdConsulta());
        java.util.Date fecha = null;
        fecha = (dts.getFecha());
        java.sql.Date fechaP = new java.sql.Date(fecha.getTime());
        pst.setDate(2, fechaP);
        pst.setString(3, dts.getNombre());
        pst.setInt(5, dts.getEdad());
        pst.setInt(4, dts.getCedula());
        pst.setString(6, dts.getObservaciones());
        int n = pst.executeUpdate();
        if (n != 0) {
            return true;
        } else {
            return false;
        }
    } catch (Exception e) {
        JOptionPane.showConfirmDialog(null, e);
        System.out.println(e.toString());
        return false;
    }
}

######


public Consulta buscarConsulta(int cedula) {
    sSQL = "select * from consulta where cedula like ?";
    Consulta c = null;
    try {
        PreparedStatement pst = cmd.prepareStatement(sSQL);
        pst.setString(1, String.valueOf(cedula));
        ResultSet res = pst.executeQuery();
        while (res.next()) {
            c = new Consulta();
            c.setIdConsulta(res.getInt("idConsulta"));
            c.setFecha(res.getDate("fecha"));
            c.setNombre(res.getString("nombre"));
            c.setEdad(res.getInt("edad"));
            c.setObservaciones(res.getString("observaciones"));
        }
        res.close();
    } catch (Exception e) {
        javax.swing.JOptionPane.showMessageDialog(null, e.getMessage());
    }
    return c;
}

######


@Override
public Periodico doRetriveById(Object... id) {
    throw new UnsupportedOperationException("Not supported yet.");
}

######


@Override
public List<Periodico> doRetriveAll() {
    List<Periodico> periodici = new ArrayList<>();
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveAllQuery);
        try {
            ResultSet rs = prst.executeQuery();
            while (rs.next()) {
                Periodico periodico = new Periodico(rs.getString("Codice"), rs.getString("Titolo"), rs.getInt("Edizione"), rs.getString("DataPubblicazione"), rs.getInt("DurataMaxPrestito"), rs.getString("Lingua"), rs.getString("DenominazioneEditore"), rs.getString("CittaEditore"), rs.getString("frequenza"));
                String isbn = rs.getString("Codice");
                periodico.setAutori(new AutoreDAO().doRetriveByLibro(isbn));
                periodico.setCopie(new CopiaDAO().doRetriveAllById(isbn));
                periodici.add(periodico);
            }
            rs.close();
        } catch (SQLException e) {
            con.rollback();
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
    }
    return periodici;
}

######


@Override
public int doInsert(Periodico periodico) {
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doInsertQuery, PreparedStatement.RETURN_GENERATED_KEYS);
        prst.setString(1, periodico.getCodice());
        prst.setString(2, periodico.getFrequenza());
        try {
            prst.execute();
            con.commit();
            ResultSet rs = prst.getGeneratedKeys();
            return 1;
        } catch (SQLException e) {
            con.rollback();
            e.printStackTrace();
            return -1;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException e) {
        return -1;
    }
}

######


@Override
public int doUpdate(Periodico entity) {
    throw new UnsupportedOperationException("Not supported yet.");
}

######


protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setContentType("text/html;charset=utf-8");
    Status status = new Status();
    DBConnect dbConnect = new DBConnect();
    Person person = new Person();
    String URI = request.getRequestURI();
    int index = URI.lastIndexOf('/');
    String account = URI.substring(index + 1);
    account = URLDecoder.decode(account, "utf-8");
    String userToken = request.getParameter("userToken");
    if (userToken == null) {
        userToken = "";
    }
    JSONObject jsonRet;
    String querySting = "SELECT * FROM user WHERE account=?";
    PreparedStatement preparedStatement = dbConnect.prepareStatement(querySting);
    if (account.equals("") || account.equals("account") || userToken.equals("")) {
        status.setStatus(false);
        status.setInfo("空参数");
        jsonRet = JSONObject.fromObject(status);
        person.setName("");
        person.setInfo("");
        person.setContact("");
        jsonRet.put("perInfo", person);
    } else {
        try {
            preparedStatement.setString(1, account);
            ResultSet rs = preparedStatement.executeQuery();
            status.setStatus(true);
            status.setInfo("获取信息成功");
            jsonRet = JSONObject.fromObject(status);
            while (rs.next()) {
                person.setName(rs.getString("name"));
                person.setInfo(rs.getString("info"));
                person.setContact(rs.getString("contact"));
            }
            jsonRet.put("perInfo", person);
        } catch (SQLException e) {
            status.setStatus(false);
            status.setInfo("空参数");
            jsonRet = JSONObject.fromObject(status);
            person.setName("");
            person.setInfo(e.getMessage());
            person.setContact("");
            jsonRet.put("perInfo", person);
            e.printStackTrace();
        }
    }
    PrintWriter out = response.getWriter();
    out.print(jsonRet.toString());
}

######


protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setContentType("text/html;charset=utf-8");
    Status status = new Status();
    DBConnect dbConnect = new DBConnect();
    Person person = new Person();
    String URI = request.getRequestURI();
    int index = URI.lastIndexOf('/');
    String account = URI.substring(index + 1);
    account = URLDecoder.decode(account, "utf-8");
    String userToken = request.getParameter("userToken");
    String name = request.getParameter("name");
    String info = request.getParameter("info");
    String contact = request.getParameter("contact");
    JSONObject jsonRet;
    if (userToken == null) {
        userToken = "";
    }
    if (name == null) {
        name = "";
    }
    if (info == null) {
        info = "";
    }
    if (contact == null) {
        contact = "";
    }
    status.setStatus(true);
    status.setInfo("更改成功");
    if (account.equals("") || account.equals("account") || userToken.equals("") || name.equals("") || info.equals("") || contact.equals("")) {
        status.setStatus(false);
        status.setInfo("空参数");
    } else {
        try {
            String queryString;
            PreparedStatement preparedStatement;
            ResultSet rs;
            queryString = "UPDATE user SET name=? ,info=?, contact=?  WHERE account = ?";
            preparedStatement = dbConnect.prepareStatement(queryString);
            preparedStatement.setString(1, name);
            preparedStatement.setString(2, info);
            preparedStatement.setString(3, contact);
            preparedStatement.setString(4, account);
            preparedStatement.executeUpdate();
            status.setStatus(true);
            status.setInfo("updated info successfully");
            jsonRet = JSONObject.fromObject(status);
            jsonRet.put("perInfo", person);
        } catch (SQLException e) {
            status.setStatus(false);
            status.setInfo("用户信息更新失败");
            jsonRet = JSONObject.fromObject(status);
            e.printStackTrace();
        }
    }
    JSONObject jsonRetStatus = JSONObject.fromObject(status);
    PrintWriter out = response.getWriter();
    out.print(jsonRetStatus.toString());
}

######


@Select("select * from person where id = #{id}")
Person getPersonById(Integer id);

######


@Insert("insert into person(name,email,age) value(#{name}, #{email}, #{age})")
Integer addPerson(Person person);

######


@Delete("delete from person where id = #{id}")
Integer delPersonById(Integer id);

######


@Update("update person set person_desc = #{personDesc} where id = #{id}")
Integer updPersonDesc(@Param("id") Integer id, @Param("personDesc") String personDesc);

######


@Update("update person set person_sex = #{personSex} where id = #{id}")
Integer updPersonSex(@Param("id") Integer id, @Param("personSex") String personSex);

######


@Override
public void addPerson(Person person) throws SQLException {
    Connection dbConnection = null;
    java.sql.Statement statement = null;
    try {
        dbConnection = PSQL.getConnection();
        statement = dbConnection.createStatement();
        String addPerson = "insert into person(id_person, name, surname, date_of_birth, pin, phone_number, position_id) values ('" + person.getId() + "' , '" + person.getName() + "' , '" + person.getSurname() + "' , '" + person.getDateOfBirth() + "' , '" + person.getPin() + "' , '" + person.getPhoneNr() + "' , '" + person.getPositionId() + "')";
        statement.executeUpdate(addPerson);
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    } finally {
        if (statement != null) {
            statement.close();
        }
        if (dbConnection != null) {
            dbConnection.close();
        }
    }
}

######


@Override
public void deletePerson(Person person) throws SQLException {
    Connection dbConnection = null;
    PreparedStatement preparedStatement = null;
    String deletePerson = "DELETE FROM person WHERE name = '" + person.getName() + "' AND surname = '" + person.getSurname() + "'";
    try {
        dbConnection = PSQL.getConnection();
        preparedStatement = dbConnection.prepareStatement(deletePerson);
        preparedStatement.executeUpdate();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    } finally {
        if (preparedStatement != null) {
            preparedStatement.close();
        }
        if (dbConnection != null) {
            dbConnection.close();
        }
    }
}

######


@Override
public void updatePerson(Person person) throws SQLException {
    Connection dbConnection = null;
    java.sql.Statement statement = null;
    try {
        dbConnection = PSQL.getConnection();
        statement = dbConnection.createStatement();
        String positionUpdate = "UPDATE person SET phone_number = " + person.getPhoneNr() + " , pin = " + person.getPin() + " , date_of_birth = " + person.getDateOfBirth() + " , position_id = " + person.getPositionId() + " WHERE surname = " + person.getSurname() + " AND name = " + person.getName();
        statement.executeUpdate(positionUpdate);
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    } finally {
        if (statement != null) {
            statement.close();
        }
        if (dbConnection != null) {
            dbConnection.close();
        }
    }
}

######


@Override
public void getAll() throws SQLException {
    Connection dbConnection = null;
    java.sql.Statement statement = null;
    String selectCourses = "SELECT id_person, name, surname, date_of_birth, pin, phone_number, position_id FROM person";
    try {
        dbConnection = PSQL.getConnection();
        statement = dbConnection.createStatement();
        ResultSet rs = statement.executeQuery(selectCourses);
        while (rs.next()) {
            int id = rs.getInt("id_person");
            String name = rs.getString("name");
            String surname = rs.getString("surname");
            Date date = rs.getDate("date_of_birth");
            String pin = rs.getString("pin");
            int phoneNr = rs.getInt("phone_number");
            int positionId = rs.getInt("position_id");
        }
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    } finally {
        if (statement != null) {
            statement.close();
        }
        if (dbConnection != null) {
            dbConnection.close();
        }
    }
}

######


@ConstructorArgs({ @Arg(column = "id", javaType = Integer.class, id = true), @Arg(column = "firstName", javaType = String.class), @Arg(column = "lastName", javaType = String.class), @Arg(column = "personType", javaType = PersonType.class, typeHandler = EnumOrdinalTypeHandler.class) })
@Select("SELECT id, firstName, lastName, personType FROM person WHERE id = #{id}")
Person findOneUsingConstructor(int id);

######


@Results({ @Result(property = "personType", column = "personType", typeHandler = EnumOrdinalTypeHandler.class) })
@Select("SELECT id, firstName, lastName, personType FROM person WHERE id = #{id}")
Person findOneUsingSetter(int id);

######


@TypeDiscriminator(column = "personType", javaType = PersonType.class, typeHandler = EnumOrdinalTypeHandler.class, cases = { @Case(value = "PERSON", type = Person.class, results = { @Result(property = "personType", column = "personType", typeHandler = EnumOrdinalTypeHandler.class) }), @Case(value = "EMPLOYEE", type = Employee.class, results = { @Result(property = "personType", column = "personType", typeHandler = EnumOrdinalTypeHandler.class) }) })
@Select("SELECT id, firstName, lastName, personType FROM person WHERE id = #{id}")
Person findOneUsingTypeDiscriminator(int id);

######


public boolean cadastrar(PessoaFisica novo) {
    String strSqlQuery = "INSERT INTO tb_clientepf( nome, telefone, email, endereco, cpf, rg, sexo, datanascimento, " + "cnh, datavalida, categoria, estadoemissor, passaporte)  VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    Connection conn = null;
    PreparedStatement stm = null;
    try {
        conn = AcessoBD.obtemConexao();
        stm = conn.prepareStatement(strSqlQuery);
        stm.setString(1, novo.getNome());
        stm.setString(2, novo.getTelefone());
        stm.setString(3, novo.getEmail());
        stm.setString(4, novo.getEndereco());
        stm.setString(5, novo.getCpf());
        stm.setString(6, novo.getRg());
        stm.setString(7, novo.getSexo());
        stm.setString(8, novo.getDtNascimento());
        stm.setString(9, novo.getCnh());
        stm.setString(10, novo.getDataValida());
        stm.setString(11, novo.getCategoria());
        stm.setString(12, novo.getEstadoEmissor());
        stm.setString(13, novo.getPassaporte());
        stm.executeUpdate();
        return true;
    } catch (Exception e) {
        e.printStackTrace();
        try {
            conn.rollback();
            return false;
        } catch (SQLException sqlEx) {
            return false;
        }
    } finally {
        if (stm != null) {
            try {
                stm.close();
            } catch (SQLException sqlEx) {
                return false;
            }
        }
    }
}

######


public PessoaFisica getClienteFisicoById(int id) {
    PessoaFisica clientepf = new PessoaFisica();
    java.sql.Connection conn = null;
    String sqlSelect;
    PreparedStatement stm = null;
    ResultSet rs = null;
    sqlSelect = "SELECT * FROM tb_clientepf" + " WHERE id =?";
    try {
        conn = AcessoBD.obtemConexao();
        stm = conn.prepareStatement(sqlSelect);
        stm.setInt(1, id);
        rs = stm.executeQuery();
        while (rs.next()) {
            clientepf.setCategoria(rs.getString("categoria"));
            clientepf.setCnh(rs.getString("cnh"));
            clientepf.setId(rs.getInt("id"));
            clientepf.setCpf(rs.getString("cpf"));
            clientepf.setDtNascimento(rs.getString("datanascimento"));
            clientepf.setDtValidade(rs.getString("datavalida"));
            clientepf.setEmail(rs.getString("email"));
            clientepf.setEndereco(rs.getString("endereco"));
            clientepf.setEstadoEmissor(rs.getString("estadoemissor"));
            clientepf.setNome(rs.getString("nome"));
            clientepf.setPassaporte(rs.getString("passaporte"));
            clientepf.setRg(rs.getString("rg"));
            clientepf.setSexo(rs.getString("sexo"));
            clientepf.setTelefone(rs.getString("telefone"));
        }
        return clientepf;
    } catch (Exception e) {
        e.printStackTrace();
        return clientepf;
    } finally {
        if (stm != null) {
            try {
                stm.close();
            } catch (Exception e1) {
                System.out.print(e1.getStackTrace());
            }
        }
    }
}

######


public List<PessoaFisica> obterAllClientesFisicos(String query) {
    ArrayList<PessoaFisica> resultado = new ArrayList<PessoaFisica>();
    java.sql.Connection conn = null;
    PreparedStatement stm = null;
    ResultSet rs = null;
    try {
        conn = AcessoBD.obtemConexao();
        stm = conn.prepareStatement(query);
        rs = stm.executeQuery();
        while (rs.next()) {
            PessoaFisica clientepf = new PessoaFisica();
            clientepf.setCategoria(rs.getString("categoria"));
            clientepf.setCnh(rs.getString("cnh"));
            clientepf.setId(rs.getInt("id"));
            clientepf.setCpf(rs.getString("cpf"));
            clientepf.setDtNascimento(rs.getString("datanascimento"));
            clientepf.setDtValidade(rs.getString("datavalida"));
            clientepf.setEmail(rs.getString("email"));
            clientepf.setEndereco(rs.getString("endereco"));
            clientepf.setEstadoEmissor(rs.getString("estadoemissor"));
            clientepf.setNome(rs.getString("nome"));
            clientepf.setPassaporte(rs.getString("passaporte"));
            clientepf.setRg(rs.getString("rg"));
            clientepf.setSexo(rs.getString("sexo"));
            clientepf.setTelefone(rs.getString("telefone"));
            resultado.add(clientepf);
        }
        return resultado;
    } catch (Exception e) {
        e.printStackTrace();
        return resultado;
    } finally {
        if (stm != null) {
            try {
                stm.close();
            } catch (Exception e1) {
                System.out.print(e1.getStackTrace());
            }
        }
    }
}

######


public boolean cadastrar(PessoaJuridica novo) {
    String strSqlQuery = "INSERT INTO tb_clientepj( nomefantasia, nomejuridico, telefone, " + "email, endereco, cnpj) VALUES (?, ?, ?, ?, ?, ?);";
    Connection conn = null;
    PreparedStatement stm = null;
    try {
        conn = AcessoBD.obtemConexao();
        stm = conn.prepareStatement(strSqlQuery);
        stm.setString(1, novo.getNomeFantasia());
        stm.setString(2, novo.getRazaosocial());
        stm.setString(3, novo.getTelefone());
        stm.setString(4, novo.getEmail());
        stm.setString(5, novo.getEndereco());
        stm.setString(6, novo.getCnpj());
        stm.executeUpdate();
        return true;
    } catch (Exception e) {
        e.printStackTrace();
        try {
            conn.rollback();
            return false;
        } catch (SQLException sqlEx) {
            return false;
        }
    } finally {
        if (stm != null) {
            try {
                stm.close();
            } catch (SQLException sqlEx) {
                return false;
            }
        }
    }
}

######


public boolean alterarClienteJuridico(PessoaJuridica pessoaJuridicaAtualizada) {
    String sqlInsert = "UPDATE tb_clientepj set nomefantasia = ? , nomejuridico = ?," + " telefone = ? ,email = ? , endereco = ? ,cnpj = ?  where id = ?";
    Connection conn = null;
    PreparedStatement stm = null;
    try {
        conn = AcessoBD.obtemConexao();
        stm = conn.prepareStatement(sqlInsert);
        stm.setString(1, pessoaJuridicaAtualizada.getNomeFantasia());
        stm.setString(2, pessoaJuridicaAtualizada.getRazaosocial());
        stm.setString(3, pessoaJuridicaAtualizada.getTelefone());
        stm.setString(4, pessoaJuridicaAtualizada.getEmail());
        stm.setString(5, pessoaJuridicaAtualizada.getEndereco());
        stm.setString(6, pessoaJuridicaAtualizada.getCnpj());
        stm.setInt(7, pessoaJuridicaAtualizada.getId());
        stm.executeUpdate();
        return true;
    } catch (Exception e) {
        e.printStackTrace();
        try {
            conn.rollback();
            return false;
        } catch (SQLException sqlEx) {
            return false;
        }
    } finally {
        if (stm != null) {
            try {
                stm.close();
            } catch (SQLException sqlEx) {
                return false;
            }
        }
    }
}

######


public void excluirClienteJuridico(int id) {
    String sqlDelete = "DELETE FROM tb_clientepj WHERE id = ?";
    java.sql.Connection conn = null;
    PreparedStatement stm = null;
    try {
        conn = AcessoBD.obtemConexao();
        stm = conn.prepareStatement(sqlDelete);
        stm.setInt(1, id);
        stm.execute();
    } catch (Exception e) {
        e.printStackTrace();
        try {
            conn.rollback();
        } catch (SQLException e1) {
            System.out.print(e1.getStackTrace());
        }
    } finally {
        if (stm != null) {
            try {
                stm.close();
            } catch (SQLException e1) {
                System.out.print(e1.getStackTrace());
            }
        }
    }
}

######


public Phase getPhaseById(Integer id) {
    return em.find(Phase.class, id);
}

######


@Transactional
public void save(PhaseChange r) {
    em.merge(r);
}

######


public List<Phase> getAll() {
    Query query = em.createQuery("SELECT e FROM Phase e");
    return (List<Phase>) query.getResultList();
}

######


public Phase getPhaseByName(String phase) {
    Query query = em.createQuery("SELECT e FROM Phase e where e.name=:name");
    query.setParameter("name", phase);
    List<Phase> results = (List<Phase>) query.getResultList();
    if (results != null && results.size() > 0) {
        return results.get(0);
    }
    return null;
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<PhenotypeCallSummary> getAllPhenotypeCallSummaries() {
    List<PhenotypeCallSummary> summaries = getCurrentSession().createQuery("from PhenotypeCallSummary").list();
    return summaries;
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<PhenotypeCallSummary> getPhenotypeCallByAccession(String accId, int dbId) {
    List<PhenotypeCallSummary> results = getCurrentSession().createQuery("from PhenotypeCallSummary as pheno where pheno.gene.id.accession = ? and pheno.gene.id.databaseId = ? and pheno.datasource is not null").setString(0, accId).setInteger(1, dbId).list();
    List<PhenotypeCallSummary> summaries = new ArrayList<PhenotypeCallSummary>();
    for (PhenotypeCallSummary p : results) {
        if (p.getPhenotypeTerm() != null) {
            summaries.add(p);
        }
    }
    return summaries;
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<PhenotypeCallSummary> getPhenotypeCallByPhenotypingCenterAndPipeline(String phenotypingCenter, String pipelineStableId) {
    List<PhenotypeCallSummary> results = getCurrentSession().createQuery("from PhenotypeCallSummary as pheno where pheno.organisation.name = ? and pheno.pipeline.stableId = ? order by pheno.pValue asc").setString(0, phenotypingCenter).setString(1, pipelineStableId).list();
    return results;
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<PhenotypeCallSummary> getPhenotypeCallByAccession(String accId) {
    List<PhenotypeCallSummary> results = getCurrentSession().createQuery("from PhenotypeCallSummary as pheno where pheno.gene.id.accession = ? and pheno.datasource !=22").setString(0, accId).list();
    return results;
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<PhenotypeCallSummary> getPhenotypeCallByMPAccession(String accId, int dbId) {
    List<PhenotypeCallSummary> results = getCurrentSession().createQuery("select distinct pheno from PhenotypeCallSummary as pheno where pheno.phenotypeTerm.id.accession = ? and pheno.phenotypeTerm.id.databaseId = ? ").setString(0, accId).setInteger(1, dbId).list();
    List<PhenotypeCallSummary> summaries = new ArrayList<PhenotypeCallSummary>();
    for (PhenotypeCallSummary p : results) {
        if (p.getPhenotypeTerm() != null) {
            summaries.add(p);
        }
    }
    return summaries;
}

######


@Transactional(readOnly = false)
public void deletePhenotypeCallSummariesByDatasource(Datasource datasource, Parameter parameter) throws SQLException {
    String sql = "DELETE FROM phenotype_call_summary WHERE external_db_id=? AND parameter_id=?";
    try (PreparedStatement statement = getConnection().prepareStatement(sql)) {
        statement.setInt(1, datasource.getId());
        statement.setInt(2, parameter.getId());
        statement.executeUpdate();
    }
}

######


@Transactional(readOnly = false)
public void deleteCategoricalResultsByParameter(Parameter parameter) throws SQLException {
    String query = "DELETE FROM stats_categorical_results WHERE parameter_id=?";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        statement.setInt(1, parameter.getId());
        statement.executeUpdate();
    }
}

######


@Transactional(readOnly = false)
public void deleteUnidimensionalResultsByParameter(Parameter parameter) throws SQLException {
    String query = "DELETE FROM stats_unidimensional_results WHERE parameter_id=?";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        statement.setInt(1, parameter.getId());
        statement.executeUpdate();
    }
}

######


@Transactional(readOnly = false)
public void deleteCategoricalResults() throws SQLException {
    String query = "TRUNCATE TABLE stats_categorical_results";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        statement.executeUpdate();
    }
}

######


@Transactional(readOnly = false)
public void deleteUnidimensionalResults() throws SQLException {
    String query = "TRUNCATE TABLE stats_unidimensional_results";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        statement.executeUpdate();
    }
}

######


@Override
public int deletePhenotypeCallSummariesByDatasourceParameterSexZygosity(Datasource datasource, Parameter parameter, SexType sex, ZygosityType zygosity) {
    Session session = sessionFactory.openSession();
    Transaction tx = session.beginTransaction();
    String hqlDelete = "delete PhenotypeCallSummary as c where c.datasource.id = ? and c.sex = ? and c.zygosity = ? and parameter = ?";
    int deletedEntities = session.createQuery(hqlDelete).setInteger(0, datasource.getId()).setString(1, sex.name()).setString(2, zygosity.name()).setInteger(3, parameter.getId()).executeUpdate();
    tx.commit();
    session.close();
    return deletedEntities;
}

######


@Transactional(readOnly = true)
@SuppressWarnings("unchecked")
public List<Pipeline> getAllPhenotypePipelines() {
    List<Pipeline> pipelines = getCurrentSession().createQuery("from Pipeline").list();
    return pipelines;
}

######


@Transactional(readOnly = true)
public Pipeline getPhenotypePipelineByStableId(String stableId) {
    return (Pipeline) getCurrentSession().createQuery("from Pipeline as p where p.stableId = ?").setString(0, stableId).uniqueResult();
}

######


@Transactional(readOnly = true)
public Pipeline getPhenotypePipelineById(Integer id) {
    return (Pipeline) getCurrentSession().get(Pipeline.class, id);
}

######


@Transactional(readOnly = true)
public Pipeline getPhenotypePipelineByStableIdAndVersion(String stableId, int majorVersion, int minorVersion) {
    Object o = getCurrentSession().createQuery("from Pipeline as p where p.stableId = ? and p.majorVersion = ? and p.minorVersion = ?").setString(0, stableId).setInteger(1, majorVersion).setInteger(2, minorVersion).uniqueResult();
    return (o == null) ? null : (Pipeline) o;
}

######


@Transactional(readOnly = true)
public Procedure getProcedureByStableIdAndVersion(String stableId, int majorVersion, int minorVersion) {
    return (Procedure) getCurrentSession().createQuery("from Procedure as p where p.stableId = ? and p.majorVersion = ? and p.minorVersion = ?").setString(0, stableId).setInteger(1, majorVersion).setInteger(2, minorVersion).uniqueResult();
}

######


@Transactional(readOnly = true)
public Procedure getProcedureByStableId(String stableId) {
    return (Procedure) getCurrentSession().createQuery("from Procedure as p where p.stableId = ?").setString(0, stableId).uniqueResult();
}

######


public static PhoneBookDao getInstance(Context context) {
    if (dao == null) {
        synchronized (PhoneBookDao.class) {
            if (dao == null) {
                dao = new PhoneBookDao(context);
            }
        }
    }
    return dao;
}

######


public void insertPhoneBook(PhoneBook book) {
    if (isPhoneBookExist(book.getBdaddr(), book.getPbnumber())) {
        return;
    } else {
        db.execSQL("insert into " + SqliteHelper.TABLE_NAME_PHONEBOOK + " values (null,?,?,?,?,?)", new Object[] { book.getBdaddr(), book.getPbname(), book.getPbnumber(), book.getPbplace(), TimeUtils.getCurTime() });
    }
}

######


public void updatePhoneBook(PhoneBook book) {
    db.execSQL("update " + SqliteHelper.TABLE_NAME_PHONEBOOK + " set pbname=?,pbnumber=?,pbplace=?,pbtime=? where bdaddr = ?", new Object[] { book.getPbname(), book.getPbnumber(), book.getPbplace(), TimeUtils.getCurDate(), book.getBdaddr() });
}

######


public void updatePhoneBookPlace(String addr, String number, String place) {
    db.execSQL("update " + SqliteHelper.TABLE_NAME_PHONEBOOK + " set pbplace=? where bdaddr = ? and pbnumber = ?", new Object[] { place, addr, number });
}

######


public void deletePhoneBook(PhoneBook book) {
    db.execSQL("delete from " + SqliteHelper.TABLE_NAME_PHONEBOOK + " where bdaddr = ? and pbnumber = ?", new String[] { book.getBdaddr(), book.getPbnumber() });
}

######


public void deletePhoneBook(String addr, String number) {
    db.execSQL("delete from " + SqliteHelper.TABLE_NAME_PHONEBOOK + " where bdaddr = ? and pbnumber = ?", new String[] { addr, number });
}

######


public void deleteAllPhoneBooks(String bdaddr) {
    db.execSQL("delete from " + SqliteHelper.TABLE_NAME_PHONEBOOK + " where bdaddr = ?", new String[] { bdaddr });
}

######


public PhoneBook queryPhoneBook(String addr, String number) {
    PhoneBook book = null;
    Cursor cursor = db.rawQuery("select * from " + SqliteHelper.TABLE_NAME_PHONEBOOK + " where bdaddr = ? and pbnumber = ?", new String[] { addr, number });
    if (cursor != null && cursor.getCount() > 0) {
        cursor.moveToNext();
        book = new PhoneBook();
        book.setBdaddr(addr);
        book.setPbname(cursor.getString(cursor.getColumnIndex("pbname")));
        book.setPbplace(cursor.getString(cursor.getColumnIndex("pbplace")));
        book.setPbnumber(number);
    } else {
        book = new PhoneBook(addr, "陌生号码", number, "");
    }
    return book;
}

######


public boolean isPhoneBookExist(String addr, String number) {
    PhoneBook book = null;
    Cursor cursor = db.rawQuery("select * from " + SqliteHelper.TABLE_NAME_PHONEBOOK + " where bdaddr = ? and pbnumber = ?", new String[] { addr, number });
    if (cursor != null && cursor.getCount() > 0) {
        return true;
    }
    return false;
}

######


public String queryPhoneName(String addr, String number) {
    return queryPhoneBook(addr, number).getPbname();
}

######


public String queryPhonePlace(String addr, String number) {
    PhoneBook book = queryPhoneBook(addr, number);
    if (book != null && TextUtils.isEmpty(book.getPbname()))
        return book.getPbplace();
    return "";
}

######


public ArrayList<PhoneBook> queryAllPhoneBooks(String bdaddr) {
    ArrayList<PhoneBook> booklist = null;
    Cursor cursor = db.rawQuery("select * from " + SqliteHelper.TABLE_NAME_PHONEBOOK + " where bdaddr = ? order by pbname asc", new String[] { bdaddr });
    if (cursor != null && cursor.getCount() > 0) {
        booklist = new ArrayList<PhoneBook>();
        while (cursor.moveToNext()) {
            PhoneBook book = new PhoneBook();
            book.setBdaddr(bdaddr);
            book.setPbname(cursor.getString(cursor.getColumnIndex("pbname")));
            book.setPbplace(cursor.getString(cursor.getColumnIndex("pbplace")));
            if (TextUtils.isEmpty(book.getPbname())) {
                book.setPbname("陌生号码");
            }
            book.setPbnumber(cursor.getString(cursor.getColumnIndex("pbnumber")));
            booklist.add(book);
        }
    }
    return booklist;
}

######


public static PhoneCallDao getInstance(Context context) {
    if (dao == null) {
        synchronized (PhoneCallDao.class) {
            if (dao == null) {
                dao = new PhoneCallDao(context);
            }
        }
    }
    return dao;
}

######


public void insertPhoneCall(PhoneCall call) {
    db.execSQL("insert into " + SqliteHelper.TABLE_NAME_PHONECALL + " values (null,?,?,?,?,?)", new Object[] { call.getBdaddr(), call.getCallNumber(), call.getCallType(), call.getCallPlace(), TimeUtils.getCurTime() });
}

######


public void updatePhoneCallPlace(String addr, String number, String place) {
    db.execSQL("update " + SqliteHelper.TABLE_NAME_PHONECALL + " set callplace = ? where bdaddr =? and callnumber= ?", new Object[] { place, addr, number });
}

######


public void deletePhoneCall(PhoneCall call) {
    db.execSQL("delete from " + SqliteHelper.TABLE_NAME_PHONECALL + " where bdaddr = ? and callnumber=? and calltype = ? and calltime=?", new Object[] { call.getBdaddr(), call.getCallNumber(), call.getCallType(), call.getCallTime() });
}

######


public void deletePhoneCall(String addr, String number, String time) {
    db.execSQL("delete from " + SqliteHelper.TABLE_NAME_PHONECALL + " where bdaddr = ? and callnumber=? and calltime=?", new Object[] { addr, number, time });
}

######


public void deletePhoneCalls(String bdaddr, String number, int callType) {
    db.execSQL("delete from " + SqliteHelper.TABLE_NAME_PHONECALL + " where bdaddr = ? and callnumber=? and calltype = ?", new String[] { bdaddr, number, String.valueOf(callType) });
}

######


public void deletePhoneCalls(String bdaddr, String number) {
    db.execSQL("delete from " + SqliteHelper.TABLE_NAME_PHONECALL + " where bdaddr = ? and callnumber=?", new String[] { bdaddr, number });
}

######


public void deleteAllPhoneCalls(String bdaddr) {
    db.execSQL("delete from " + SqliteHelper.TABLE_NAME_PHONECALL + " where bdaddr = ?", new String[] { bdaddr });
}

######


public ArrayList<PhoneCall> queryPhoneCall(String bdaddr, String number, int callType) {
    ArrayList<PhoneCall> calllist = null;
    Cursor cursor = db.rawQuery("select * from " + SqliteHelper.TABLE_NAME_PHONECALL + " where bdaddr = ? and callnumber=? and calltype = ? order by calltime desc", new String[] { bdaddr, number, String.valueOf(callType) });
    if (cursor != null && cursor.getCount() > 0) {
        calllist = new ArrayList<PhoneCall>();
        while (cursor.moveToNext()) {
            PhoneCall call = new PhoneCall();
            call.setBdaddr(bdaddr);
            call.setCallNumber(number);
            call.setCallTime(cursor.getString(cursor.getColumnIndex("calltime")));
            call.setCallName(PhoneBookDao.getInstance(mContext).queryPhoneName(bdaddr, number));
            call.setCallPlace(cursor.getString(cursor.getColumnIndex("callplace")));
            call.setCallType(callType);
            calllist.add(call);
        }
    }
    return calllist;
}

######


public ArrayList<PhoneCall> queryPhoneCalls(String bdaddr, String number) {
    ArrayList<PhoneCall> calllist = null;
    Cursor cursor = db.rawQuery("select * from " + SqliteHelper.TABLE_NAME_PHONECALL + " where bdaddr = ? and callnumber=? order by calltime desc", new String[] { bdaddr, number });
    if (cursor != null && cursor.getCount() > 0) {
        calllist = new ArrayList<PhoneCall>();
        while (cursor.moveToNext()) {
            PhoneCall call = new PhoneCall();
            call.setBdaddr(bdaddr);
            call.setCallNumber(number);
            call.setCallTime(cursor.getString(cursor.getColumnIndex("calltime")));
            call.setCallType(cursor.getInt(cursor.getColumnIndex("calltype")));
            call.setCallName(PhoneBookDao.getInstance(mContext).queryPhoneName(bdaddr, call.getCallNumber()));
            call.setCallPlace(cursor.getString(cursor.getColumnIndex("callplace")));
            calllist.add(call);
        }
    }
    return calllist;
}

######


public ArrayList<PhoneCall> queryAllPhoneCalls(String bdaddr) {
    ArrayList<PhoneCall> calllist = null;
    Cursor cursor = db.rawQuery("select * from " + SqliteHelper.TABLE_NAME_PHONECALL + " where bdaddr = ?  order by calltime desc", new String[] { bdaddr });
    if (cursor != null && cursor.getCount() > 0) {
        calllist = new ArrayList<PhoneCall>();
        while (cursor.moveToNext()) {
            PhoneCall call = new PhoneCall();
            call.setBdaddr(bdaddr);
            call.setCallNumber(cursor.getString(cursor.getColumnIndex("callnumber")));
            call.setCallTime(cursor.getString(cursor.getColumnIndex("calltime")));
            call.setCallType(cursor.getInt(cursor.getColumnIndex("calltype")));
            call.setCallName(PhoneBookDao.getInstance(mContext).queryPhoneName(bdaddr, call.getCallNumber()));
            call.setCallPlace(cursor.getString(cursor.getColumnIndex("callplace")));
            calllist.add(call);
        }
    }
    return calllist;
}

######


public ArrayList<PhoneCall> queryAllPhoneCalls(String bdaddr, int type) {
    ArrayList<PhoneCall> calllist = null;
    Cursor cursor = db.rawQuery("select * from " + SqliteHelper.TABLE_NAME_PHONECALL + " where bdaddr = ? and calltype = ? order by calltime desc", new String[] { bdaddr, String.valueOf(type) });
    if (cursor != null && cursor.getCount() > 0) {
        calllist = new ArrayList<PhoneCall>();
        while (cursor.moveToNext()) {
            PhoneCall call = new PhoneCall();
            call.setBdaddr(bdaddr);
            call.setCallNumber(cursor.getString(cursor.getColumnIndex("callnumber")));
            call.setCallTime(cursor.getString(cursor.getColumnIndex("calltime")));
            call.setCallType(cursor.getInt(cursor.getColumnIndex("calltype")));
            call.setCallName(PhoneBookDao.getInstance(mContext).queryPhoneName(bdaddr, call.getCallNumber()));
            call.setCallPlace(cursor.getString(cursor.getColumnIndex("callplace")));
            calllist.add(call);
        }
    }
    return calllist;
}

######


public String queryPhonePlaceFromPC(String bdaddr, String number) {
    ArrayList<PhoneCall> calllist = null;
    Cursor cursor = db.rawQuery("select callplace from " + SqliteHelper.TABLE_NAME_PHONECALL + " where bdaddr = ? and callnumber=?", new String[] { bdaddr, number });
    if (cursor != null && cursor.getCount() > 0) {
        while (cursor.moveToNext()) {
            String place = cursor.getString(cursor.getColumnIndex("callplace"));
            if (!TextUtils.isEmpty(place)) {
                return place;
            }
        }
    }
    return "";
}

######


public static PhoneDeviceDao getInstance(Context context) {
    if (dao == null) {
        synchronized (PhoneDeviceDao.class) {
            if (dao == null) {
                dao = new PhoneDeviceDao(context);
            }
        }
    }
    return dao;
}

######


public void insertDevice(PhoneDevice device) {
    db.execSQL("insert into " + SqliteHelper.TABLE_NAME_DEVICE + " values (null,?,?,?)", new Object[] { device.getBdaddr(), NormalUtils.string2Unicode(device.getBdname()), TimeUtils.getCurTime() });
}

######


public void updateDevice(PhoneDevice device) {
    db.execSQL("update " + SqliteHelper.TABLE_NAME_DEVICE + " set bdname=?,bdtime=? where bdaddr = ?", new Object[] { NormalUtils.string2Unicode(device.getBdname()), TimeUtils.getCurTime(), device.getBdaddr() });
}

######


public void deleteDevice(String addr) {
    db.execSQL("delete from " + SqliteHelper.TABLE_NAME_DEVICE + " where bdaddr = ?", new String[] { addr });
}

######


public PhoneDevice queryDevice(String addr) {
    PhoneDevice device = null;
    Cursor cursor = db.rawQuery("select * from " + SqliteHelper.TABLE_NAME_DEVICE + " where bdaddr = ?", new String[] { addr });
    if (cursor != null && cursor.getCount() >= 1) {
        cursor.moveToNext();
        device = new PhoneDevice();
        device.setBdname(NormalUtils.unicode2String(cursor.getString(cursor.getColumnIndex("bdname"))));
        device.setBdaddr(addr);
    }
    return device;
}

######


public ArrayList<PhoneDevice> queryAllDevices() {
    ArrayList<PhoneDevice> devicelist = null;
    Cursor cursor = db.rawQuery("select * from " + SqliteHelper.TABLE_NAME_DEVICE + " order by bdtime desc", null);
    if (cursor != null && cursor.getCount() > 0) {
        devicelist = new ArrayList<PhoneDevice>();
        while (cursor.moveToNext()) {
            PhoneDevice device = new PhoneDevice();
            device.setBdname(NormalUtils.unicode2String(cursor.getString(cursor.getColumnIndex("bdname"))));
            device.setBdaddr(cursor.getString(cursor.getColumnIndex("bdaddr")));
            devicelist.add(device);
        }
    }
    return devicelist;
}

######


public ArrayList<PhoneDevice> queryDevices(int number) {
    ArrayList<PhoneDevice> devicelist = null;
    Cursor cursor = db.rawQuery("select * from " + SqliteHelper.TABLE_NAME_DEVICE + " order by _id desc limit 0," + number, null);
    if (cursor != null && cursor.getCount() > 0) {
        devicelist = new ArrayList<PhoneDevice>();
        while (cursor.moveToNext()) {
            PhoneDevice device = new PhoneDevice();
            device.setBdname(NormalUtils.unicode2String(cursor.getString(cursor.getColumnIndex("bdname"))));
            device.setBdaddr(cursor.getString(cursor.getColumnIndex("bdaddr")));
            devicelist.add(device);
        }
    }
    return devicelist;
}

######


public void PicModel() {
}

######


public void setCluster(Cluster cluster) {
    this.cluster = cluster;
}

######


public void insertPic(byte[] b, String type, String name, String user) {
    try {
        Convertors convertor = new Convertors();
        String[] types = Convertors.SplitFiletype(type);
        ByteBuffer buffer = ByteBuffer.wrap(b);
        int length = b.length;
        java.util.UUID picid = convertor.getTimeUUID();
        Boolean success = (new File("/var/tmp/instagrim/")).mkdirs();
        FileOutputStream output = new FileOutputStream(new File("/var/tmp/instagrim/" + picid));
        output.write(b);
        byte[] thumbb = picresize(picid.toString(), types[1]);
        int thumblength = thumbb.length;
        ByteBuffer thumbbuf = ByteBuffer.wrap(thumbb);
        byte[] processedb = picdecolour(picid.toString(), types[1]);
        ByteBuffer processedbuf = ByteBuffer.wrap(processedb);
        int processedlength = processedb.length;
        Session session = cluster.connect("instagrim");
        PreparedStatement psInsertPic = session.prepare("insert into pics ( picid, image,thumb,processed, user, interaction_time,imagelength,thumblength,processedlength,type,name) values(?,?,?,?,?,?,?,?,?,?,?)");
        PreparedStatement psInsertPicToUser = session.prepare("insert into userpiclist ( picid, user, pic_added) values(?,?,?)");
        BoundStatement bsInsertPic = new BoundStatement(psInsertPic);
        BoundStatement bsInsertPicToUser = new BoundStatement(psInsertPicToUser);
        Date DateAdded = new Date();
        session.execute(bsInsertPic.bind(picid, buffer, thumbbuf, processedbuf, user, DateAdded, length, thumblength, processedlength, type, name));
        session.execute(bsInsertPicToUser.bind(picid, user, DateAdded));
        session.close();
    } catch (IOException ex) {
        System.out.println("Error --> " + ex);
    }
}

######


public byte[] picresize(String picid, String type) {
    try {
        BufferedImage BI = ImageIO.read(new File("/var/tmp/instagrim/" + picid));
        BufferedImage thumbnail = createThumbnail(BI);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ImageIO.write(thumbnail, type, baos);
        baos.flush();
        byte[] imageInByte = baos.toByteArray();
        baos.close();
        return imageInByte;
    } catch (IOException et) {
    }
    return null;
}

######


public byte[] picdecolour(String picid, String type) {
    try {
        BufferedImage BI = ImageIO.read(new File("/var/tmp/instagrim/" + picid));
        BufferedImage processed = createProcessed(BI);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ImageIO.write(processed, type, baos);
        baos.flush();
        byte[] imageInByte = baos.toByteArray();
        baos.close();
        return imageInByte;
    } catch (IOException et) {
    }
    return null;
}

######


public static BufferedImage createThumbnail(BufferedImage img) {
    img = resize(img, Method.SPEED, 250, OP_ANTIALIAS, OP_GRAYSCALE);
    return pad(img, 2);
}

######


public static BufferedImage createProcessed(BufferedImage img) {
    int Width = img.getWidth() - 1;
    img = resize(img, Method.SPEED, Width, OP_ANTIALIAS, OP_GRAYSCALE);
    return pad(img, 4);
}

######


public java.util.LinkedList<Pic> getPicsForUser(String User) {
    java.util.LinkedList<Pic> Pics = new java.util.LinkedList<>();
    Session session = cluster.connect("instagrim");
    PreparedStatement ps = session.prepare("select picid from userpiclist where user =?");
    ResultSet rs = null;
    BoundStatement boundStatement = new BoundStatement(ps);
    rs = session.execute(boundStatement.bind(User));
    if (rs.isExhausted()) {
        System.out.println("No Images returned");
        return null;
    } else {
        for (Row row : rs) {
            Pic pic = new Pic();
            java.util.UUID UUID = row.getUUID("picid");
            System.out.println("UUID" + UUID.toString());
            pic.setUUID(UUID);
            Pics.add(pic);
        }
    }
    return Pics;
}

######


public Pic getPic(int image_type, java.util.UUID picid) {
    Session session = cluster.connect("instagrim");
    ByteBuffer bImage = null;
    String type = null;
    int length = 0;
    try {
        Convertors convertor = new Convertors();
        ResultSet rs = null;
        PreparedStatement ps = null;
        if (image_type == Convertors.DISPLAY_IMAGE) {
            ps = session.prepare("select image,imagelength,type from pics where picid =?");
        } else if (image_type == Convertors.DISPLAY_THUMB) {
            ps = session.prepare("select thumb,imagelength,thumblength,type from pics where picid =?");
        } else if (image_type == Convertors.DISPLAY_PROCESSED) {
            ps = session.prepare("select processed,processedlength,type from pics where picid =?");
        }
        BoundStatement boundStatement = new BoundStatement(ps);
        rs = session.execute(boundStatement.bind(picid));
        if (rs.isExhausted()) {
            System.out.println("No Images returned");
            return null;
        } else {
            for (Row row : rs) {
                if (image_type == Convertors.DISPLAY_IMAGE) {
                    bImage = row.getBytes("image");
                    length = row.getInt("imagelength");
                } else if (image_type == Convertors.DISPLAY_THUMB) {
                    bImage = row.getBytes("thumb");
                    length = row.getInt("thumblength");
                } else if (image_type == Convertors.DISPLAY_PROCESSED) {
                    bImage = row.getBytes("processed");
                    length = row.getInt("processedlength");
                }
                type = row.getString("type");
            }
        }
    } catch (Exception et) {
        System.out.println("Can't get Pic" + et);
        return null;
    }
    session.close();
    Pic p = new Pic();
    p.setPic(bImage, length, type);
    return p;
}

######


@Override
public void validateBuild() throws IndexerException {
    Long numFound = getDocumentCount(pipelineCore);
    if (numFound <= MINIMUM_DOCUMENT_COUNT)
        throw new IndexerException(new ValidationException("Actual pipeline document count is " + numFound + "."));
    if (numFound != documentCount)
        logger.warn("WARNING: Added " + documentCount + " pipeline documents but SOLR reports " + numFound + " documents.");
    else
        logger.info("validateBuild(): Indexed " + documentCount + " pipeline documents.");
}

######


@Override
public void initialise(String[] args) throws IndexerException {
    super.initialise(args);
    try {
        this.komp2DbConnection = komp2DataSource.getConnection();
    } catch (SQLException sqle) {
        logger.error("Caught SQL Exception initialising database connections: {}", sqle.getMessage());
        throw new IndexerException(sqle);
    }
}

######


private void initialiseSupportingBeans() throws IndexerException {
    paramDbIdToParameter = populateParamDbIdToParametersMap();
    procedureIdToParams = populateParamIdToProcedureIdListMap();
    procedureIdToProcedure = populateProcedureIdToProcedureMap();
    pipelines = populateProcedureIdToPipelineMap();
    parameterStableIdToAbnormalMaMap = populateParameterStableIdToAbnormalOntologyMap();
    pppidsToGfMpBeans = populateGfAccAndMp();
    mgiToAlleleMap = IndexerMap.getGeneToAlleles(alleleCore);
    mpIdToMp = populateMpIdToMp();
}

######


@Override
public void run() throws IndexerException {
    long startTime = System.currentTimeMillis();
    try {
        logger.info("Starting Pipeline Indexer...");
        initialiseSupportingBeans();
        pipelineCore.deleteByQuery("*:*");
        pipelineCore.commit();
        for (PipelineBean pipeline : pipelines) {
            Set<Integer> parameterIds = procedureIdToParams.get(pipeline.pipelineId);
            for (int paramDbId : parameterIds) {
                PipelineDTO pipe = new PipelineDTO();
                Map<String, String> row = paramDbIdToParameter.get(paramDbId);
                pipe.setParameterId(paramDbId);
                pipe.setParameterName(row.get(ObservationDTO.PARAMETER_NAME));
                String paramStableId = row.get(ObservationDTO.PARAMETER_STABLE_ID);
                String paramStableName = row.get(ObservationDTO.PARAMETER_NAME);
                pipe.setParameterStableId(paramStableId);
                if (parameterStableIdToAbnormalMaMap.containsKey(paramStableId)) {
                    pipe.setAbnormalMaTermId(parameterStableIdToAbnormalMaMap.get(paramStableId));
                    OntologyTermBean term = maOntologyService.getTerm(parameterStableIdToAbnormalMaMap.get(paramStableId));
                    pipe.setAbnormalMaName(term.getName());
                }
                pipe.setParameterStableKey(row.get("stable_key"));
                ProcedureBean procBean = procedureIdToProcedure.get(pipeline.procedureId);
                pipe.addProcedureId(pipeline.procedureId);
                pipe.addProcedureName(procBean.procedureName);
                pipe.addProcedureStableId(procBean.procedureStableId);
                pipe.addProcedureStableKey(procBean.procedureStableKey);
                pipe.addProcedureNameId(procBean.procNameId);
                pipe.addMappedProcedureName(SangerProcedureMapper.getImpcProcedureFromSanger(procBean.procedureName));
                String procParamStableId = procBean.procedureStableId + "___" + paramStableId;
                String procParamName = procBean.procedureName + "___" + paramStableName;
                pipe.addProcParamStableId(procParamStableId);
                pipe.addProcParamName(procParamName);
                pipe.setPipelineId(pipeline.pipelineId);
                pipe.addPipelineName(pipeline.pipelineName);
                pipe.addPipelineStableId(pipeline.pipelineStableId);
                pipe.addPipelineStableKey(pipeline.pipelineStableKey);
                pipe.addPipeProcId(pipeline.pipeProcSid);
                String ididid = pipeline.pipelineStableId + "_" + procBean.procedureStableId + "_" + paramStableId;
                String idididKey = paramDbId + "_" + pipeline.pipeProcSid + "_" + pipe.getPipelineId();
                pipe.setIdIdId(ididid);
                if (pppidsToGfMpBeans.containsKey(idididKey)) {
                    List<GfMpBean> gfMpBeanList = pppidsToGfMpBeans.get(idididKey);
                    for (GfMpBean gfMpBean : gfMpBeanList) {
                        String mgiAccession = gfMpBean.gfAcc;
                        pipe.addMgiAccession(mgiAccession);
                        if (mgiToAlleleMap.containsKey(mgiAccession)) {
                            List<AlleleDTO> alleles = mgiToAlleleMap.get(mgiAccession);
                            for (AlleleDTO allele : alleles) {
                                if (allele.getMarkerSymbol() != null) {
                                    pipe.addMarkerType(allele.getMarkerType());
                                    pipe.addMarkerSymbol(allele.getMarkerSymbol());
                                    if (allele.getMarkerSynonym() != null) {
                                        pipe.addMarkerSynonym(allele.getMarkerSynonym());
                                    }
                                }
                                pipe.addMarkerName(allele.getMarkerName());
                                if (allele.getHumanGeneSymbol() != null) {
                                    pipe.addHumanGeneSymbol(allele.getHumanGeneSymbol());
                                }
                                pipe.addStatus(allele.getStatus());
                                pipe.addImitsPhenotypeStarted(allele.getImitsPhenotypeStarted());
                                pipe.addImitsPhenotypeComplete(allele.getImitsPhenotypeComplete());
                                pipe.addImitsPhenotypeStatus(allele.getImitsPhenotypeStatus());
                                if (allele.getLatestProductionCentre() != null) {
                                    pipe.addLatestProductionCentre(allele.getLatestProductionCentre());
                                }
                                if (allele.getLatestPhenotypingCentre() != null) {
                                    pipe.addLatestPhenotypingCentre(allele.getLatestPhenotypingCentre());
                                }
                                pipe.addLatestPhenotypingCentre(allele.getLatestPhenotypeStatus());
                                pipe.addLegacyPhenotypingStatus(allele.getLatestPhenotypeStatus());
                                pipe.addAlleleName(allele.getAlleleName());
                            }
                        }
                        String mpTermId = gfMpBean.mpAcc;
                        MpDTO mp = mpIdToMp.get(mpTermId);
                        pipe.addMpId(mpTermId);
                        if (mp != null) {
                            pipe.addMpTerm(mp.getMpTerm());
                            if (mp.getMpTermSynonym() != null) {
                                pipe.addMpTermSynonym(mp.getMpTermSynonym());
                            }
                            if (mp.getOntologySubset() != null) {
                                pipe.addOntologySubset(mp.getOntologySubset());
                            }
                            if (mp.getTopLevelMpTermId() != null) {
                                pipe.addTopLevelMpId(mp.getTopLevelMpTermId());
                            } else {
                                logger.warn("topLevelMpTermId for mpTerm " + mpTermId + " is null!");
                            }
                            if (mp.getTopLevelMpTerm() != null) {
                                pipe.addTopLevelMpTerm(mp.getTopLevelMpTerm());
                            } else {
                                logger.warn("topLevelMpTerm for mpTerm " + mpTermId + " is null!");
                            }
                            if (mp.getTopLevelMpTermSynonym() != null) {
                                pipe.addTopLevelMpTermSynonym(mp.getTopLevelMpTermSynonym());
                            }
                            if (mp.getIntermediateMpId() != null) {
                                pipe.addIntermediateMpId(mp.getIntermediateMpId());
                            }
                            if (mp.getIntermediateMpTerm() != null) {
                                pipe.addIntermediateMpTerm(mp.getIntermediateMpTerm());
                            }
                            if (mp.getIntermediateMpTermSynonym() != null) {
                                pipe.addIntermediateMpTermSynonym(mp.getIntermediateMpTermSynonym());
                            }
                            if (mp.getChildMpId() != null) {
                                pipe.addChildMpId(mp.getChildMpId());
                                pipe.addChildMpTerm(mp.getChildMpTerm());
                            }
                            if (mp.getChildMpTermSynonym() != null) {
                                pipe.addChildMpTermSynonym(mp.getChildMpTermSynonym());
                            }
                            if (mp.getHpId() != null) {
                                pipe.addHpId(mp.getHpId());
                            }
                            if (mp.getHpTerm() != null) {
                                pipe.addHpTerm(mp.getHpTerm());
                            }
                            if (mp.getInferredMaId() != null) {
                                pipe.addInferredMaId(mp.getInferredMaId());
                                pipe.addInferredMaTerm(mp.getInferredMaTerm());
                                if (mp.getInferredMaTermSynonym() != null) {
                                    pipe.addInferredMaTermSynonym(mp.getInferredMaTermSynonym());
                                }
                            }
                            if (mp.getInferredSelectedTopLevelMaId() != null) {
                                pipe.addInferredSelectedTopLevelMaId(mp.getInferredSelectedTopLevelMaId());
                                if (mp.getInferredSelectedTopLevelMaTerm() != null) {
                                    pipe.addInferredSelectedTopLevelMaTerm(mp.getInferredSelectedTopLevelMaTerm());
                                }
                                if (mp.getInferredSelectedTopLevelMaTermSynonym() != null) {
                                    pipe.addInferredSelectedToLevelMaTermSynonym(mp.getInferredSelectedTopLevelMaTermSynonym());
                                }
                            }
                            if (mp.getInferredChildMaId() != null) {
                                pipe.addInferredChildMaId(mp.getInferredChildMaId());
                                pipe.addInferredChildMaTerm(mp.getInferredChildMaTerm());
                                if (mp.getInferredChildMaTermSynonym() != null) {
                                    pipe.addInferredChildMaTermSynonyms(mp.getInferredChildMaTermSynonym());
                                }
                            }
                        }
                    }
                }
                documentCount++;
                pipelineCore.addBean(pipe);
                if (documentCount % 10000 == 0) {
                    System.out.println("documentCount=" + documentCount);
                    pipelineCore.commit();
                }
            }
        }
        logger.info("commiting to Pipeline core for last time!");
        logger.info("Pipeline commit started.");
        pipelineCore.commit();
        logger.info("Pipeline commit finished.");
    } catch (IOException | SolrServerException e) {
        e.printStackTrace();
        throw new IndexerException(e);
    } catch (NullPointerException npe) {
        npe.printStackTrace();
    }
    long endTime = System.currentTimeMillis();
    logger.info("time was " + (endTime - startTime) / 1000);
    logger.info("Pipeline Indexer complete!");
}

######


@Override
protected Logger getLogger() {
    return logger;
}

######


private Map<Integer, Map<String, String>> populateParamDbIdToParametersMap() {
    logger.info("populating PCS pipeline info");
    Map<Integer, Map<String, String>> localParamDbIdToParameter = new HashMap<>();
    String queryString = "select 'pipeline' as dataType, id, stable_id, name, stable_key from phenotype_parameter";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(queryString)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            Map<String, String> rowMap = new HashMap<>();
            int id = resultSet.getInt("id");
            rowMap.put(ObservationDTO.PARAMETER_NAME, resultSet.getString("name"));
            rowMap.put(ObservationDTO.PARAMETER_STABLE_ID, resultSet.getString("stable_id"));
            rowMap.put("dataType", resultSet.getString("dataType"));
            rowMap.put("stable_key", resultSet.getString("stable_key"));
            localParamDbIdToParameter.put(id, rowMap);
        }
        System.out.println("phenotype parameter should have 5704+ entries and has " + localParamDbIdToParameter.size() + " entries");
    } catch (Exception e) {
        e.printStackTrace();
    }
    return localParamDbIdToParameter;
}

######


private Map<Integer, Set<Integer>> populateParamIdToProcedureIdListMap() {
    logger.info("populating param To ProcedureId info");
    Map<Integer, Set<Integer>> procIdToParams = new HashMap<>();
    String queryString = "select procedure_id, parameter_id from phenotype_procedure_parameter";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(queryString)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            Set<Integer> parameterIds = new HashSet<>();
            int paramId = resultSet.getInt("parameter_id");
            int procId = resultSet.getInt("procedure_id");
            if (procIdToParams.containsKey(procId)) {
                parameterIds = procIdToParams.get(procId);
            } else {
                parameterIds = new HashSet<>();
            }
            parameterIds.add(paramId);
            procIdToParams.put(procId, parameterIds);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    System.out.println("should be 5704+ entries " + procIdToParams.size());
    return procIdToParams;
}

######


private Map<Integer, ProcedureBean> populateProcedureIdToProcedureMap() {
    logger.info("populating procedureId to Procedure Map info");
    Map<Integer, ProcedureBean> procedureIdToProcedureMap = new HashMap<>();
    String queryString = "select id as pproc_id, stable_id, name, stable_key, concat(name, '___', stable_id) as proc_name_id from phenotype_procedure";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(queryString)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            ProcedureBean proc = new ProcedureBean();
            int procId = resultSet.getInt("pproc_id");
            String procStableId = resultSet.getString("stable_id");
            String procName = resultSet.getString("name");
            int stableKey = resultSet.getInt("stable_key");
            String procNameId = resultSet.getString("proc_name_id");
            proc.procedureStableId = procStableId;
            proc.procedureName = procName;
            proc.procedureStableKey = stableKey;
            proc.procNameId = procNameId;
            procedureIdToProcedureMap.put(procId, proc);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    System.out.println("187+ the procedureIdToProcedureMap size=" + procedureIdToProcedureMap.size());
    return procedureIdToProcedureMap;
}

######


private List<PipelineBean> populateProcedureIdToPipelineMap() {
    logger.info("populating procedureId to  pipeline Map info");
    List<PipelineBean> procIdToPipelineMap = new ArrayList<>();
    String queryString = "select pproc.id as pproc_id, ppipe.name as pipe_name, ppipe.id as pipe_id, ppipe.stable_id as pipe_stable_id, ppipe.stable_key as pipe_stable_key, concat(ppipe.name, '___', pproc.name, '___', pproc.stable_id) as pipe_proc_sid from phenotype_procedure pproc inner join phenotype_pipeline_procedure ppproc on pproc.id=ppproc.procedure_id inner join phenotype_pipeline ppipe on ppproc.pipeline_id=ppipe.id where ppipe.db_id=6";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(queryString)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            PipelineBean pipe = new PipelineBean();
            int procedureId = resultSet.getInt("pproc_id");
            String pipeName = resultSet.getString("pipe_name");
            int pipeId = resultSet.getInt("pipe_id");
            String pipeStableId = resultSet.getString("pipe_stable_id");
            int pipeStableKey = resultSet.getInt("pipe_stable_key");
            String pipeProcSid = resultSet.getString("pipe_proc_sid");
            pipe.pipelineId = pipeId;
            pipe.pipelineName = pipeName;
            pipe.pipelineStableKey = pipeStableKey;
            pipe.pipelineStableId = pipeStableId;
            pipe.pipeProcSid = pipeProcSid;
            pipe.procedureId = procedureId;
            procIdToPipelineMap.add(pipe);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    System.out.println("547+ should be and is in procIdToPipelineMap " + procIdToPipelineMap.size());
    return procIdToPipelineMap;
}

######


private Map<String, String> populateParameterStableIdToAbnormalOntologyMap() {
    Map<String, String> parameterStableIdToOntology = new HashMap<>();
    String sqlQuery = "SELECT stable_id, ontology_acc FROM phenotype_parameter pp INNER JOIN phenotype_parameter_lnk_ontology_annotation pploa ON pp.id=pploa.parameter_id INNER JOIN phenotype_parameter_ontology_annotation ppoa ON ppoa.id=pploa.annotation_id WHERE ppoa.ontology_db_id=8 LIMIT 10000";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(sqlQuery)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            String parameterId = resultSet.getString("stable_id");
            String maId = resultSet.getString("ontology_acc");
            parameterStableIdToOntology.put(parameterId, maId);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    System.out.println("547+ should be and is in procIdToPipelineMap " + parameterStableIdToOntology.size());
    return parameterStableIdToOntology;
}

######


private Map<String, List<GfMpBean>> populateGfAccAndMp() {
    logger.info("populating GfAcc and Mp info - started");
    Map<String, List<GfMpBean>> gfMpBeansMap = new HashMap<>();
    String queryString = "select distinct concat(s.parameter_id,'_',s.procedure_id,'_',s.pipeline_id) as pppIds, s.gf_acc, s.mp_acc, s.parameter_id as pp_parameter_id, s.procedure_id as pproc_procedure_id, s.pipeline_id as ppipe_pipeline_id, s.allele_acc, s.strain_acc from phenotype_parameter pp INNER JOIN phenotype_procedure_parameter ppp on pp.id=ppp.parameter_id INNER JOIN phenotype_procedure pproc on ppp.procedure_id=pproc.id INNER JOIN phenotype_pipeline_procedure ppproc on pproc.id=ppproc.procedure_id INNER JOIN phenotype_pipeline ppipe on ppproc.pipeline_id=ppipe.id inner join phenotype_call_summary s on ppipe.id=s.pipeline_id and pproc.id=s.procedure_id and pp.id=s.parameter_id";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(queryString)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            GfMpBean gfMpBean = new GfMpBean();
            String pppids = resultSet.getString("pppids");
            String gfAcc = resultSet.getString("gf_acc");
            String mpAcc = resultSet.getString("mp_acc");
            gfMpBean.gfAcc = gfAcc;
            gfMpBean.mpAcc = mpAcc;
            List<GfMpBean> beanList = new ArrayList<>();
            if (gfMpBeansMap.containsKey(pppids)) {
                beanList = gfMpBeansMap.get(pppids);
            }
            beanList.add(gfMpBean);
            gfMpBeansMap.put(pppids, beanList);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    logger.info("populating GfAcc and Mp info - finished");
    return gfMpBeansMap;
}

######


private Map<String, MpDTO> populateMpIdToMp() throws IndexerException {
    return SolrUtils.populateMpTermIdToMp(mpCore);
}

######


public static void main(String[] args) throws IndexerException {
    PipelineIndexer indexer = new PipelineIndexer();
    indexer.initialise(args);
    indexer.run();
    indexer.validateBuild();
    logger.info("Process finished.  Exiting.");
}

######


@Query("SELECT * FROM player")
List<Player> getAll();

######


@Query("SELECT * FROM player WHERE id IN (:playerIds)")
List<Player> loadAllByIds(int[] playerIds);

######


@Query("SELECT * FROM player WHERE id = (:playerId)")
Player getPlayerById(long playerId);

######


@Query("SELECT * FROM player WHERE eventId = (:eventId)")
List<Player> getPlayersFromEvent(long eventId);

######


@Query("SELECT * FROM player WHERE raceId = (:raceId)")
List<Player> getPlayersFromRace(long raceId);

######


@Query("SELECT * FROM player WHERE raceId = (:raceId) AND colorBlue = (:isblue)")
Player getPlayer(long raceId, boolean isblue);

######


@Update
void update(Player player);

######


@Insert
long insert(Player player);

######


@Query("DELETE FROM player")
void deleteAllPlayers();

######


@Delete
void delete(Player player);

######


public void addSong(BrowserSong song) {
    long songId = -1;
    PlaylistsDatabase playlistsDatabase = new PlaylistsDatabase();
    SQLiteDatabase db = playlistsDatabase.getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put("idPlaylist", id);
    values.put("uri", song.getUri());
    values.put("artist", song.getArtist());
    values.put("title", song.getTitle());
    values.put("hasImage", song.hasImage());
    try {
        songId = db.insertOrThrow("SongsInPlaylist", null, values);
    } catch (Exception e) {
    } finally {
        db.close();
    }
    if (songId == -1)
        return;
    PlaylistSong playlistSong = new PlaylistSong(song.getUri(), song.getArtist(), song.getTitle(), songId, song.hasImage(), this);
    songs.add(playlistSong);
}

######


public void deleteSong(PlaylistSong song) {
    PlaylistsDatabase playlistsDatabase = new PlaylistsDatabase();
    SQLiteDatabase db = playlistsDatabase.getWritableDatabase();
    db.delete("SongsInPlaylist", "idSong=" + song.getId(), null);
    db.close();
    songs.remove(song);
}

######


public void sort(int from, int to) {
    if (to > from) {
        Collections.rotate(songs.subList(from, to + 1), -1);
    } else {
        Collections.rotate(songs.subList(to, from + 1), +1);
    }
    PlaylistsDatabase playlistsDatabase = new PlaylistsDatabase();
    SQLiteDatabase db = playlistsDatabase.getWritableDatabase();
    for (int i = 0; i < songs.size(); i++) {
        PlaylistSong song = songs.get(i);
        ContentValues values = new ContentValues();
        values.put("position", i);
        db.update("SongsInPlaylist", values, "idSong=" + song.getId(), null);
    }
    db.close();
}

######


public void editName(String newName) {
    name = newName;
    PlaylistsDatabase playlistsDatabase = new PlaylistsDatabase();
    SQLiteDatabase db = playlistsDatabase.getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put("name", newName);
    db.update("Playlists", values, "id=" + id, null);
    db.close();
}

######


public long getId() {
    return id;
}

######


public String getName() {
    return name;
}

######


public ArrayList<PlaylistSong> getSongs() {
    return songs;
}

######


@Override
public boolean equals(Object o) {
    if (!(o instanceof Playlist))
        return false;
    Playlist p2 = (Playlist) o;
    return id == p2.id;
}

######


@Override
public String toString() {
    return getName();
}

######


public static ArrayList<Playlist> getPlaylists() {
    if (playlists == null)
        loadPlaylists();
    return playlists;
}

######


private static void loadPlaylists() {
    playlists = new ArrayList<>();
    PlaylistsDatabase playlistsDatabase = new PlaylistsDatabase();
    SQLiteDatabase db = playlistsDatabase.getReadableDatabase();
    Cursor cursor = db.rawQuery("SELECT id, name FROM Playlists ORDER BY position", null);
    while (cursor.moveToNext()) {
        long id = cursor.getLong(0);
        String name = cursor.getString(1);
        Playlist playlist = new Playlist(id, name);
        playlists.add(playlist);
    }
    cursor.close();
    db.close();
}

######


public static Playlist addPlaylist(String name) {
    if (playlists == null)
        loadPlaylists();
    long id = -1;
    PlaylistsDatabase playlistsDatabase = new PlaylistsDatabase();
    SQLiteDatabase db = playlistsDatabase.getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put("name", name);
    try {
        id = db.insertOrThrow("Playlists", null, values);
    } catch (Exception e) {
    } finally {
        db.close();
    }
    if (id == -1)
        return null;
    Playlist playlist = new Playlist(id, name);
    playlists.add(playlist);
    return playlist;
}

######


public static void deletePlaylist(Playlist playlist) {
    if (playlists == null)
        loadPlaylists();
    PlaylistsDatabase playlistsDatabase = new PlaylistsDatabase();
    SQLiteDatabase db = playlistsDatabase.getWritableDatabase();
    db.delete("SongsInPlaylist", "idPlaylist=" + playlist.getId(), null);
    db.delete("Playlists", "id=" + playlist.getId(), null);
    db.close();
    playlists.remove(playlist);
}

######


public static void sortPlaylists(int from, int to) {
    if (playlists == null)
        loadPlaylists();
    if (to > from) {
        Collections.rotate(playlists.subList(from, to + 1), -1);
    } else {
        Collections.rotate(playlists.subList(to, from + 1), +1);
    }
    PlaylistsDatabase playlistsDatabase = new PlaylistsDatabase();
    SQLiteDatabase db = playlistsDatabase.getWritableDatabase();
    for (int i = 0; i < playlists.size(); i++) {
        Playlist playlist = playlists.get(i);
        ContentValues values = new ContentValues();
        values.put("position", i);
        db.update("Playlists", values, "id=" + playlist.getId(), null);
    }
    db.close();
}

######


public static PlaylistSong getSavedSongFromPlaylist(long idSong) {
    PlaylistSong song = null;
    PlaylistsDatabase playlistsDatabase = new PlaylistsDatabase();
    SQLiteDatabase db = playlistsDatabase.getReadableDatabase();
    Cursor cursor = db.rawQuery("SELECT idPlaylist, uri, artist, title, hasImage FROM SongsInPlaylist WHERE idSong=" + idSong, null);
    if (cursor.moveToNext()) {
        Playlist playlist = null;
        long idPlaylist = cursor.getLong(0);
        for (Playlist p : Playlists.getPlaylists()) {
            if (p.getId() == idPlaylist)
                playlist = p;
            break;
        }
        String uri = cursor.getString(1);
        String artist = cursor.getString(2);
        String title = cursor.getString(3);
        boolean hasImage = cursor.getInt(4) == 1;
        song = new PlaylistSong(uri, artist, title, idSong, hasImage, playlist);
    }
    cursor.close();
    db.close();
    return song;
}

######


public void loadItemsFromDatabase() {
    episodes = new ArrayList<>();
    PodcastsDatabase podcastsDatabase = new PodcastsDatabase();
    SQLiteDatabase db = podcastsDatabase.getReadableDatabase();
    Cursor cursor = db.rawQuery("SELECT idItem, url, title, status, filename, pubDate, duration, type, description FROM ItemsInPodcast WHERE idPodcast=" + id + " ORDER BY pubDate DESC", null);
    while (cursor.moveToNext()) {
        String itemId = cursor.getString(0);
        String itemUrl = cursor.getString(1);
        String title = cursor.getString(2);
        int status = cursor.getInt(3);
        String filename = cursor.getString(4);
        long pubDate = cursor.getLong(5);
        String duration = cursor.getString(6);
        String type = cursor.getString(7);
        String description = cursor.getString(8);
        PodcastEpisode item = new PodcastEpisode(itemUrl, filename, title, itemId, this, status, pubDate, duration, type, description);
        episodes.add(item);
    }
    cursor.close();
    db.close();
}

######


private void addItem(SQLiteDatabase db, PodcastEpisode episode) {
    ContentValues values = new ContentValues();
    values.put("idPodcast", id);
    values.put("idItem", episode.getId());
    values.put("url", episode.getUrl());
    values.put("title", episode.getTitle());
    values.put("status", episode.getStatus());
    values.put("pubDate", episode.getPubDate());
    values.put("duration", episode.getDuration());
    values.put("type", episode.getType());
    values.put("description", episode.getDescription());
    try {
        db.insertOrThrow("ItemsInPodcast", null, values);
    } catch (Exception e) {
    }
}

######


public void deleteEpisode(PodcastEpisode episode) {
    episode.deleteDownloadedFile();
    PodcastsDatabase podcastsDatabase = new PodcastsDatabase();
    SQLiteDatabase db = podcastsDatabase.getWritableDatabase();
    db.delete("ItemsInPodcast", "idItem='" + episode.getId() + "'", null);
    db.close();
    episodes.remove(episode);
}

######


public void remove() {
    for (PodcastEpisode episode : episodes) {
        episode.deleteDownloadedFile();
    }
    PodcastsDatabase podcastsDatabase = new PodcastsDatabase();
    SQLiteDatabase db = podcastsDatabase.getWritableDatabase();
    db.delete("Podcasts", "id=" + id, null);
    db.delete("ItemsInPodcast", "idPodcast=" + id, null);
    db.close();
}

######


public void editName(String newName) {
    name = newName;
    PodcastsDatabase podcastsDatabase = new PodcastsDatabase();
    SQLiteDatabase db = podcastsDatabase.getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put("name", newName);
    db.update("Podcasts", values, "id=" + id, null);
    db.close();
}

######


public static ArrayList<Podcast> getPodcasts() {
    ArrayList<Podcast> podcasts = new ArrayList<>();
    PodcastsDatabase podcastsDatabase = new PodcastsDatabase();
    SQLiteDatabase db = podcastsDatabase.getReadableDatabase();
    Cursor cursor = db.rawQuery("SELECT id, url, name, image FROM Podcasts ORDER BY name", null);
    while (cursor.moveToNext()) {
        Podcast podcast = new Podcast(cursor.getLong(0), cursor.getString(1), cursor.getString(2), cursor.getBlob(3));
        podcasts.add(podcast);
    }
    db.close();
    return podcasts;
}

######


public static void addPodcast(Context context, String url, String name, byte[] image) {
    PodcastsDatabase podcastsDatabase = new PodcastsDatabase();
    SQLiteDatabase db = podcastsDatabase.getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put("url", url);
    values.put("name", name);
    if (image != null) {
        values.put("image", image);
    }
    try {
        db.insertOrThrow("Podcasts", null, values);
    } catch (Exception e) {
    } finally {
        db.close();
    }
}

######


public static void deleteEpisodes(Podcast podcast, boolean downloadedOnly) {
    ArrayList<Podcast> podcasts;
    if (podcast == null) {
        podcasts = Podcast.getPodcasts();
    } else {
        podcasts = new ArrayList<>();
        podcasts.add(podcast);
    }
    if (downloadedOnly)
        deleteDownloadedEpisodes(podcasts);
    else
        deleteEpisodes(podcasts);
}

######


private static void deleteEpisodes(ArrayList<Podcast> podcasts) {
    PodcastsDatabase podcastsDatabase = new PodcastsDatabase();
    SQLiteDatabase db = podcastsDatabase.getWritableDatabase();
    for (Podcast podcast : podcasts) {
        for (PodcastEpisode episode : podcast.getEpisodes()) {
            episode.deleteDownloadedFile();
        }
        db.delete("ItemsInPodcast", "idPodcast=" + podcast.id, null);
    }
    db.close();
}

######


private static void deleteDownloadedEpisodes(ArrayList<Podcast> podcasts) {
    for (Podcast podcast : podcasts) {
        for (PodcastEpisode episode : podcast.getEpisodes()) {
            if (episode.getStatus() == PodcastEpisode.STATUS_DOWNLOADED) {
                episode.deleteDownloadedFile();
                episode.setStatus(PodcastEpisode.STATUS_NEW);
            }
        }
    }
}

######


public boolean update() {
    PodcastParser parser = new PodcastParser();
    boolean ok = parser.parse(url);
    if (!ok)
        return false;
    ArrayList<PodcastEpisode> items = parser.getEpisodes();
    PodcastsDatabase podcastsDatabase = new PodcastsDatabase();
    SQLiteDatabase db = podcastsDatabase.getWritableDatabase();
    for (PodcastEpisode item : items) {
        item.setPodcast(this);
        addItem(db, item);
    }
    db.close();
    loadItemsFromDatabase();
    return true;
}

######


public String getUrl() {
    return url;
}

######


public long getId() {
    return id;
}

######


public String getName() {
    return name;
}

######


public ArrayList<PodcastEpisode> getEpisodes() {
    return episodes;
}

######


public byte[] getImageBytes() {
    return image;
}

######


public Bitmap getImage() {
    if (image == null)
        return null;
    return BitmapFactory.decodeByteArray(image, 0, image.length);
}

######


@Override
public boolean equals(Object o) {
    if (!(o instanceof Podcast))
        return false;
    Podcast p2 = (Podcast) o;
    return id == p2.id;
}

######


public List<InspectionPlaceModel> getInspectionPlacesByHospitalPoliclinicRel(HospitalPoliclinicRelModel hospitalPoliclinicRelModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM InspectionPlaceModel e WHERE e.hospitalPoliclinicRel = :hospitalPoliclinicRel AND e.doctor IS NOT NULL ORDER BY e.placeName");
    query.setParameter("hospitalPoliclinicRel", hospitalPoliclinicRelModel);
    return query.getResultList();
}

######


public List<AppointmentModel> getAppointmentsByPoliclinic(HospitalPoliclinicRelModel hospitalPoliclinicRelModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM AppointmentModel e WHERE " + "e.inspectionPlace.hospitalPoliclinicRel = :hospitalPoliclinicRel " + "AND appointmentDate > :date " + "ORDER BY e.inspectionPlace.placeName,e.creationTime");
    query.setParameter("hospitalPoliclinicRel", hospitalPoliclinicRelModel);
    query.setParameter("date", new Date());
    return query.getResultList();
}

######


public List<InspectionPlaceModel> getAppointmentHeadersByPoliclinic(HospitalPoliclinicRelModel hospitalPoliclinicRelModel, Date startDate, Date endDate) {
    Query query = getEntitymanager().createQuery("SELECT DISTINCT(ip) FROM InspectionPlaceModel ip INNER JOIN ip.appointmentModels ap WHERE ip.hospitalPoliclinicRel = :HOSPITAL_POLICLINIC_REL AND ap.appointmentStatus = :APPOINTMENT_STATUS AND ap.appointmentDate BETWEEN :START_DATE AND :END_DATE ORDER BY ip.placeName ASC");
    query.setParameter("HOSPITAL_POLICLINIC_REL", hospitalPoliclinicRelModel);
    query.setParameter("APPOINTMENT_STATUS", AppointmentStatusEnum.NOT_RESERVED);
    query.setParameter("START_DATE", startDate);
    query.setParameter("END_DATE", endDate);
    return query.getResultList();
}

######


public List<InspectionPlaceModel> getAppointmentHeadersByPoliclinic(HospitalPoliclinicRelModel hospitalPoliclinicRelModel) {
    Query query = getEntitymanager().createQuery("SELECT DISTINCT(ip) FROM InspectionPlaceModel ip INNER JOIN ip.appointmentModels ap WHERE ip.hospitalPoliclinicRel = :HOSPITAL_POLICLINIC_REL AND ap.appointmentStatus = :APPOINTMENT_STATUS AND ap.appointmentDate > :START_DATE ORDER BY ip.placeName ASC");
    query.setParameter("HOSPITAL_POLICLINIC_REL", hospitalPoliclinicRelModel);
    query.setParameter("APPOINTMENT_STATUS", AppointmentStatusEnum.NOT_RESERVED);
    query.setParameter("START_DATE", DateUtil.getEndOfDay());
    return query.getResultList();
}

######


public List<InspectionPlaceModel> getAppointmentHeadersByPoliclinic(HospitalPoliclinicRelModel hospitalPoliclinicRelModel, Date startDate) {
    Query query = getEntitymanager().createQuery("SELECT DISTINCT(ip) FROM InspectionPlaceModel ip INNER JOIN ip.appointmentModels ap WHERE ip.hospitalPoliclinicRel = :HOSPITAL_POLICLINIC_REL AND ap.appointmentStatus = :APPOINTMENT_STATUS AND ap.appointmentDate > :START_DATE ORDER BY ip.placeName ASC");
    query.setParameter("HOSPITAL_POLICLINIC_REL", hospitalPoliclinicRelModel);
    query.setParameter("APPOINTMENT_STATUS", AppointmentStatusEnum.NOT_RESERVED);
    query.setParameter("START_DATE", startDate);
    return query.getResultList();
}

######


@Override
public void addPosition(Position position) throws SQLException {
    Connection dbConnection = null;
    java.sql.Statement statement = null;
    try {
        dbConnection = PSQL.getConnection();
        statement = dbConnection.createStatement();
        String addPosition = "insert into position(id_position, name, sallary) values ('" + position.getId() + "' , '" + position.getName() + "' , '" + position.getSallary() + "')";
        statement.executeUpdate(addPosition);
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    } finally {
        if (statement != null) {
            statement.close();
        }
        if (dbConnection != null) {
            dbConnection.close();
        }
    }
}

######


@Override
public void deletePosition(Position position) throws SQLException {
    Connection dbConnection = null;
    PreparedStatement preparedStatement = null;
    String deletePosition = "DELETE FROM position WHERE id_position = '" + position.getId() + "'";
    try {
        dbConnection = PSQL.getConnection();
        preparedStatement = dbConnection.prepareStatement(deletePosition);
        preparedStatement.executeUpdate();
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    } finally {
        if (preparedStatement != null) {
            preparedStatement.close();
        }
        if (dbConnection != null) {
            dbConnection.close();
        }
    }
}

######


@Override
public void updateSallary(Position position) throws SQLException {
    Connection dbConnection = null;
    java.sql.Statement statement = null;
    try {
        dbConnection = PSQL.getConnection();
        statement = dbConnection.createStatement();
        String positionUpdate = "UPDATE position SET sallary = " + position.getSallary() + "  WHERE id = " + position.getName() + ";";
        statement.executeUpdate(positionUpdate);
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    } finally {
        if (statement != null) {
            statement.close();
        }
        if (dbConnection != null) {
            dbConnection.close();
        }
    }
}

######


@Override
public List<Position> getAll() throws SQLException {
    List<Position> results = new ArrayList<Position>();
    Connection dbConnection = null;
    java.sql.Statement statement = null;
    String selectCourses = "SELECT id_position, name, sallary FROM position";
    try {
        dbConnection = PSQL.getConnection();
        statement = dbConnection.createStatement();
        ResultSet rs = statement.executeQuery(selectCourses);
        while (rs.next()) {
            Position position = new Position();
            int id = rs.getInt("id_position");
            String name = rs.getString("name");
            int sallary = rs.getInt("sallary");
            position.setId(id);
            position.setName(name);
            position.setSallary(sallary);
            results.add(position);
        }
    } catch (SQLException e) {
        System.out.println(e.getMessage());
    } finally {
        if (statement != null) {
            statement.close();
        }
        if (dbConnection != null) {
            dbConnection.close();
        }
    }
    return results;
}

######


@Override
protected String getDuplicateKeyErrorCode() {
    return POSTGRES_DUPLICATE_KEY_ERROR_CODE;
}

######


@Override
protected List<String> getCreateTablesSQL() {
    List<String> sqlStatements = new ArrayList<String>();
    sqlStatements.add(CREATE_SETTINGS_TABLE);
    sqlStatements.add(CREATE_HEADERS_TABLE);
    sqlStatements.add(CREATE_UNDOABLE_TABLE);
    sqlStatements.add(CREATE_OPEN_OUTPUT_TABLE);
    return sqlStatements;
}

######


@Override
protected List<String> getCreateIndexesSQL() {
    List<String> sqlStatements = new ArrayList<String>();
    sqlStatements.add(CREATE_UNDOABLE_TABLE_INDEX);
    sqlStatements.add(CREATE_OUTPUTS_ADDRESS_MULTI_INDEX);
    sqlStatements.add(CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX);
    sqlStatements.add(CREATE_OUTPUTS_HASH_INDEX);
    sqlStatements.add(CREATE_OUTPUTS_TOADDRESS_INDEX);
    return sqlStatements;
}

######


@Override
protected List<String> getCreateSchemeSQL() {
    List<String> sqlStatements = new ArrayList<String>();
    sqlStatements.add("CREATE SCHEMA IF NOT EXISTS " + schemaName);
    sqlStatements.add("set search_path to '" + schemaName + "'");
    return sqlStatements;
}

######


@Override
protected String getDatabaseDriverClass() {
    return DATABASE_DRIVER_CLASS;
}

######


@Override
public void put(StoredBlock storedBlock, StoredUndoableBlock undoableBlock) throws BlockStoreException {
    maybeConnect();
    byte[] hashBytes = new byte[28];
    System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28);
    int height = storedBlock.getHeight();
    byte[] transactions = null;
    byte[] txOutChanges = null;
    try {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        if (undoableBlock.getTxOutChanges() != null) {
            undoableBlock.getTxOutChanges().serializeToStream(bos);
            txOutChanges = bos.toByteArray();
        } else {
            int numTxn = undoableBlock.getTransactions().size();
            bos.write(0xFF & numTxn);
            bos.write(0xFF & (numTxn >> 8));
            bos.write(0xFF & (numTxn >> 16));
            bos.write(0xFF & (numTxn >> 24));
            for (Transaction tx : undoableBlock.getTransactions()) tx.bitcoinSerialize(bos);
            transactions = bos.toByteArray();
        }
        bos.close();
    } catch (IOException e) {
        throw new BlockStoreException(e);
    }
    try {
        if (log.isDebugEnabled())
            log.debug("Looking for undoable block with hash: " + Utils.HEX.encode(hashBytes));
        PreparedStatement findS = conn.get().prepareStatement(SELECT_UNDOABLEBLOCKS_EXISTS_SQL);
        findS.setBytes(1, hashBytes);
        ResultSet rs = findS.executeQuery();
        if (rs.next()) {
            findS.close();
            PreparedStatement s = conn.get().prepareStatement(getUpdateUndoableBlocksSQL());
            s.setBytes(3, hashBytes);
            if (log.isDebugEnabled())
                log.debug("Updating undoable block with hash: " + Utils.HEX.encode(hashBytes));
            if (transactions == null) {
                s.setBytes(1, txOutChanges);
                s.setNull(2, Types.BINARY);
            } else {
                s.setNull(1, Types.BINARY);
                s.setBytes(2, transactions);
            }
            s.executeUpdate();
            s.close();
            return;
        }
        PreparedStatement s = conn.get().prepareStatement(getInsertUndoableBlocksSQL());
        s.setBytes(1, hashBytes);
        s.setInt(2, height);
        if (log.isDebugEnabled())
            log.debug("Inserting undoable block with hash: " + Utils.HEX.encode(hashBytes) + " at height " + height);
        if (transactions == null) {
            s.setBytes(3, txOutChanges);
            s.setNull(4, Types.BINARY);
        } else {
            s.setNull(3, Types.BINARY);
            s.setBytes(4, transactions);
        }
        s.executeUpdate();
        s.close();
        try {
            putUpdateStoredBlock(storedBlock, true);
        } catch (SQLException e) {
            throw new BlockStoreException(e);
        }
    } catch (SQLException e) {
        if (!e.getSQLState().equals(POSTGRES_DUPLICATE_KEY_ERROR_CODE))
            throw new BlockStoreException(e);
    }
}

######


@Select("select * from post where author_id = #{id} order by id")
@Results(value = { @Result(property = "id", column = "id"), @Result(property = "subject", column = "subject"), @Result(property = "body", column = "body"), @Result(property = "tags", javaType = List.class, column = "id", many = @Many(select = "getTagsForPost")) })
List<AnnoPost> getPosts(int authorId);

######


@Select("select t.id, t.name from tag t inner join post_tag pt on pt.tag_id = t.id where pt.post_id = #{postId} order by id")
@ConstructorArgs(value = { @Arg(column = "id", javaType = int.class), @Arg(column = "name", javaType = String.class) })
List<AnnoPostTag> getTagsForPost(int postId);

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("table1", "id1 int auto_increment primary key");
    createTable("table2", "id2 int auto_increment primary key");
    createTable("`testBigintTable`", "`id` bigint(20) unsigned NOT NULL, PRIMARY KEY (`id`)", "ENGINE=InnoDB DEFAULT CHARSET=utf8");
    createTable("`backTicksPreparedStatements`", "`id` int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY," + "`SLIndex#orBV#` text," + "`isM&M'sTasty?` bit(1) DEFAULT NULL," + "`Seems:LikeParam?` bit(1) DEFAULT NULL," + "`Webinar10-TM/ProjComp` text", "ENGINE=InnoDB DEFAULT CHARSET=utf8");
    createTable("test_insert_select", "`field1` varchar(20)");
    createTable("test_decimal_insert", "`field1` decimal(10, 7)");
    createTable("PreparedStatementTest1", "id int not null primary key auto_increment, test longblob");
    createTable("PreparedStatementTest2", "my_col varchar(20)");
    createTable("PreparedStatementTest3", "my_col varchar(20)");
}

######


@Test
public void testClosingError() throws Exception {
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT ?");
    preparedStatement.close();
    preparedStatement.close();
}

######


@Test
public void cannotPrepareExecuteFallback() throws Exception {
    sharedConnection.createStatement().execute("TRUNCATE test_insert_select");
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into test_insert_select ( field1) (select  TMP.field1 from (select ? `field1` from dual) TMP)", Statement.RETURN_GENERATED_KEYS);
    stmt.setString(1, "test");
    stmt.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select count(*) from test_insert_select");
    assertTrue(rs.next());
}

######


@Test
public void cannotPrepareBatchFallback() throws Exception {
    sharedConnection.createStatement().execute("TRUNCATE test_insert_select");
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into test_insert_select ( field1) (select  TMP.field1 from (select ? `field1` from dual) TMP)", Statement.RETURN_GENERATED_KEYS);
    stmt.setString(1, "test");
    stmt.addBatch();
    stmt.executeBatch();
    ResultSet rs = sharedConnection.createStatement().executeQuery("select count(*) from test_insert_select");
    assertTrue(rs.next());
}

######


@Test
public void cannotPrepareMetadata() throws Exception {
    Assume.assumeTrue(isMariadbServer() && !minVersion(10, 2));
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into test_insert_select ( field1) (select  TMP.field1 from (select ? `field1` from dual) TMP)");
    try {
        stmt.getMetaData();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("If column exists but type cannot be identified (example 'select ? `field1` from dual'). " + "Use CAST function to solve this problem (example 'select CAST(? as integer) `field1` from dual')"));
    }
}

######


@Test
public void reexecuteStatementTest() throws SQLException {
    try (Connection connection = setConnection("&allowMultiQueries=true")) {
        try (PreparedStatement stmt = connection.prepareStatement("SELECT 1")) {
            stmt.setFetchSize(Integer.MIN_VALUE);
            ResultSet rs = stmt.executeQuery();
            assertTrue(rs.next());
            try (ResultSet rs2 = stmt.executeQuery()) {
                assertTrue(rs2.next());
            }
        }
    }
}

######


@Test
public void testNoSuchTableBatchUpdate() throws SQLException {
    sharedConnection.createStatement().execute("drop table if exists vendor_code_test");
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO vendor_code_test VALUES(?)");
    preparedStatement.setString(1, "dummyValue");
    preparedStatement.addBatch();
    try {
        preparedStatement.executeBatch();
        fail("The above statement should result in an exception");
    } catch (SQLException sqlException) {
        assertEquals(ER_NO_SUCH_TABLE, sqlException.getErrorCode());
        assertEquals(ER_NO_SUCH_TABLE_STATE, sqlException.getSQLState());
    }
}

######


@Test
public void testBigInt() throws SQLException {
    Statement st = sharedConnection.createStatement();
    st.execute("INSERT INTO `testBigintTable` (`id`) VALUES (0)");
    PreparedStatement stmt = sharedConnection.prepareStatement("UPDATE `testBigintTable` SET `id` = ?");
    BigInteger bigT = BigInteger.valueOf(System.currentTimeMillis());
    stmt.setObject(1, bigT);
    stmt.executeUpdate();
    stmt = sharedConnection.prepareStatement("SELECT `id` FROM `testBigintTable` WHERE `id` = ?");
    stmt.setObject(1, bigT);
    ResultSet rs = stmt.executeQuery();
    assertTrue(rs.next());
    assertEquals(0, rs.getBigDecimal(1).toBigInteger().compareTo(bigT));
}

######


@Test
public void testDoubleToDecimal() throws SQLException {
    PreparedStatement stmt = sharedConnection.prepareStatement("INSERT INTO test_decimal_insert (field1) VALUES (?)");
    Double value = 0.3456789;
    stmt.setObject(1, value, Types.DECIMAL, 7);
    stmt.executeUpdate();
    stmt = sharedConnection.prepareStatement("SELECT `field1` FROM test_decimal_insert");
    ResultSet rs = stmt.executeQuery();
    assertTrue(rs.next());
    assertEquals(value, rs.getDouble(1), 0.00000001);
}

######


@Test
public void testPreparedStatementsWithQuotes() throws SQLException {
    String query = "INSERT INTO backTicksPreparedStatements (`SLIndex#orBV#`,`Seems:LikeParam?`," + "`Webinar10-TM/ProjComp`,`isM&M'sTasty?`)" + " VALUES (?,?,?,?)";
    PreparedStatement ps = sharedConnection.prepareStatement(query);
    ps.setString(1, "slIndex");
    ps.setBoolean(2, false);
    ps.setString(3, "webinar10");
    ps.setBoolean(4, true);
    ps.execute();
    ResultSet rs = sharedConnection.createStatement().executeQuery("SELECT `SLIndex#orBV#`,`Seems:LikeParam?`," + "`Webinar10-TM/ProjComp`,`isM&M'sTasty?` FROM backTicksPreparedStatements");
    assertTrue(rs.next());
    assertEquals("slIndex", rs.getString(1));
    assertEquals(false, rs.getBoolean(2));
    assertEquals("webinar10", rs.getString(3));
    assertEquals(true, rs.getBoolean(4));
}

######


@Test
public void testExecuteBatch() throws SQLException {
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO table1 VALUE ?");
    try {
        int[] result = preparedStatement.executeBatch();
        assertEquals(0, result.length);
    } catch (SQLException sqle) {
        fail("Must not throw error");
    }
}

######


@Test
public void testFallbackPrepare() throws SQLException {
    createTable("testFallbackPrepare", "`test` varchar(500) COLLATE utf8mb4_unicode_ci NOT NULL", "ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci");
    try (Connection connection = setConnection()) {
        Statement stmt = connection.createStatement();
        stmt.execute("SET @@character_set_connection = 'utf8mb4'");
        stmt.execute("SELECT * FROM `testFallbackPrepare` WHERE `test` LIKE 'jj' COLLATE utf8mb4_unicode_ci");
        try (PreparedStatement preparedStatement = connection.prepareStatement("SELECT * FROM `testFallbackPrepare` WHERE `test` LIKE ? COLLATE utf8mb4_unicode_ci")) {
            preparedStatement.setString(1, "jj");
            preparedStatement.execute();
        } catch (SQLException sqle) {
            fail("Must not have issue, because must fallback on client prepare");
        }
    }
}

######


@Test
public void testCallExecuteErrorBatch() throws SQLException {
    PreparedStatement pstmt = sharedConnection.prepareStatement("SELECT 1;INSERT INTO INCORRECT_QUERY");
    try {
        pstmt.execute();
        fail("Must have thrown error");
    } catch (SQLSyntaxErrorException sqlSyntax) {
    } catch (SQLException sqle) {
        fail("must have thrown an SQLSyntaxErrorException");
    }
}

######


@Test
public void testRewriteValuesMaxSizeOneParam() throws SQLException {
    testRewriteMultiPacket(false);
}

######


@Test
public void testRewriteMultiMaxSizeOneParam() throws SQLException {
    testRewriteMultiPacket(true);
}

######


private void testRewriteMultiPacket(boolean notRewritable) throws SQLException {
    Assume.assumeFalse(sharedIsAurora());
    Statement statement = sharedConnection.createStatement();
    statement.execute("TRUNCATE PreparedStatementTest1");
    ResultSet rs = statement.executeQuery("select @@max_allowed_packet");
    assertTrue(rs.next());
    int maxAllowedPacket = rs.getInt(1);
    if (maxAllowedPacket < 21_000_000) {
        String query = "INSERT INTO PreparedStatementTest1 VALUES (null, ?)" + (notRewritable ? " ON DUPLICATE KEY UPDATE id=?" : "");
        char[] arr = new char[maxAllowedPacket - (query.length() + (sharedUseCompression() ? 8 : 4))];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (char) ('a' + (i % 10));
        }
        try (Connection connection = setConnection("&rewriteBatchedStatements=true")) {
            PreparedStatement pstmt = connection.prepareStatement(query);
            for (int i = 0; i < 2; i++) {
                pstmt.setString(1, new String(arr));
                if (notRewritable) {
                    pstmt.setInt(2, 1);
                }
                pstmt.addBatch();
            }
            int[] results = pstmt.executeBatch();
            assertEquals(2, results.length);
            for (int result : results) {
                if (!notRewritable || (isMariadbServer() && minVersion(10, 2) && sharedOptions().useBulkStmts)) {
                    assertEquals(Statement.SUCCESS_NO_INFO, result);
                } else {
                    assertEquals(1, result);
                }
            }
        }
        rs = statement.executeQuery("select * from PreparedStatementTest1");
        int counter = 0;
        while (rs.next()) {
            counter++;
            byte[] newBytes = rs.getBytes(2);
            assertEquals(arr.length, newBytes.length);
            for (int i = 0; i < arr.length; i++) {
                assertEquals(arr[i], newBytes[i]);
            }
        }
        assertEquals(2, counter);
    }
}

######


@Test
public void testRewriteValuesMaxSize2Param() throws SQLException {
    Assume.assumeTrue(!sharedIsRewrite());
    testRewriteMultiPacket2param(false);
}

######


@Test
public void testRewriteMultiMaxSize2Param() throws SQLException {
    testRewriteMultiPacket2param(true);
}

######


private void testRewriteMultiPacket2param(boolean rewritableMulti) throws SQLException {
    Assume.assumeFalse(sharedIsAurora());
    Statement statement = sharedConnection.createStatement();
    statement.execute("TRUNCATE PreparedStatementTest1");
    ResultSet rs = statement.executeQuery("select @@max_allowed_packet");
    assertTrue(rs.next());
    int maxAllowedPacket = rs.getInt(1);
    if (maxAllowedPacket < 21000000) {
        String query = "INSERT INTO PreparedStatementTest1 VALUES (null, ?)" + (rewritableMulti ? "" : " ON DUPLICATE KEY UPDATE id=?");
        char[] arr = new char[(maxAllowedPacket - (query.length() + 18)) / 2];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (char) ('a' + (i % 10));
        }
        try (Connection connection = setConnection("&rewriteBatchedStatements=true&profileSql=true")) {
            PreparedStatement pstmt = connection.prepareStatement(query);
            for (int i = 0; i < 4; i++) {
                pstmt.setString(1, new String(arr));
                if (!rewritableMulti) {
                    pstmt.setInt(2, 1);
                }
                pstmt.addBatch();
            }
            int[] results = pstmt.executeBatch();
            assertEquals(4, results.length);
            if (rewritableMulti || sharedIsRewrite() || (sharedOptions().useBulkStmts && isMariadbServer() && minVersion(10, 2))) {
                for (int result : results) {
                    assertEquals(Statement.SUCCESS_NO_INFO, result);
                }
            } else {
                for (int result : results) {
                    assertEquals(1, result);
                }
            }
        }
        rs = statement.executeQuery("select * from PreparedStatementTest1");
        int counter = 0;
        while (rs.next()) {
            counter++;
            byte[] newBytes = rs.getBytes(2);
            assertEquals(arr.length, newBytes.length);
            for (int i = 0; i < arr.length; i++) {
                assertEquals(arr[i], newBytes[i]);
            }
        }
        assertEquals(4, counter);
    }
}

######


@Test
public void clientPrepareStatementWithoutParameter() throws Throwable {
    try (Connection connection = setConnection("&rewriteBatchedStatements=true")) {
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO PreparedStatementTest2 (my_col) VALUES ('my_val')");
        preparedStatement.execute();
        PreparedStatement preparedStatementMulti = connection.prepareStatement("INSERT INTO PreparedStatementTest2 (my_col) VALUES ('my_val1'),('my_val2')");
        preparedStatementMulti.execute();
    }
}

######


@Test
public void clientPrepareStatementValuesWithoutParameter() throws Throwable {
    createTable("clientPrepareStatementValuesWithoutParameter", "created_at datetime primary key");
    String query = "ALTER table clientPrepareStatementValuesWithoutParameter PARTITION BY RANGE COLUMNS( created_at ) " + "(PARTITION test_p201605 VALUES LESS THAN ('2016-06-01'))";
    try (Connection connection = setConnection("&rewriteBatchedStatements=true")) {
        try (PreparedStatement preparedStatement = connection.prepareStatement(query)) {
            preparedStatement.execute();
        }
    }
}

######


@Test
public void emptyStringParameter() throws Throwable {
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO PreparedStatementTest3 (my_col) VALUES (?)")) {
        preparedStatement.setString(1, "");
        preparedStatement.execute();
    }
}

######


@Test
public void nullStringParameter() throws Throwable {
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO PreparedStatementTest3 (my_col) VALUES (?)")) {
        preparedStatement.setString(1, null);
        preparedStatement.execute();
    }
}

######


@Test
public void testInsertSelectBulk() throws SQLException {
    cancelForVersion(10, 3, 0);
    cancelForVersion(10, 3, 1);
    cancelForVersion(10, 3, 2);
    cancelForVersion(10, 3, 3);
    cancelForVersion(10, 3, 4);
    try (Statement statement = sharedConnection.createStatement()) {
        statement.execute("DROP TABLE IF EXISTS myTable");
        statement.execute("CREATE TABLE myTable(v1 varchar(10), v2 varchar(10), v3 varchar(10), v4 varchar(10))");
        String[][] val = { { null, "b1", "c1", "d1" }, { "a2", null, "c2", "d2" }, { "a3", "b3", null, "d3" }, { "a4", "b4", "c4", null }, { "a5", "b5", "c5", "d5" } };
        try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO myTable VALUES (?, ?, ?, ?)")) {
            for (int i = 0; i < val.length; i++) {
                for (int j = 0; j < 4; j++) {
                    preparedStatement.setString(j + 1, val[i][j]);
                }
                preparedStatement.addBatch();
            }
            preparedStatement.executeBatch();
        }
        ResultSet rs = statement.executeQuery("SELECT * from myTable");
        for (int i = 0; i < val.length; i++) {
            assertTrue(rs.next());
            for (int j = 0; j < 4; j++) {
                if (val[i][j] == null) {
                    assertNull(rs.getString(j + 1));
                } else {
                    assertEquals(val[i][j], rs.getString(j + 1));
                }
            }
        }
    }
}

######


@Test
public void largePrepareUpdate() throws SQLException {
    createTable("largePrepareUpdate", "a int not null primary key auto_increment, t varchar(256)", "engine=innodb");
    try (PreparedStatement stmt = sharedConnection.prepareStatement("insert into largePrepareUpdate(t) values(?)", Statement.RETURN_GENERATED_KEYS)) {
        stmt.setString(1, "a");
        long updateRes = stmt.executeLargeUpdate();
        assertEquals(1L, updateRes);
        assertEquals(1L, stmt.getUpdateCount());
        assertEquals(1L, stmt.getLargeUpdateCount());
        stmt.setString(1, "b");
        stmt.addBatch();
        stmt.setString(1, "c");
        stmt.addBatch();
        long[] batchRes = stmt.executeLargeBatch();
        assertArrayEquals(new long[] { 1, 1 }, batchRes);
        ResultSet rs = stmt.getGeneratedKeys();
        assertTrue(rs.next());
        assertEquals(2, rs.getInt(1));
        assertEquals(0L, stmt.getLargeMaxRows());
        stmt.setLargeMaxRows(10_000L);
        assertEquals(10_000L, stmt.getLargeMaxRows());
    }
}

######


@Override
public void validateBuild() throws IndexerException {
    Long numFound = getDocumentCount(preqcCore);
    if (numFound <= MINIMUM_DOCUMENT_COUNT)
        throw new IndexerException(new ValidationException("Actual preqc document count is " + numFound + "."));
    if (numFound != documentCount)
        logger.warn("WARNING: Added " + documentCount + " preqc documents but SOLR reports " + numFound + " documents.");
    else
        logger.info("validateBuild(): Indexed " + documentCount + " preqc documents.");
}

######


@Override
public void run() throws IndexerException {
    long start = System.currentTimeMillis();
    logger.info(" start time: " + (System.currentTimeMillis() - start));
    zygosityMapping.put("Heterozygous", "heterozygote");
    zygosityMapping.put("Homozygous", "homozygote");
    zygosityMapping.put("Hemizygous", "hemizygote");
    Set<String> bad = new HashSet<>();
    try {
        conn_komp2 = komp2DataSource.getConnection();
        conn_ontodb = ontodbDataSource.getConnection();
        preqcXmlFilename = config.get("preqcXmlFilename");
        doGeneSymbol2IdMapping();
        doAlleleSymbol2NameIdMapping();
        doStrainId2NameMapping();
        doImpressSid2NameMapping();
        doOntologyMapping();
        populatePostQcData();
        populateResourceMap();
        preqcCore.deleteByQuery("*:*");
        Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new FileInputStream(preqcXmlFilename));
        Element rootElement = document.getDocumentElement();
        NodeList nodes = rootElement.getElementsByTagName("uk.ac.ebi.phenotype.pojo.PhenotypeCallSummary");
        logger.info("length: " + nodes.getLength());
        logger.info("  read document time: " + (System.currentTimeMillis() - start));
        int counter = 1;
        for (int i = 0; i < nodes.getLength(); ++i) {
            Element e = (Element) nodes.item(i);
            NodeList childNodes = e.getChildNodes();
            Integer id = null;
            String colonyId = null;
            Double pValue = null;
            String sex = null;
            String phenotypeTerm = null;
            String externalId = null;
            String zygosity = null;
            String datasource = null;
            String project = null;
            String gene = null;
            Double effectSize = null;
            String strain = null;
            String allele = null;
            String pipeline = null;
            String procedure = null;
            String parameter = null;
            String phenotypingCenter = null;
            for (int j = 0; j < childNodes.getLength(); ++j) {
                Node cnode = childNodes.item(j);
                if (cnode.getNodeType() == Node.ELEMENT_NODE) {
                    switch(cnode.getNodeName()) {
                        case "id":
                            id = Integer.parseInt(cnode.getTextContent());
                            break;
                        case "colonyId":
                            colonyId = cnode.getTextContent();
                            break;
                        case "pValue":
                            pValue = Double.parseDouble(cnode.getTextContent());
                            break;
                        case "sex":
                            sex = cnode.getTextContent();
                            break;
                        case "phenotypeTerm":
                            phenotypeTerm = cnode.getTextContent();
                            break;
                        case "externalId":
                            externalId = cnode.getTextContent();
                            break;
                        case "zygosity":
                            zygosity = cnode.getTextContent();
                            break;
                        case "datasource":
                            datasource = cnode.getTextContent();
                            break;
                        case "project":
                            project = cnode.getTextContent();
                            break;
                        case "gene":
                            gene = cnode.getTextContent();
                            break;
                        case "effectSize":
                            effectSize = Double.parseDouble(cnode.getTextContent());
                            break;
                        case "strain":
                            strain = cnode.getTextContent();
                            break;
                        case "allele":
                            allele = cnode.getTextContent().replace("<sup>", "<").replace("</sup>", ">");
                            break;
                        case "pipeline":
                            pipeline = cnode.getTextContent();
                            break;
                        case "procedure":
                            procedure = cnode.getTextContent();
                            break;
                        case "parameter":
                            parameter = cnode.getTextContent();
                            break;
                        case "phenotypingCenter":
                            phenotypingCenter = cnode.getTextContent().toUpperCase();
                            break;
                    }
                }
            }
            if (phenotypeTerm == null) {
                logger.warn("Phenotype term is missing for record with id {}", id);
                continue;
            }
            if ((pValue != null && pValue >= 0.0001) || phenotypeTerm.startsWith("MA:")) {
                continue;
            }
            if (mpId2TermMapping.get(phenotypeTerm) == null) {
                bad.add(phenotypeTerm);
                continue;
            }
            phenotypingCenter = dccMapping.dccCenterMap.containsKey(phenotypingCenter) ? dccMapping.dccCenterMap.get(phenotypingCenter) : phenotypingCenter;
            if (postQcData.contains(StringUtils.join(Arrays.asList(new String[] { colonyId, parameter, phenotypingCenter.toUpperCase() }), "_"))) {
                continue;
            }
            GenotypePhenotypeDTO o = new GenotypePhenotypeDTO();
            String procedurePrefix = StringUtils.join(Arrays.asList(parameter.split("_")).subList(0, 2), "_");
            if (GenotypePhenotypeIndexer.source3iProcedurePrefixes.contains(procedurePrefix)) {
                o.setResourceName(StatisticalResultIndexer.RESOURCE_3I.toUpperCase());
                o.setResourceFullname(resourceMap.get(StatisticalResultIndexer.RESOURCE_3I.toUpperCase()));
            } else {
                o.setResourceName(datasource);
                if (resourceMap.containsKey(project.toUpperCase())) {
                    o.setResourceFullname(resourceMap.get(project.toUpperCase()));
                }
            }
            o.setProjectName(project);
            if (projectMap.containsKey(project.toUpperCase())) {
                o.setProjectFullname(projectMap.get(project.toUpperCase()));
            }
            o.setColonyId(colonyId);
            o.setExternalId(externalId);
            o.setStrainAccessionId(strain);
            o.setStrainName(strainId2NameMapping.get(strain));
            o.setMarkerSymbol(gene);
            o.setMarkerAccessionId(geneSymbol2IdMapping.get(gene));
            o.setPipelineName(pipelineSid2NameMapping.get(pipeline));
            o.setPipelineStableId(pipeline);
            o.setProcedureName(procedureSid2NameMapping.get(procedure));
            o.setProcedureStableId(procedure);
            o.setParameterName(parameterSid2NameMapping.get(parameter));
            o.setParameterStableId(parameter);
            o.setMpTermId(phenotypeTerm);
            o.setMpTermName(mpId2TermMapping.get(phenotypeTerm));
            o.setP_value(pValue);
            o.setEffect_size(effectSize);
            if (!zygosityMapping.containsKey(zygosity)) {
                logger.warn("Zygosity {} not found for record id {}", zygosity, id);
                continue;
            }
            o.setZygosity(zygosityMapping.get(zygosity));
            if (alleleSymbol2NameIdMapping.get(allele) == null) {
                o.setAlleleAccessionId(createFakeIdFromSymbol(allele));
                o.setAlleleName(allele);
            } else {
                o.setAlleleAccessionId(alleleSymbol2NameIdMapping.get(allele).acc);
                o.setAlleleName(alleleSymbol2NameIdMapping.get(allele).name);
            }
            o.setAlleleSymbol(allele);
            if (dccMapping.dccCenterMap.containsKey(phenotypingCenter)) {
                o.setPhenotypingCenter(dccMapping.dccCenterMap.get(phenotypingCenter));
            } else {
                o.setPhenotypingCenter(phenotypingCenter);
            }
            List<String> ids = new ArrayList<>();
            List<String> names = new ArrayList<>();
            for (MpTermDTO mp : getIntermediateMpTerms(phenotypeTerm)) {
                ids.add(mp.id);
                names.add(mp.name);
            }
            o.setIntermediateMpTermId(ids);
            o.setIntermediateMpTermName(names);
            ids = new ArrayList<>();
            names = new ArrayList<>();
            for (MpTermDTO mp : getTopMpTerms(phenotypeTerm)) {
                ids.add(mp.id);
                names.add(mp.name);
            }
            o.setTopLevelMpTermId(ids);
            o.setTopLevelMpTermName(names);
            if (sex.equals("Both")) {
                o.setId(counter++);
                o.setSex(SexType.female.getName());
                documentCount++;
                preqcCore.addBean(o);
                o.setId(counter++);
                o.setSex(SexType.male.getName());
                documentCount++;
                preqcCore.addBean(o);
            } else {
                o.setId(counter++);
                try {
                    SexType.valueOf(sex.toLowerCase());
                } catch (IllegalArgumentException se) {
                    logger.error("Got unexpected sex value '{}' from PreQC file. Not loading", se);
                    continue;
                }
                o.setSex(sex.toLowerCase());
                documentCount++;
                preqcCore.addBean(o);
            }
            if (counter % 1000 == 0) {
                logger.info("Added {} preqc documents to index", counter);
            }
        }
        preqcCore.commit();
    } catch (ParserConfigurationException | SAXException | SQLException | SolrServerException | IOException e) {
        throw new IndexerException(e);
    }
    logger.info("time: " + (System.currentTimeMillis() - start));
    if (bad.size() > 0) {
        logger.warn("found {} unique mps not in ontodb", bad.size());
        logger.warn("MP terms not found: {} ", StringUtils.join(bad, ","));
    }
}

######


public String createFakeIdFromSymbol(String alleleSymbol) {
    String fakeId = null;
    ResultSet rs = null;
    Statement statement = null;
    String query = "select CONCAT('NULL-', UPPER(SUBSTR(MD5('" + alleleSymbol + "'),1,10))) as fakeId";
    try {
        statement = conn_komp2.createStatement();
        rs = statement.executeQuery(query);
        while (rs.next()) {
            fakeId = rs.getString("fakeId");
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return fakeId;
}

######


public void doGeneSymbol2IdMapping() {
    ResultSet rs = null;
    Statement statement = null;
    String query = "select acc, symbol from genomic_feature";
    try {
        statement = conn_komp2.createStatement();
        rs = statement.executeQuery(query);
        while (rs.next()) {
            String acc = rs.getString("acc");
            String symbol = rs.getString("symbol");
            geneSymbol2IdMapping.put(symbol, acc);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public void populateResourceMap() throws SQLException {
    String projQuery = "SELECT p.name as name, p.fullname as fullname FROM project p";
    String resQuery = "SELECT db.short_name as name, db.name as fullname FROM external_db db ";
    try (PreparedStatement p = conn_komp2.prepareStatement(projQuery, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {
        p.setFetchSize(Integer.MIN_VALUE);
        ResultSet r = p.executeQuery();
        while (r.next()) {
            projectMap.put(r.getString("name").toUpperCase(), r.getString("fullname"));
        }
    }
    try (PreparedStatement p = conn_komp2.prepareStatement(resQuery, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {
        p.setFetchSize(Integer.MIN_VALUE);
        ResultSet r = p.executeQuery();
        while (r.next()) {
            resourceMap.put(r.getString("name").toUpperCase(), r.getString("fullname"));
        }
    }
}

######


public void doImpressSid2NameMapping() {
    Map<String, Map> impressMapping = new HashMap<>();
    impressMapping.put("phenotype_pipeline", pipelineSid2NameMapping);
    impressMapping.put("phenotype_procedure", procedureSid2NameMapping);
    impressMapping.put("phenotype_parameter", parameterSid2NameMapping);
    ResultSet rs = null;
    Statement statement = null;
    for (Map.Entry entry : impressMapping.entrySet()) {
        String tableName = entry.getKey().toString();
        Map<String, String> mapping = (Map) entry.getValue();
        String query = "select name, stable_id from " + tableName;
        try {
            statement = conn_komp2.createStatement();
            rs = statement.executeQuery(query);
            while (rs.next()) {
                String sid = rs.getString("stable_id");
                String name = rs.getString("name");
                if (tableName.equals("phenotype_procedure")) {
                    sid = sid.replaceAll("_\\d+$", "");
                }
                mapping.put(sid, name);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

######


public void doAlleleSymbol2NameIdMapping() {
    ResultSet rs = null;
    Statement statement = null;
    String query = "select acc, symbol, name from allele";
    try {
        statement = conn_komp2.createStatement();
        rs = statement.executeQuery(query);
        while (rs.next()) {
            String acc = rs.getString("acc");
            String symbol = rs.getString("symbol");
            String name = rs.getString("name");
            AlleleDTO al = new AlleleDTO();
            al.acc = acc;
            al.name = name;
            alleleSymbol2NameIdMapping.put(symbol, al);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public void doStrainId2NameMapping() {
    ResultSet rs = null;
    Statement statement = null;
    String query = "select acc, name from strain";
    try {
        statement = conn_komp2.createStatement();
        rs = statement.executeQuery(query);
        while (rs.next()) {
            String acc = rs.getString("acc");
            String name = rs.getString("name");
            strainId2NameMapping.put(acc, name);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public void doOntologyMapping() {
    ResultSet rs1, rs2, rs3, rs4, rs45 = null;
    Statement statement = null;
    String query1 = "select ti.term_id, ti.name, nt.node_id from mp_term_infos ti, mp_node2term nt where ti.term_id=nt.term_id and ti.term_id !='MP:0000001'";
    String query2 = "select lv.node_id as mp_node_id, ti.term_id, ti.name from mp_node_top_level lv" + " inner join mp_node2term nt on lv.top_level_node_id=nt.node_id" + " inner join mp_term_infos ti on nt.term_id=ti.term_id" + " and ti.term_id!='MP:0000001'";
    String query3 = "select ti.term_id, group_concat(nt.node_id) as nodeIds from mp_term_infos ti, mp_node2term nt where ti.term_id=nt.term_id and ti.term_id !='MP:0000001' group by ti.term_id order by ti.term_id";
    String query4 = "select child_node_id, group_concat(node_id) as intermediate_nodeIds from mp_node_subsumption_fullpath group by child_node_id";
    try {
        statement = conn_ontodb.createStatement();
        rs1 = statement.executeQuery(query1);
        statement = conn_ontodb.createStatement();
        rs2 = statement.executeQuery(query2);
        statement = conn_ontodb.createStatement();
        rs3 = statement.executeQuery(query3);
        statement = conn_ontodb.createStatement();
        rs4 = statement.executeQuery(query4);
        while (rs1.next()) {
            String mp_term_id = rs1.getString("term_id");
            String mp_term_name = rs1.getString("name");
            int mp_node_id = rs1.getInt("node_id");
            mpId2TermMapping.put(mp_term_id, mp_term_name);
            mpNodeId2MpIdMapping.put(mp_node_id, mp_term_id);
        }
        while (rs2.next()) {
            int top_level_mp_node_id = rs2.getInt("mp_node_id");
            String top_level_mp_term_id = rs2.getString("term_id");
            String top_level_mp_term_name = rs2.getString("name");
            Node2TopDTO n2t = new Node2TopDTO();
            n2t.topLevelMpTermId = top_level_mp_term_id;
            n2t.topLevelMpTermName = top_level_mp_term_name;
            mpNodeId2TopLevelMapping.put(top_level_mp_node_id, n2t);
        }
        while (rs3.next()) {
            String mp_node_ids = rs3.getString("nodeIds");
            String mp_term_id = rs3.getString("term_id");
            mpId2NodeIdsMapping.put(mp_term_id, mp_node_ids);
        }
        while (rs4.next()) {
            int child_node_id = rs4.getInt("child_node_id");
            String intermediate_nodeIds = rs4.getString("intermediate_nodeIds");
            mpNodeId2IntermediateNodeIdsMapping.put(child_node_id, intermediate_nodeIds);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public List<MpTermDTO> getIntermediateMpTerms(String mpId) {
    if (!intermediateMpTerms.containsKey(mpId)) {
        intermediateMpTerms.put(mpId, new ArrayList<MpTermDTO>());
        if (mpId2NodeIdsMapping.containsKey(mpId)) {
            String[] nodeIdsStr = mpId2NodeIdsMapping.get(mpId).split(",");
            List<MpTermDTO> mps = new ArrayList<>();
            for (int i = 0; i < nodeIdsStr.length; i++) {
                int childNodeId = Integer.parseInt(nodeIdsStr[i]);
                List<MpTermDTO> top = getTopMpTerms(mpId);
                if (mpNodeId2IntermediateNodeIdsMapping.get(childNodeId) != null) {
                    String[] intermediateNodeIdsStr = mpNodeId2IntermediateNodeIdsMapping.get(childNodeId).split(",");
                    for (int j = 0; j < intermediateNodeIdsStr.length; j++) {
                        int intermediateNodeId = Integer.parseInt(intermediateNodeIdsStr[j]);
                        MpTermDTO mp = new MpTermDTO();
                        mp.id = mpNodeId2MpIdMapping.get(intermediateNodeId);
                        mp.name = mpId2TermMapping.get(mp.id);
                        if (childNodeId != intermediateNodeId && !top.contains(mp)) {
                            mps.add(mp);
                        }
                    }
                }
            }
            if (mps.size() != 0) {
                intermediateMpTerms.put(mpId, mps);
            }
        }
    }
    return intermediateMpTerms.get(mpId);
}

######


public List<MpTermDTO> getTopMpTerms(String mpId) {
    if (!topMpTerms.containsKey(mpId)) {
        topMpTerms.put(mpId, new ArrayList<MpTermDTO>());
        if (mpId2NodeIdsMapping.containsKey(mpId)) {
            String[] nodeIdsStr = mpId2NodeIdsMapping.get(mpId).split(",");
            List<MpTermDTO> mps = new ArrayList<>();
            for (int i = 0; i < nodeIdsStr.length; i++) {
                int topLevelMpNodeId = Integer.parseInt(nodeIdsStr[i]);
                if (mpNodeId2TopLevelMapping.containsKey(topLevelMpNodeId)) {
                    MpTermDTO mp = new MpTermDTO();
                    mp.id = mpNodeId2TopLevelMapping.get(topLevelMpNodeId).topLevelMpTermId;
                    mp.name = mpNodeId2TopLevelMapping.get(topLevelMpNodeId).topLevelMpTermName;
                    mps.add(mp);
                }
            }
            topMpTerms.put(mpId, mps);
        }
    }
    return topMpTerms.get(mpId);
}

######


public void populatePostQcData() {
    String query = "SELECT DISTINCT CONCAT(e.colony_id, '_', o.parameter_stable_id, '_', UPPER(org.name)) AS data_value " + "FROM observation o " + "INNER JOIN experiment_observation eo ON eo.observation_id=o.id " + "INNER JOIN experiment e ON e.id=eo.experiment_id " + "INNER JOIN organisation org ON org.id=e.organisation_id " + "WHERE e.colony_id IS NOT NULL " + "UNION " + "SELECT DISTINCT CONCAT(ls.colony_id, '_', o.parameter_stable_id, '_', UPPER(org.name)) AS data_value " + "FROM observation o " + "INNER JOIN live_sample ls ON ls.id=o.biological_sample_id " + "INNER JOIN biological_sample bs ON bs.id=o.biological_sample_id " + "INNER JOIN organisation org ON org.id=bs.organisation_id " + "WHERE bs.sample_group='experimental' ";
    try (PreparedStatement p = conn_komp2.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            postQcData.add(resultSet.getString("data_value"));
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + getOuterType().hashCode();
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    return result;
}

######


@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    MpTermDTO other = (MpTermDTO) obj;
    if (!getOuterType().equals(other.getOuterType())) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (name == null) {
        if (other.name != null) {
            return false;
        }
    } else if (!name.equals(other.name)) {
        return false;
    }
    return true;
}

######


private PreqcIndexer getOuterType() {
    return PreqcIndexer.this;
}

######


@Override
public void initialise(String[] args) throws IndexerException {
    super.initialise(args);
}

######


public static void main(String[] args) throws IndexerException {
    PreqcIndexer main = new PreqcIndexer();
    main.initialise(args);
    main.run();
    main.validateBuild();
    logger.info("Process finished.  Exiting.");
}

######


@Override
protected Logger getLogger() {
    return logger;
}

######


public List<Prestito> doRetriveByNumTess(Object... id) {
    int numTess = (int) id[0];
    List<Prestito> prestiti = new ArrayList<>();
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveByNumTessInfoQuery);
        prst.setInt(1, numTess);
        Date dataO = Calendar.getInstance(TimeZone.getTimeZone("Europe/Rome"), Locale.ITALY).getTime();
        long time = dataO.getTime();
        try {
            ResultSet rs = prst.executeQuery();
            while (rs.next()) {
                Calendar dataPrestito = new GregorianCalendar();
                dataPrestito.setTimeInMillis(rs.getDate("DataPrestito").getTime());
                Calendar dataRestituzione = new GregorianCalendar();
                dataRestituzione.setTimeInMillis(rs.getDate("DataRestituzione").getTime());
                long dataR = rs.getDate("DataRestituzione").getTime();
                Volume volume = new Volume(rs.getString("Codice"), rs.getString("Titolo"), rs.getInt("Edizione"), rs.getString("DataPubblicazione"), rs.getInt("DurataMaxPrestito"), rs.getString("Lingua"), rs.getString("DenominazioneEditore"), rs.getString("CittaEditore"));
                Prestito prestito = new Prestito(rs.getInt("NumTessUtente"), rs.getString("NumRegCopia"), rs.getString("NumScafCopia"), rs.getInt("PosCopia"), dataPrestito, dataRestituzione, volume);
                prestito.setStatus(prestito.getStatus(time, dataR));
                prestiti.add(prestito);
            }
            rs.close();
        } catch (SQLException e) {
            con.rollback();
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
    }
    return prestiti;
}

######


@Override
public Prestito doRetriveById(Object... id) {
    throw new UnsupportedOperationException("Not supported yet.");
}

######


@Override
public List<Prestito> doRetriveAll() {
    List<Prestito> prestiti = new ArrayList<>();
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveAll);
        Date dataO = Calendar.getInstance(TimeZone.getTimeZone("Europe/Rome"), Locale.ITALY).getTime();
        long time = dataO.getTime();
        try {
            ResultSet rs = prst.executeQuery();
            while (rs.next()) {
                Calendar dataPrestito = new GregorianCalendar();
                dataPrestito.setTimeInMillis(rs.getDate("DataPrestito").getTime());
                Calendar dataRestituzione = new GregorianCalendar();
                dataRestituzione.setTimeInMillis(rs.getDate("DataRestituzione").getTime());
                long dataR = rs.getDate("DataRestituzione").getTime();
                Volume volume = new Volume(rs.getString("Codice"), rs.getString("Titolo"), rs.getInt("Edizione"), rs.getString("DataPubblicazione"), rs.getInt("DurataMaxPrestito"), rs.getString("Lingua"), rs.getString("DenominazioneEditore"), rs.getString("CittaEditore"));
                Prestito prestito = new Prestito(rs.getInt("NumTessUtente"), rs.getString("NumRegCopia"), rs.getString("NumScafCopia"), rs.getInt("PosCopia"), dataPrestito, dataRestituzione, volume);
                prestito.setStatus(prestito.getStatus(time, dataR));
                prestito.setUtente(new UtenteDAO().doRetriveById(rs.getInt("NumTessUtente")));
                prestiti.add(prestito);
            }
            rs.close();
        } catch (SQLException e) {
            con.rollback();
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
    }
    return prestiti;
}

######


@Override
public int doUpdate(Prestito entity) {
    throw new UnsupportedOperationException("Not supported yet.");
}

######


public int doDelete(String numRegCopia) {
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        try {
            PreparedStatement prst = con.prepareStatement(doDeleteQUery);
            prst.setString(1, numRegCopia);
            prst.execute();
            con.commit();
            prst.close();
            return 1;
        } catch (SQLException e) {
            con.rollback();
            return -1;
        } finally {
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException e) {
        return -1;
    }
}

######


@Override
public int doInsert(Prestito p) {
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        try {
            PreparedStatement prst = con.prepareStatement(doInsertQuery);
            prst.setString(1, p.getNumRegCopia());
            prst.setString(2, p.getNumScafCopia());
            prst.setInt(3, p.getPosCopia());
            prst.setInt(4, p.getNumTessUtente());
            prst.execute();
            con.commit();
            prst.close();
            return 1;
        } catch (SQLException e) {
            con.rollback();
            return -1;
        } finally {
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException e) {
        return -1;
    }
}

######


@Select("select pi.* from product_info pi,product_category pc where pc.category_type = pi.category_type and pc.category_name = #{cName}")
List<ProductInfo> selectByCategory(@Param("cName") String cName);

######


public void insertar(Producto vo) throws SQLException {
    PreparedStatement sentencia = cnn.prepareStatement("INSERT INTO producto (nombre,cantidadp,tipop,preciop,fecharegistro,descripcion) " + "VALUES(?,?,?,?,?,?)");
    sentencia.setString(1, vo.getNombre());
    sentencia.setInt(2, vo.getCantidadp());
    sentencia.setString(3, vo.getTipop());
    sentencia.setInt(4, vo.getPreciop());
    sentencia.setDate(5, new java.sql.Date(vo.getFecharegistro().getTime()));
    sentencia.setString(6, vo.getDescripcion());
    sentencia.executeUpdate();
}

######


public void modificar(Producto vo) throws SQLException {
    PreparedStatement sentencia = cnn.prepareStatement("UPDATE producto SET nombre= ?,cantidadp= ?,tipop= ?,preciop=?,fecharegistro= ?,descripcion= ? " + "WHERE idproducto = ?");
    sentencia.setString(1, vo.getNombre());
    sentencia.setInt(2, vo.getCantidadp());
    sentencia.setString(3, vo.getTipop());
    sentencia.setInt(4, vo.getPreciop());
    sentencia.setDate(5, new java.sql.Date(vo.getFecharegistro().getTime()));
    sentencia.setString(6, vo.getDescripcion());
    sentencia.setInt(7, vo.getIdproducto());
    sentencia.executeUpdate();
}

######


public List<Producto> consultar() throws SQLException {
    List<Producto> listaProducto = new ArrayList<>();
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM producto");
    ResultSet resultado = sentencia.executeQuery();
    while (resultado.next()) {
        Producto voTemp = new Producto();
        voTemp.setIdproducto(resultado.getInt("idproducto"));
        voTemp.setNombre(resultado.getString("nombre"));
        voTemp.setCantidadp(resultado.getInt("cantidadp"));
        voTemp.setTipop(resultado.getString("tipop"));
        voTemp.setPreciop(resultado.getInt("preciop"));
        voTemp.setFecharegistro(resultado.getDate("fecharegistro"));
        voTemp.setDescripcion(resultado.getString("descripcion"));
        listaProducto.add(voTemp);
    }
    if (listaProducto.size() > 0) {
        return listaProducto;
    } else {
        return null;
    }
}

######


public List<Producto> consultarnombre(String nombre) throws SQLException {
    List<Producto> listaProveedor = new ArrayList<>();
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM producto");
    ResultSet resultado = sentencia.executeQuery();
    while (resultado.next()) {
        Producto voTemp = new Producto();
        voTemp.setIdproducto(resultado.getInt("idproveedor"));
        voTemp.setNombre(resultado.getString("nombre"));
        voTemp.setCantidadp(resultado.getInt("cantidadp"));
        voTemp.setTipop(resultado.getString("tipop"));
        voTemp.setPreciop(resultado.getInt("preciop"));
        voTemp.setFecharegistro(resultado.getDate("fecharegistro"));
        voTemp.setDescripcion(resultado.getString("descripcion"));
        listaProveedor.add(voTemp);
    }
    if (listaProveedor.size() > 0) {
        return listaProveedor;
    } else {
        return null;
    }
}

######


public Producto queryNombre(String nombre) throws SQLException, ParseException {
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM producto WHERE nombre=?");
    sentencia.setString(1, nombre);
    ResultSet resultado = sentencia.executeQuery();
    if (resultado.next()) {
        return getVo(resultado);
    }
    return null;
}

######


public Producto consultaridProducto(int idproducto) throws SQLException, ParseException {
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM producto WHERE idproducto=?");
    sentencia.setInt(1, idproducto);
    ResultSet resultado = sentencia.executeQuery();
    if (resultado.next()) {
        return getVo(resultado);
    }
    return null;
}

######


public Producto getVo(ResultSet resultado) throws SQLException, ParseException {
    Producto vot = new Producto();
    vot.setIdproducto(resultado.getInt("idproveedor"));
    vot.setNombre(resultado.getString("nombre"));
    vot.setCantidadp(resultado.getInt("cantidadp"));
    vot.setTipop(resultado.getString("tipop"));
    vot.setPreciop(resultado.getInt("preciop"));
    vot.setDescripcion(resultado.getString("descripcion"));
    SimpleDateFormat formato = new SimpleDateFormat("yyyy-MM-dd");
    vot.setFecharegistro(formato.parse(resultado.getString("fecharegistro")));
    return vot;
}

######


@SqlUpdate("create table produits (idt integer primary key autoincrement, libelle varchar(100), photo varchar(255), prix varchar(100), description varchar(240), idVendeur integer, promo integer, offreGroupe boolean, categorie varchar(100))")
void createProductTable();

######


@SqlUpdate("insert into produits (libelle, photo, prix, description, idVendeur, promo, offreGroupe, categorie) values (:libelle, :photo, :prix, :description, :idVendeur, :promo, :offreGroupe, :categorie)")
@GetGeneratedKeys
int insert(@BindBean Produit p);

######


@SqlUpdate("update produits set libelle = :libelle, photo = :photo, prix = :prix, description = :description, idVendeur = :idVendeur, promo = :promo, offreGroupe = :offreGroupe, categorie = :categorie")
void update(@BindBean Produit p);

######


@SqlQuery("select count(*) from produits")
public int count();

######


@SqlQuery("select * from produits where idt = :idt")
@RegisterMapperFactory(BeanMapperFactory.class)
Produit findByIdt(@Bind("idt") int idt);

######


@SqlQuery("select * from produits where idVendeur = :idVendeur")
@RegisterMapperFactory(BeanMapperFactory.class)
List<Produit> listerProduitsParIdClient(@Bind("idVendeur") int idVendeur);

######


@SqlUpdate("delete from produits where idt = :idt")
int deleteProd(@Bind("idt") int idt);

######


@SqlUpdate("drop table if exists produits")
void dropProductTable();

######


void close();

######


public void insert(Produto prod) throws SQLException {
    Connection conexao = DriverManager.getConnection("jdbc:mysql://localhost/builder", "root", "root");
    Statement comando = conexao.createStatement();
    String sql = "INSERT INTO produtos (descricao, peso) VALUES ('" + prod.getDescricao() + "', " + prod.getPeso() + ")";
    System.out.println(sql);
    comando.execute(sql);
    conexao.close();
}

######


public void insert(Produto prod) throws SQLException {
    Connection conexao = DriverManager.getConnection("jdbc:mysql://localhost/builder", "root", "root");
    Statement comando = conexao.createStatement();
    String sql = "INSERT INTO produtos (descricao, peso) VALUES ('" + prod.getDescricao() + "', " + prod.getPeso() + ")";
    System.out.println(sql);
    comando.execute(sql);
    conexao.close();
}

######


public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
    return inflater.inflate(R.layout.profiel_fragment, container, false);
}

######


@Override
public void onClick(View v) {
    dat = new DatabaseConnector();
    String user = String.valueOf(usernameView.getText());
    Editable voornaamInput = voornaamView.getText();
    Editable achternaamInput = achternaamView.getText();
    Editable adresInput = adresView.getText();
    Editable telefoonInput = telefoonView.getText();
    Editable emailInput = emailView.getText();
    String sql = "UPDATE Klant SET Voornaam = '" + voornaamInput + "', Achternaam = '" + achternaamInput + "', Adres = '" + adresInput + "', Telefoon = '" + telefoonInput + "', Email = '" + emailInput + "' WHERE Gebruikersnaam = '" + user + "'";
    dat.execute(sql);
    Toast.makeText(getActivity().getApplicationContext(), "Gewijzigd", Toast.LENGTH_LONG).show();
}

######


@Override
public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
    db = new DatabaseConnector();
    String sql = "select * from Klant";
    try {
        db.execute(sql);
        Object oResult = db.get();
        String strResult = oResult.toString();
        jResult = new JSONArray(strResult);
    } catch (Exception e) {
        e.printStackTrace();
    }
    usernameView = getView().findViewById(R.id.usernameView);
    try {
        for (int i = 0; i < jResult.length(); i++) {
            try {
                JSONObject jsonObject = (JSONObject) jResult.get(i);
                String userName = (String) jsonObject.get("Gebruikersnaam");
                usernameView.setText("" + userName);
                Log.i("e", jResult.toString());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    voornaamView = getView().findViewById(R.id.voornaamView);
    try {
        for (int i = 0; i < jResult.length(); i++) {
            try {
                JSONObject jsonObject = (JSONObject) jResult.get(i);
                String firstName = (String) jsonObject.get("Voornaam");
                voornaamView.setText("" + firstName);
                Log.i("e", jResult.toString());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    achternaamView = getView().findViewById(R.id.achternaamView);
    try {
        for (int i = 0; i < jResult.length(); i++) {
            try {
                JSONObject jsonObject = (JSONObject) jResult.get(i);
                String lastName = (String) jsonObject.get("Achternaam");
                achternaamView.setText("" + lastName);
                Log.i("e", jResult.toString());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    adresView = getView().findViewById(R.id.adresView);
    try {
        for (int i = 0; i < jResult.length(); i++) {
            try {
                JSONObject jsonObject = (JSONObject) jResult.get(i);
                String adres = (String) jsonObject.get("Adres");
                adresView.setText("" + adres);
                Log.i("e", jResult.toString());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    telefoonView = getView().findViewById(R.id.telefoonView);
    try {
        for (int i = 0; i < jResult.length(); i++) {
            try {
                JSONObject jsonObject = (JSONObject) jResult.get(i);
                String telefoon = (String) jsonObject.get("Telefoon");
                telefoonView.setText("" + telefoon);
                Log.i("e", jResult.toString());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    emailView = getView().findViewById(R.id.emailView);
    try {
        for (int i = 0; i < jResult.length(); i++) {
            try {
                JSONObject jsonObject = (JSONObject) jResult.get(i);
                String email = (String) jsonObject.get("Email");
                emailView.setText("" + email);
                Log.i("e", jResult.toString());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    editButton = getView().findViewById(R.id.editButton);
    editButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dat = new DatabaseConnector();
            String user = String.valueOf(usernameView.getText());
            Editable voornaamInput = voornaamView.getText();
            Editable achternaamInput = achternaamView.getText();
            Editable adresInput = adresView.getText();
            Editable telefoonInput = telefoonView.getText();
            Editable emailInput = emailView.getText();
            String sql = "UPDATE Klant SET Voornaam = '" + voornaamInput + "', Achternaam = '" + achternaamInput + "', Adres = '" + adresInput + "', Telefoon = '" + telefoonInput + "', Email = '" + emailInput + "' WHERE Gebruikersnaam = '" + user + "'";
            dat.execute(sql);
            Toast.makeText(getActivity().getApplicationContext(), "Gewijzigd", Toast.LENGTH_LONG).show();
        }
    });
    super.onViewCreated(view, savedInstanceState);
}

######


@Override
public void changed(ObservableValue<? extends ProjectModel> observable, ProjectModel oldValue, ProjectModel newValue) {
    if (oldValue == null) {
        tasksScreenFiller.setVisible(false);
    }
    if (newValue == null) {
        tasksScreenFiller.setVisible(true);
    }
    currentModel = newValue;
    setProjectFields(currentModel);
}

######


@Override
public void initialize(URL location, ResourceBundle resources) {
    addProjBtn.setOnAction(e -> getNewProjectScreen());
    delProjBtn.setOnAction(e -> removeProject());
    initProjects();
    listView_projects.getSelectionModel().selectedItemProperty().addListener(new ChangeListener<ProjectModel>() {

        @Override
        public void changed(ObservableValue<? extends ProjectModel> observable, ProjectModel oldValue, ProjectModel newValue) {
            if (oldValue == null) {
                tasksScreenFiller.setVisible(false);
            }
            if (newValue == null) {
                tasksScreenFiller.setVisible(true);
            }
            currentModel = newValue;
            setProjectFields(currentModel);
        }
    });
}

######


private void removeProject() {
    String t = "delete from mupp_task where project_id=" + currentModel.getProjectId() + ";";
    String q = "delete from mupp_project where project_id=" + currentModel.getProjectId() + ";";
    try {
        TCPConnection.getInstance().send(t);
        TCPConnection.getInstance().send(q);
        listView_projects.getSelectionModel().selectFirst();
        currentModel = projectsList.get(0);
        initProjects();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

######


private void getNewProjectScreen() {
    try {
        Stage newProjWin = new Stage();
        newProjWin.initModality(Modality.APPLICATION_MODAL);
        newProjWin.setTitle("Создание нового проекта");
        newProjWin.setWidth(300);
        newProjWin.setHeight(300);
        Parent root = FXMLLoader.load(getClass().getResource("NewProjectSreen.fxml"));
        newProjWin.setScene(new Scene(root, 300, 300));
        newProjWin.show();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

######


private void initProjects() {
    projectsList.clear();
    projectsNamesList.clear();
    String query = "select * from mupp_project;";
    try {
        String result = TCPConnection.getInstance().sendAndRecieve(query);
        System.out.println(result);
        Object resultJson = new JSONParser().parse(result);
        JSONObject resultObject = (JSONObject) resultJson;
        JSONArray resultsArray = (JSONArray) resultObject.get("result");
        for (Object e : resultsArray) {
            JSONObject obj = (JSONObject) e;
            ProjectModel model = ProjectModel.fromJson(obj);
            projectsList.add(model);
            projectsNamesList.add(model.toString());
        }
        listView_projects.setItems(null);
        listView_projects.setItems(projectsList);
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ParseException e) {
        e.printStackTrace();
    }
}

######


private void setProjectFields(ProjectModel value) {
    projectNameLabel.setText(value.getProjectName());
    projectDescText.setText(value.getProjectDescription());
    projectGitText.setText(value.getProjectGitUrl());
    tasksList.clear();
    String query = "select * from mupp_task where project_id=" + currentModel.getProjectId() + ";";
    String result = null;
    try {
        result = TCPConnection.getInstance().sendAndRecieve(query);
        Object resultJson = new JSONParser().parse(result);
        JSONObject resultObject = (JSONObject) resultJson;
        JSONArray resultsArray = (JSONArray) resultObject.get("result");
        for (Object e : resultsArray) {
            JSONObject obj = (JSONObject) e;
            TaskModel model = TaskModel.fromJson(obj);
            tasksList.add(model);
        }
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ParseException e) {
        e.printStackTrace();
    }
    projectTasksLV.setItems(null);
    projectTasksLV.setItems(tasksList);
}

######


@SqlUpdate("create table promos (idt integer primary key autoincrement, idProduit integer, idService integer, datefin varchar(100), nvPrix varchar(255), description varchar(240))")
void createPromoTable();

######


@SqlUpdate("insert into promos (idProduit, idService, datefin, nvPrix, description) values (:idProduit, :idService , :datefin, :nvPrix, :description)")
@GetGeneratedKeys
int insert(@BindBean Promo p);

######


@SqlUpdate("update promos set idProduit = :idProduit, idService = :idService, datefin = :datefin, nvPrix = :nvPrix, description = :description")
void update(@BindBean Promo p);

######


@SqlQuery("select * from promos where idt = :idt")
@RegisterMapperFactory(BeanMapperFactory.class)
Promo findByIdt(@Bind("idt") int idt);

######


@SqlQuery("select * from promos where idProduit = :idProduit")
@RegisterMapperFactory(BeanMapperFactory.class)
Promo findByIdProduct(@Bind("idProduit") int idProduit);

######


@SqlQuery("select * from promos where idService = :idService")
@RegisterMapperFactory(BeanMapperFactory.class)
Promo findByIdService(@Bind("idService") int idService);

######


@SqlUpdate("delete from promos where idt = :idt")
int deletePromo(@Bind("idt") int idt);

######


@SqlUpdate("drop table if exists promos")
void dropPromoTable();

######


void close();

######


public Long getPropertyId() {
    return propertyId;
}

######


public void setPropertyId(Long propertyId) {
    this.propertyId = propertyId;
}

######


public String getPropertyKey() {
    return propertyKey;
}

######


public void setPropertyKey(String propertyKey) {
    this.propertyKey = propertyKey;
}

######


public String getPropertyValue() {
    return propertyValue;
}

######


public void setPropertyValue(String propertyValue) {
    this.propertyValue = propertyValue;
}

######


public String getDescription() {
    return description;
}

######


public void setDescription(String description) {
    this.description = description;
}

######


public User getmodifiedBy() {
    return modifiedBy;
}

######


public void setModifiedBy(User modifiedBy) {
    this.modifiedBy = modifiedBy;
}

######


public User getCreatedBy() {
    return createdBy;
}

######


public void setCreatedBy(User createdBy) {
    this.createdBy = createdBy;
}

######


public void setCreatedDate(Date createdDate) {
    this.createdDate = createdDate;
}

######


public Date getCreatedDate() {
    return createdDate;
}

######


public void setModifiedDate(Date modifiedDate) {
    this.modifiedDate = modifiedDate;
}

######


public Date getModifiedDate() {
    return modifiedDate;
}

######


public static void registerAllExtensions(com.google.protobuf.ExtensionRegistry registry) {
}

######


boolean hasIpAddress();

######


com.google.protobuf.ByteString getIpAddress();

######


boolean hasPort();

######


int getPort();

######


boolean hasServices();

######


long getServices();

######


public static PeerAddress getDefaultInstance() {
    return defaultInstance;
}

######


public PeerAddress getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_PeerAddress_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_PeerAddress_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.PeerAddress.class, org.galilelj.wallet.Protos.PeerAddress.Builder.class);
}

######


public PeerAddress parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new PeerAddress(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<PeerAddress> getParserForType() {
    return PARSER;
}

######


public boolean hasIpAddress() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public com.google.protobuf.ByteString getIpAddress() {
    return ipAddress_;
}

######


public boolean hasPort() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public int getPort() {
    return port_;
}

######


public boolean hasServices() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public long getServices() {
    return services_;
}

######


private void initFields() {
    ipAddress_ = com.google.protobuf.ByteString.EMPTY;
    port_ = 0;
    services_ = 0L;
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasIpAddress()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (!hasPort()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (!hasServices()) {
        memoizedIsInitialized = 0;
        return false;
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, ipAddress_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeUInt32(2, port_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt64(3, services_);
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, ipAddress_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeUInt32Size(2, port_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeUInt64Size(3, services_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.PeerAddress parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.PeerAddress parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.PeerAddress parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.PeerAddress parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.PeerAddress parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.PeerAddress parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.PeerAddress parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.PeerAddress parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.PeerAddress parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.PeerAddress parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.PeerAddress prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_PeerAddress_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_PeerAddress_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.PeerAddress.class, org.galilelj.wallet.Protos.PeerAddress.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    ipAddress_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    port_ = 0;
    bitField0_ = (bitField0_ & ~0x00000002);
    services_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000004);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_PeerAddress_descriptor;
}

######


public org.galilelj.wallet.Protos.PeerAddress getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.PeerAddress.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.PeerAddress build() {
    org.galilelj.wallet.Protos.PeerAddress result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.PeerAddress buildPartial() {
    org.galilelj.wallet.Protos.PeerAddress result = new org.galilelj.wallet.Protos.PeerAddress(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.ipAddress_ = ipAddress_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.port_ = port_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.services_ = services_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.PeerAddress) {
        return mergeFrom((org.galilelj.wallet.Protos.PeerAddress) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.PeerAddress other) {
    if (other == org.galilelj.wallet.Protos.PeerAddress.getDefaultInstance())
        return this;
    if (other.hasIpAddress()) {
        setIpAddress(other.getIpAddress());
    }
    if (other.hasPort()) {
        setPort(other.getPort());
    }
    if (other.hasServices()) {
        setServices(other.getServices());
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasIpAddress()) {
        return false;
    }
    if (!hasPort()) {
        return false;
    }
    if (!hasServices()) {
        return false;
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.PeerAddress parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.PeerAddress) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasIpAddress() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public com.google.protobuf.ByteString getIpAddress() {
    return ipAddress_;
}

######


public Builder setIpAddress(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    ipAddress_ = value;
    onChanged();
    return this;
}

######


public Builder clearIpAddress() {
    bitField0_ = (bitField0_ & ~0x00000001);
    ipAddress_ = getDefaultInstance().getIpAddress();
    onChanged();
    return this;
}

######


public boolean hasPort() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public int getPort() {
    return port_;
}

######


public Builder setPort(int value) {
    bitField0_ |= 0x00000002;
    port_ = value;
    onChanged();
    return this;
}

######


public Builder clearPort() {
    bitField0_ = (bitField0_ & ~0x00000002);
    port_ = 0;
    onChanged();
    return this;
}

######


public boolean hasServices() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public long getServices() {
    return services_;
}

######


public Builder setServices(long value) {
    bitField0_ |= 0x00000004;
    services_ = value;
    onChanged();
    return this;
}

######


public Builder clearServices() {
    bitField0_ = (bitField0_ & ~0x00000004);
    services_ = 0L;
    onChanged();
    return this;
}

######


boolean hasInitialisationVector();

######


com.google.protobuf.ByteString getInitialisationVector();

######


boolean hasEncryptedPrivateKey();

######


com.google.protobuf.ByteString getEncryptedPrivateKey();

######


public static EncryptedData getDefaultInstance() {
    return defaultInstance;
}

######


public EncryptedData getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_EncryptedData_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_EncryptedData_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.EncryptedData.class, org.galilelj.wallet.Protos.EncryptedData.Builder.class);
}

######


public EncryptedData parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new EncryptedData(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<EncryptedData> getParserForType() {
    return PARSER;
}

######


public boolean hasInitialisationVector() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public com.google.protobuf.ByteString getInitialisationVector() {
    return initialisationVector_;
}

######


public boolean hasEncryptedPrivateKey() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getEncryptedPrivateKey() {
    return encryptedPrivateKey_;
}

######


private void initFields() {
    initialisationVector_ = com.google.protobuf.ByteString.EMPTY;
    encryptedPrivateKey_ = com.google.protobuf.ByteString.EMPTY;
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasInitialisationVector()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (!hasEncryptedPrivateKey()) {
        memoizedIsInitialized = 0;
        return false;
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, initialisationVector_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, encryptedPrivateKey_);
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, initialisationVector_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, encryptedPrivateKey_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.EncryptedData parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.EncryptedData parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.EncryptedData parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.EncryptedData parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.EncryptedData parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.EncryptedData parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.EncryptedData parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.EncryptedData parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.EncryptedData parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.EncryptedData parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.EncryptedData prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_EncryptedData_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_EncryptedData_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.EncryptedData.class, org.galilelj.wallet.Protos.EncryptedData.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    initialisationVector_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    encryptedPrivateKey_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_EncryptedData_descriptor;
}

######


public org.galilelj.wallet.Protos.EncryptedData getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.EncryptedData.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.EncryptedData build() {
    org.galilelj.wallet.Protos.EncryptedData result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.EncryptedData buildPartial() {
    org.galilelj.wallet.Protos.EncryptedData result = new org.galilelj.wallet.Protos.EncryptedData(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.initialisationVector_ = initialisationVector_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.encryptedPrivateKey_ = encryptedPrivateKey_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.EncryptedData) {
        return mergeFrom((org.galilelj.wallet.Protos.EncryptedData) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.EncryptedData other) {
    if (other == org.galilelj.wallet.Protos.EncryptedData.getDefaultInstance())
        return this;
    if (other.hasInitialisationVector()) {
        setInitialisationVector(other.getInitialisationVector());
    }
    if (other.hasEncryptedPrivateKey()) {
        setEncryptedPrivateKey(other.getEncryptedPrivateKey());
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasInitialisationVector()) {
        return false;
    }
    if (!hasEncryptedPrivateKey()) {
        return false;
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.EncryptedData parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.EncryptedData) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasInitialisationVector() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public com.google.protobuf.ByteString getInitialisationVector() {
    return initialisationVector_;
}

######


public Builder setInitialisationVector(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    initialisationVector_ = value;
    onChanged();
    return this;
}

######


public Builder clearInitialisationVector() {
    bitField0_ = (bitField0_ & ~0x00000001);
    initialisationVector_ = getDefaultInstance().getInitialisationVector();
    onChanged();
    return this;
}

######


public boolean hasEncryptedPrivateKey() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getEncryptedPrivateKey() {
    return encryptedPrivateKey_;
}

######


public Builder setEncryptedPrivateKey(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000002;
    encryptedPrivateKey_ = value;
    onChanged();
    return this;
}

######


public Builder clearEncryptedPrivateKey() {
    bitField0_ = (bitField0_ & ~0x00000002);
    encryptedPrivateKey_ = getDefaultInstance().getEncryptedPrivateKey();
    onChanged();
    return this;
}

######


boolean hasChainCode();

######


com.google.protobuf.ByteString getChainCode();

######


java.util.List<java.lang.Integer> getPathList();

######


int getPathCount();

######


int getPath(int index);

######


boolean hasIssuedSubkeys();

######


int getIssuedSubkeys();

######


boolean hasLookaheadSize();

######


int getLookaheadSize();

######


boolean hasIsFollowing();

######


boolean getIsFollowing();

######


boolean hasSigsRequiredToSpend();

######


int getSigsRequiredToSpend();

######


public static DeterministicKey getDefaultInstance() {
    return defaultInstance;
}

######


public DeterministicKey getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_DeterministicKey_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_DeterministicKey_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.DeterministicKey.class, org.galilelj.wallet.Protos.DeterministicKey.Builder.class);
}

######


public DeterministicKey parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new DeterministicKey(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<DeterministicKey> getParserForType() {
    return PARSER;
}

######


public boolean hasChainCode() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public com.google.protobuf.ByteString getChainCode() {
    return chainCode_;
}

######


public java.util.List<java.lang.Integer> getPathList() {
    return path_;
}

######


public int getPathCount() {
    return path_.size();
}

######


public int getPath(int index) {
    return path_.get(index);
}

######


public boolean hasIssuedSubkeys() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public int getIssuedSubkeys() {
    return issuedSubkeys_;
}

######


public boolean hasLookaheadSize() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public int getLookaheadSize() {
    return lookaheadSize_;
}

######


public boolean hasIsFollowing() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public boolean getIsFollowing() {
    return isFollowing_;
}

######


public boolean hasSigsRequiredToSpend() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}

######


public int getSigsRequiredToSpend() {
    return sigsRequiredToSpend_;
}

######


private void initFields() {
    chainCode_ = com.google.protobuf.ByteString.EMPTY;
    path_ = java.util.Collections.emptyList();
    issuedSubkeys_ = 0;
    lookaheadSize_ = 0;
    isFollowing_ = false;
    sigsRequiredToSpend_ = 1;
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasChainCode()) {
        memoizedIsInitialized = 0;
        return false;
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, chainCode_);
    }
    for (int i = 0; i < path_.size(); i++) {
        output.writeUInt32(2, path_.get(i));
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeUInt32(3, issuedSubkeys_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt32(4, lookaheadSize_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeBool(5, isFollowing_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeUInt32(6, sigsRequiredToSpend_);
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, chainCode_);
    }
    {
        int dataSize = 0;
        for (int i = 0; i < path_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(path_.get(i));
        }
        size += dataSize;
        size += 1 * getPathList().size();
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeUInt32Size(3, issuedSubkeys_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeUInt32Size(4, lookaheadSize_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(5, isFollowing_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream.computeUInt32Size(6, sigsRequiredToSpend_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.DeterministicKey parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.DeterministicKey parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.DeterministicKey parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.DeterministicKey parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.DeterministicKey parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.DeterministicKey parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.DeterministicKey parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.DeterministicKey parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.DeterministicKey parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.DeterministicKey parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.DeterministicKey prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_DeterministicKey_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_DeterministicKey_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.DeterministicKey.class, org.galilelj.wallet.Protos.DeterministicKey.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    chainCode_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    path_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000002);
    issuedSubkeys_ = 0;
    bitField0_ = (bitField0_ & ~0x00000004);
    lookaheadSize_ = 0;
    bitField0_ = (bitField0_ & ~0x00000008);
    isFollowing_ = false;
    bitField0_ = (bitField0_ & ~0x00000010);
    sigsRequiredToSpend_ = 1;
    bitField0_ = (bitField0_ & ~0x00000020);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_DeterministicKey_descriptor;
}

######


public org.galilelj.wallet.Protos.DeterministicKey getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.DeterministicKey.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.DeterministicKey build() {
    org.galilelj.wallet.Protos.DeterministicKey result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.DeterministicKey buildPartial() {
    org.galilelj.wallet.Protos.DeterministicKey result = new org.galilelj.wallet.Protos.DeterministicKey(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.chainCode_ = chainCode_;
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        path_ = java.util.Collections.unmodifiableList(path_);
        bitField0_ = (bitField0_ & ~0x00000002);
    }
    result.path_ = path_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000002;
    }
    result.issuedSubkeys_ = issuedSubkeys_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000004;
    }
    result.lookaheadSize_ = lookaheadSize_;
    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
        to_bitField0_ |= 0x00000008;
    }
    result.isFollowing_ = isFollowing_;
    if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
        to_bitField0_ |= 0x00000010;
    }
    result.sigsRequiredToSpend_ = sigsRequiredToSpend_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.DeterministicKey) {
        return mergeFrom((org.galilelj.wallet.Protos.DeterministicKey) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.DeterministicKey other) {
    if (other == org.galilelj.wallet.Protos.DeterministicKey.getDefaultInstance())
        return this;
    if (other.hasChainCode()) {
        setChainCode(other.getChainCode());
    }
    if (!other.path_.isEmpty()) {
        if (path_.isEmpty()) {
            path_ = other.path_;
            bitField0_ = (bitField0_ & ~0x00000002);
        } else {
            ensurePathIsMutable();
            path_.addAll(other.path_);
        }
        onChanged();
    }
    if (other.hasIssuedSubkeys()) {
        setIssuedSubkeys(other.getIssuedSubkeys());
    }
    if (other.hasLookaheadSize()) {
        setLookaheadSize(other.getLookaheadSize());
    }
    if (other.hasIsFollowing()) {
        setIsFollowing(other.getIsFollowing());
    }
    if (other.hasSigsRequiredToSpend()) {
        setSigsRequiredToSpend(other.getSigsRequiredToSpend());
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasChainCode()) {
        return false;
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.DeterministicKey parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.DeterministicKey) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasChainCode() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public com.google.protobuf.ByteString getChainCode() {
    return chainCode_;
}

######


public Builder setChainCode(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    chainCode_ = value;
    onChanged();
    return this;
}

######


public Builder clearChainCode() {
    bitField0_ = (bitField0_ & ~0x00000001);
    chainCode_ = getDefaultInstance().getChainCode();
    onChanged();
    return this;
}

######


private void ensurePathIsMutable() {
    if (!((bitField0_ & 0x00000002) == 0x00000002)) {
        path_ = new java.util.ArrayList<java.lang.Integer>(path_);
        bitField0_ |= 0x00000002;
    }
}

######


public java.util.List<java.lang.Integer> getPathList() {
    return java.util.Collections.unmodifiableList(path_);
}

######


public int getPathCount() {
    return path_.size();
}

######


public int getPath(int index) {
    return path_.get(index);
}

######


public Builder setPath(int index, int value) {
    ensurePathIsMutable();
    path_.set(index, value);
    onChanged();
    return this;
}

######


public Builder addPath(int value) {
    ensurePathIsMutable();
    path_.add(value);
    onChanged();
    return this;
}

######


public Builder addAllPath(java.lang.Iterable<? extends java.lang.Integer> values) {
    ensurePathIsMutable();
    super.addAll(values, path_);
    onChanged();
    return this;
}

######


public Builder clearPath() {
    path_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000002);
    onChanged();
    return this;
}

######


public boolean hasIssuedSubkeys() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public int getIssuedSubkeys() {
    return issuedSubkeys_;
}

######


public Builder setIssuedSubkeys(int value) {
    bitField0_ |= 0x00000004;
    issuedSubkeys_ = value;
    onChanged();
    return this;
}

######


public Builder clearIssuedSubkeys() {
    bitField0_ = (bitField0_ & ~0x00000004);
    issuedSubkeys_ = 0;
    onChanged();
    return this;
}

######


public boolean hasLookaheadSize() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public int getLookaheadSize() {
    return lookaheadSize_;
}

######


public Builder setLookaheadSize(int value) {
    bitField0_ |= 0x00000008;
    lookaheadSize_ = value;
    onChanged();
    return this;
}

######


public Builder clearLookaheadSize() {
    bitField0_ = (bitField0_ & ~0x00000008);
    lookaheadSize_ = 0;
    onChanged();
    return this;
}

######


public boolean hasIsFollowing() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}

######


public boolean getIsFollowing() {
    return isFollowing_;
}

######


public Builder setIsFollowing(boolean value) {
    bitField0_ |= 0x00000010;
    isFollowing_ = value;
    onChanged();
    return this;
}

######


public Builder clearIsFollowing() {
    bitField0_ = (bitField0_ & ~0x00000010);
    isFollowing_ = false;
    onChanged();
    return this;
}

######


public boolean hasSigsRequiredToSpend() {
    return ((bitField0_ & 0x00000020) == 0x00000020);
}

######


public int getSigsRequiredToSpend() {
    return sigsRequiredToSpend_;
}

######


public Builder setSigsRequiredToSpend(int value) {
    bitField0_ |= 0x00000020;
    sigsRequiredToSpend_ = value;
    onChanged();
    return this;
}

######


public Builder clearSigsRequiredToSpend() {
    bitField0_ = (bitField0_ & ~0x00000020);
    sigsRequiredToSpend_ = 1;
    onChanged();
    return this;
}

######


boolean hasType();

######


org.galilelj.wallet.Protos.Key.Type getType();

######


boolean hasSecretBytes();

######


com.google.protobuf.ByteString getSecretBytes();

######


boolean hasEncryptedData();

######


org.galilelj.wallet.Protos.EncryptedData getEncryptedData();

######


org.galilelj.wallet.Protos.EncryptedDataOrBuilder getEncryptedDataOrBuilder();

######


boolean hasPublicKey();

######


com.google.protobuf.ByteString getPublicKey();

######


boolean hasLabel();

######


java.lang.String getLabel();

######


com.google.protobuf.ByteString getLabelBytes();

######


boolean hasCreationTimestamp();

######


long getCreationTimestamp();

######


boolean hasDeterministicKey();

######


org.galilelj.wallet.Protos.DeterministicKey getDeterministicKey();

######


org.galilelj.wallet.Protos.DeterministicKeyOrBuilder getDeterministicKeyOrBuilder();

######


boolean hasDeterministicSeed();

######


com.google.protobuf.ByteString getDeterministicSeed();

######


boolean hasEncryptedDeterministicSeed();

######


org.galilelj.wallet.Protos.EncryptedData getEncryptedDeterministicSeed();

######


org.galilelj.wallet.Protos.EncryptedDataOrBuilder getEncryptedDeterministicSeedOrBuilder();

######


public static Key getDefaultInstance() {
    return defaultInstance;
}

######


public Key getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Key_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Key_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.Key.class, org.galilelj.wallet.Protos.Key.Builder.class);
}

######


public Key parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new Key(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<Key> getParserForType() {
    return PARSER;
}

######


public final int getNumber() {
    return value;
}

######


public static Type valueOf(int value) {
    switch(value) {
        case 1:
            return ORIGINAL;
        case 2:
            return ENCRYPTED_SCRYPT_AES;
        case 3:
            return DETERMINISTIC_MNEMONIC;
        case 4:
            return DETERMINISTIC_KEY;
        default:
            return null;
    }
}

######


public static com.google.protobuf.Internal.EnumLiteMap<Type> internalGetValueMap() {
    return internalValueMap;
}

######


public Type findValueByNumber(int number) {
    return Type.valueOf(number);
}

######


public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
    return getDescriptor().getValues().get(index);
}

######


public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
    return getDescriptor();
}

######


public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
    return org.galilelj.wallet.Protos.Key.getDescriptor().getEnumTypes().get(0);
}

######


public static Type valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
    if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
    }
    return VALUES[desc.getIndex()];
}

######


public boolean hasType() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public org.galilelj.wallet.Protos.Key.Type getType() {
    return type_;
}

######


public boolean hasSecretBytes() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getSecretBytes() {
    return secretBytes_;
}

######


public boolean hasEncryptedData() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public org.galilelj.wallet.Protos.EncryptedData getEncryptedData() {
    return encryptedData_;
}

######


public org.galilelj.wallet.Protos.EncryptedDataOrBuilder getEncryptedDataOrBuilder() {
    return encryptedData_;
}

######


public boolean hasPublicKey() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public com.google.protobuf.ByteString getPublicKey() {
    return publicKey_;
}

######


public boolean hasLabel() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}

######


public java.lang.String getLabel() {
    java.lang.Object ref = label_;
    if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
    } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
            label_ = s;
        }
        return s;
    }
}

######


public com.google.protobuf.ByteString getLabelBytes() {
    java.lang.Object ref = label_;
    if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        label_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public boolean hasCreationTimestamp() {
    return ((bitField0_ & 0x00000020) == 0x00000020);
}

######


public long getCreationTimestamp() {
    return creationTimestamp_;
}

######


public boolean hasDeterministicKey() {
    return ((bitField0_ & 0x00000040) == 0x00000040);
}

######


public org.galilelj.wallet.Protos.DeterministicKey getDeterministicKey() {
    return deterministicKey_;
}

######


public org.galilelj.wallet.Protos.DeterministicKeyOrBuilder getDeterministicKeyOrBuilder() {
    return deterministicKey_;
}

######


public boolean hasDeterministicSeed() {
    return ((bitField0_ & 0x00000080) == 0x00000080);
}

######


public com.google.protobuf.ByteString getDeterministicSeed() {
    return deterministicSeed_;
}

######


public boolean hasEncryptedDeterministicSeed() {
    return ((bitField0_ & 0x00000100) == 0x00000100);
}

######


public org.galilelj.wallet.Protos.EncryptedData getEncryptedDeterministicSeed() {
    return encryptedDeterministicSeed_;
}

######


public org.galilelj.wallet.Protos.EncryptedDataOrBuilder getEncryptedDeterministicSeedOrBuilder() {
    return encryptedDeterministicSeed_;
}

######


private void initFields() {
    type_ = org.galilelj.wallet.Protos.Key.Type.ORIGINAL;
    secretBytes_ = com.google.protobuf.ByteString.EMPTY;
    encryptedData_ = org.galilelj.wallet.Protos.EncryptedData.getDefaultInstance();
    publicKey_ = com.google.protobuf.ByteString.EMPTY;
    label_ = "";
    creationTimestamp_ = 0L;
    deterministicKey_ = org.galilelj.wallet.Protos.DeterministicKey.getDefaultInstance();
    deterministicSeed_ = com.google.protobuf.ByteString.EMPTY;
    encryptedDeterministicSeed_ = org.galilelj.wallet.Protos.EncryptedData.getDefaultInstance();
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasType()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (hasEncryptedData()) {
        if (!getEncryptedData().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    if (hasDeterministicKey()) {
        if (!getDeterministicKey().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    if (hasEncryptedDeterministicSeed()) {
        if (!getEncryptedDeterministicSeed().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeEnum(1, type_.getNumber());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, secretBytes_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeBytes(3, publicKey_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeBytes(4, getLabelBytes());
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeInt64(5, creationTimestamp_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(6, encryptedData_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeMessage(7, deterministicKey_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeBytes(8, deterministicSeed_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeMessage(9, encryptedDeterministicSeed_);
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeEnumSize(1, type_.getNumber());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, secretBytes_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(3, publicKey_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(4, getLabelBytes());
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(5, creationTimestamp_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(6, encryptedData_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(7, deterministicKey_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(8, deterministicSeed_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(9, encryptedDeterministicSeed_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.Key parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.Key parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Key parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.Key parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Key parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.Key parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Key parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.Key parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Key parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.Key parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.Key prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Key_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Key_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.Key.class, org.galilelj.wallet.Protos.Key.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        getEncryptedDataFieldBuilder();
        getDeterministicKeyFieldBuilder();
        getEncryptedDeterministicSeedFieldBuilder();
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    type_ = org.galilelj.wallet.Protos.Key.Type.ORIGINAL;
    bitField0_ = (bitField0_ & ~0x00000001);
    secretBytes_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    if (encryptedDataBuilder_ == null) {
        encryptedData_ = org.galilelj.wallet.Protos.EncryptedData.getDefaultInstance();
    } else {
        encryptedDataBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000004);
    publicKey_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000008);
    label_ = "";
    bitField0_ = (bitField0_ & ~0x00000010);
    creationTimestamp_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000020);
    if (deterministicKeyBuilder_ == null) {
        deterministicKey_ = org.galilelj.wallet.Protos.DeterministicKey.getDefaultInstance();
    } else {
        deterministicKeyBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000040);
    deterministicSeed_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000080);
    if (encryptedDeterministicSeedBuilder_ == null) {
        encryptedDeterministicSeed_ = org.galilelj.wallet.Protos.EncryptedData.getDefaultInstance();
    } else {
        encryptedDeterministicSeedBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000100);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Key_descriptor;
}

######


public org.galilelj.wallet.Protos.Key getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.Key.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.Key build() {
    org.galilelj.wallet.Protos.Key result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.Key buildPartial() {
    org.galilelj.wallet.Protos.Key result = new org.galilelj.wallet.Protos.Key(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.type_ = type_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.secretBytes_ = secretBytes_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    if (encryptedDataBuilder_ == null) {
        result.encryptedData_ = encryptedData_;
    } else {
        result.encryptedData_ = encryptedDataBuilder_.build();
    }
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000008;
    }
    result.publicKey_ = publicKey_;
    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
        to_bitField0_ |= 0x00000010;
    }
    result.label_ = label_;
    if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
        to_bitField0_ |= 0x00000020;
    }
    result.creationTimestamp_ = creationTimestamp_;
    if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
        to_bitField0_ |= 0x00000040;
    }
    if (deterministicKeyBuilder_ == null) {
        result.deterministicKey_ = deterministicKey_;
    } else {
        result.deterministicKey_ = deterministicKeyBuilder_.build();
    }
    if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
        to_bitField0_ |= 0x00000080;
    }
    result.deterministicSeed_ = deterministicSeed_;
    if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
        to_bitField0_ |= 0x00000100;
    }
    if (encryptedDeterministicSeedBuilder_ == null) {
        result.encryptedDeterministicSeed_ = encryptedDeterministicSeed_;
    } else {
        result.encryptedDeterministicSeed_ = encryptedDeterministicSeedBuilder_.build();
    }
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.Key) {
        return mergeFrom((org.galilelj.wallet.Protos.Key) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.Key other) {
    if (other == org.galilelj.wallet.Protos.Key.getDefaultInstance())
        return this;
    if (other.hasType()) {
        setType(other.getType());
    }
    if (other.hasSecretBytes()) {
        setSecretBytes(other.getSecretBytes());
    }
    if (other.hasEncryptedData()) {
        mergeEncryptedData(other.getEncryptedData());
    }
    if (other.hasPublicKey()) {
        setPublicKey(other.getPublicKey());
    }
    if (other.hasLabel()) {
        bitField0_ |= 0x00000010;
        label_ = other.label_;
        onChanged();
    }
    if (other.hasCreationTimestamp()) {
        setCreationTimestamp(other.getCreationTimestamp());
    }
    if (other.hasDeterministicKey()) {
        mergeDeterministicKey(other.getDeterministicKey());
    }
    if (other.hasDeterministicSeed()) {
        setDeterministicSeed(other.getDeterministicSeed());
    }
    if (other.hasEncryptedDeterministicSeed()) {
        mergeEncryptedDeterministicSeed(other.getEncryptedDeterministicSeed());
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasType()) {
        return false;
    }
    if (hasEncryptedData()) {
        if (!getEncryptedData().isInitialized()) {
            return false;
        }
    }
    if (hasDeterministicKey()) {
        if (!getDeterministicKey().isInitialized()) {
            return false;
        }
    }
    if (hasEncryptedDeterministicSeed()) {
        if (!getEncryptedDeterministicSeed().isInitialized()) {
            return false;
        }
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.Key parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.Key) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasType() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public org.galilelj.wallet.Protos.Key.Type getType() {
    return type_;
}

######


public Builder setType(org.galilelj.wallet.Protos.Key.Type value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    type_ = value;
    onChanged();
    return this;
}

######


public Builder clearType() {
    bitField0_ = (bitField0_ & ~0x00000001);
    type_ = org.galilelj.wallet.Protos.Key.Type.ORIGINAL;
    onChanged();
    return this;
}

######


public boolean hasSecretBytes() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getSecretBytes() {
    return secretBytes_;
}

######


public Builder setSecretBytes(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000002;
    secretBytes_ = value;
    onChanged();
    return this;
}

######


public Builder clearSecretBytes() {
    bitField0_ = (bitField0_ & ~0x00000002);
    secretBytes_ = getDefaultInstance().getSecretBytes();
    onChanged();
    return this;
}

######


public boolean hasEncryptedData() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public org.galilelj.wallet.Protos.EncryptedData getEncryptedData() {
    if (encryptedDataBuilder_ == null) {
        return encryptedData_;
    } else {
        return encryptedDataBuilder_.getMessage();
    }
}

######


public Builder setEncryptedData(org.galilelj.wallet.Protos.EncryptedData value) {
    if (encryptedDataBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        encryptedData_ = value;
        onChanged();
    } else {
        encryptedDataBuilder_.setMessage(value);
    }
    bitField0_ |= 0x00000004;
    return this;
}

######


public Builder setEncryptedData(org.galilelj.wallet.Protos.EncryptedData.Builder builderForValue) {
    if (encryptedDataBuilder_ == null) {
        encryptedData_ = builderForValue.build();
        onChanged();
    } else {
        encryptedDataBuilder_.setMessage(builderForValue.build());
    }
    bitField0_ |= 0x00000004;
    return this;
}

######


public Builder mergeEncryptedData(org.galilelj.wallet.Protos.EncryptedData value) {
    if (encryptedDataBuilder_ == null) {
        if (((bitField0_ & 0x00000004) == 0x00000004) && encryptedData_ != org.galilelj.wallet.Protos.EncryptedData.getDefaultInstance()) {
            encryptedData_ = org.galilelj.wallet.Protos.EncryptedData.newBuilder(encryptedData_).mergeFrom(value).buildPartial();
        } else {
            encryptedData_ = value;
        }
        onChanged();
    } else {
        encryptedDataBuilder_.mergeFrom(value);
    }
    bitField0_ |= 0x00000004;
    return this;
}

######


public Builder clearEncryptedData() {
    if (encryptedDataBuilder_ == null) {
        encryptedData_ = org.galilelj.wallet.Protos.EncryptedData.getDefaultInstance();
        onChanged();
    } else {
        encryptedDataBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000004);
    return this;
}

######


public org.galilelj.wallet.Protos.EncryptedData.Builder getEncryptedDataBuilder() {
    bitField0_ |= 0x00000004;
    onChanged();
    return getEncryptedDataFieldBuilder().getBuilder();
}

######


public org.galilelj.wallet.Protos.EncryptedDataOrBuilder getEncryptedDataOrBuilder() {
    if (encryptedDataBuilder_ != null) {
        return encryptedDataBuilder_.getMessageOrBuilder();
    } else {
        return encryptedData_;
    }
}

######


private com.google.protobuf.SingleFieldBuilder<org.galilelj.wallet.Protos.EncryptedData, org.galilelj.wallet.Protos.EncryptedData.Builder, org.galilelj.wallet.Protos.EncryptedDataOrBuilder> getEncryptedDataFieldBuilder() {
    if (encryptedDataBuilder_ == null) {
        encryptedDataBuilder_ = new com.google.protobuf.SingleFieldBuilder<org.galilelj.wallet.Protos.EncryptedData, org.galilelj.wallet.Protos.EncryptedData.Builder, org.galilelj.wallet.Protos.EncryptedDataOrBuilder>(encryptedData_, getParentForChildren(), isClean());
        encryptedData_ = null;
    }
    return encryptedDataBuilder_;
}

######


public boolean hasPublicKey() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public com.google.protobuf.ByteString getPublicKey() {
    return publicKey_;
}

######


public Builder setPublicKey(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000008;
    publicKey_ = value;
    onChanged();
    return this;
}

######


public Builder clearPublicKey() {
    bitField0_ = (bitField0_ & ~0x00000008);
    publicKey_ = getDefaultInstance().getPublicKey();
    onChanged();
    return this;
}

######


public boolean hasLabel() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}

######


public java.lang.String getLabel() {
    java.lang.Object ref = label_;
    if (!(ref instanceof java.lang.String)) {
        java.lang.String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();
        label_ = s;
        return s;
    } else {
        return (java.lang.String) ref;
    }
}

######


public com.google.protobuf.ByteString getLabelBytes() {
    java.lang.Object ref = label_;
    if (ref instanceof String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        label_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public Builder setLabel(java.lang.String value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000010;
    label_ = value;
    onChanged();
    return this;
}

######


public Builder clearLabel() {
    bitField0_ = (bitField0_ & ~0x00000010);
    label_ = getDefaultInstance().getLabel();
    onChanged();
    return this;
}

######


public Builder setLabelBytes(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000010;
    label_ = value;
    onChanged();
    return this;
}

######


public boolean hasCreationTimestamp() {
    return ((bitField0_ & 0x00000020) == 0x00000020);
}

######


public long getCreationTimestamp() {
    return creationTimestamp_;
}

######


public Builder setCreationTimestamp(long value) {
    bitField0_ |= 0x00000020;
    creationTimestamp_ = value;
    onChanged();
    return this;
}

######


public Builder clearCreationTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000020);
    creationTimestamp_ = 0L;
    onChanged();
    return this;
}

######


public boolean hasDeterministicKey() {
    return ((bitField0_ & 0x00000040) == 0x00000040);
}

######


public org.galilelj.wallet.Protos.DeterministicKey getDeterministicKey() {
    if (deterministicKeyBuilder_ == null) {
        return deterministicKey_;
    } else {
        return deterministicKeyBuilder_.getMessage();
    }
}

######


public Builder setDeterministicKey(org.galilelj.wallet.Protos.DeterministicKey value) {
    if (deterministicKeyBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        deterministicKey_ = value;
        onChanged();
    } else {
        deterministicKeyBuilder_.setMessage(value);
    }
    bitField0_ |= 0x00000040;
    return this;
}

######


public Builder setDeterministicKey(org.galilelj.wallet.Protos.DeterministicKey.Builder builderForValue) {
    if (deterministicKeyBuilder_ == null) {
        deterministicKey_ = builderForValue.build();
        onChanged();
    } else {
        deterministicKeyBuilder_.setMessage(builderForValue.build());
    }
    bitField0_ |= 0x00000040;
    return this;
}

######


public Builder mergeDeterministicKey(org.galilelj.wallet.Protos.DeterministicKey value) {
    if (deterministicKeyBuilder_ == null) {
        if (((bitField0_ & 0x00000040) == 0x00000040) && deterministicKey_ != org.galilelj.wallet.Protos.DeterministicKey.getDefaultInstance()) {
            deterministicKey_ = org.galilelj.wallet.Protos.DeterministicKey.newBuilder(deterministicKey_).mergeFrom(value).buildPartial();
        } else {
            deterministicKey_ = value;
        }
        onChanged();
    } else {
        deterministicKeyBuilder_.mergeFrom(value);
    }
    bitField0_ |= 0x00000040;
    return this;
}

######


public Builder clearDeterministicKey() {
    if (deterministicKeyBuilder_ == null) {
        deterministicKey_ = org.galilelj.wallet.Protos.DeterministicKey.getDefaultInstance();
        onChanged();
    } else {
        deterministicKeyBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000040);
    return this;
}

######


public org.galilelj.wallet.Protos.DeterministicKey.Builder getDeterministicKeyBuilder() {
    bitField0_ |= 0x00000040;
    onChanged();
    return getDeterministicKeyFieldBuilder().getBuilder();
}

######


public org.galilelj.wallet.Protos.DeterministicKeyOrBuilder getDeterministicKeyOrBuilder() {
    if (deterministicKeyBuilder_ != null) {
        return deterministicKeyBuilder_.getMessageOrBuilder();
    } else {
        return deterministicKey_;
    }
}

######


private com.google.protobuf.SingleFieldBuilder<org.galilelj.wallet.Protos.DeterministicKey, org.galilelj.wallet.Protos.DeterministicKey.Builder, org.galilelj.wallet.Protos.DeterministicKeyOrBuilder> getDeterministicKeyFieldBuilder() {
    if (deterministicKeyBuilder_ == null) {
        deterministicKeyBuilder_ = new com.google.protobuf.SingleFieldBuilder<org.galilelj.wallet.Protos.DeterministicKey, org.galilelj.wallet.Protos.DeterministicKey.Builder, org.galilelj.wallet.Protos.DeterministicKeyOrBuilder>(deterministicKey_, getParentForChildren(), isClean());
        deterministicKey_ = null;
    }
    return deterministicKeyBuilder_;
}

######


public boolean hasDeterministicSeed() {
    return ((bitField0_ & 0x00000080) == 0x00000080);
}

######


public com.google.protobuf.ByteString getDeterministicSeed() {
    return deterministicSeed_;
}

######


public Builder setDeterministicSeed(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000080;
    deterministicSeed_ = value;
    onChanged();
    return this;
}

######


public Builder clearDeterministicSeed() {
    bitField0_ = (bitField0_ & ~0x00000080);
    deterministicSeed_ = getDefaultInstance().getDeterministicSeed();
    onChanged();
    return this;
}

######


public boolean hasEncryptedDeterministicSeed() {
    return ((bitField0_ & 0x00000100) == 0x00000100);
}

######


public org.galilelj.wallet.Protos.EncryptedData getEncryptedDeterministicSeed() {
    if (encryptedDeterministicSeedBuilder_ == null) {
        return encryptedDeterministicSeed_;
    } else {
        return encryptedDeterministicSeedBuilder_.getMessage();
    }
}

######


public Builder setEncryptedDeterministicSeed(org.galilelj.wallet.Protos.EncryptedData value) {
    if (encryptedDeterministicSeedBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        encryptedDeterministicSeed_ = value;
        onChanged();
    } else {
        encryptedDeterministicSeedBuilder_.setMessage(value);
    }
    bitField0_ |= 0x00000100;
    return this;
}

######


public Builder setEncryptedDeterministicSeed(org.galilelj.wallet.Protos.EncryptedData.Builder builderForValue) {
    if (encryptedDeterministicSeedBuilder_ == null) {
        encryptedDeterministicSeed_ = builderForValue.build();
        onChanged();
    } else {
        encryptedDeterministicSeedBuilder_.setMessage(builderForValue.build());
    }
    bitField0_ |= 0x00000100;
    return this;
}

######


public Builder mergeEncryptedDeterministicSeed(org.galilelj.wallet.Protos.EncryptedData value) {
    if (encryptedDeterministicSeedBuilder_ == null) {
        if (((bitField0_ & 0x00000100) == 0x00000100) && encryptedDeterministicSeed_ != org.galilelj.wallet.Protos.EncryptedData.getDefaultInstance()) {
            encryptedDeterministicSeed_ = org.galilelj.wallet.Protos.EncryptedData.newBuilder(encryptedDeterministicSeed_).mergeFrom(value).buildPartial();
        } else {
            encryptedDeterministicSeed_ = value;
        }
        onChanged();
    } else {
        encryptedDeterministicSeedBuilder_.mergeFrom(value);
    }
    bitField0_ |= 0x00000100;
    return this;
}

######


public Builder clearEncryptedDeterministicSeed() {
    if (encryptedDeterministicSeedBuilder_ == null) {
        encryptedDeterministicSeed_ = org.galilelj.wallet.Protos.EncryptedData.getDefaultInstance();
        onChanged();
    } else {
        encryptedDeterministicSeedBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000100);
    return this;
}

######


public org.galilelj.wallet.Protos.EncryptedData.Builder getEncryptedDeterministicSeedBuilder() {
    bitField0_ |= 0x00000100;
    onChanged();
    return getEncryptedDeterministicSeedFieldBuilder().getBuilder();
}

######


public org.galilelj.wallet.Protos.EncryptedDataOrBuilder getEncryptedDeterministicSeedOrBuilder() {
    if (encryptedDeterministicSeedBuilder_ != null) {
        return encryptedDeterministicSeedBuilder_.getMessageOrBuilder();
    } else {
        return encryptedDeterministicSeed_;
    }
}

######


private com.google.protobuf.SingleFieldBuilder<org.galilelj.wallet.Protos.EncryptedData, org.galilelj.wallet.Protos.EncryptedData.Builder, org.galilelj.wallet.Protos.EncryptedDataOrBuilder> getEncryptedDeterministicSeedFieldBuilder() {
    if (encryptedDeterministicSeedBuilder_ == null) {
        encryptedDeterministicSeedBuilder_ = new com.google.protobuf.SingleFieldBuilder<org.galilelj.wallet.Protos.EncryptedData, org.galilelj.wallet.Protos.EncryptedData.Builder, org.galilelj.wallet.Protos.EncryptedDataOrBuilder>(encryptedDeterministicSeed_, getParentForChildren(), isClean());
        encryptedDeterministicSeed_ = null;
    }
    return encryptedDeterministicSeedBuilder_;
}

######


boolean hasProgram();

######


com.google.protobuf.ByteString getProgram();

######


boolean hasCreationTimestamp();

######


long getCreationTimestamp();

######


public static Script getDefaultInstance() {
    return defaultInstance;
}

######


public Script getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Script_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Script_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.Script.class, org.galilelj.wallet.Protos.Script.Builder.class);
}

######


public Script parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new Script(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<Script> getParserForType() {
    return PARSER;
}

######


public boolean hasProgram() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public com.google.protobuf.ByteString getProgram() {
    return program_;
}

######


public boolean hasCreationTimestamp() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public long getCreationTimestamp() {
    return creationTimestamp_;
}

######


private void initFields() {
    program_ = com.google.protobuf.ByteString.EMPTY;
    creationTimestamp_ = 0L;
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasProgram()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (!hasCreationTimestamp()) {
        memoizedIsInitialized = 0;
        return false;
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, program_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt64(2, creationTimestamp_);
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, program_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(2, creationTimestamp_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.Script parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.Script parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Script parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.Script parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Script parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.Script parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Script parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.Script parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Script parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.Script parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.Script prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Script_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Script_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.Script.class, org.galilelj.wallet.Protos.Script.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    program_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    creationTimestamp_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000002);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Script_descriptor;
}

######


public org.galilelj.wallet.Protos.Script getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.Script.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.Script build() {
    org.galilelj.wallet.Protos.Script result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.Script buildPartial() {
    org.galilelj.wallet.Protos.Script result = new org.galilelj.wallet.Protos.Script(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.program_ = program_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.creationTimestamp_ = creationTimestamp_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.Script) {
        return mergeFrom((org.galilelj.wallet.Protos.Script) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.Script other) {
    if (other == org.galilelj.wallet.Protos.Script.getDefaultInstance())
        return this;
    if (other.hasProgram()) {
        setProgram(other.getProgram());
    }
    if (other.hasCreationTimestamp()) {
        setCreationTimestamp(other.getCreationTimestamp());
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasProgram()) {
        return false;
    }
    if (!hasCreationTimestamp()) {
        return false;
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.Script parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.Script) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasProgram() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public com.google.protobuf.ByteString getProgram() {
    return program_;
}

######


public Builder setProgram(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    program_ = value;
    onChanged();
    return this;
}

######


public Builder clearProgram() {
    bitField0_ = (bitField0_ & ~0x00000001);
    program_ = getDefaultInstance().getProgram();
    onChanged();
    return this;
}

######


public boolean hasCreationTimestamp() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public long getCreationTimestamp() {
    return creationTimestamp_;
}

######


public Builder setCreationTimestamp(long value) {
    bitField0_ |= 0x00000002;
    creationTimestamp_ = value;
    onChanged();
    return this;
}

######


public Builder clearCreationTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000002);
    creationTimestamp_ = 0L;
    onChanged();
    return this;
}

######


boolean hasTransactionOutPointHash();

######


com.google.protobuf.ByteString getTransactionOutPointHash();

######


boolean hasTransactionOutPointIndex();

######


int getTransactionOutPointIndex();

######


boolean hasScriptBytes();

######


com.google.protobuf.ByteString getScriptBytes();

######


boolean hasSequence();

######


int getSequence();

######


boolean hasValue();

######


long getValue();

######


public static TransactionInput getDefaultInstance() {
    return defaultInstance;
}

######


public TransactionInput getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionInput_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionInput_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.TransactionInput.class, org.galilelj.wallet.Protos.TransactionInput.Builder.class);
}

######


public TransactionInput parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new TransactionInput(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<TransactionInput> getParserForType() {
    return PARSER;
}

######


public boolean hasTransactionOutPointHash() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public com.google.protobuf.ByteString getTransactionOutPointHash() {
    return transactionOutPointHash_;
}

######


public boolean hasTransactionOutPointIndex() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public int getTransactionOutPointIndex() {
    return transactionOutPointIndex_;
}

######


public boolean hasScriptBytes() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public com.google.protobuf.ByteString getScriptBytes() {
    return scriptBytes_;
}

######


public boolean hasSequence() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public int getSequence() {
    return sequence_;
}

######


public boolean hasValue() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}

######


public long getValue() {
    return value_;
}

######


private void initFields() {
    transactionOutPointHash_ = com.google.protobuf.ByteString.EMPTY;
    transactionOutPointIndex_ = 0;
    scriptBytes_ = com.google.protobuf.ByteString.EMPTY;
    sequence_ = 0;
    value_ = 0L;
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasTransactionOutPointHash()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (!hasTransactionOutPointIndex()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (!hasScriptBytes()) {
        memoizedIsInitialized = 0;
        return false;
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, transactionOutPointHash_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeUInt32(2, transactionOutPointIndex_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(3, scriptBytes_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeUInt32(4, sequence_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeInt64(5, value_);
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, transactionOutPointHash_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeUInt32Size(2, transactionOutPointIndex_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(3, scriptBytes_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeUInt32Size(4, sequence_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(5, value_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.TransactionInput parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.TransactionInput parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionInput parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.TransactionInput parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionInput parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.TransactionInput parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionInput parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.TransactionInput parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionInput parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.TransactionInput parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.TransactionInput prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionInput_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionInput_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.TransactionInput.class, org.galilelj.wallet.Protos.TransactionInput.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    transactionOutPointHash_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    transactionOutPointIndex_ = 0;
    bitField0_ = (bitField0_ & ~0x00000002);
    scriptBytes_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000004);
    sequence_ = 0;
    bitField0_ = (bitField0_ & ~0x00000008);
    value_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000010);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionInput_descriptor;
}

######


public org.galilelj.wallet.Protos.TransactionInput getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.TransactionInput.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.TransactionInput build() {
    org.galilelj.wallet.Protos.TransactionInput result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.TransactionInput buildPartial() {
    org.galilelj.wallet.Protos.TransactionInput result = new org.galilelj.wallet.Protos.TransactionInput(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.transactionOutPointHash_ = transactionOutPointHash_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.transactionOutPointIndex_ = transactionOutPointIndex_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.scriptBytes_ = scriptBytes_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000008;
    }
    result.sequence_ = sequence_;
    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
        to_bitField0_ |= 0x00000010;
    }
    result.value_ = value_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.TransactionInput) {
        return mergeFrom((org.galilelj.wallet.Protos.TransactionInput) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.TransactionInput other) {
    if (other == org.galilelj.wallet.Protos.TransactionInput.getDefaultInstance())
        return this;
    if (other.hasTransactionOutPointHash()) {
        setTransactionOutPointHash(other.getTransactionOutPointHash());
    }
    if (other.hasTransactionOutPointIndex()) {
        setTransactionOutPointIndex(other.getTransactionOutPointIndex());
    }
    if (other.hasScriptBytes()) {
        setScriptBytes(other.getScriptBytes());
    }
    if (other.hasSequence()) {
        setSequence(other.getSequence());
    }
    if (other.hasValue()) {
        setValue(other.getValue());
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasTransactionOutPointHash()) {
        return false;
    }
    if (!hasTransactionOutPointIndex()) {
        return false;
    }
    if (!hasScriptBytes()) {
        return false;
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.TransactionInput parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.TransactionInput) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasTransactionOutPointHash() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public com.google.protobuf.ByteString getTransactionOutPointHash() {
    return transactionOutPointHash_;
}

######


public Builder setTransactionOutPointHash(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    transactionOutPointHash_ = value;
    onChanged();
    return this;
}

######


public Builder clearTransactionOutPointHash() {
    bitField0_ = (bitField0_ & ~0x00000001);
    transactionOutPointHash_ = getDefaultInstance().getTransactionOutPointHash();
    onChanged();
    return this;
}

######


public boolean hasTransactionOutPointIndex() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public int getTransactionOutPointIndex() {
    return transactionOutPointIndex_;
}

######


public Builder setTransactionOutPointIndex(int value) {
    bitField0_ |= 0x00000002;
    transactionOutPointIndex_ = value;
    onChanged();
    return this;
}

######


public Builder clearTransactionOutPointIndex() {
    bitField0_ = (bitField0_ & ~0x00000002);
    transactionOutPointIndex_ = 0;
    onChanged();
    return this;
}

######


public boolean hasScriptBytes() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public com.google.protobuf.ByteString getScriptBytes() {
    return scriptBytes_;
}

######


public Builder setScriptBytes(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000004;
    scriptBytes_ = value;
    onChanged();
    return this;
}

######


public Builder clearScriptBytes() {
    bitField0_ = (bitField0_ & ~0x00000004);
    scriptBytes_ = getDefaultInstance().getScriptBytes();
    onChanged();
    return this;
}

######


public boolean hasSequence() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public int getSequence() {
    return sequence_;
}

######


public Builder setSequence(int value) {
    bitField0_ |= 0x00000008;
    sequence_ = value;
    onChanged();
    return this;
}

######


public Builder clearSequence() {
    bitField0_ = (bitField0_ & ~0x00000008);
    sequence_ = 0;
    onChanged();
    return this;
}

######


public boolean hasValue() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}

######


public long getValue() {
    return value_;
}

######


public Builder setValue(long value) {
    bitField0_ |= 0x00000010;
    value_ = value;
    onChanged();
    return this;
}

######


public Builder clearValue() {
    bitField0_ = (bitField0_ & ~0x00000010);
    value_ = 0L;
    onChanged();
    return this;
}

######


boolean hasValue();

######


long getValue();

######


boolean hasScriptBytes();

######


com.google.protobuf.ByteString getScriptBytes();

######


boolean hasSpentByTransactionHash();

######


com.google.protobuf.ByteString getSpentByTransactionHash();

######


boolean hasSpentByTransactionIndex();

######


int getSpentByTransactionIndex();

######


public static TransactionOutput getDefaultInstance() {
    return defaultInstance;
}

######


public TransactionOutput getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionOutput_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionOutput_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.TransactionOutput.class, org.galilelj.wallet.Protos.TransactionOutput.Builder.class);
}

######


public TransactionOutput parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new TransactionOutput(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<TransactionOutput> getParserForType() {
    return PARSER;
}

######


public boolean hasValue() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public long getValue() {
    return value_;
}

######


public boolean hasScriptBytes() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getScriptBytes() {
    return scriptBytes_;
}

######


public boolean hasSpentByTransactionHash() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public com.google.protobuf.ByteString getSpentByTransactionHash() {
    return spentByTransactionHash_;
}

######


public boolean hasSpentByTransactionIndex() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public int getSpentByTransactionIndex() {
    return spentByTransactionIndex_;
}

######


private void initFields() {
    value_ = 0L;
    scriptBytes_ = com.google.protobuf.ByteString.EMPTY;
    spentByTransactionHash_ = com.google.protobuf.ByteString.EMPTY;
    spentByTransactionIndex_ = 0;
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasValue()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (!hasScriptBytes()) {
        memoizedIsInitialized = 0;
        return false;
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt64(1, value_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, scriptBytes_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(3, spentByTransactionHash_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(4, spentByTransactionIndex_);
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(1, value_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, scriptBytes_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(3, spentByTransactionHash_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(4, spentByTransactionIndex_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.TransactionOutput parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.TransactionOutput parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionOutput parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.TransactionOutput parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionOutput parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.TransactionOutput parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionOutput parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.TransactionOutput parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionOutput parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.TransactionOutput parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.TransactionOutput prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionOutput_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionOutput_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.TransactionOutput.class, org.galilelj.wallet.Protos.TransactionOutput.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    value_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000001);
    scriptBytes_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    spentByTransactionHash_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000004);
    spentByTransactionIndex_ = 0;
    bitField0_ = (bitField0_ & ~0x00000008);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionOutput_descriptor;
}

######


public org.galilelj.wallet.Protos.TransactionOutput getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.TransactionOutput.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.TransactionOutput build() {
    org.galilelj.wallet.Protos.TransactionOutput result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.TransactionOutput buildPartial() {
    org.galilelj.wallet.Protos.TransactionOutput result = new org.galilelj.wallet.Protos.TransactionOutput(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.value_ = value_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.scriptBytes_ = scriptBytes_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.spentByTransactionHash_ = spentByTransactionHash_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000008;
    }
    result.spentByTransactionIndex_ = spentByTransactionIndex_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.TransactionOutput) {
        return mergeFrom((org.galilelj.wallet.Protos.TransactionOutput) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.TransactionOutput other) {
    if (other == org.galilelj.wallet.Protos.TransactionOutput.getDefaultInstance())
        return this;
    if (other.hasValue()) {
        setValue(other.getValue());
    }
    if (other.hasScriptBytes()) {
        setScriptBytes(other.getScriptBytes());
    }
    if (other.hasSpentByTransactionHash()) {
        setSpentByTransactionHash(other.getSpentByTransactionHash());
    }
    if (other.hasSpentByTransactionIndex()) {
        setSpentByTransactionIndex(other.getSpentByTransactionIndex());
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasValue()) {
        return false;
    }
    if (!hasScriptBytes()) {
        return false;
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.TransactionOutput parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.TransactionOutput) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasValue() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public long getValue() {
    return value_;
}

######


public Builder setValue(long value) {
    bitField0_ |= 0x00000001;
    value_ = value;
    onChanged();
    return this;
}

######


public Builder clearValue() {
    bitField0_ = (bitField0_ & ~0x00000001);
    value_ = 0L;
    onChanged();
    return this;
}

######


public boolean hasScriptBytes() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getScriptBytes() {
    return scriptBytes_;
}

######


public Builder setScriptBytes(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000002;
    scriptBytes_ = value;
    onChanged();
    return this;
}

######


public Builder clearScriptBytes() {
    bitField0_ = (bitField0_ & ~0x00000002);
    scriptBytes_ = getDefaultInstance().getScriptBytes();
    onChanged();
    return this;
}

######


public boolean hasSpentByTransactionHash() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public com.google.protobuf.ByteString getSpentByTransactionHash() {
    return spentByTransactionHash_;
}

######


public Builder setSpentByTransactionHash(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000004;
    spentByTransactionHash_ = value;
    onChanged();
    return this;
}

######


public Builder clearSpentByTransactionHash() {
    bitField0_ = (bitField0_ & ~0x00000004);
    spentByTransactionHash_ = getDefaultInstance().getSpentByTransactionHash();
    onChanged();
    return this;
}

######


public boolean hasSpentByTransactionIndex() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public int getSpentByTransactionIndex() {
    return spentByTransactionIndex_;
}

######


public Builder setSpentByTransactionIndex(int value) {
    bitField0_ |= 0x00000008;
    spentByTransactionIndex_ = value;
    onChanged();
    return this;
}

######


public Builder clearSpentByTransactionIndex() {
    bitField0_ = (bitField0_ & ~0x00000008);
    spentByTransactionIndex_ = 0;
    onChanged();
    return this;
}

######


boolean hasType();

######


org.galilelj.wallet.Protos.TransactionConfidence.Type getType();

######


boolean hasAppearedAtHeight();

######


int getAppearedAtHeight();

######


boolean hasOverridingTransaction();

######


com.google.protobuf.ByteString getOverridingTransaction();

######


boolean hasDepth();

######


int getDepth();

######


java.util.List<org.galilelj.wallet.Protos.PeerAddress> getBroadcastByList();

######


org.galilelj.wallet.Protos.PeerAddress getBroadcastBy(int index);

######


int getBroadcastByCount();

######


java.util.List<? extends org.galilelj.wallet.Protos.PeerAddressOrBuilder> getBroadcastByOrBuilderList();

######


org.galilelj.wallet.Protos.PeerAddressOrBuilder getBroadcastByOrBuilder(int index);

######


boolean hasLastBroadcastedAt();

######


long getLastBroadcastedAt();

######


boolean hasSource();

######


org.galilelj.wallet.Protos.TransactionConfidence.Source getSource();

######


boolean hasIxType();

######


org.galilelj.wallet.Protos.TransactionConfidence.IXType getIxType();

######


public static TransactionConfidence getDefaultInstance() {
    return defaultInstance;
}

######


public TransactionConfidence getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionConfidence_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionConfidence_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.TransactionConfidence.class, org.galilelj.wallet.Protos.TransactionConfidence.Builder.class);
}

######


public TransactionConfidence parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new TransactionConfidence(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<TransactionConfidence> getParserForType() {
    return PARSER;
}

######


public final int getNumber() {
    return value;
}

######


public static Type valueOf(int value) {
    switch(value) {
        case 0:
            return UNKNOWN;
        case 1:
            return BUILDING;
        case 2:
            return PENDING;
        case 3:
            return NOT_IN_BEST_CHAIN;
        case 4:
            return DEAD;
        case 5:
            return IN_CONFLICT;
        default:
            return null;
    }
}

######


public static com.google.protobuf.Internal.EnumLiteMap<Type> internalGetValueMap() {
    return internalValueMap;
}

######


public Type findValueByNumber(int number) {
    return Type.valueOf(number);
}

######


public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
    return getDescriptor().getValues().get(index);
}

######


public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
    return getDescriptor();
}

######


public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
    return org.galilelj.wallet.Protos.TransactionConfidence.getDescriptor().getEnumTypes().get(0);
}

######


public static Type valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
    if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
    }
    return VALUES[desc.getIndex()];
}

######


public final int getNumber() {
    return value;
}

######


public static Source valueOf(int value) {
    switch(value) {
        case 0:
            return SOURCE_UNKNOWN;
        case 1:
            return SOURCE_NETWORK;
        case 2:
            return SOURCE_SELF;
        default:
            return null;
    }
}

######


public static com.google.protobuf.Internal.EnumLiteMap<Source> internalGetValueMap() {
    return internalValueMap;
}

######


public Source findValueByNumber(int number) {
    return Source.valueOf(number);
}

######


public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
    return getDescriptor().getValues().get(index);
}

######


public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
    return getDescriptor();
}

######


public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
    return org.galilelj.wallet.Protos.TransactionConfidence.getDescriptor().getEnumTypes().get(1);
}

######


public static Source valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
    if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
    }
    return VALUES[desc.getIndex()];
}

######


public final int getNumber() {
    return value;
}

######


public static IXType valueOf(int value) {
    switch(value) {
        case 0:
            return IX_NONE;
        case 1:
            return IX_REQUEST;
        case 2:
            return IX_LOCKED;
        default:
            return null;
    }
}

######


public static com.google.protobuf.Internal.EnumLiteMap<IXType> internalGetValueMap() {
    return internalValueMap;
}

######


public IXType findValueByNumber(int number) {
    return IXType.valueOf(number);
}

######


public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
    return getDescriptor().getValues().get(index);
}

######


public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
    return getDescriptor();
}

######


public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
    return org.galilelj.wallet.Protos.TransactionConfidence.getDescriptor().getEnumTypes().get(2);
}

######


public static IXType valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
    if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
    }
    return VALUES[desc.getIndex()];
}

######


public boolean hasType() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public org.galilelj.wallet.Protos.TransactionConfidence.Type getType() {
    return type_;
}

######


public boolean hasAppearedAtHeight() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public int getAppearedAtHeight() {
    return appearedAtHeight_;
}

######


public boolean hasOverridingTransaction() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public com.google.protobuf.ByteString getOverridingTransaction() {
    return overridingTransaction_;
}

######


public boolean hasDepth() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public int getDepth() {
    return depth_;
}

######


public java.util.List<org.galilelj.wallet.Protos.PeerAddress> getBroadcastByList() {
    return broadcastBy_;
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.PeerAddressOrBuilder> getBroadcastByOrBuilderList() {
    return broadcastBy_;
}

######


public int getBroadcastByCount() {
    return broadcastBy_.size();
}

######


public org.galilelj.wallet.Protos.PeerAddress getBroadcastBy(int index) {
    return broadcastBy_.get(index);
}

######


public org.galilelj.wallet.Protos.PeerAddressOrBuilder getBroadcastByOrBuilder(int index) {
    return broadcastBy_.get(index);
}

######


public boolean hasLastBroadcastedAt() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}

######


public long getLastBroadcastedAt() {
    return lastBroadcastedAt_;
}

######


public boolean hasSource() {
    return ((bitField0_ & 0x00000020) == 0x00000020);
}

######


public org.galilelj.wallet.Protos.TransactionConfidence.Source getSource() {
    return source_;
}

######


public boolean hasIxType() {
    return ((bitField0_ & 0x00000040) == 0x00000040);
}

######


public org.galilelj.wallet.Protos.TransactionConfidence.IXType getIxType() {
    return ixType_;
}

######


private void initFields() {
    type_ = org.galilelj.wallet.Protos.TransactionConfidence.Type.UNKNOWN;
    appearedAtHeight_ = 0;
    overridingTransaction_ = com.google.protobuf.ByteString.EMPTY;
    depth_ = 0;
    broadcastBy_ = java.util.Collections.emptyList();
    lastBroadcastedAt_ = 0L;
    source_ = org.galilelj.wallet.Protos.TransactionConfidence.Source.SOURCE_UNKNOWN;
    ixType_ = org.galilelj.wallet.Protos.TransactionConfidence.IXType.IX_NONE;
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    for (int i = 0; i < getBroadcastByCount(); i++) {
        if (!getBroadcastBy(i).isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeEnum(1, type_.getNumber());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(2, appearedAtHeight_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(3, overridingTransaction_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(4, depth_);
    }
    for (int i = 0; i < broadcastBy_.size(); i++) {
        output.writeMessage(6, broadcastBy_.get(i));
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeEnum(7, source_.getNumber());
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeInt64(8, lastBroadcastedAt_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeEnum(19, ixType_.getNumber());
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeEnumSize(1, type_.getNumber());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(2, appearedAtHeight_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(3, overridingTransaction_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(4, depth_);
    }
    for (int i = 0; i < broadcastBy_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(6, broadcastBy_.get(i));
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream.computeEnumSize(7, source_.getNumber());
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(8, lastBroadcastedAt_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream.computeEnumSize(19, ixType_.getNumber());
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.TransactionConfidence parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.TransactionConfidence parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionConfidence parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.TransactionConfidence parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionConfidence parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.TransactionConfidence parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionConfidence parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.TransactionConfidence parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionConfidence parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.TransactionConfidence parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.TransactionConfidence prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionConfidence_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionConfidence_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.TransactionConfidence.class, org.galilelj.wallet.Protos.TransactionConfidence.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        getBroadcastByFieldBuilder();
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    type_ = org.galilelj.wallet.Protos.TransactionConfidence.Type.UNKNOWN;
    bitField0_ = (bitField0_ & ~0x00000001);
    appearedAtHeight_ = 0;
    bitField0_ = (bitField0_ & ~0x00000002);
    overridingTransaction_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000004);
    depth_ = 0;
    bitField0_ = (bitField0_ & ~0x00000008);
    if (broadcastByBuilder_ == null) {
        broadcastBy_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
    } else {
        broadcastByBuilder_.clear();
    }
    lastBroadcastedAt_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000020);
    source_ = org.galilelj.wallet.Protos.TransactionConfidence.Source.SOURCE_UNKNOWN;
    bitField0_ = (bitField0_ & ~0x00000040);
    ixType_ = org.galilelj.wallet.Protos.TransactionConfidence.IXType.IX_NONE;
    bitField0_ = (bitField0_ & ~0x00000080);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionConfidence_descriptor;
}

######


public org.galilelj.wallet.Protos.TransactionConfidence getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.TransactionConfidence.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.TransactionConfidence build() {
    org.galilelj.wallet.Protos.TransactionConfidence result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.TransactionConfidence buildPartial() {
    org.galilelj.wallet.Protos.TransactionConfidence result = new org.galilelj.wallet.Protos.TransactionConfidence(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.type_ = type_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.appearedAtHeight_ = appearedAtHeight_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.overridingTransaction_ = overridingTransaction_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000008;
    }
    result.depth_ = depth_;
    if (broadcastByBuilder_ == null) {
        if (((bitField0_ & 0x00000010) == 0x00000010)) {
            broadcastBy_ = java.util.Collections.unmodifiableList(broadcastBy_);
            bitField0_ = (bitField0_ & ~0x00000010);
        }
        result.broadcastBy_ = broadcastBy_;
    } else {
        result.broadcastBy_ = broadcastByBuilder_.build();
    }
    if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
        to_bitField0_ |= 0x00000010;
    }
    result.lastBroadcastedAt_ = lastBroadcastedAt_;
    if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
        to_bitField0_ |= 0x00000020;
    }
    result.source_ = source_;
    if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
        to_bitField0_ |= 0x00000040;
    }
    result.ixType_ = ixType_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.TransactionConfidence) {
        return mergeFrom((org.galilelj.wallet.Protos.TransactionConfidence) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.TransactionConfidence other) {
    if (other == org.galilelj.wallet.Protos.TransactionConfidence.getDefaultInstance())
        return this;
    if (other.hasType()) {
        setType(other.getType());
    }
    if (other.hasAppearedAtHeight()) {
        setAppearedAtHeight(other.getAppearedAtHeight());
    }
    if (other.hasOverridingTransaction()) {
        setOverridingTransaction(other.getOverridingTransaction());
    }
    if (other.hasDepth()) {
        setDepth(other.getDepth());
    }
    if (broadcastByBuilder_ == null) {
        if (!other.broadcastBy_.isEmpty()) {
            if (broadcastBy_.isEmpty()) {
                broadcastBy_ = other.broadcastBy_;
                bitField0_ = (bitField0_ & ~0x00000010);
            } else {
                ensureBroadcastByIsMutable();
                broadcastBy_.addAll(other.broadcastBy_);
            }
            onChanged();
        }
    } else {
        if (!other.broadcastBy_.isEmpty()) {
            if (broadcastByBuilder_.isEmpty()) {
                broadcastByBuilder_.dispose();
                broadcastByBuilder_ = null;
                broadcastBy_ = other.broadcastBy_;
                bitField0_ = (bitField0_ & ~0x00000010);
                broadcastByBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getBroadcastByFieldBuilder() : null;
            } else {
                broadcastByBuilder_.addAllMessages(other.broadcastBy_);
            }
        }
    }
    if (other.hasLastBroadcastedAt()) {
        setLastBroadcastedAt(other.getLastBroadcastedAt());
    }
    if (other.hasSource()) {
        setSource(other.getSource());
    }
    if (other.hasIxType()) {
        setIxType(other.getIxType());
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    for (int i = 0; i < getBroadcastByCount(); i++) {
        if (!getBroadcastBy(i).isInitialized()) {
            return false;
        }
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.TransactionConfidence parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.TransactionConfidence) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasType() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public org.galilelj.wallet.Protos.TransactionConfidence.Type getType() {
    return type_;
}

######


public Builder setType(org.galilelj.wallet.Protos.TransactionConfidence.Type value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    type_ = value;
    onChanged();
    return this;
}

######


public Builder clearType() {
    bitField0_ = (bitField0_ & ~0x00000001);
    type_ = org.galilelj.wallet.Protos.TransactionConfidence.Type.UNKNOWN;
    onChanged();
    return this;
}

######


public boolean hasAppearedAtHeight() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public int getAppearedAtHeight() {
    return appearedAtHeight_;
}

######


public Builder setAppearedAtHeight(int value) {
    bitField0_ |= 0x00000002;
    appearedAtHeight_ = value;
    onChanged();
    return this;
}

######


public Builder clearAppearedAtHeight() {
    bitField0_ = (bitField0_ & ~0x00000002);
    appearedAtHeight_ = 0;
    onChanged();
    return this;
}

######


public boolean hasOverridingTransaction() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public com.google.protobuf.ByteString getOverridingTransaction() {
    return overridingTransaction_;
}

######


public Builder setOverridingTransaction(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000004;
    overridingTransaction_ = value;
    onChanged();
    return this;
}

######


public Builder clearOverridingTransaction() {
    bitField0_ = (bitField0_ & ~0x00000004);
    overridingTransaction_ = getDefaultInstance().getOverridingTransaction();
    onChanged();
    return this;
}

######


public boolean hasDepth() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public int getDepth() {
    return depth_;
}

######


public Builder setDepth(int value) {
    bitField0_ |= 0x00000008;
    depth_ = value;
    onChanged();
    return this;
}

######


public Builder clearDepth() {
    bitField0_ = (bitField0_ & ~0x00000008);
    depth_ = 0;
    onChanged();
    return this;
}

######


private void ensureBroadcastByIsMutable() {
    if (!((bitField0_ & 0x00000010) == 0x00000010)) {
        broadcastBy_ = new java.util.ArrayList<org.galilelj.wallet.Protos.PeerAddress>(broadcastBy_);
        bitField0_ |= 0x00000010;
    }
}

######


public java.util.List<org.galilelj.wallet.Protos.PeerAddress> getBroadcastByList() {
    if (broadcastByBuilder_ == null) {
        return java.util.Collections.unmodifiableList(broadcastBy_);
    } else {
        return broadcastByBuilder_.getMessageList();
    }
}

######


public int getBroadcastByCount() {
    if (broadcastByBuilder_ == null) {
        return broadcastBy_.size();
    } else {
        return broadcastByBuilder_.getCount();
    }
}

######


public org.galilelj.wallet.Protos.PeerAddress getBroadcastBy(int index) {
    if (broadcastByBuilder_ == null) {
        return broadcastBy_.get(index);
    } else {
        return broadcastByBuilder_.getMessage(index);
    }
}

######


public Builder setBroadcastBy(int index, org.galilelj.wallet.Protos.PeerAddress value) {
    if (broadcastByBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureBroadcastByIsMutable();
        broadcastBy_.set(index, value);
        onChanged();
    } else {
        broadcastByBuilder_.setMessage(index, value);
    }
    return this;
}

######


public Builder setBroadcastBy(int index, org.galilelj.wallet.Protos.PeerAddress.Builder builderForValue) {
    if (broadcastByBuilder_ == null) {
        ensureBroadcastByIsMutable();
        broadcastBy_.set(index, builderForValue.build());
        onChanged();
    } else {
        broadcastByBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addBroadcastBy(org.galilelj.wallet.Protos.PeerAddress value) {
    if (broadcastByBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureBroadcastByIsMutable();
        broadcastBy_.add(value);
        onChanged();
    } else {
        broadcastByBuilder_.addMessage(value);
    }
    return this;
}

######


public Builder addBroadcastBy(int index, org.galilelj.wallet.Protos.PeerAddress value) {
    if (broadcastByBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureBroadcastByIsMutable();
        broadcastBy_.add(index, value);
        onChanged();
    } else {
        broadcastByBuilder_.addMessage(index, value);
    }
    return this;
}

######


public Builder addBroadcastBy(org.galilelj.wallet.Protos.PeerAddress.Builder builderForValue) {
    if (broadcastByBuilder_ == null) {
        ensureBroadcastByIsMutable();
        broadcastBy_.add(builderForValue.build());
        onChanged();
    } else {
        broadcastByBuilder_.addMessage(builderForValue.build());
    }
    return this;
}

######


public Builder addBroadcastBy(int index, org.galilelj.wallet.Protos.PeerAddress.Builder builderForValue) {
    if (broadcastByBuilder_ == null) {
        ensureBroadcastByIsMutable();
        broadcastBy_.add(index, builderForValue.build());
        onChanged();
    } else {
        broadcastByBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addAllBroadcastBy(java.lang.Iterable<? extends org.galilelj.wallet.Protos.PeerAddress> values) {
    if (broadcastByBuilder_ == null) {
        ensureBroadcastByIsMutable();
        super.addAll(values, broadcastBy_);
        onChanged();
    } else {
        broadcastByBuilder_.addAllMessages(values);
    }
    return this;
}

######


public Builder clearBroadcastBy() {
    if (broadcastByBuilder_ == null) {
        broadcastBy_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
    } else {
        broadcastByBuilder_.clear();
    }
    return this;
}

######


public Builder removeBroadcastBy(int index) {
    if (broadcastByBuilder_ == null) {
        ensureBroadcastByIsMutable();
        broadcastBy_.remove(index);
        onChanged();
    } else {
        broadcastByBuilder_.remove(index);
    }
    return this;
}

######


public org.galilelj.wallet.Protos.PeerAddress.Builder getBroadcastByBuilder(int index) {
    return getBroadcastByFieldBuilder().getBuilder(index);
}

######


public org.galilelj.wallet.Protos.PeerAddressOrBuilder getBroadcastByOrBuilder(int index) {
    if (broadcastByBuilder_ == null) {
        return broadcastBy_.get(index);
    } else {
        return broadcastByBuilder_.getMessageOrBuilder(index);
    }
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.PeerAddressOrBuilder> getBroadcastByOrBuilderList() {
    if (broadcastByBuilder_ != null) {
        return broadcastByBuilder_.getMessageOrBuilderList();
    } else {
        return java.util.Collections.unmodifiableList(broadcastBy_);
    }
}

######


public org.galilelj.wallet.Protos.PeerAddress.Builder addBroadcastByBuilder() {
    return getBroadcastByFieldBuilder().addBuilder(org.galilelj.wallet.Protos.PeerAddress.getDefaultInstance());
}

######


public org.galilelj.wallet.Protos.PeerAddress.Builder addBroadcastByBuilder(int index) {
    return getBroadcastByFieldBuilder().addBuilder(index, org.galilelj.wallet.Protos.PeerAddress.getDefaultInstance());
}

######


public java.util.List<org.galilelj.wallet.Protos.PeerAddress.Builder> getBroadcastByBuilderList() {
    return getBroadcastByFieldBuilder().getBuilderList();
}

######


private com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.PeerAddress, org.galilelj.wallet.Protos.PeerAddress.Builder, org.galilelj.wallet.Protos.PeerAddressOrBuilder> getBroadcastByFieldBuilder() {
    if (broadcastByBuilder_ == null) {
        broadcastByBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.PeerAddress, org.galilelj.wallet.Protos.PeerAddress.Builder, org.galilelj.wallet.Protos.PeerAddressOrBuilder>(broadcastBy_, ((bitField0_ & 0x00000010) == 0x00000010), getParentForChildren(), isClean());
        broadcastBy_ = null;
    }
    return broadcastByBuilder_;
}

######


public boolean hasLastBroadcastedAt() {
    return ((bitField0_ & 0x00000020) == 0x00000020);
}

######


public long getLastBroadcastedAt() {
    return lastBroadcastedAt_;
}

######


public Builder setLastBroadcastedAt(long value) {
    bitField0_ |= 0x00000020;
    lastBroadcastedAt_ = value;
    onChanged();
    return this;
}

######


public Builder clearLastBroadcastedAt() {
    bitField0_ = (bitField0_ & ~0x00000020);
    lastBroadcastedAt_ = 0L;
    onChanged();
    return this;
}

######


public boolean hasSource() {
    return ((bitField0_ & 0x00000040) == 0x00000040);
}

######


public org.galilelj.wallet.Protos.TransactionConfidence.Source getSource() {
    return source_;
}

######


public Builder setSource(org.galilelj.wallet.Protos.TransactionConfidence.Source value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000040;
    source_ = value;
    onChanged();
    return this;
}

######


public Builder clearSource() {
    bitField0_ = (bitField0_ & ~0x00000040);
    source_ = org.galilelj.wallet.Protos.TransactionConfidence.Source.SOURCE_UNKNOWN;
    onChanged();
    return this;
}

######


public boolean hasIxType() {
    return ((bitField0_ & 0x00000080) == 0x00000080);
}

######


public org.galilelj.wallet.Protos.TransactionConfidence.IXType getIxType() {
    return ixType_;
}

######


public Builder setIxType(org.galilelj.wallet.Protos.TransactionConfidence.IXType value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000080;
    ixType_ = value;
    onChanged();
    return this;
}

######


public Builder clearIxType() {
    bitField0_ = (bitField0_ & ~0x00000080);
    ixType_ = org.galilelj.wallet.Protos.TransactionConfidence.IXType.IX_NONE;
    onChanged();
    return this;
}

######


boolean hasVersion();

######


int getVersion();

######


boolean hasHash();

######


com.google.protobuf.ByteString getHash();

######


boolean hasPool();

######


org.galilelj.wallet.Protos.Transaction.Pool getPool();

######


boolean hasLockTime();

######


int getLockTime();

######


boolean hasUpdatedAt();

######


long getUpdatedAt();

######


java.util.List<org.galilelj.wallet.Protos.TransactionInput> getTransactionInputList();

######


org.galilelj.wallet.Protos.TransactionInput getTransactionInput(int index);

######


int getTransactionInputCount();

######


java.util.List<? extends org.galilelj.wallet.Protos.TransactionInputOrBuilder> getTransactionInputOrBuilderList();

######


org.galilelj.wallet.Protos.TransactionInputOrBuilder getTransactionInputOrBuilder(int index);

######


java.util.List<org.galilelj.wallet.Protos.TransactionOutput> getTransactionOutputList();

######


org.galilelj.wallet.Protos.TransactionOutput getTransactionOutput(int index);

######


int getTransactionOutputCount();

######


java.util.List<? extends org.galilelj.wallet.Protos.TransactionOutputOrBuilder> getTransactionOutputOrBuilderList();

######


org.galilelj.wallet.Protos.TransactionOutputOrBuilder getTransactionOutputOrBuilder(int index);

######


java.util.List<com.google.protobuf.ByteString> getBlockHashList();

######


int getBlockHashCount();

######


com.google.protobuf.ByteString getBlockHash(int index);

######


java.util.List<java.lang.Integer> getBlockRelativityOffsetsList();

######


int getBlockRelativityOffsetsCount();

######


int getBlockRelativityOffsets(int index);

######


boolean hasConfidence();

######


org.galilelj.wallet.Protos.TransactionConfidence getConfidence();

######


org.galilelj.wallet.Protos.TransactionConfidenceOrBuilder getConfidenceOrBuilder();

######


boolean hasPurpose();

######


org.galilelj.wallet.Protos.Transaction.Purpose getPurpose();

######


boolean hasExchangeRate();

######


org.galilelj.wallet.Protos.ExchangeRate getExchangeRate();

######


org.galilelj.wallet.Protos.ExchangeRateOrBuilder getExchangeRateOrBuilder();

######


boolean hasMemo();

######


java.lang.String getMemo();

######


com.google.protobuf.ByteString getMemoBytes();

######


public static Transaction getDefaultInstance() {
    return defaultInstance;
}

######


public Transaction getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Transaction_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Transaction_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.Transaction.class, org.galilelj.wallet.Protos.Transaction.Builder.class);
}

######


public Transaction parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new Transaction(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<Transaction> getParserForType() {
    return PARSER;
}

######


public final int getNumber() {
    return value;
}

######


public static Pool valueOf(int value) {
    switch(value) {
        case 4:
            return UNSPENT;
        case 5:
            return SPENT;
        case 2:
            return INACTIVE;
        case 10:
            return DEAD;
        case 16:
            return PENDING;
        case 18:
            return PENDING_INACTIVE;
        default:
            return null;
    }
}

######


public static com.google.protobuf.Internal.EnumLiteMap<Pool> internalGetValueMap() {
    return internalValueMap;
}

######


public Pool findValueByNumber(int number) {
    return Pool.valueOf(number);
}

######


public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
    return getDescriptor().getValues().get(index);
}

######


public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
    return getDescriptor();
}

######


public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
    return org.galilelj.wallet.Protos.Transaction.getDescriptor().getEnumTypes().get(0);
}

######


public static Pool valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
    if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
    }
    return VALUES[desc.getIndex()];
}

######


public final int getNumber() {
    return value;
}

######


public static Purpose valueOf(int value) {
    switch(value) {
        case 0:
            return UNKNOWN;
        case 1:
            return USER_PAYMENT;
        case 2:
            return KEY_ROTATION;
        case 3:
            return ASSURANCE_CONTRACT_CLAIM;
        case 4:
            return ASSURANCE_CONTRACT_PLEDGE;
        case 5:
            return ASSURANCE_CONTRACT_STUB;
        case 6:
            return RAISE_FEE;
        default:
            return null;
    }
}

######


public static com.google.protobuf.Internal.EnumLiteMap<Purpose> internalGetValueMap() {
    return internalValueMap;
}

######


public Purpose findValueByNumber(int number) {
    return Purpose.valueOf(number);
}

######


public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
    return getDescriptor().getValues().get(index);
}

######


public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
    return getDescriptor();
}

######


public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
    return org.galilelj.wallet.Protos.Transaction.getDescriptor().getEnumTypes().get(1);
}

######


public static Purpose valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
    if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
    }
    return VALUES[desc.getIndex()];
}

######


public boolean hasVersion() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public int getVersion() {
    return version_;
}

######


public boolean hasHash() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getHash() {
    return hash_;
}

######


public boolean hasPool() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public org.galilelj.wallet.Protos.Transaction.Pool getPool() {
    return pool_;
}

######


public boolean hasLockTime() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public int getLockTime() {
    return lockTime_;
}

######


public boolean hasUpdatedAt() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}

######


public long getUpdatedAt() {
    return updatedAt_;
}

######


public java.util.List<org.galilelj.wallet.Protos.TransactionInput> getTransactionInputList() {
    return transactionInput_;
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.TransactionInputOrBuilder> getTransactionInputOrBuilderList() {
    return transactionInput_;
}

######


public int getTransactionInputCount() {
    return transactionInput_.size();
}

######


public org.galilelj.wallet.Protos.TransactionInput getTransactionInput(int index) {
    return transactionInput_.get(index);
}

######


public org.galilelj.wallet.Protos.TransactionInputOrBuilder getTransactionInputOrBuilder(int index) {
    return transactionInput_.get(index);
}

######


public java.util.List<org.galilelj.wallet.Protos.TransactionOutput> getTransactionOutputList() {
    return transactionOutput_;
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.TransactionOutputOrBuilder> getTransactionOutputOrBuilderList() {
    return transactionOutput_;
}

######


public int getTransactionOutputCount() {
    return transactionOutput_.size();
}

######


public org.galilelj.wallet.Protos.TransactionOutput getTransactionOutput(int index) {
    return transactionOutput_.get(index);
}

######


public org.galilelj.wallet.Protos.TransactionOutputOrBuilder getTransactionOutputOrBuilder(int index) {
    return transactionOutput_.get(index);
}

######


public java.util.List<com.google.protobuf.ByteString> getBlockHashList() {
    return blockHash_;
}

######


public int getBlockHashCount() {
    return blockHash_.size();
}

######


public com.google.protobuf.ByteString getBlockHash(int index) {
    return blockHash_.get(index);
}

######


public java.util.List<java.lang.Integer> getBlockRelativityOffsetsList() {
    return blockRelativityOffsets_;
}

######


public int getBlockRelativityOffsetsCount() {
    return blockRelativityOffsets_.size();
}

######


public int getBlockRelativityOffsets(int index) {
    return blockRelativityOffsets_.get(index);
}

######


public boolean hasConfidence() {
    return ((bitField0_ & 0x00000020) == 0x00000020);
}

######


public org.galilelj.wallet.Protos.TransactionConfidence getConfidence() {
    return confidence_;
}

######


public org.galilelj.wallet.Protos.TransactionConfidenceOrBuilder getConfidenceOrBuilder() {
    return confidence_;
}

######


public boolean hasPurpose() {
    return ((bitField0_ & 0x00000040) == 0x00000040);
}

######


public org.galilelj.wallet.Protos.Transaction.Purpose getPurpose() {
    return purpose_;
}

######


public boolean hasExchangeRate() {
    return ((bitField0_ & 0x00000080) == 0x00000080);
}

######


public org.galilelj.wallet.Protos.ExchangeRate getExchangeRate() {
    return exchangeRate_;
}

######


public org.galilelj.wallet.Protos.ExchangeRateOrBuilder getExchangeRateOrBuilder() {
    return exchangeRate_;
}

######


public boolean hasMemo() {
    return ((bitField0_ & 0x00000100) == 0x00000100);
}

######


public java.lang.String getMemo() {
    java.lang.Object ref = memo_;
    if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
    } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
            memo_ = s;
        }
        return s;
    }
}

######


public com.google.protobuf.ByteString getMemoBytes() {
    java.lang.Object ref = memo_;
    if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        memo_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


private void initFields() {
    version_ = 0;
    hash_ = com.google.protobuf.ByteString.EMPTY;
    pool_ = org.galilelj.wallet.Protos.Transaction.Pool.UNSPENT;
    lockTime_ = 0;
    updatedAt_ = 0L;
    transactionInput_ = java.util.Collections.emptyList();
    transactionOutput_ = java.util.Collections.emptyList();
    blockHash_ = java.util.Collections.emptyList();
    blockRelativityOffsets_ = java.util.Collections.emptyList();
    confidence_ = org.galilelj.wallet.Protos.TransactionConfidence.getDefaultInstance();
    purpose_ = org.galilelj.wallet.Protos.Transaction.Purpose.UNKNOWN;
    exchangeRate_ = org.galilelj.wallet.Protos.ExchangeRate.getDefaultInstance();
    memo_ = "";
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasVersion()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (!hasHash()) {
        memoizedIsInitialized = 0;
        return false;
    }
    for (int i = 0; i < getTransactionInputCount(); i++) {
        if (!getTransactionInput(i).isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    for (int i = 0; i < getTransactionOutputCount(); i++) {
        if (!getTransactionOutput(i).isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    if (hasConfidence()) {
        if (!getConfidence().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    if (hasExchangeRate()) {
        if (!getExchangeRate().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, version_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, hash_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeEnum(3, pool_.getNumber());
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeUInt32(4, lockTime_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeInt64(5, updatedAt_);
    }
    for (int i = 0; i < transactionInput_.size(); i++) {
        output.writeMessage(6, transactionInput_.get(i));
    }
    for (int i = 0; i < transactionOutput_.size(); i++) {
        output.writeMessage(7, transactionOutput_.get(i));
    }
    for (int i = 0; i < blockHash_.size(); i++) {
        output.writeBytes(8, blockHash_.get(i));
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeMessage(9, confidence_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeEnum(10, purpose_.getNumber());
    }
    for (int i = 0; i < blockRelativityOffsets_.size(); i++) {
        output.writeInt32(11, blockRelativityOffsets_.get(i));
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeMessage(12, exchangeRate_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeBytes(13, getMemoBytes());
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, version_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, hash_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeEnumSize(3, pool_.getNumber());
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeUInt32Size(4, lockTime_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(5, updatedAt_);
    }
    for (int i = 0; i < transactionInput_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(6, transactionInput_.get(i));
    }
    for (int i = 0; i < transactionOutput_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(7, transactionOutput_.get(i));
    }
    {
        int dataSize = 0;
        for (int i = 0; i < blockHash_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(blockHash_.get(i));
        }
        size += dataSize;
        size += 1 * getBlockHashList().size();
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(9, confidence_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream.computeEnumSize(10, purpose_.getNumber());
    }
    {
        int dataSize = 0;
        for (int i = 0; i < blockRelativityOffsets_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(blockRelativityOffsets_.get(i));
        }
        size += dataSize;
        size += 1 * getBlockRelativityOffsetsList().size();
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(12, exchangeRate_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(13, getMemoBytes());
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.Transaction parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.Transaction parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Transaction parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.Transaction parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Transaction parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.Transaction parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Transaction parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.Transaction parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Transaction parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.Transaction parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.Transaction prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Transaction_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Transaction_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.Transaction.class, org.galilelj.wallet.Protos.Transaction.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        getTransactionInputFieldBuilder();
        getTransactionOutputFieldBuilder();
        getConfidenceFieldBuilder();
        getExchangeRateFieldBuilder();
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    version_ = 0;
    bitField0_ = (bitField0_ & ~0x00000001);
    hash_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    pool_ = org.galilelj.wallet.Protos.Transaction.Pool.UNSPENT;
    bitField0_ = (bitField0_ & ~0x00000004);
    lockTime_ = 0;
    bitField0_ = (bitField0_ & ~0x00000008);
    updatedAt_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000010);
    if (transactionInputBuilder_ == null) {
        transactionInput_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000020);
    } else {
        transactionInputBuilder_.clear();
    }
    if (transactionOutputBuilder_ == null) {
        transactionOutput_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000040);
    } else {
        transactionOutputBuilder_.clear();
    }
    blockHash_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000080);
    blockRelativityOffsets_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000100);
    if (confidenceBuilder_ == null) {
        confidence_ = org.galilelj.wallet.Protos.TransactionConfidence.getDefaultInstance();
    } else {
        confidenceBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000200);
    purpose_ = org.galilelj.wallet.Protos.Transaction.Purpose.UNKNOWN;
    bitField0_ = (bitField0_ & ~0x00000400);
    if (exchangeRateBuilder_ == null) {
        exchangeRate_ = org.galilelj.wallet.Protos.ExchangeRate.getDefaultInstance();
    } else {
        exchangeRateBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000800);
    memo_ = "";
    bitField0_ = (bitField0_ & ~0x00001000);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Transaction_descriptor;
}

######


public org.galilelj.wallet.Protos.Transaction getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.Transaction.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.Transaction build() {
    org.galilelj.wallet.Protos.Transaction result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.Transaction buildPartial() {
    org.galilelj.wallet.Protos.Transaction result = new org.galilelj.wallet.Protos.Transaction(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.version_ = version_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.hash_ = hash_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.pool_ = pool_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000008;
    }
    result.lockTime_ = lockTime_;
    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
        to_bitField0_ |= 0x00000010;
    }
    result.updatedAt_ = updatedAt_;
    if (transactionInputBuilder_ == null) {
        if (((bitField0_ & 0x00000020) == 0x00000020)) {
            transactionInput_ = java.util.Collections.unmodifiableList(transactionInput_);
            bitField0_ = (bitField0_ & ~0x00000020);
        }
        result.transactionInput_ = transactionInput_;
    } else {
        result.transactionInput_ = transactionInputBuilder_.build();
    }
    if (transactionOutputBuilder_ == null) {
        if (((bitField0_ & 0x00000040) == 0x00000040)) {
            transactionOutput_ = java.util.Collections.unmodifiableList(transactionOutput_);
            bitField0_ = (bitField0_ & ~0x00000040);
        }
        result.transactionOutput_ = transactionOutput_;
    } else {
        result.transactionOutput_ = transactionOutputBuilder_.build();
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        blockHash_ = java.util.Collections.unmodifiableList(blockHash_);
        bitField0_ = (bitField0_ & ~0x00000080);
    }
    result.blockHash_ = blockHash_;
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        blockRelativityOffsets_ = java.util.Collections.unmodifiableList(blockRelativityOffsets_);
        bitField0_ = (bitField0_ & ~0x00000100);
    }
    result.blockRelativityOffsets_ = blockRelativityOffsets_;
    if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
        to_bitField0_ |= 0x00000020;
    }
    if (confidenceBuilder_ == null) {
        result.confidence_ = confidence_;
    } else {
        result.confidence_ = confidenceBuilder_.build();
    }
    if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
        to_bitField0_ |= 0x00000040;
    }
    result.purpose_ = purpose_;
    if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
        to_bitField0_ |= 0x00000080;
    }
    if (exchangeRateBuilder_ == null) {
        result.exchangeRate_ = exchangeRate_;
    } else {
        result.exchangeRate_ = exchangeRateBuilder_.build();
    }
    if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
        to_bitField0_ |= 0x00000100;
    }
    result.memo_ = memo_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.Transaction) {
        return mergeFrom((org.galilelj.wallet.Protos.Transaction) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.Transaction other) {
    if (other == org.galilelj.wallet.Protos.Transaction.getDefaultInstance())
        return this;
    if (other.hasVersion()) {
        setVersion(other.getVersion());
    }
    if (other.hasHash()) {
        setHash(other.getHash());
    }
    if (other.hasPool()) {
        setPool(other.getPool());
    }
    if (other.hasLockTime()) {
        setLockTime(other.getLockTime());
    }
    if (other.hasUpdatedAt()) {
        setUpdatedAt(other.getUpdatedAt());
    }
    if (transactionInputBuilder_ == null) {
        if (!other.transactionInput_.isEmpty()) {
            if (transactionInput_.isEmpty()) {
                transactionInput_ = other.transactionInput_;
                bitField0_ = (bitField0_ & ~0x00000020);
            } else {
                ensureTransactionInputIsMutable();
                transactionInput_.addAll(other.transactionInput_);
            }
            onChanged();
        }
    } else {
        if (!other.transactionInput_.isEmpty()) {
            if (transactionInputBuilder_.isEmpty()) {
                transactionInputBuilder_.dispose();
                transactionInputBuilder_ = null;
                transactionInput_ = other.transactionInput_;
                bitField0_ = (bitField0_ & ~0x00000020);
                transactionInputBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getTransactionInputFieldBuilder() : null;
            } else {
                transactionInputBuilder_.addAllMessages(other.transactionInput_);
            }
        }
    }
    if (transactionOutputBuilder_ == null) {
        if (!other.transactionOutput_.isEmpty()) {
            if (transactionOutput_.isEmpty()) {
                transactionOutput_ = other.transactionOutput_;
                bitField0_ = (bitField0_ & ~0x00000040);
            } else {
                ensureTransactionOutputIsMutable();
                transactionOutput_.addAll(other.transactionOutput_);
            }
            onChanged();
        }
    } else {
        if (!other.transactionOutput_.isEmpty()) {
            if (transactionOutputBuilder_.isEmpty()) {
                transactionOutputBuilder_.dispose();
                transactionOutputBuilder_ = null;
                transactionOutput_ = other.transactionOutput_;
                bitField0_ = (bitField0_ & ~0x00000040);
                transactionOutputBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getTransactionOutputFieldBuilder() : null;
            } else {
                transactionOutputBuilder_.addAllMessages(other.transactionOutput_);
            }
        }
    }
    if (!other.blockHash_.isEmpty()) {
        if (blockHash_.isEmpty()) {
            blockHash_ = other.blockHash_;
            bitField0_ = (bitField0_ & ~0x00000080);
        } else {
            ensureBlockHashIsMutable();
            blockHash_.addAll(other.blockHash_);
        }
        onChanged();
    }
    if (!other.blockRelativityOffsets_.isEmpty()) {
        if (blockRelativityOffsets_.isEmpty()) {
            blockRelativityOffsets_ = other.blockRelativityOffsets_;
            bitField0_ = (bitField0_ & ~0x00000100);
        } else {
            ensureBlockRelativityOffsetsIsMutable();
            blockRelativityOffsets_.addAll(other.blockRelativityOffsets_);
        }
        onChanged();
    }
    if (other.hasConfidence()) {
        mergeConfidence(other.getConfidence());
    }
    if (other.hasPurpose()) {
        setPurpose(other.getPurpose());
    }
    if (other.hasExchangeRate()) {
        mergeExchangeRate(other.getExchangeRate());
    }
    if (other.hasMemo()) {
        bitField0_ |= 0x00001000;
        memo_ = other.memo_;
        onChanged();
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasVersion()) {
        return false;
    }
    if (!hasHash()) {
        return false;
    }
    for (int i = 0; i < getTransactionInputCount(); i++) {
        if (!getTransactionInput(i).isInitialized()) {
            return false;
        }
    }
    for (int i = 0; i < getTransactionOutputCount(); i++) {
        if (!getTransactionOutput(i).isInitialized()) {
            return false;
        }
    }
    if (hasConfidence()) {
        if (!getConfidence().isInitialized()) {
            return false;
        }
    }
    if (hasExchangeRate()) {
        if (!getExchangeRate().isInitialized()) {
            return false;
        }
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.Transaction parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.Transaction) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasVersion() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public int getVersion() {
    return version_;
}

######


public Builder setVersion(int value) {
    bitField0_ |= 0x00000001;
    version_ = value;
    onChanged();
    return this;
}

######


public Builder clearVersion() {
    bitField0_ = (bitField0_ & ~0x00000001);
    version_ = 0;
    onChanged();
    return this;
}

######


public boolean hasHash() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getHash() {
    return hash_;
}

######


public Builder setHash(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000002;
    hash_ = value;
    onChanged();
    return this;
}

######


public Builder clearHash() {
    bitField0_ = (bitField0_ & ~0x00000002);
    hash_ = getDefaultInstance().getHash();
    onChanged();
    return this;
}

######


public boolean hasPool() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public org.galilelj.wallet.Protos.Transaction.Pool getPool() {
    return pool_;
}

######


public Builder setPool(org.galilelj.wallet.Protos.Transaction.Pool value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000004;
    pool_ = value;
    onChanged();
    return this;
}

######


public Builder clearPool() {
    bitField0_ = (bitField0_ & ~0x00000004);
    pool_ = org.galilelj.wallet.Protos.Transaction.Pool.UNSPENT;
    onChanged();
    return this;
}

######


public boolean hasLockTime() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public int getLockTime() {
    return lockTime_;
}

######


public Builder setLockTime(int value) {
    bitField0_ |= 0x00000008;
    lockTime_ = value;
    onChanged();
    return this;
}

######


public Builder clearLockTime() {
    bitField0_ = (bitField0_ & ~0x00000008);
    lockTime_ = 0;
    onChanged();
    return this;
}

######


public boolean hasUpdatedAt() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}

######


public long getUpdatedAt() {
    return updatedAt_;
}

######


public Builder setUpdatedAt(long value) {
    bitField0_ |= 0x00000010;
    updatedAt_ = value;
    onChanged();
    return this;
}

######


public Builder clearUpdatedAt() {
    bitField0_ = (bitField0_ & ~0x00000010);
    updatedAt_ = 0L;
    onChanged();
    return this;
}

######


private void ensureTransactionInputIsMutable() {
    if (!((bitField0_ & 0x00000020) == 0x00000020)) {
        transactionInput_ = new java.util.ArrayList<org.galilelj.wallet.Protos.TransactionInput>(transactionInput_);
        bitField0_ |= 0x00000020;
    }
}

######


public java.util.List<org.galilelj.wallet.Protos.TransactionInput> getTransactionInputList() {
    if (transactionInputBuilder_ == null) {
        return java.util.Collections.unmodifiableList(transactionInput_);
    } else {
        return transactionInputBuilder_.getMessageList();
    }
}

######


public int getTransactionInputCount() {
    if (transactionInputBuilder_ == null) {
        return transactionInput_.size();
    } else {
        return transactionInputBuilder_.getCount();
    }
}

######


public org.galilelj.wallet.Protos.TransactionInput getTransactionInput(int index) {
    if (transactionInputBuilder_ == null) {
        return transactionInput_.get(index);
    } else {
        return transactionInputBuilder_.getMessage(index);
    }
}

######


public Builder setTransactionInput(int index, org.galilelj.wallet.Protos.TransactionInput value) {
    if (transactionInputBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTransactionInputIsMutable();
        transactionInput_.set(index, value);
        onChanged();
    } else {
        transactionInputBuilder_.setMessage(index, value);
    }
    return this;
}

######


public Builder setTransactionInput(int index, org.galilelj.wallet.Protos.TransactionInput.Builder builderForValue) {
    if (transactionInputBuilder_ == null) {
        ensureTransactionInputIsMutable();
        transactionInput_.set(index, builderForValue.build());
        onChanged();
    } else {
        transactionInputBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addTransactionInput(org.galilelj.wallet.Protos.TransactionInput value) {
    if (transactionInputBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTransactionInputIsMutable();
        transactionInput_.add(value);
        onChanged();
    } else {
        transactionInputBuilder_.addMessage(value);
    }
    return this;
}

######


public Builder addTransactionInput(int index, org.galilelj.wallet.Protos.TransactionInput value) {
    if (transactionInputBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTransactionInputIsMutable();
        transactionInput_.add(index, value);
        onChanged();
    } else {
        transactionInputBuilder_.addMessage(index, value);
    }
    return this;
}

######


public Builder addTransactionInput(org.galilelj.wallet.Protos.TransactionInput.Builder builderForValue) {
    if (transactionInputBuilder_ == null) {
        ensureTransactionInputIsMutable();
        transactionInput_.add(builderForValue.build());
        onChanged();
    } else {
        transactionInputBuilder_.addMessage(builderForValue.build());
    }
    return this;
}

######


public Builder addTransactionInput(int index, org.galilelj.wallet.Protos.TransactionInput.Builder builderForValue) {
    if (transactionInputBuilder_ == null) {
        ensureTransactionInputIsMutable();
        transactionInput_.add(index, builderForValue.build());
        onChanged();
    } else {
        transactionInputBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addAllTransactionInput(java.lang.Iterable<? extends org.galilelj.wallet.Protos.TransactionInput> values) {
    if (transactionInputBuilder_ == null) {
        ensureTransactionInputIsMutable();
        super.addAll(values, transactionInput_);
        onChanged();
    } else {
        transactionInputBuilder_.addAllMessages(values);
    }
    return this;
}

######


public Builder clearTransactionInput() {
    if (transactionInputBuilder_ == null) {
        transactionInput_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
    } else {
        transactionInputBuilder_.clear();
    }
    return this;
}

######


public Builder removeTransactionInput(int index) {
    if (transactionInputBuilder_ == null) {
        ensureTransactionInputIsMutable();
        transactionInput_.remove(index);
        onChanged();
    } else {
        transactionInputBuilder_.remove(index);
    }
    return this;
}

######


public org.galilelj.wallet.Protos.TransactionInput.Builder getTransactionInputBuilder(int index) {
    return getTransactionInputFieldBuilder().getBuilder(index);
}

######


public org.galilelj.wallet.Protos.TransactionInputOrBuilder getTransactionInputOrBuilder(int index) {
    if (transactionInputBuilder_ == null) {
        return transactionInput_.get(index);
    } else {
        return transactionInputBuilder_.getMessageOrBuilder(index);
    }
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.TransactionInputOrBuilder> getTransactionInputOrBuilderList() {
    if (transactionInputBuilder_ != null) {
        return transactionInputBuilder_.getMessageOrBuilderList();
    } else {
        return java.util.Collections.unmodifiableList(transactionInput_);
    }
}

######


public org.galilelj.wallet.Protos.TransactionInput.Builder addTransactionInputBuilder() {
    return getTransactionInputFieldBuilder().addBuilder(org.galilelj.wallet.Protos.TransactionInput.getDefaultInstance());
}

######


public org.galilelj.wallet.Protos.TransactionInput.Builder addTransactionInputBuilder(int index) {
    return getTransactionInputFieldBuilder().addBuilder(index, org.galilelj.wallet.Protos.TransactionInput.getDefaultInstance());
}

######


public java.util.List<org.galilelj.wallet.Protos.TransactionInput.Builder> getTransactionInputBuilderList() {
    return getTransactionInputFieldBuilder().getBuilderList();
}

######


private com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.TransactionInput, org.galilelj.wallet.Protos.TransactionInput.Builder, org.galilelj.wallet.Protos.TransactionInputOrBuilder> getTransactionInputFieldBuilder() {
    if (transactionInputBuilder_ == null) {
        transactionInputBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.TransactionInput, org.galilelj.wallet.Protos.TransactionInput.Builder, org.galilelj.wallet.Protos.TransactionInputOrBuilder>(transactionInput_, ((bitField0_ & 0x00000020) == 0x00000020), getParentForChildren(), isClean());
        transactionInput_ = null;
    }
    return transactionInputBuilder_;
}

######


private void ensureTransactionOutputIsMutable() {
    if (!((bitField0_ & 0x00000040) == 0x00000040)) {
        transactionOutput_ = new java.util.ArrayList<org.galilelj.wallet.Protos.TransactionOutput>(transactionOutput_);
        bitField0_ |= 0x00000040;
    }
}

######


public java.util.List<org.galilelj.wallet.Protos.TransactionOutput> getTransactionOutputList() {
    if (transactionOutputBuilder_ == null) {
        return java.util.Collections.unmodifiableList(transactionOutput_);
    } else {
        return transactionOutputBuilder_.getMessageList();
    }
}

######


public int getTransactionOutputCount() {
    if (transactionOutputBuilder_ == null) {
        return transactionOutput_.size();
    } else {
        return transactionOutputBuilder_.getCount();
    }
}

######


public org.galilelj.wallet.Protos.TransactionOutput getTransactionOutput(int index) {
    if (transactionOutputBuilder_ == null) {
        return transactionOutput_.get(index);
    } else {
        return transactionOutputBuilder_.getMessage(index);
    }
}

######


public Builder setTransactionOutput(int index, org.galilelj.wallet.Protos.TransactionOutput value) {
    if (transactionOutputBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTransactionOutputIsMutable();
        transactionOutput_.set(index, value);
        onChanged();
    } else {
        transactionOutputBuilder_.setMessage(index, value);
    }
    return this;
}

######


public Builder setTransactionOutput(int index, org.galilelj.wallet.Protos.TransactionOutput.Builder builderForValue) {
    if (transactionOutputBuilder_ == null) {
        ensureTransactionOutputIsMutable();
        transactionOutput_.set(index, builderForValue.build());
        onChanged();
    } else {
        transactionOutputBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addTransactionOutput(org.galilelj.wallet.Protos.TransactionOutput value) {
    if (transactionOutputBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTransactionOutputIsMutable();
        transactionOutput_.add(value);
        onChanged();
    } else {
        transactionOutputBuilder_.addMessage(value);
    }
    return this;
}

######


public Builder addTransactionOutput(int index, org.galilelj.wallet.Protos.TransactionOutput value) {
    if (transactionOutputBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTransactionOutputIsMutable();
        transactionOutput_.add(index, value);
        onChanged();
    } else {
        transactionOutputBuilder_.addMessage(index, value);
    }
    return this;
}

######


public Builder addTransactionOutput(org.galilelj.wallet.Protos.TransactionOutput.Builder builderForValue) {
    if (transactionOutputBuilder_ == null) {
        ensureTransactionOutputIsMutable();
        transactionOutput_.add(builderForValue.build());
        onChanged();
    } else {
        transactionOutputBuilder_.addMessage(builderForValue.build());
    }
    return this;
}

######


public Builder addTransactionOutput(int index, org.galilelj.wallet.Protos.TransactionOutput.Builder builderForValue) {
    if (transactionOutputBuilder_ == null) {
        ensureTransactionOutputIsMutable();
        transactionOutput_.add(index, builderForValue.build());
        onChanged();
    } else {
        transactionOutputBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addAllTransactionOutput(java.lang.Iterable<? extends org.galilelj.wallet.Protos.TransactionOutput> values) {
    if (transactionOutputBuilder_ == null) {
        ensureTransactionOutputIsMutable();
        super.addAll(values, transactionOutput_);
        onChanged();
    } else {
        transactionOutputBuilder_.addAllMessages(values);
    }
    return this;
}

######


public Builder clearTransactionOutput() {
    if (transactionOutputBuilder_ == null) {
        transactionOutput_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
    } else {
        transactionOutputBuilder_.clear();
    }
    return this;
}

######


public Builder removeTransactionOutput(int index) {
    if (transactionOutputBuilder_ == null) {
        ensureTransactionOutputIsMutable();
        transactionOutput_.remove(index);
        onChanged();
    } else {
        transactionOutputBuilder_.remove(index);
    }
    return this;
}

######


public org.galilelj.wallet.Protos.TransactionOutput.Builder getTransactionOutputBuilder(int index) {
    return getTransactionOutputFieldBuilder().getBuilder(index);
}

######


public org.galilelj.wallet.Protos.TransactionOutputOrBuilder getTransactionOutputOrBuilder(int index) {
    if (transactionOutputBuilder_ == null) {
        return transactionOutput_.get(index);
    } else {
        return transactionOutputBuilder_.getMessageOrBuilder(index);
    }
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.TransactionOutputOrBuilder> getTransactionOutputOrBuilderList() {
    if (transactionOutputBuilder_ != null) {
        return transactionOutputBuilder_.getMessageOrBuilderList();
    } else {
        return java.util.Collections.unmodifiableList(transactionOutput_);
    }
}

######


public org.galilelj.wallet.Protos.TransactionOutput.Builder addTransactionOutputBuilder() {
    return getTransactionOutputFieldBuilder().addBuilder(org.galilelj.wallet.Protos.TransactionOutput.getDefaultInstance());
}

######


public org.galilelj.wallet.Protos.TransactionOutput.Builder addTransactionOutputBuilder(int index) {
    return getTransactionOutputFieldBuilder().addBuilder(index, org.galilelj.wallet.Protos.TransactionOutput.getDefaultInstance());
}

######


public java.util.List<org.galilelj.wallet.Protos.TransactionOutput.Builder> getTransactionOutputBuilderList() {
    return getTransactionOutputFieldBuilder().getBuilderList();
}

######


private com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.TransactionOutput, org.galilelj.wallet.Protos.TransactionOutput.Builder, org.galilelj.wallet.Protos.TransactionOutputOrBuilder> getTransactionOutputFieldBuilder() {
    if (transactionOutputBuilder_ == null) {
        transactionOutputBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.TransactionOutput, org.galilelj.wallet.Protos.TransactionOutput.Builder, org.galilelj.wallet.Protos.TransactionOutputOrBuilder>(transactionOutput_, ((bitField0_ & 0x00000040) == 0x00000040), getParentForChildren(), isClean());
        transactionOutput_ = null;
    }
    return transactionOutputBuilder_;
}

######


private void ensureBlockHashIsMutable() {
    if (!((bitField0_ & 0x00000080) == 0x00000080)) {
        blockHash_ = new java.util.ArrayList<com.google.protobuf.ByteString>(blockHash_);
        bitField0_ |= 0x00000080;
    }
}

######


public java.util.List<com.google.protobuf.ByteString> getBlockHashList() {
    return java.util.Collections.unmodifiableList(blockHash_);
}

######


public int getBlockHashCount() {
    return blockHash_.size();
}

######


public com.google.protobuf.ByteString getBlockHash(int index) {
    return blockHash_.get(index);
}

######


public Builder setBlockHash(int index, com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    ensureBlockHashIsMutable();
    blockHash_.set(index, value);
    onChanged();
    return this;
}

######


public Builder addBlockHash(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    ensureBlockHashIsMutable();
    blockHash_.add(value);
    onChanged();
    return this;
}

######


public Builder addAllBlockHash(java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
    ensureBlockHashIsMutable();
    super.addAll(values, blockHash_);
    onChanged();
    return this;
}

######


public Builder clearBlockHash() {
    blockHash_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000080);
    onChanged();
    return this;
}

######


private void ensureBlockRelativityOffsetsIsMutable() {
    if (!((bitField0_ & 0x00000100) == 0x00000100)) {
        blockRelativityOffsets_ = new java.util.ArrayList<java.lang.Integer>(blockRelativityOffsets_);
        bitField0_ |= 0x00000100;
    }
}

######


public java.util.List<java.lang.Integer> getBlockRelativityOffsetsList() {
    return java.util.Collections.unmodifiableList(blockRelativityOffsets_);
}

######


public int getBlockRelativityOffsetsCount() {
    return blockRelativityOffsets_.size();
}

######


public int getBlockRelativityOffsets(int index) {
    return blockRelativityOffsets_.get(index);
}

######


public Builder setBlockRelativityOffsets(int index, int value) {
    ensureBlockRelativityOffsetsIsMutable();
    blockRelativityOffsets_.set(index, value);
    onChanged();
    return this;
}

######


public Builder addBlockRelativityOffsets(int value) {
    ensureBlockRelativityOffsetsIsMutable();
    blockRelativityOffsets_.add(value);
    onChanged();
    return this;
}

######


public Builder addAllBlockRelativityOffsets(java.lang.Iterable<? extends java.lang.Integer> values) {
    ensureBlockRelativityOffsetsIsMutable();
    super.addAll(values, blockRelativityOffsets_);
    onChanged();
    return this;
}

######


public Builder clearBlockRelativityOffsets() {
    blockRelativityOffsets_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000100);
    onChanged();
    return this;
}

######


public boolean hasConfidence() {
    return ((bitField0_ & 0x00000200) == 0x00000200);
}

######


public org.galilelj.wallet.Protos.TransactionConfidence getConfidence() {
    if (confidenceBuilder_ == null) {
        return confidence_;
    } else {
        return confidenceBuilder_.getMessage();
    }
}

######


public Builder setConfidence(org.galilelj.wallet.Protos.TransactionConfidence value) {
    if (confidenceBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        confidence_ = value;
        onChanged();
    } else {
        confidenceBuilder_.setMessage(value);
    }
    bitField0_ |= 0x00000200;
    return this;
}

######


public Builder setConfidence(org.galilelj.wallet.Protos.TransactionConfidence.Builder builderForValue) {
    if (confidenceBuilder_ == null) {
        confidence_ = builderForValue.build();
        onChanged();
    } else {
        confidenceBuilder_.setMessage(builderForValue.build());
    }
    bitField0_ |= 0x00000200;
    return this;
}

######


public Builder mergeConfidence(org.galilelj.wallet.Protos.TransactionConfidence value) {
    if (confidenceBuilder_ == null) {
        if (((bitField0_ & 0x00000200) == 0x00000200) && confidence_ != org.galilelj.wallet.Protos.TransactionConfidence.getDefaultInstance()) {
            confidence_ = org.galilelj.wallet.Protos.TransactionConfidence.newBuilder(confidence_).mergeFrom(value).buildPartial();
        } else {
            confidence_ = value;
        }
        onChanged();
    } else {
        confidenceBuilder_.mergeFrom(value);
    }
    bitField0_ |= 0x00000200;
    return this;
}

######


public Builder clearConfidence() {
    if (confidenceBuilder_ == null) {
        confidence_ = org.galilelj.wallet.Protos.TransactionConfidence.getDefaultInstance();
        onChanged();
    } else {
        confidenceBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000200);
    return this;
}

######


public org.galilelj.wallet.Protos.TransactionConfidence.Builder getConfidenceBuilder() {
    bitField0_ |= 0x00000200;
    onChanged();
    return getConfidenceFieldBuilder().getBuilder();
}

######


public org.galilelj.wallet.Protos.TransactionConfidenceOrBuilder getConfidenceOrBuilder() {
    if (confidenceBuilder_ != null) {
        return confidenceBuilder_.getMessageOrBuilder();
    } else {
        return confidence_;
    }
}

######


private com.google.protobuf.SingleFieldBuilder<org.galilelj.wallet.Protos.TransactionConfidence, org.galilelj.wallet.Protos.TransactionConfidence.Builder, org.galilelj.wallet.Protos.TransactionConfidenceOrBuilder> getConfidenceFieldBuilder() {
    if (confidenceBuilder_ == null) {
        confidenceBuilder_ = new com.google.protobuf.SingleFieldBuilder<org.galilelj.wallet.Protos.TransactionConfidence, org.galilelj.wallet.Protos.TransactionConfidence.Builder, org.galilelj.wallet.Protos.TransactionConfidenceOrBuilder>(confidence_, getParentForChildren(), isClean());
        confidence_ = null;
    }
    return confidenceBuilder_;
}

######


public boolean hasPurpose() {
    return ((bitField0_ & 0x00000400) == 0x00000400);
}

######


public org.galilelj.wallet.Protos.Transaction.Purpose getPurpose() {
    return purpose_;
}

######


public Builder setPurpose(org.galilelj.wallet.Protos.Transaction.Purpose value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000400;
    purpose_ = value;
    onChanged();
    return this;
}

######


public Builder clearPurpose() {
    bitField0_ = (bitField0_ & ~0x00000400);
    purpose_ = org.galilelj.wallet.Protos.Transaction.Purpose.UNKNOWN;
    onChanged();
    return this;
}

######


public boolean hasExchangeRate() {
    return ((bitField0_ & 0x00000800) == 0x00000800);
}

######


public org.galilelj.wallet.Protos.ExchangeRate getExchangeRate() {
    if (exchangeRateBuilder_ == null) {
        return exchangeRate_;
    } else {
        return exchangeRateBuilder_.getMessage();
    }
}

######


public Builder setExchangeRate(org.galilelj.wallet.Protos.ExchangeRate value) {
    if (exchangeRateBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        exchangeRate_ = value;
        onChanged();
    } else {
        exchangeRateBuilder_.setMessage(value);
    }
    bitField0_ |= 0x00000800;
    return this;
}

######


public Builder setExchangeRate(org.galilelj.wallet.Protos.ExchangeRate.Builder builderForValue) {
    if (exchangeRateBuilder_ == null) {
        exchangeRate_ = builderForValue.build();
        onChanged();
    } else {
        exchangeRateBuilder_.setMessage(builderForValue.build());
    }
    bitField0_ |= 0x00000800;
    return this;
}

######


public Builder mergeExchangeRate(org.galilelj.wallet.Protos.ExchangeRate value) {
    if (exchangeRateBuilder_ == null) {
        if (((bitField0_ & 0x00000800) == 0x00000800) && exchangeRate_ != org.galilelj.wallet.Protos.ExchangeRate.getDefaultInstance()) {
            exchangeRate_ = org.galilelj.wallet.Protos.ExchangeRate.newBuilder(exchangeRate_).mergeFrom(value).buildPartial();
        } else {
            exchangeRate_ = value;
        }
        onChanged();
    } else {
        exchangeRateBuilder_.mergeFrom(value);
    }
    bitField0_ |= 0x00000800;
    return this;
}

######


public Builder clearExchangeRate() {
    if (exchangeRateBuilder_ == null) {
        exchangeRate_ = org.galilelj.wallet.Protos.ExchangeRate.getDefaultInstance();
        onChanged();
    } else {
        exchangeRateBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000800);
    return this;
}

######


public org.galilelj.wallet.Protos.ExchangeRate.Builder getExchangeRateBuilder() {
    bitField0_ |= 0x00000800;
    onChanged();
    return getExchangeRateFieldBuilder().getBuilder();
}

######


public org.galilelj.wallet.Protos.ExchangeRateOrBuilder getExchangeRateOrBuilder() {
    if (exchangeRateBuilder_ != null) {
        return exchangeRateBuilder_.getMessageOrBuilder();
    } else {
        return exchangeRate_;
    }
}

######


private com.google.protobuf.SingleFieldBuilder<org.galilelj.wallet.Protos.ExchangeRate, org.galilelj.wallet.Protos.ExchangeRate.Builder, org.galilelj.wallet.Protos.ExchangeRateOrBuilder> getExchangeRateFieldBuilder() {
    if (exchangeRateBuilder_ == null) {
        exchangeRateBuilder_ = new com.google.protobuf.SingleFieldBuilder<org.galilelj.wallet.Protos.ExchangeRate, org.galilelj.wallet.Protos.ExchangeRate.Builder, org.galilelj.wallet.Protos.ExchangeRateOrBuilder>(exchangeRate_, getParentForChildren(), isClean());
        exchangeRate_ = null;
    }
    return exchangeRateBuilder_;
}

######


public boolean hasMemo() {
    return ((bitField0_ & 0x00001000) == 0x00001000);
}

######


public java.lang.String getMemo() {
    java.lang.Object ref = memo_;
    if (!(ref instanceof java.lang.String)) {
        java.lang.String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();
        memo_ = s;
        return s;
    } else {
        return (java.lang.String) ref;
    }
}

######


public com.google.protobuf.ByteString getMemoBytes() {
    java.lang.Object ref = memo_;
    if (ref instanceof String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        memo_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public Builder setMemo(java.lang.String value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00001000;
    memo_ = value;
    onChanged();
    return this;
}

######


public Builder clearMemo() {
    bitField0_ = (bitField0_ & ~0x00001000);
    memo_ = getDefaultInstance().getMemo();
    onChanged();
    return this;
}

######


public Builder setMemoBytes(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00001000;
    memo_ = value;
    onChanged();
    return this;
}

######


boolean hasSalt();

######


com.google.protobuf.ByteString getSalt();

######


boolean hasN();

######


long getN();

######


boolean hasR();

######


int getR();

######


boolean hasP();

######


int getP();

######


public static ScryptParameters getDefaultInstance() {
    return defaultInstance;
}

######


public ScryptParameters getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_ScryptParameters_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_ScryptParameters_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.ScryptParameters.class, org.galilelj.wallet.Protos.ScryptParameters.Builder.class);
}

######


public ScryptParameters parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new ScryptParameters(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<ScryptParameters> getParserForType() {
    return PARSER;
}

######


public boolean hasSalt() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public com.google.protobuf.ByteString getSalt() {
    return salt_;
}

######


public boolean hasN() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public long getN() {
    return n_;
}

######


public boolean hasR() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public int getR() {
    return r_;
}

######


public boolean hasP() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public int getP() {
    return p_;
}

######


private void initFields() {
    salt_ = com.google.protobuf.ByteString.EMPTY;
    n_ = 16384L;
    r_ = 8;
    p_ = 1;
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasSalt()) {
        memoizedIsInitialized = 0;
        return false;
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, salt_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt64(2, n_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeInt32(3, r_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(4, p_);
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, salt_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(2, n_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(3, r_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(4, p_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.ScryptParameters parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.ScryptParameters parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.ScryptParameters parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.ScryptParameters parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.ScryptParameters parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.ScryptParameters parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.ScryptParameters parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.ScryptParameters parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.ScryptParameters parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.ScryptParameters parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.ScryptParameters prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_ScryptParameters_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_ScryptParameters_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.ScryptParameters.class, org.galilelj.wallet.Protos.ScryptParameters.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    salt_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    n_ = 16384L;
    bitField0_ = (bitField0_ & ~0x00000002);
    r_ = 8;
    bitField0_ = (bitField0_ & ~0x00000004);
    p_ = 1;
    bitField0_ = (bitField0_ & ~0x00000008);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_ScryptParameters_descriptor;
}

######


public org.galilelj.wallet.Protos.ScryptParameters getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.ScryptParameters.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.ScryptParameters build() {
    org.galilelj.wallet.Protos.ScryptParameters result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.ScryptParameters buildPartial() {
    org.galilelj.wallet.Protos.ScryptParameters result = new org.galilelj.wallet.Protos.ScryptParameters(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.salt_ = salt_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.n_ = n_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.r_ = r_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000008;
    }
    result.p_ = p_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.ScryptParameters) {
        return mergeFrom((org.galilelj.wallet.Protos.ScryptParameters) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.ScryptParameters other) {
    if (other == org.galilelj.wallet.Protos.ScryptParameters.getDefaultInstance())
        return this;
    if (other.hasSalt()) {
        setSalt(other.getSalt());
    }
    if (other.hasN()) {
        setN(other.getN());
    }
    if (other.hasR()) {
        setR(other.getR());
    }
    if (other.hasP()) {
        setP(other.getP());
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasSalt()) {
        return false;
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.ScryptParameters parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.ScryptParameters) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasSalt() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public com.google.protobuf.ByteString getSalt() {
    return salt_;
}

######


public Builder setSalt(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    salt_ = value;
    onChanged();
    return this;
}

######


public Builder clearSalt() {
    bitField0_ = (bitField0_ & ~0x00000001);
    salt_ = getDefaultInstance().getSalt();
    onChanged();
    return this;
}

######


public boolean hasN() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public long getN() {
    return n_;
}

######


public Builder setN(long value) {
    bitField0_ |= 0x00000002;
    n_ = value;
    onChanged();
    return this;
}

######


public Builder clearN() {
    bitField0_ = (bitField0_ & ~0x00000002);
    n_ = 16384L;
    onChanged();
    return this;
}

######


public boolean hasR() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public int getR() {
    return r_;
}

######


public Builder setR(int value) {
    bitField0_ |= 0x00000004;
    r_ = value;
    onChanged();
    return this;
}

######


public Builder clearR() {
    bitField0_ = (bitField0_ & ~0x00000004);
    r_ = 8;
    onChanged();
    return this;
}

######


public boolean hasP() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public int getP() {
    return p_;
}

######


public Builder setP(int value) {
    bitField0_ |= 0x00000008;
    p_ = value;
    onChanged();
    return this;
}

######


public Builder clearP() {
    bitField0_ = (bitField0_ & ~0x00000008);
    p_ = 1;
    onChanged();
    return this;
}

######


boolean hasId();

######


java.lang.String getId();

######


com.google.protobuf.ByteString getIdBytes();

######


boolean hasData();

######


com.google.protobuf.ByteString getData();

######


boolean hasMandatory();

######


boolean getMandatory();

######


public static Extension getDefaultInstance() {
    return defaultInstance;
}

######


public Extension getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Extension_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Extension_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.Extension.class, org.galilelj.wallet.Protos.Extension.Builder.class);
}

######


public Extension parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new Extension(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<Extension> getParserForType() {
    return PARSER;
}

######


public boolean hasId() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public java.lang.String getId() {
    java.lang.Object ref = id_;
    if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
    } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
            id_ = s;
        }
        return s;
    }
}

######


public com.google.protobuf.ByteString getIdBytes() {
    java.lang.Object ref = id_;
    if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        id_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public boolean hasData() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getData() {
    return data_;
}

######


public boolean hasMandatory() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public boolean getMandatory() {
    return mandatory_;
}

######


private void initFields() {
    id_ = "";
    data_ = com.google.protobuf.ByteString.EMPTY;
    mandatory_ = false;
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasId()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (!hasData()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (!hasMandatory()) {
        memoizedIsInitialized = 0;
        return false;
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, getIdBytes());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, data_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBool(3, mandatory_);
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, getIdBytes());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, data_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(3, mandatory_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.Extension parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.Extension parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Extension parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.Extension parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Extension parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.Extension parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Extension parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.Extension parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Extension parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.Extension parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.Extension prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Extension_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Extension_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.Extension.class, org.galilelj.wallet.Protos.Extension.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    id_ = "";
    bitField0_ = (bitField0_ & ~0x00000001);
    data_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    mandatory_ = false;
    bitField0_ = (bitField0_ & ~0x00000004);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Extension_descriptor;
}

######


public org.galilelj.wallet.Protos.Extension getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.Extension.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.Extension build() {
    org.galilelj.wallet.Protos.Extension result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.Extension buildPartial() {
    org.galilelj.wallet.Protos.Extension result = new org.galilelj.wallet.Protos.Extension(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.id_ = id_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.data_ = data_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.mandatory_ = mandatory_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.Extension) {
        return mergeFrom((org.galilelj.wallet.Protos.Extension) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.Extension other) {
    if (other == org.galilelj.wallet.Protos.Extension.getDefaultInstance())
        return this;
    if (other.hasId()) {
        bitField0_ |= 0x00000001;
        id_ = other.id_;
        onChanged();
    }
    if (other.hasData()) {
        setData(other.getData());
    }
    if (other.hasMandatory()) {
        setMandatory(other.getMandatory());
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasId()) {
        return false;
    }
    if (!hasData()) {
        return false;
    }
    if (!hasMandatory()) {
        return false;
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.Extension parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.Extension) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasId() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public java.lang.String getId() {
    java.lang.Object ref = id_;
    if (!(ref instanceof java.lang.String)) {
        java.lang.String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();
        id_ = s;
        return s;
    } else {
        return (java.lang.String) ref;
    }
}

######


public com.google.protobuf.ByteString getIdBytes() {
    java.lang.Object ref = id_;
    if (ref instanceof String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        id_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public Builder setId(java.lang.String value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    id_ = value;
    onChanged();
    return this;
}

######


public Builder clearId() {
    bitField0_ = (bitField0_ & ~0x00000001);
    id_ = getDefaultInstance().getId();
    onChanged();
    return this;
}

######


public Builder setIdBytes(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    id_ = value;
    onChanged();
    return this;
}

######


public boolean hasData() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getData() {
    return data_;
}

######


public Builder setData(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000002;
    data_ = value;
    onChanged();
    return this;
}

######


public Builder clearData() {
    bitField0_ = (bitField0_ & ~0x00000002);
    data_ = getDefaultInstance().getData();
    onChanged();
    return this;
}

######


public boolean hasMandatory() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public boolean getMandatory() {
    return mandatory_;
}

######


public Builder setMandatory(boolean value) {
    bitField0_ |= 0x00000004;
    mandatory_ = value;
    onChanged();
    return this;
}

######


public Builder clearMandatory() {
    bitField0_ = (bitField0_ & ~0x00000004);
    mandatory_ = false;
    onChanged();
    return this;
}

######


boolean hasTag();

######


java.lang.String getTag();

######


com.google.protobuf.ByteString getTagBytes();

######


boolean hasData();

######


com.google.protobuf.ByteString getData();

######


public static Tag getDefaultInstance() {
    return defaultInstance;
}

######


public Tag getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Tag_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Tag_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.Tag.class, org.galilelj.wallet.Protos.Tag.Builder.class);
}

######


public Tag parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new Tag(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<Tag> getParserForType() {
    return PARSER;
}

######


public boolean hasTag() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public java.lang.String getTag() {
    java.lang.Object ref = tag_;
    if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
    } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
            tag_ = s;
        }
        return s;
    }
}

######


public com.google.protobuf.ByteString getTagBytes() {
    java.lang.Object ref = tag_;
    if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        tag_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public boolean hasData() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getData() {
    return data_;
}

######


private void initFields() {
    tag_ = "";
    data_ = com.google.protobuf.ByteString.EMPTY;
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasTag()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (!hasData()) {
        memoizedIsInitialized = 0;
        return false;
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, getTagBytes());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, data_);
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, getTagBytes());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, data_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.Tag parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.Tag parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Tag parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.Tag parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Tag parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.Tag parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Tag parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.Tag parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Tag parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.Tag parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.Tag prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Tag_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Tag_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.Tag.class, org.galilelj.wallet.Protos.Tag.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    tag_ = "";
    bitField0_ = (bitField0_ & ~0x00000001);
    data_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Tag_descriptor;
}

######


public org.galilelj.wallet.Protos.Tag getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.Tag.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.Tag build() {
    org.galilelj.wallet.Protos.Tag result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.Tag buildPartial() {
    org.galilelj.wallet.Protos.Tag result = new org.galilelj.wallet.Protos.Tag(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.tag_ = tag_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.data_ = data_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.Tag) {
        return mergeFrom((org.galilelj.wallet.Protos.Tag) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.Tag other) {
    if (other == org.galilelj.wallet.Protos.Tag.getDefaultInstance())
        return this;
    if (other.hasTag()) {
        bitField0_ |= 0x00000001;
        tag_ = other.tag_;
        onChanged();
    }
    if (other.hasData()) {
        setData(other.getData());
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasTag()) {
        return false;
    }
    if (!hasData()) {
        return false;
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.Tag parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.Tag) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasTag() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public java.lang.String getTag() {
    java.lang.Object ref = tag_;
    if (!(ref instanceof java.lang.String)) {
        java.lang.String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();
        tag_ = s;
        return s;
    } else {
        return (java.lang.String) ref;
    }
}

######


public com.google.protobuf.ByteString getTagBytes() {
    java.lang.Object ref = tag_;
    if (ref instanceof String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        tag_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public Builder setTag(java.lang.String value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    tag_ = value;
    onChanged();
    return this;
}

######


public Builder clearTag() {
    bitField0_ = (bitField0_ & ~0x00000001);
    tag_ = getDefaultInstance().getTag();
    onChanged();
    return this;
}

######


public Builder setTagBytes(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    tag_ = value;
    onChanged();
    return this;
}

######


public boolean hasData() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getData() {
    return data_;
}

######


public Builder setData(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000002;
    data_ = value;
    onChanged();
    return this;
}

######


public Builder clearData() {
    bitField0_ = (bitField0_ & ~0x00000002);
    data_ = getDefaultInstance().getData();
    onChanged();
    return this;
}

######


boolean hasClassName();

######


java.lang.String getClassName();

######


com.google.protobuf.ByteString getClassNameBytes();

######


boolean hasData();

######


com.google.protobuf.ByteString getData();

######


public static TransactionSigner getDefaultInstance() {
    return defaultInstance;
}

######


public TransactionSigner getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionSigner_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionSigner_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.TransactionSigner.class, org.galilelj.wallet.Protos.TransactionSigner.Builder.class);
}

######


public TransactionSigner parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new TransactionSigner(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<TransactionSigner> getParserForType() {
    return PARSER;
}

######


public boolean hasClassName() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public java.lang.String getClassName() {
    java.lang.Object ref = className_;
    if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
    } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
            className_ = s;
        }
        return s;
    }
}

######


public com.google.protobuf.ByteString getClassNameBytes() {
    java.lang.Object ref = className_;
    if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        className_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public boolean hasData() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getData() {
    return data_;
}

######


private void initFields() {
    className_ = "";
    data_ = com.google.protobuf.ByteString.EMPTY;
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasClassName()) {
        memoizedIsInitialized = 0;
        return false;
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, getClassNameBytes());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, data_);
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, getClassNameBytes());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, data_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.TransactionSigner parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.TransactionSigner parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionSigner parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.TransactionSigner parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionSigner parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.TransactionSigner parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionSigner parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.TransactionSigner parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.TransactionSigner parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.TransactionSigner parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.TransactionSigner prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionSigner_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionSigner_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.TransactionSigner.class, org.galilelj.wallet.Protos.TransactionSigner.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    className_ = "";
    bitField0_ = (bitField0_ & ~0x00000001);
    data_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_TransactionSigner_descriptor;
}

######


public org.galilelj.wallet.Protos.TransactionSigner getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.TransactionSigner.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.TransactionSigner build() {
    org.galilelj.wallet.Protos.TransactionSigner result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.TransactionSigner buildPartial() {
    org.galilelj.wallet.Protos.TransactionSigner result = new org.galilelj.wallet.Protos.TransactionSigner(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.className_ = className_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.data_ = data_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.TransactionSigner) {
        return mergeFrom((org.galilelj.wallet.Protos.TransactionSigner) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.TransactionSigner other) {
    if (other == org.galilelj.wallet.Protos.TransactionSigner.getDefaultInstance())
        return this;
    if (other.hasClassName()) {
        bitField0_ |= 0x00000001;
        className_ = other.className_;
        onChanged();
    }
    if (other.hasData()) {
        setData(other.getData());
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasClassName()) {
        return false;
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.TransactionSigner parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.TransactionSigner) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasClassName() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public java.lang.String getClassName() {
    java.lang.Object ref = className_;
    if (!(ref instanceof java.lang.String)) {
        java.lang.String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();
        className_ = s;
        return s;
    } else {
        return (java.lang.String) ref;
    }
}

######


public com.google.protobuf.ByteString getClassNameBytes() {
    java.lang.Object ref = className_;
    if (ref instanceof String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        className_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public Builder setClassName(java.lang.String value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    className_ = value;
    onChanged();
    return this;
}

######


public Builder clearClassName() {
    bitField0_ = (bitField0_ & ~0x00000001);
    className_ = getDefaultInstance().getClassName();
    onChanged();
    return this;
}

######


public Builder setClassNameBytes(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    className_ = value;
    onChanged();
    return this;
}

######


public boolean hasData() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getData() {
    return data_;
}

######


public Builder setData(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000002;
    data_ = value;
    onChanged();
    return this;
}

######


public Builder clearData() {
    bitField0_ = (bitField0_ & ~0x00000002);
    data_ = getDefaultInstance().getData();
    onChanged();
    return this;
}

######


boolean hasNetworkIdentifier();

######


java.lang.String getNetworkIdentifier();

######


com.google.protobuf.ByteString getNetworkIdentifierBytes();

######


boolean hasLastSeenBlockHash();

######


com.google.protobuf.ByteString getLastSeenBlockHash();

######


boolean hasLastSeenBlockHeight();

######


int getLastSeenBlockHeight();

######


boolean hasLastSeenBlockTimeSecs();

######


long getLastSeenBlockTimeSecs();

######


java.util.List<org.galilelj.wallet.Protos.Key> getKeyList();

######


org.galilelj.wallet.Protos.Key getKey(int index);

######


int getKeyCount();

######


java.util.List<? extends org.galilelj.wallet.Protos.KeyOrBuilder> getKeyOrBuilderList();

######


org.galilelj.wallet.Protos.KeyOrBuilder getKeyOrBuilder(int index);

######


java.util.List<org.galilelj.wallet.Protos.Transaction> getTransactionList();

######


org.galilelj.wallet.Protos.Transaction getTransaction(int index);

######


int getTransactionCount();

######


java.util.List<? extends org.galilelj.wallet.Protos.TransactionOrBuilder> getTransactionOrBuilderList();

######


org.galilelj.wallet.Protos.TransactionOrBuilder getTransactionOrBuilder(int index);

######


java.util.List<org.galilelj.wallet.Protos.Script> getWatchedScriptList();

######


org.galilelj.wallet.Protos.Script getWatchedScript(int index);

######


int getWatchedScriptCount();

######


java.util.List<? extends org.galilelj.wallet.Protos.ScriptOrBuilder> getWatchedScriptOrBuilderList();

######


org.galilelj.wallet.Protos.ScriptOrBuilder getWatchedScriptOrBuilder(int index);

######


boolean hasEncryptionType();

######


org.galilelj.wallet.Protos.Wallet.EncryptionType getEncryptionType();

######


boolean hasEncryptionParameters();

######


org.galilelj.wallet.Protos.ScryptParameters getEncryptionParameters();

######


org.galilelj.wallet.Protos.ScryptParametersOrBuilder getEncryptionParametersOrBuilder();

######


boolean hasVersion();

######


int getVersion();

######


java.util.List<org.galilelj.wallet.Protos.Extension> getExtensionList();

######


org.galilelj.wallet.Protos.Extension getExtension(int index);

######


int getExtensionCount();

######


java.util.List<? extends org.galilelj.wallet.Protos.ExtensionOrBuilder> getExtensionOrBuilderList();

######


org.galilelj.wallet.Protos.ExtensionOrBuilder getExtensionOrBuilder(int index);

######


boolean hasDescription();

######


java.lang.String getDescription();

######


com.google.protobuf.ByteString getDescriptionBytes();

######


boolean hasKeyRotationTime();

######


long getKeyRotationTime();

######


java.util.List<org.galilelj.wallet.Protos.Tag> getTagsList();

######


org.galilelj.wallet.Protos.Tag getTags(int index);

######


int getTagsCount();

######


java.util.List<? extends org.galilelj.wallet.Protos.TagOrBuilder> getTagsOrBuilderList();

######


org.galilelj.wallet.Protos.TagOrBuilder getTagsOrBuilder(int index);

######


java.util.List<org.galilelj.wallet.Protos.TransactionSigner> getTransactionSignersList();

######


org.galilelj.wallet.Protos.TransactionSigner getTransactionSigners(int index);

######


int getTransactionSignersCount();

######


java.util.List<? extends org.galilelj.wallet.Protos.TransactionSignerOrBuilder> getTransactionSignersOrBuilderList();

######


org.galilelj.wallet.Protos.TransactionSignerOrBuilder getTransactionSignersOrBuilder(int index);

######


public static Wallet getDefaultInstance() {
    return defaultInstance;
}

######


public Wallet getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Wallet_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Wallet_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.Wallet.class, org.galilelj.wallet.Protos.Wallet.Builder.class);
}

######


public Wallet parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new Wallet(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<Wallet> getParserForType() {
    return PARSER;
}

######


public final int getNumber() {
    return value;
}

######


public static EncryptionType valueOf(int value) {
    switch(value) {
        case 1:
            return UNENCRYPTED;
        case 2:
            return ENCRYPTED_SCRYPT_AES;
        default:
            return null;
    }
}

######


public static com.google.protobuf.Internal.EnumLiteMap<EncryptionType> internalGetValueMap() {
    return internalValueMap;
}

######


public EncryptionType findValueByNumber(int number) {
    return EncryptionType.valueOf(number);
}

######


public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
    return getDescriptor().getValues().get(index);
}

######


public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
    return getDescriptor();
}

######


public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
    return org.galilelj.wallet.Protos.Wallet.getDescriptor().getEnumTypes().get(0);
}

######


public static EncryptionType valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
    if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
    }
    return VALUES[desc.getIndex()];
}

######


public boolean hasNetworkIdentifier() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public java.lang.String getNetworkIdentifier() {
    java.lang.Object ref = networkIdentifier_;
    if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
    } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
            networkIdentifier_ = s;
        }
        return s;
    }
}

######


public com.google.protobuf.ByteString getNetworkIdentifierBytes() {
    java.lang.Object ref = networkIdentifier_;
    if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        networkIdentifier_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public boolean hasLastSeenBlockHash() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getLastSeenBlockHash() {
    return lastSeenBlockHash_;
}

######


public boolean hasLastSeenBlockHeight() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public int getLastSeenBlockHeight() {
    return lastSeenBlockHeight_;
}

######


public boolean hasLastSeenBlockTimeSecs() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public long getLastSeenBlockTimeSecs() {
    return lastSeenBlockTimeSecs_;
}

######


public java.util.List<org.galilelj.wallet.Protos.Key> getKeyList() {
    return key_;
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.KeyOrBuilder> getKeyOrBuilderList() {
    return key_;
}

######


public int getKeyCount() {
    return key_.size();
}

######


public org.galilelj.wallet.Protos.Key getKey(int index) {
    return key_.get(index);
}

######


public org.galilelj.wallet.Protos.KeyOrBuilder getKeyOrBuilder(int index) {
    return key_.get(index);
}

######


public java.util.List<org.galilelj.wallet.Protos.Transaction> getTransactionList() {
    return transaction_;
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.TransactionOrBuilder> getTransactionOrBuilderList() {
    return transaction_;
}

######


public int getTransactionCount() {
    return transaction_.size();
}

######


public org.galilelj.wallet.Protos.Transaction getTransaction(int index) {
    return transaction_.get(index);
}

######


public org.galilelj.wallet.Protos.TransactionOrBuilder getTransactionOrBuilder(int index) {
    return transaction_.get(index);
}

######


public java.util.List<org.galilelj.wallet.Protos.Script> getWatchedScriptList() {
    return watchedScript_;
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.ScriptOrBuilder> getWatchedScriptOrBuilderList() {
    return watchedScript_;
}

######


public int getWatchedScriptCount() {
    return watchedScript_.size();
}

######


public org.galilelj.wallet.Protos.Script getWatchedScript(int index) {
    return watchedScript_.get(index);
}

######


public org.galilelj.wallet.Protos.ScriptOrBuilder getWatchedScriptOrBuilder(int index) {
    return watchedScript_.get(index);
}

######


public boolean hasEncryptionType() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}

######


public org.galilelj.wallet.Protos.Wallet.EncryptionType getEncryptionType() {
    return encryptionType_;
}

######


public boolean hasEncryptionParameters() {
    return ((bitField0_ & 0x00000020) == 0x00000020);
}

######


public org.galilelj.wallet.Protos.ScryptParameters getEncryptionParameters() {
    return encryptionParameters_;
}

######


public org.galilelj.wallet.Protos.ScryptParametersOrBuilder getEncryptionParametersOrBuilder() {
    return encryptionParameters_;
}

######


public boolean hasVersion() {
    return ((bitField0_ & 0x00000040) == 0x00000040);
}

######


public int getVersion() {
    return version_;
}

######


public java.util.List<org.galilelj.wallet.Protos.Extension> getExtensionList() {
    return extension_;
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.ExtensionOrBuilder> getExtensionOrBuilderList() {
    return extension_;
}

######


public int getExtensionCount() {
    return extension_.size();
}

######


public org.galilelj.wallet.Protos.Extension getExtension(int index) {
    return extension_.get(index);
}

######


public org.galilelj.wallet.Protos.ExtensionOrBuilder getExtensionOrBuilder(int index) {
    return extension_.get(index);
}

######


public boolean hasDescription() {
    return ((bitField0_ & 0x00000080) == 0x00000080);
}

######


public java.lang.String getDescription() {
    java.lang.Object ref = description_;
    if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
    } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
            description_ = s;
        }
        return s;
    }
}

######


public com.google.protobuf.ByteString getDescriptionBytes() {
    java.lang.Object ref = description_;
    if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        description_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public boolean hasKeyRotationTime() {
    return ((bitField0_ & 0x00000100) == 0x00000100);
}

######


public long getKeyRotationTime() {
    return keyRotationTime_;
}

######


public java.util.List<org.galilelj.wallet.Protos.Tag> getTagsList() {
    return tags_;
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.TagOrBuilder> getTagsOrBuilderList() {
    return tags_;
}

######


public int getTagsCount() {
    return tags_.size();
}

######


public org.galilelj.wallet.Protos.Tag getTags(int index) {
    return tags_.get(index);
}

######


public org.galilelj.wallet.Protos.TagOrBuilder getTagsOrBuilder(int index) {
    return tags_.get(index);
}

######


public java.util.List<org.galilelj.wallet.Protos.TransactionSigner> getTransactionSignersList() {
    return transactionSigners_;
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.TransactionSignerOrBuilder> getTransactionSignersOrBuilderList() {
    return transactionSigners_;
}

######


public int getTransactionSignersCount() {
    return transactionSigners_.size();
}

######


public org.galilelj.wallet.Protos.TransactionSigner getTransactionSigners(int index) {
    return transactionSigners_.get(index);
}

######


public org.galilelj.wallet.Protos.TransactionSignerOrBuilder getTransactionSignersOrBuilder(int index) {
    return transactionSigners_.get(index);
}

######


private void initFields() {
    networkIdentifier_ = "";
    lastSeenBlockHash_ = com.google.protobuf.ByteString.EMPTY;
    lastSeenBlockHeight_ = 0;
    lastSeenBlockTimeSecs_ = 0L;
    key_ = java.util.Collections.emptyList();
    transaction_ = java.util.Collections.emptyList();
    watchedScript_ = java.util.Collections.emptyList();
    encryptionType_ = org.galilelj.wallet.Protos.Wallet.EncryptionType.UNENCRYPTED;
    encryptionParameters_ = org.galilelj.wallet.Protos.ScryptParameters.getDefaultInstance();
    version_ = 1;
    extension_ = java.util.Collections.emptyList();
    description_ = "";
    keyRotationTime_ = 0L;
    tags_ = java.util.Collections.emptyList();
    transactionSigners_ = java.util.Collections.emptyList();
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasNetworkIdentifier()) {
        memoizedIsInitialized = 0;
        return false;
    }
    for (int i = 0; i < getKeyCount(); i++) {
        if (!getKey(i).isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    for (int i = 0; i < getTransactionCount(); i++) {
        if (!getTransaction(i).isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    for (int i = 0; i < getWatchedScriptCount(); i++) {
        if (!getWatchedScript(i).isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    if (hasEncryptionParameters()) {
        if (!getEncryptionParameters().isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    for (int i = 0; i < getExtensionCount(); i++) {
        if (!getExtension(i).isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    for (int i = 0; i < getTagsCount(); i++) {
        if (!getTags(i).isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    for (int i = 0; i < getTransactionSignersCount(); i++) {
        if (!getTransactionSigners(i).isInitialized()) {
            memoizedIsInitialized = 0;
            return false;
        }
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, getNetworkIdentifierBytes());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, lastSeenBlockHash_);
    }
    for (int i = 0; i < key_.size(); i++) {
        output.writeMessage(3, key_.get(i));
    }
    for (int i = 0; i < transaction_.size(); i++) {
        output.writeMessage(4, transaction_.get(i));
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeEnum(5, encryptionType_.getNumber());
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeMessage(6, encryptionParameters_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeInt32(7, version_);
    }
    for (int i = 0; i < extension_.size(); i++) {
        output.writeMessage(10, extension_.get(i));
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeBytes(11, getDescriptionBytes());
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt32(12, lastSeenBlockHeight_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeUInt64(13, keyRotationTime_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt64(14, lastSeenBlockTimeSecs_);
    }
    for (int i = 0; i < watchedScript_.size(); i++) {
        output.writeMessage(15, watchedScript_.get(i));
    }
    for (int i = 0; i < tags_.size(); i++) {
        output.writeMessage(16, tags_.get(i));
    }
    for (int i = 0; i < transactionSigners_.size(); i++) {
        output.writeMessage(17, transactionSigners_.get(i));
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, getNetworkIdentifierBytes());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, lastSeenBlockHash_);
    }
    for (int i = 0; i < key_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, key_.get(i));
    }
    for (int i = 0; i < transaction_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(4, transaction_.get(i));
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream.computeEnumSize(5, encryptionType_.getNumber());
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(6, encryptionParameters_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(7, version_);
    }
    for (int i = 0; i < extension_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(10, extension_.get(i));
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(11, getDescriptionBytes());
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeUInt32Size(12, lastSeenBlockHeight_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream.computeUInt64Size(13, keyRotationTime_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(14, lastSeenBlockTimeSecs_);
    }
    for (int i = 0; i < watchedScript_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(15, watchedScript_.get(i));
    }
    for (int i = 0; i < tags_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(16, tags_.get(i));
    }
    for (int i = 0; i < transactionSigners_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(17, transactionSigners_.get(i));
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.Wallet parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.Wallet parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Wallet parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.Wallet parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Wallet parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.Wallet parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Wallet parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.Wallet parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.Wallet parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.Wallet parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.Wallet prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Wallet_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Wallet_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.Wallet.class, org.galilelj.wallet.Protos.Wallet.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        getKeyFieldBuilder();
        getTransactionFieldBuilder();
        getWatchedScriptFieldBuilder();
        getEncryptionParametersFieldBuilder();
        getExtensionFieldBuilder();
        getTagsFieldBuilder();
        getTransactionSignersFieldBuilder();
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    networkIdentifier_ = "";
    bitField0_ = (bitField0_ & ~0x00000001);
    lastSeenBlockHash_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    lastSeenBlockHeight_ = 0;
    bitField0_ = (bitField0_ & ~0x00000004);
    lastSeenBlockTimeSecs_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000008);
    if (keyBuilder_ == null) {
        key_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
    } else {
        keyBuilder_.clear();
    }
    if (transactionBuilder_ == null) {
        transaction_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000020);
    } else {
        transactionBuilder_.clear();
    }
    if (watchedScriptBuilder_ == null) {
        watchedScript_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000040);
    } else {
        watchedScriptBuilder_.clear();
    }
    encryptionType_ = org.galilelj.wallet.Protos.Wallet.EncryptionType.UNENCRYPTED;
    bitField0_ = (bitField0_ & ~0x00000080);
    if (encryptionParametersBuilder_ == null) {
        encryptionParameters_ = org.galilelj.wallet.Protos.ScryptParameters.getDefaultInstance();
    } else {
        encryptionParametersBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000100);
    version_ = 1;
    bitField0_ = (bitField0_ & ~0x00000200);
    if (extensionBuilder_ == null) {
        extension_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000400);
    } else {
        extensionBuilder_.clear();
    }
    description_ = "";
    bitField0_ = (bitField0_ & ~0x00000800);
    keyRotationTime_ = 0L;
    bitField0_ = (bitField0_ & ~0x00001000);
    if (tagsBuilder_ == null) {
        tags_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00002000);
    } else {
        tagsBuilder_.clear();
    }
    if (transactionSignersBuilder_ == null) {
        transactionSigners_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00004000);
    } else {
        transactionSignersBuilder_.clear();
    }
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_Wallet_descriptor;
}

######


public org.galilelj.wallet.Protos.Wallet getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.Wallet.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.Wallet build() {
    org.galilelj.wallet.Protos.Wallet result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.Wallet buildPartial() {
    org.galilelj.wallet.Protos.Wallet result = new org.galilelj.wallet.Protos.Wallet(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.networkIdentifier_ = networkIdentifier_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.lastSeenBlockHash_ = lastSeenBlockHash_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.lastSeenBlockHeight_ = lastSeenBlockHeight_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000008;
    }
    result.lastSeenBlockTimeSecs_ = lastSeenBlockTimeSecs_;
    if (keyBuilder_ == null) {
        if (((bitField0_ & 0x00000010) == 0x00000010)) {
            key_ = java.util.Collections.unmodifiableList(key_);
            bitField0_ = (bitField0_ & ~0x00000010);
        }
        result.key_ = key_;
    } else {
        result.key_ = keyBuilder_.build();
    }
    if (transactionBuilder_ == null) {
        if (((bitField0_ & 0x00000020) == 0x00000020)) {
            transaction_ = java.util.Collections.unmodifiableList(transaction_);
            bitField0_ = (bitField0_ & ~0x00000020);
        }
        result.transaction_ = transaction_;
    } else {
        result.transaction_ = transactionBuilder_.build();
    }
    if (watchedScriptBuilder_ == null) {
        if (((bitField0_ & 0x00000040) == 0x00000040)) {
            watchedScript_ = java.util.Collections.unmodifiableList(watchedScript_);
            bitField0_ = (bitField0_ & ~0x00000040);
        }
        result.watchedScript_ = watchedScript_;
    } else {
        result.watchedScript_ = watchedScriptBuilder_.build();
    }
    if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
        to_bitField0_ |= 0x00000010;
    }
    result.encryptionType_ = encryptionType_;
    if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
        to_bitField0_ |= 0x00000020;
    }
    if (encryptionParametersBuilder_ == null) {
        result.encryptionParameters_ = encryptionParameters_;
    } else {
        result.encryptionParameters_ = encryptionParametersBuilder_.build();
    }
    if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
        to_bitField0_ |= 0x00000040;
    }
    result.version_ = version_;
    if (extensionBuilder_ == null) {
        if (((bitField0_ & 0x00000400) == 0x00000400)) {
            extension_ = java.util.Collections.unmodifiableList(extension_);
            bitField0_ = (bitField0_ & ~0x00000400);
        }
        result.extension_ = extension_;
    } else {
        result.extension_ = extensionBuilder_.build();
    }
    if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
        to_bitField0_ |= 0x00000080;
    }
    result.description_ = description_;
    if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
        to_bitField0_ |= 0x00000100;
    }
    result.keyRotationTime_ = keyRotationTime_;
    if (tagsBuilder_ == null) {
        if (((bitField0_ & 0x00002000) == 0x00002000)) {
            tags_ = java.util.Collections.unmodifiableList(tags_);
            bitField0_ = (bitField0_ & ~0x00002000);
        }
        result.tags_ = tags_;
    } else {
        result.tags_ = tagsBuilder_.build();
    }
    if (transactionSignersBuilder_ == null) {
        if (((bitField0_ & 0x00004000) == 0x00004000)) {
            transactionSigners_ = java.util.Collections.unmodifiableList(transactionSigners_);
            bitField0_ = (bitField0_ & ~0x00004000);
        }
        result.transactionSigners_ = transactionSigners_;
    } else {
        result.transactionSigners_ = transactionSignersBuilder_.build();
    }
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.Wallet) {
        return mergeFrom((org.galilelj.wallet.Protos.Wallet) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.Wallet other) {
    if (other == org.galilelj.wallet.Protos.Wallet.getDefaultInstance())
        return this;
    if (other.hasNetworkIdentifier()) {
        bitField0_ |= 0x00000001;
        networkIdentifier_ = other.networkIdentifier_;
        onChanged();
    }
    if (other.hasLastSeenBlockHash()) {
        setLastSeenBlockHash(other.getLastSeenBlockHash());
    }
    if (other.hasLastSeenBlockHeight()) {
        setLastSeenBlockHeight(other.getLastSeenBlockHeight());
    }
    if (other.hasLastSeenBlockTimeSecs()) {
        setLastSeenBlockTimeSecs(other.getLastSeenBlockTimeSecs());
    }
    if (keyBuilder_ == null) {
        if (!other.key_.isEmpty()) {
            if (key_.isEmpty()) {
                key_ = other.key_;
                bitField0_ = (bitField0_ & ~0x00000010);
            } else {
                ensureKeyIsMutable();
                key_.addAll(other.key_);
            }
            onChanged();
        }
    } else {
        if (!other.key_.isEmpty()) {
            if (keyBuilder_.isEmpty()) {
                keyBuilder_.dispose();
                keyBuilder_ = null;
                key_ = other.key_;
                bitField0_ = (bitField0_ & ~0x00000010);
                keyBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getKeyFieldBuilder() : null;
            } else {
                keyBuilder_.addAllMessages(other.key_);
            }
        }
    }
    if (transactionBuilder_ == null) {
        if (!other.transaction_.isEmpty()) {
            if (transaction_.isEmpty()) {
                transaction_ = other.transaction_;
                bitField0_ = (bitField0_ & ~0x00000020);
            } else {
                ensureTransactionIsMutable();
                transaction_.addAll(other.transaction_);
            }
            onChanged();
        }
    } else {
        if (!other.transaction_.isEmpty()) {
            if (transactionBuilder_.isEmpty()) {
                transactionBuilder_.dispose();
                transactionBuilder_ = null;
                transaction_ = other.transaction_;
                bitField0_ = (bitField0_ & ~0x00000020);
                transactionBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getTransactionFieldBuilder() : null;
            } else {
                transactionBuilder_.addAllMessages(other.transaction_);
            }
        }
    }
    if (watchedScriptBuilder_ == null) {
        if (!other.watchedScript_.isEmpty()) {
            if (watchedScript_.isEmpty()) {
                watchedScript_ = other.watchedScript_;
                bitField0_ = (bitField0_ & ~0x00000040);
            } else {
                ensureWatchedScriptIsMutable();
                watchedScript_.addAll(other.watchedScript_);
            }
            onChanged();
        }
    } else {
        if (!other.watchedScript_.isEmpty()) {
            if (watchedScriptBuilder_.isEmpty()) {
                watchedScriptBuilder_.dispose();
                watchedScriptBuilder_ = null;
                watchedScript_ = other.watchedScript_;
                bitField0_ = (bitField0_ & ~0x00000040);
                watchedScriptBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getWatchedScriptFieldBuilder() : null;
            } else {
                watchedScriptBuilder_.addAllMessages(other.watchedScript_);
            }
        }
    }
    if (other.hasEncryptionType()) {
        setEncryptionType(other.getEncryptionType());
    }
    if (other.hasEncryptionParameters()) {
        mergeEncryptionParameters(other.getEncryptionParameters());
    }
    if (other.hasVersion()) {
        setVersion(other.getVersion());
    }
    if (extensionBuilder_ == null) {
        if (!other.extension_.isEmpty()) {
            if (extension_.isEmpty()) {
                extension_ = other.extension_;
                bitField0_ = (bitField0_ & ~0x00000400);
            } else {
                ensureExtensionIsMutable();
                extension_.addAll(other.extension_);
            }
            onChanged();
        }
    } else {
        if (!other.extension_.isEmpty()) {
            if (extensionBuilder_.isEmpty()) {
                extensionBuilder_.dispose();
                extensionBuilder_ = null;
                extension_ = other.extension_;
                bitField0_ = (bitField0_ & ~0x00000400);
                extensionBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getExtensionFieldBuilder() : null;
            } else {
                extensionBuilder_.addAllMessages(other.extension_);
            }
        }
    }
    if (other.hasDescription()) {
        bitField0_ |= 0x00000800;
        description_ = other.description_;
        onChanged();
    }
    if (other.hasKeyRotationTime()) {
        setKeyRotationTime(other.getKeyRotationTime());
    }
    if (tagsBuilder_ == null) {
        if (!other.tags_.isEmpty()) {
            if (tags_.isEmpty()) {
                tags_ = other.tags_;
                bitField0_ = (bitField0_ & ~0x00002000);
            } else {
                ensureTagsIsMutable();
                tags_.addAll(other.tags_);
            }
            onChanged();
        }
    } else {
        if (!other.tags_.isEmpty()) {
            if (tagsBuilder_.isEmpty()) {
                tagsBuilder_.dispose();
                tagsBuilder_ = null;
                tags_ = other.tags_;
                bitField0_ = (bitField0_ & ~0x00002000);
                tagsBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getTagsFieldBuilder() : null;
            } else {
                tagsBuilder_.addAllMessages(other.tags_);
            }
        }
    }
    if (transactionSignersBuilder_ == null) {
        if (!other.transactionSigners_.isEmpty()) {
            if (transactionSigners_.isEmpty()) {
                transactionSigners_ = other.transactionSigners_;
                bitField0_ = (bitField0_ & ~0x00004000);
            } else {
                ensureTransactionSignersIsMutable();
                transactionSigners_.addAll(other.transactionSigners_);
            }
            onChanged();
        }
    } else {
        if (!other.transactionSigners_.isEmpty()) {
            if (transactionSignersBuilder_.isEmpty()) {
                transactionSignersBuilder_.dispose();
                transactionSignersBuilder_ = null;
                transactionSigners_ = other.transactionSigners_;
                bitField0_ = (bitField0_ & ~0x00004000);
                transactionSignersBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getTransactionSignersFieldBuilder() : null;
            } else {
                transactionSignersBuilder_.addAllMessages(other.transactionSigners_);
            }
        }
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasNetworkIdentifier()) {
        return false;
    }
    for (int i = 0; i < getKeyCount(); i++) {
        if (!getKey(i).isInitialized()) {
            return false;
        }
    }
    for (int i = 0; i < getTransactionCount(); i++) {
        if (!getTransaction(i).isInitialized()) {
            return false;
        }
    }
    for (int i = 0; i < getWatchedScriptCount(); i++) {
        if (!getWatchedScript(i).isInitialized()) {
            return false;
        }
    }
    if (hasEncryptionParameters()) {
        if (!getEncryptionParameters().isInitialized()) {
            return false;
        }
    }
    for (int i = 0; i < getExtensionCount(); i++) {
        if (!getExtension(i).isInitialized()) {
            return false;
        }
    }
    for (int i = 0; i < getTagsCount(); i++) {
        if (!getTags(i).isInitialized()) {
            return false;
        }
    }
    for (int i = 0; i < getTransactionSignersCount(); i++) {
        if (!getTransactionSigners(i).isInitialized()) {
            return false;
        }
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.Wallet parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.Wallet) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasNetworkIdentifier() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public java.lang.String getNetworkIdentifier() {
    java.lang.Object ref = networkIdentifier_;
    if (!(ref instanceof java.lang.String)) {
        java.lang.String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();
        networkIdentifier_ = s;
        return s;
    } else {
        return (java.lang.String) ref;
    }
}

######


public com.google.protobuf.ByteString getNetworkIdentifierBytes() {
    java.lang.Object ref = networkIdentifier_;
    if (ref instanceof String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        networkIdentifier_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public Builder setNetworkIdentifier(java.lang.String value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    networkIdentifier_ = value;
    onChanged();
    return this;
}

######


public Builder clearNetworkIdentifier() {
    bitField0_ = (bitField0_ & ~0x00000001);
    networkIdentifier_ = getDefaultInstance().getNetworkIdentifier();
    onChanged();
    return this;
}

######


public Builder setNetworkIdentifierBytes(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    networkIdentifier_ = value;
    onChanged();
    return this;
}

######


public boolean hasLastSeenBlockHash() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public com.google.protobuf.ByteString getLastSeenBlockHash() {
    return lastSeenBlockHash_;
}

######


public Builder setLastSeenBlockHash(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000002;
    lastSeenBlockHash_ = value;
    onChanged();
    return this;
}

######


public Builder clearLastSeenBlockHash() {
    bitField0_ = (bitField0_ & ~0x00000002);
    lastSeenBlockHash_ = getDefaultInstance().getLastSeenBlockHash();
    onChanged();
    return this;
}

######


public boolean hasLastSeenBlockHeight() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public int getLastSeenBlockHeight() {
    return lastSeenBlockHeight_;
}

######


public Builder setLastSeenBlockHeight(int value) {
    bitField0_ |= 0x00000004;
    lastSeenBlockHeight_ = value;
    onChanged();
    return this;
}

######


public Builder clearLastSeenBlockHeight() {
    bitField0_ = (bitField0_ & ~0x00000004);
    lastSeenBlockHeight_ = 0;
    onChanged();
    return this;
}

######


public boolean hasLastSeenBlockTimeSecs() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}

######


public long getLastSeenBlockTimeSecs() {
    return lastSeenBlockTimeSecs_;
}

######


public Builder setLastSeenBlockTimeSecs(long value) {
    bitField0_ |= 0x00000008;
    lastSeenBlockTimeSecs_ = value;
    onChanged();
    return this;
}

######


public Builder clearLastSeenBlockTimeSecs() {
    bitField0_ = (bitField0_ & ~0x00000008);
    lastSeenBlockTimeSecs_ = 0L;
    onChanged();
    return this;
}

######


private void ensureKeyIsMutable() {
    if (!((bitField0_ & 0x00000010) == 0x00000010)) {
        key_ = new java.util.ArrayList<org.galilelj.wallet.Protos.Key>(key_);
        bitField0_ |= 0x00000010;
    }
}

######


public java.util.List<org.galilelj.wallet.Protos.Key> getKeyList() {
    if (keyBuilder_ == null) {
        return java.util.Collections.unmodifiableList(key_);
    } else {
        return keyBuilder_.getMessageList();
    }
}

######


public int getKeyCount() {
    if (keyBuilder_ == null) {
        return key_.size();
    } else {
        return keyBuilder_.getCount();
    }
}

######


public org.galilelj.wallet.Protos.Key getKey(int index) {
    if (keyBuilder_ == null) {
        return key_.get(index);
    } else {
        return keyBuilder_.getMessage(index);
    }
}

######


public Builder setKey(int index, org.galilelj.wallet.Protos.Key value) {
    if (keyBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureKeyIsMutable();
        key_.set(index, value);
        onChanged();
    } else {
        keyBuilder_.setMessage(index, value);
    }
    return this;
}

######


public Builder setKey(int index, org.galilelj.wallet.Protos.Key.Builder builderForValue) {
    if (keyBuilder_ == null) {
        ensureKeyIsMutable();
        key_.set(index, builderForValue.build());
        onChanged();
    } else {
        keyBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addKey(org.galilelj.wallet.Protos.Key value) {
    if (keyBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureKeyIsMutable();
        key_.add(value);
        onChanged();
    } else {
        keyBuilder_.addMessage(value);
    }
    return this;
}

######


public Builder addKey(int index, org.galilelj.wallet.Protos.Key value) {
    if (keyBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureKeyIsMutable();
        key_.add(index, value);
        onChanged();
    } else {
        keyBuilder_.addMessage(index, value);
    }
    return this;
}

######


public Builder addKey(org.galilelj.wallet.Protos.Key.Builder builderForValue) {
    if (keyBuilder_ == null) {
        ensureKeyIsMutable();
        key_.add(builderForValue.build());
        onChanged();
    } else {
        keyBuilder_.addMessage(builderForValue.build());
    }
    return this;
}

######


public Builder addKey(int index, org.galilelj.wallet.Protos.Key.Builder builderForValue) {
    if (keyBuilder_ == null) {
        ensureKeyIsMutable();
        key_.add(index, builderForValue.build());
        onChanged();
    } else {
        keyBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addAllKey(java.lang.Iterable<? extends org.galilelj.wallet.Protos.Key> values) {
    if (keyBuilder_ == null) {
        ensureKeyIsMutable();
        super.addAll(values, key_);
        onChanged();
    } else {
        keyBuilder_.addAllMessages(values);
    }
    return this;
}

######


public Builder clearKey() {
    if (keyBuilder_ == null) {
        key_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
    } else {
        keyBuilder_.clear();
    }
    return this;
}

######


public Builder removeKey(int index) {
    if (keyBuilder_ == null) {
        ensureKeyIsMutable();
        key_.remove(index);
        onChanged();
    } else {
        keyBuilder_.remove(index);
    }
    return this;
}

######


public org.galilelj.wallet.Protos.Key.Builder getKeyBuilder(int index) {
    return getKeyFieldBuilder().getBuilder(index);
}

######


public org.galilelj.wallet.Protos.KeyOrBuilder getKeyOrBuilder(int index) {
    if (keyBuilder_ == null) {
        return key_.get(index);
    } else {
        return keyBuilder_.getMessageOrBuilder(index);
    }
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.KeyOrBuilder> getKeyOrBuilderList() {
    if (keyBuilder_ != null) {
        return keyBuilder_.getMessageOrBuilderList();
    } else {
        return java.util.Collections.unmodifiableList(key_);
    }
}

######


public org.galilelj.wallet.Protos.Key.Builder addKeyBuilder() {
    return getKeyFieldBuilder().addBuilder(org.galilelj.wallet.Protos.Key.getDefaultInstance());
}

######


public org.galilelj.wallet.Protos.Key.Builder addKeyBuilder(int index) {
    return getKeyFieldBuilder().addBuilder(index, org.galilelj.wallet.Protos.Key.getDefaultInstance());
}

######


public java.util.List<org.galilelj.wallet.Protos.Key.Builder> getKeyBuilderList() {
    return getKeyFieldBuilder().getBuilderList();
}

######


private com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.Key, org.galilelj.wallet.Protos.Key.Builder, org.galilelj.wallet.Protos.KeyOrBuilder> getKeyFieldBuilder() {
    if (keyBuilder_ == null) {
        keyBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.Key, org.galilelj.wallet.Protos.Key.Builder, org.galilelj.wallet.Protos.KeyOrBuilder>(key_, ((bitField0_ & 0x00000010) == 0x00000010), getParentForChildren(), isClean());
        key_ = null;
    }
    return keyBuilder_;
}

######


private void ensureTransactionIsMutable() {
    if (!((bitField0_ & 0x00000020) == 0x00000020)) {
        transaction_ = new java.util.ArrayList<org.galilelj.wallet.Protos.Transaction>(transaction_);
        bitField0_ |= 0x00000020;
    }
}

######


public java.util.List<org.galilelj.wallet.Protos.Transaction> getTransactionList() {
    if (transactionBuilder_ == null) {
        return java.util.Collections.unmodifiableList(transaction_);
    } else {
        return transactionBuilder_.getMessageList();
    }
}

######


public int getTransactionCount() {
    if (transactionBuilder_ == null) {
        return transaction_.size();
    } else {
        return transactionBuilder_.getCount();
    }
}

######


public org.galilelj.wallet.Protos.Transaction getTransaction(int index) {
    if (transactionBuilder_ == null) {
        return transaction_.get(index);
    } else {
        return transactionBuilder_.getMessage(index);
    }
}

######


public Builder setTransaction(int index, org.galilelj.wallet.Protos.Transaction value) {
    if (transactionBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTransactionIsMutable();
        transaction_.set(index, value);
        onChanged();
    } else {
        transactionBuilder_.setMessage(index, value);
    }
    return this;
}

######


public Builder setTransaction(int index, org.galilelj.wallet.Protos.Transaction.Builder builderForValue) {
    if (transactionBuilder_ == null) {
        ensureTransactionIsMutable();
        transaction_.set(index, builderForValue.build());
        onChanged();
    } else {
        transactionBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addTransaction(org.galilelj.wallet.Protos.Transaction value) {
    if (transactionBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTransactionIsMutable();
        transaction_.add(value);
        onChanged();
    } else {
        transactionBuilder_.addMessage(value);
    }
    return this;
}

######


public Builder addTransaction(int index, org.galilelj.wallet.Protos.Transaction value) {
    if (transactionBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTransactionIsMutable();
        transaction_.add(index, value);
        onChanged();
    } else {
        transactionBuilder_.addMessage(index, value);
    }
    return this;
}

######


public Builder addTransaction(org.galilelj.wallet.Protos.Transaction.Builder builderForValue) {
    if (transactionBuilder_ == null) {
        ensureTransactionIsMutable();
        transaction_.add(builderForValue.build());
        onChanged();
    } else {
        transactionBuilder_.addMessage(builderForValue.build());
    }
    return this;
}

######


public Builder addTransaction(int index, org.galilelj.wallet.Protos.Transaction.Builder builderForValue) {
    if (transactionBuilder_ == null) {
        ensureTransactionIsMutable();
        transaction_.add(index, builderForValue.build());
        onChanged();
    } else {
        transactionBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addAllTransaction(java.lang.Iterable<? extends org.galilelj.wallet.Protos.Transaction> values) {
    if (transactionBuilder_ == null) {
        ensureTransactionIsMutable();
        super.addAll(values, transaction_);
        onChanged();
    } else {
        transactionBuilder_.addAllMessages(values);
    }
    return this;
}

######


public Builder clearTransaction() {
    if (transactionBuilder_ == null) {
        transaction_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
    } else {
        transactionBuilder_.clear();
    }
    return this;
}

######


public Builder removeTransaction(int index) {
    if (transactionBuilder_ == null) {
        ensureTransactionIsMutable();
        transaction_.remove(index);
        onChanged();
    } else {
        transactionBuilder_.remove(index);
    }
    return this;
}

######


public org.galilelj.wallet.Protos.Transaction.Builder getTransactionBuilder(int index) {
    return getTransactionFieldBuilder().getBuilder(index);
}

######


public org.galilelj.wallet.Protos.TransactionOrBuilder getTransactionOrBuilder(int index) {
    if (transactionBuilder_ == null) {
        return transaction_.get(index);
    } else {
        return transactionBuilder_.getMessageOrBuilder(index);
    }
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.TransactionOrBuilder> getTransactionOrBuilderList() {
    if (transactionBuilder_ != null) {
        return transactionBuilder_.getMessageOrBuilderList();
    } else {
        return java.util.Collections.unmodifiableList(transaction_);
    }
}

######


public org.galilelj.wallet.Protos.Transaction.Builder addTransactionBuilder() {
    return getTransactionFieldBuilder().addBuilder(org.galilelj.wallet.Protos.Transaction.getDefaultInstance());
}

######


public org.galilelj.wallet.Protos.Transaction.Builder addTransactionBuilder(int index) {
    return getTransactionFieldBuilder().addBuilder(index, org.galilelj.wallet.Protos.Transaction.getDefaultInstance());
}

######


public java.util.List<org.galilelj.wallet.Protos.Transaction.Builder> getTransactionBuilderList() {
    return getTransactionFieldBuilder().getBuilderList();
}

######


private com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.Transaction, org.galilelj.wallet.Protos.Transaction.Builder, org.galilelj.wallet.Protos.TransactionOrBuilder> getTransactionFieldBuilder() {
    if (transactionBuilder_ == null) {
        transactionBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.Transaction, org.galilelj.wallet.Protos.Transaction.Builder, org.galilelj.wallet.Protos.TransactionOrBuilder>(transaction_, ((bitField0_ & 0x00000020) == 0x00000020), getParentForChildren(), isClean());
        transaction_ = null;
    }
    return transactionBuilder_;
}

######


private void ensureWatchedScriptIsMutable() {
    if (!((bitField0_ & 0x00000040) == 0x00000040)) {
        watchedScript_ = new java.util.ArrayList<org.galilelj.wallet.Protos.Script>(watchedScript_);
        bitField0_ |= 0x00000040;
    }
}

######


public java.util.List<org.galilelj.wallet.Protos.Script> getWatchedScriptList() {
    if (watchedScriptBuilder_ == null) {
        return java.util.Collections.unmodifiableList(watchedScript_);
    } else {
        return watchedScriptBuilder_.getMessageList();
    }
}

######


public int getWatchedScriptCount() {
    if (watchedScriptBuilder_ == null) {
        return watchedScript_.size();
    } else {
        return watchedScriptBuilder_.getCount();
    }
}

######


public org.galilelj.wallet.Protos.Script getWatchedScript(int index) {
    if (watchedScriptBuilder_ == null) {
        return watchedScript_.get(index);
    } else {
        return watchedScriptBuilder_.getMessage(index);
    }
}

######


public Builder setWatchedScript(int index, org.galilelj.wallet.Protos.Script value) {
    if (watchedScriptBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureWatchedScriptIsMutable();
        watchedScript_.set(index, value);
        onChanged();
    } else {
        watchedScriptBuilder_.setMessage(index, value);
    }
    return this;
}

######


public Builder setWatchedScript(int index, org.galilelj.wallet.Protos.Script.Builder builderForValue) {
    if (watchedScriptBuilder_ == null) {
        ensureWatchedScriptIsMutable();
        watchedScript_.set(index, builderForValue.build());
        onChanged();
    } else {
        watchedScriptBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addWatchedScript(org.galilelj.wallet.Protos.Script value) {
    if (watchedScriptBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureWatchedScriptIsMutable();
        watchedScript_.add(value);
        onChanged();
    } else {
        watchedScriptBuilder_.addMessage(value);
    }
    return this;
}

######


public Builder addWatchedScript(int index, org.galilelj.wallet.Protos.Script value) {
    if (watchedScriptBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureWatchedScriptIsMutable();
        watchedScript_.add(index, value);
        onChanged();
    } else {
        watchedScriptBuilder_.addMessage(index, value);
    }
    return this;
}

######


public Builder addWatchedScript(org.galilelj.wallet.Protos.Script.Builder builderForValue) {
    if (watchedScriptBuilder_ == null) {
        ensureWatchedScriptIsMutable();
        watchedScript_.add(builderForValue.build());
        onChanged();
    } else {
        watchedScriptBuilder_.addMessage(builderForValue.build());
    }
    return this;
}

######


public Builder addWatchedScript(int index, org.galilelj.wallet.Protos.Script.Builder builderForValue) {
    if (watchedScriptBuilder_ == null) {
        ensureWatchedScriptIsMutable();
        watchedScript_.add(index, builderForValue.build());
        onChanged();
    } else {
        watchedScriptBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addAllWatchedScript(java.lang.Iterable<? extends org.galilelj.wallet.Protos.Script> values) {
    if (watchedScriptBuilder_ == null) {
        ensureWatchedScriptIsMutable();
        super.addAll(values, watchedScript_);
        onChanged();
    } else {
        watchedScriptBuilder_.addAllMessages(values);
    }
    return this;
}

######


public Builder clearWatchedScript() {
    if (watchedScriptBuilder_ == null) {
        watchedScript_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
    } else {
        watchedScriptBuilder_.clear();
    }
    return this;
}

######


public Builder removeWatchedScript(int index) {
    if (watchedScriptBuilder_ == null) {
        ensureWatchedScriptIsMutable();
        watchedScript_.remove(index);
        onChanged();
    } else {
        watchedScriptBuilder_.remove(index);
    }
    return this;
}

######


public org.galilelj.wallet.Protos.Script.Builder getWatchedScriptBuilder(int index) {
    return getWatchedScriptFieldBuilder().getBuilder(index);
}

######


public org.galilelj.wallet.Protos.ScriptOrBuilder getWatchedScriptOrBuilder(int index) {
    if (watchedScriptBuilder_ == null) {
        return watchedScript_.get(index);
    } else {
        return watchedScriptBuilder_.getMessageOrBuilder(index);
    }
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.ScriptOrBuilder> getWatchedScriptOrBuilderList() {
    if (watchedScriptBuilder_ != null) {
        return watchedScriptBuilder_.getMessageOrBuilderList();
    } else {
        return java.util.Collections.unmodifiableList(watchedScript_);
    }
}

######


public org.galilelj.wallet.Protos.Script.Builder addWatchedScriptBuilder() {
    return getWatchedScriptFieldBuilder().addBuilder(org.galilelj.wallet.Protos.Script.getDefaultInstance());
}

######


public org.galilelj.wallet.Protos.Script.Builder addWatchedScriptBuilder(int index) {
    return getWatchedScriptFieldBuilder().addBuilder(index, org.galilelj.wallet.Protos.Script.getDefaultInstance());
}

######


public java.util.List<org.galilelj.wallet.Protos.Script.Builder> getWatchedScriptBuilderList() {
    return getWatchedScriptFieldBuilder().getBuilderList();
}

######


private com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.Script, org.galilelj.wallet.Protos.Script.Builder, org.galilelj.wallet.Protos.ScriptOrBuilder> getWatchedScriptFieldBuilder() {
    if (watchedScriptBuilder_ == null) {
        watchedScriptBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.Script, org.galilelj.wallet.Protos.Script.Builder, org.galilelj.wallet.Protos.ScriptOrBuilder>(watchedScript_, ((bitField0_ & 0x00000040) == 0x00000040), getParentForChildren(), isClean());
        watchedScript_ = null;
    }
    return watchedScriptBuilder_;
}

######


public boolean hasEncryptionType() {
    return ((bitField0_ & 0x00000080) == 0x00000080);
}

######


public org.galilelj.wallet.Protos.Wallet.EncryptionType getEncryptionType() {
    return encryptionType_;
}

######


public Builder setEncryptionType(org.galilelj.wallet.Protos.Wallet.EncryptionType value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000080;
    encryptionType_ = value;
    onChanged();
    return this;
}

######


public Builder clearEncryptionType() {
    bitField0_ = (bitField0_ & ~0x00000080);
    encryptionType_ = org.galilelj.wallet.Protos.Wallet.EncryptionType.UNENCRYPTED;
    onChanged();
    return this;
}

######


public boolean hasEncryptionParameters() {
    return ((bitField0_ & 0x00000100) == 0x00000100);
}

######


public org.galilelj.wallet.Protos.ScryptParameters getEncryptionParameters() {
    if (encryptionParametersBuilder_ == null) {
        return encryptionParameters_;
    } else {
        return encryptionParametersBuilder_.getMessage();
    }
}

######


public Builder setEncryptionParameters(org.galilelj.wallet.Protos.ScryptParameters value) {
    if (encryptionParametersBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        encryptionParameters_ = value;
        onChanged();
    } else {
        encryptionParametersBuilder_.setMessage(value);
    }
    bitField0_ |= 0x00000100;
    return this;
}

######


public Builder setEncryptionParameters(org.galilelj.wallet.Protos.ScryptParameters.Builder builderForValue) {
    if (encryptionParametersBuilder_ == null) {
        encryptionParameters_ = builderForValue.build();
        onChanged();
    } else {
        encryptionParametersBuilder_.setMessage(builderForValue.build());
    }
    bitField0_ |= 0x00000100;
    return this;
}

######


public Builder mergeEncryptionParameters(org.galilelj.wallet.Protos.ScryptParameters value) {
    if (encryptionParametersBuilder_ == null) {
        if (((bitField0_ & 0x00000100) == 0x00000100) && encryptionParameters_ != org.galilelj.wallet.Protos.ScryptParameters.getDefaultInstance()) {
            encryptionParameters_ = org.galilelj.wallet.Protos.ScryptParameters.newBuilder(encryptionParameters_).mergeFrom(value).buildPartial();
        } else {
            encryptionParameters_ = value;
        }
        onChanged();
    } else {
        encryptionParametersBuilder_.mergeFrom(value);
    }
    bitField0_ |= 0x00000100;
    return this;
}

######


public Builder clearEncryptionParameters() {
    if (encryptionParametersBuilder_ == null) {
        encryptionParameters_ = org.galilelj.wallet.Protos.ScryptParameters.getDefaultInstance();
        onChanged();
    } else {
        encryptionParametersBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000100);
    return this;
}

######


public org.galilelj.wallet.Protos.ScryptParameters.Builder getEncryptionParametersBuilder() {
    bitField0_ |= 0x00000100;
    onChanged();
    return getEncryptionParametersFieldBuilder().getBuilder();
}

######


public org.galilelj.wallet.Protos.ScryptParametersOrBuilder getEncryptionParametersOrBuilder() {
    if (encryptionParametersBuilder_ != null) {
        return encryptionParametersBuilder_.getMessageOrBuilder();
    } else {
        return encryptionParameters_;
    }
}

######


private com.google.protobuf.SingleFieldBuilder<org.galilelj.wallet.Protos.ScryptParameters, org.galilelj.wallet.Protos.ScryptParameters.Builder, org.galilelj.wallet.Protos.ScryptParametersOrBuilder> getEncryptionParametersFieldBuilder() {
    if (encryptionParametersBuilder_ == null) {
        encryptionParametersBuilder_ = new com.google.protobuf.SingleFieldBuilder<org.galilelj.wallet.Protos.ScryptParameters, org.galilelj.wallet.Protos.ScryptParameters.Builder, org.galilelj.wallet.Protos.ScryptParametersOrBuilder>(encryptionParameters_, getParentForChildren(), isClean());
        encryptionParameters_ = null;
    }
    return encryptionParametersBuilder_;
}

######


public boolean hasVersion() {
    return ((bitField0_ & 0x00000200) == 0x00000200);
}

######


public int getVersion() {
    return version_;
}

######


public Builder setVersion(int value) {
    bitField0_ |= 0x00000200;
    version_ = value;
    onChanged();
    return this;
}

######


public Builder clearVersion() {
    bitField0_ = (bitField0_ & ~0x00000200);
    version_ = 1;
    onChanged();
    return this;
}

######


private void ensureExtensionIsMutable() {
    if (!((bitField0_ & 0x00000400) == 0x00000400)) {
        extension_ = new java.util.ArrayList<org.galilelj.wallet.Protos.Extension>(extension_);
        bitField0_ |= 0x00000400;
    }
}

######


public java.util.List<org.galilelj.wallet.Protos.Extension> getExtensionList() {
    if (extensionBuilder_ == null) {
        return java.util.Collections.unmodifiableList(extension_);
    } else {
        return extensionBuilder_.getMessageList();
    }
}

######


public int getExtensionCount() {
    if (extensionBuilder_ == null) {
        return extension_.size();
    } else {
        return extensionBuilder_.getCount();
    }
}

######


public org.galilelj.wallet.Protos.Extension getExtension(int index) {
    if (extensionBuilder_ == null) {
        return extension_.get(index);
    } else {
        return extensionBuilder_.getMessage(index);
    }
}

######


public Builder setExtension(int index, org.galilelj.wallet.Protos.Extension value) {
    if (extensionBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureExtensionIsMutable();
        extension_.set(index, value);
        onChanged();
    } else {
        extensionBuilder_.setMessage(index, value);
    }
    return this;
}

######


public Builder setExtension(int index, org.galilelj.wallet.Protos.Extension.Builder builderForValue) {
    if (extensionBuilder_ == null) {
        ensureExtensionIsMutable();
        extension_.set(index, builderForValue.build());
        onChanged();
    } else {
        extensionBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addExtension(org.galilelj.wallet.Protos.Extension value) {
    if (extensionBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureExtensionIsMutable();
        extension_.add(value);
        onChanged();
    } else {
        extensionBuilder_.addMessage(value);
    }
    return this;
}

######


public Builder addExtension(int index, org.galilelj.wallet.Protos.Extension value) {
    if (extensionBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureExtensionIsMutable();
        extension_.add(index, value);
        onChanged();
    } else {
        extensionBuilder_.addMessage(index, value);
    }
    return this;
}

######


public Builder addExtension(org.galilelj.wallet.Protos.Extension.Builder builderForValue) {
    if (extensionBuilder_ == null) {
        ensureExtensionIsMutable();
        extension_.add(builderForValue.build());
        onChanged();
    } else {
        extensionBuilder_.addMessage(builderForValue.build());
    }
    return this;
}

######


public Builder addExtension(int index, org.galilelj.wallet.Protos.Extension.Builder builderForValue) {
    if (extensionBuilder_ == null) {
        ensureExtensionIsMutable();
        extension_.add(index, builderForValue.build());
        onChanged();
    } else {
        extensionBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addAllExtension(java.lang.Iterable<? extends org.galilelj.wallet.Protos.Extension> values) {
    if (extensionBuilder_ == null) {
        ensureExtensionIsMutable();
        super.addAll(values, extension_);
        onChanged();
    } else {
        extensionBuilder_.addAllMessages(values);
    }
    return this;
}

######


public Builder clearExtension() {
    if (extensionBuilder_ == null) {
        extension_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000400);
        onChanged();
    } else {
        extensionBuilder_.clear();
    }
    return this;
}

######


public Builder removeExtension(int index) {
    if (extensionBuilder_ == null) {
        ensureExtensionIsMutable();
        extension_.remove(index);
        onChanged();
    } else {
        extensionBuilder_.remove(index);
    }
    return this;
}

######


public org.galilelj.wallet.Protos.Extension.Builder getExtensionBuilder(int index) {
    return getExtensionFieldBuilder().getBuilder(index);
}

######


public org.galilelj.wallet.Protos.ExtensionOrBuilder getExtensionOrBuilder(int index) {
    if (extensionBuilder_ == null) {
        return extension_.get(index);
    } else {
        return extensionBuilder_.getMessageOrBuilder(index);
    }
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.ExtensionOrBuilder> getExtensionOrBuilderList() {
    if (extensionBuilder_ != null) {
        return extensionBuilder_.getMessageOrBuilderList();
    } else {
        return java.util.Collections.unmodifiableList(extension_);
    }
}

######


public org.galilelj.wallet.Protos.Extension.Builder addExtensionBuilder() {
    return getExtensionFieldBuilder().addBuilder(org.galilelj.wallet.Protos.Extension.getDefaultInstance());
}

######


public org.galilelj.wallet.Protos.Extension.Builder addExtensionBuilder(int index) {
    return getExtensionFieldBuilder().addBuilder(index, org.galilelj.wallet.Protos.Extension.getDefaultInstance());
}

######


public java.util.List<org.galilelj.wallet.Protos.Extension.Builder> getExtensionBuilderList() {
    return getExtensionFieldBuilder().getBuilderList();
}

######


private com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.Extension, org.galilelj.wallet.Protos.Extension.Builder, org.galilelj.wallet.Protos.ExtensionOrBuilder> getExtensionFieldBuilder() {
    if (extensionBuilder_ == null) {
        extensionBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.Extension, org.galilelj.wallet.Protos.Extension.Builder, org.galilelj.wallet.Protos.ExtensionOrBuilder>(extension_, ((bitField0_ & 0x00000400) == 0x00000400), getParentForChildren(), isClean());
        extension_ = null;
    }
    return extensionBuilder_;
}

######


public boolean hasDescription() {
    return ((bitField0_ & 0x00000800) == 0x00000800);
}

######


public java.lang.String getDescription() {
    java.lang.Object ref = description_;
    if (!(ref instanceof java.lang.String)) {
        java.lang.String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();
        description_ = s;
        return s;
    } else {
        return (java.lang.String) ref;
    }
}

######


public com.google.protobuf.ByteString getDescriptionBytes() {
    java.lang.Object ref = description_;
    if (ref instanceof String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        description_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public Builder setDescription(java.lang.String value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000800;
    description_ = value;
    onChanged();
    return this;
}

######


public Builder clearDescription() {
    bitField0_ = (bitField0_ & ~0x00000800);
    description_ = getDefaultInstance().getDescription();
    onChanged();
    return this;
}

######


public Builder setDescriptionBytes(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000800;
    description_ = value;
    onChanged();
    return this;
}

######


public boolean hasKeyRotationTime() {
    return ((bitField0_ & 0x00001000) == 0x00001000);
}

######


public long getKeyRotationTime() {
    return keyRotationTime_;
}

######


public Builder setKeyRotationTime(long value) {
    bitField0_ |= 0x00001000;
    keyRotationTime_ = value;
    onChanged();
    return this;
}

######


public Builder clearKeyRotationTime() {
    bitField0_ = (bitField0_ & ~0x00001000);
    keyRotationTime_ = 0L;
    onChanged();
    return this;
}

######


private void ensureTagsIsMutable() {
    if (!((bitField0_ & 0x00002000) == 0x00002000)) {
        tags_ = new java.util.ArrayList<org.galilelj.wallet.Protos.Tag>(tags_);
        bitField0_ |= 0x00002000;
    }
}

######


public java.util.List<org.galilelj.wallet.Protos.Tag> getTagsList() {
    if (tagsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(tags_);
    } else {
        return tagsBuilder_.getMessageList();
    }
}

######


public int getTagsCount() {
    if (tagsBuilder_ == null) {
        return tags_.size();
    } else {
        return tagsBuilder_.getCount();
    }
}

######


public org.galilelj.wallet.Protos.Tag getTags(int index) {
    if (tagsBuilder_ == null) {
        return tags_.get(index);
    } else {
        return tagsBuilder_.getMessage(index);
    }
}

######


public Builder setTags(int index, org.galilelj.wallet.Protos.Tag value) {
    if (tagsBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTagsIsMutable();
        tags_.set(index, value);
        onChanged();
    } else {
        tagsBuilder_.setMessage(index, value);
    }
    return this;
}

######


public Builder setTags(int index, org.galilelj.wallet.Protos.Tag.Builder builderForValue) {
    if (tagsBuilder_ == null) {
        ensureTagsIsMutable();
        tags_.set(index, builderForValue.build());
        onChanged();
    } else {
        tagsBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addTags(org.galilelj.wallet.Protos.Tag value) {
    if (tagsBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTagsIsMutable();
        tags_.add(value);
        onChanged();
    } else {
        tagsBuilder_.addMessage(value);
    }
    return this;
}

######


public Builder addTags(int index, org.galilelj.wallet.Protos.Tag value) {
    if (tagsBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTagsIsMutable();
        tags_.add(index, value);
        onChanged();
    } else {
        tagsBuilder_.addMessage(index, value);
    }
    return this;
}

######


public Builder addTags(org.galilelj.wallet.Protos.Tag.Builder builderForValue) {
    if (tagsBuilder_ == null) {
        ensureTagsIsMutable();
        tags_.add(builderForValue.build());
        onChanged();
    } else {
        tagsBuilder_.addMessage(builderForValue.build());
    }
    return this;
}

######


public Builder addTags(int index, org.galilelj.wallet.Protos.Tag.Builder builderForValue) {
    if (tagsBuilder_ == null) {
        ensureTagsIsMutable();
        tags_.add(index, builderForValue.build());
        onChanged();
    } else {
        tagsBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addAllTags(java.lang.Iterable<? extends org.galilelj.wallet.Protos.Tag> values) {
    if (tagsBuilder_ == null) {
        ensureTagsIsMutable();
        super.addAll(values, tags_);
        onChanged();
    } else {
        tagsBuilder_.addAllMessages(values);
    }
    return this;
}

######


public Builder clearTags() {
    if (tagsBuilder_ == null) {
        tags_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00002000);
        onChanged();
    } else {
        tagsBuilder_.clear();
    }
    return this;
}

######


public Builder removeTags(int index) {
    if (tagsBuilder_ == null) {
        ensureTagsIsMutable();
        tags_.remove(index);
        onChanged();
    } else {
        tagsBuilder_.remove(index);
    }
    return this;
}

######


public org.galilelj.wallet.Protos.Tag.Builder getTagsBuilder(int index) {
    return getTagsFieldBuilder().getBuilder(index);
}

######


public org.galilelj.wallet.Protos.TagOrBuilder getTagsOrBuilder(int index) {
    if (tagsBuilder_ == null) {
        return tags_.get(index);
    } else {
        return tagsBuilder_.getMessageOrBuilder(index);
    }
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.TagOrBuilder> getTagsOrBuilderList() {
    if (tagsBuilder_ != null) {
        return tagsBuilder_.getMessageOrBuilderList();
    } else {
        return java.util.Collections.unmodifiableList(tags_);
    }
}

######


public org.galilelj.wallet.Protos.Tag.Builder addTagsBuilder() {
    return getTagsFieldBuilder().addBuilder(org.galilelj.wallet.Protos.Tag.getDefaultInstance());
}

######


public org.galilelj.wallet.Protos.Tag.Builder addTagsBuilder(int index) {
    return getTagsFieldBuilder().addBuilder(index, org.galilelj.wallet.Protos.Tag.getDefaultInstance());
}

######


public java.util.List<org.galilelj.wallet.Protos.Tag.Builder> getTagsBuilderList() {
    return getTagsFieldBuilder().getBuilderList();
}

######


private com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.Tag, org.galilelj.wallet.Protos.Tag.Builder, org.galilelj.wallet.Protos.TagOrBuilder> getTagsFieldBuilder() {
    if (tagsBuilder_ == null) {
        tagsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.Tag, org.galilelj.wallet.Protos.Tag.Builder, org.galilelj.wallet.Protos.TagOrBuilder>(tags_, ((bitField0_ & 0x00002000) == 0x00002000), getParentForChildren(), isClean());
        tags_ = null;
    }
    return tagsBuilder_;
}

######


private void ensureTransactionSignersIsMutable() {
    if (!((bitField0_ & 0x00004000) == 0x00004000)) {
        transactionSigners_ = new java.util.ArrayList<org.galilelj.wallet.Protos.TransactionSigner>(transactionSigners_);
        bitField0_ |= 0x00004000;
    }
}

######


public java.util.List<org.galilelj.wallet.Protos.TransactionSigner> getTransactionSignersList() {
    if (transactionSignersBuilder_ == null) {
        return java.util.Collections.unmodifiableList(transactionSigners_);
    } else {
        return transactionSignersBuilder_.getMessageList();
    }
}

######


public int getTransactionSignersCount() {
    if (transactionSignersBuilder_ == null) {
        return transactionSigners_.size();
    } else {
        return transactionSignersBuilder_.getCount();
    }
}

######


public org.galilelj.wallet.Protos.TransactionSigner getTransactionSigners(int index) {
    if (transactionSignersBuilder_ == null) {
        return transactionSigners_.get(index);
    } else {
        return transactionSignersBuilder_.getMessage(index);
    }
}

######


public Builder setTransactionSigners(int index, org.galilelj.wallet.Protos.TransactionSigner value) {
    if (transactionSignersBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTransactionSignersIsMutable();
        transactionSigners_.set(index, value);
        onChanged();
    } else {
        transactionSignersBuilder_.setMessage(index, value);
    }
    return this;
}

######


public Builder setTransactionSigners(int index, org.galilelj.wallet.Protos.TransactionSigner.Builder builderForValue) {
    if (transactionSignersBuilder_ == null) {
        ensureTransactionSignersIsMutable();
        transactionSigners_.set(index, builderForValue.build());
        onChanged();
    } else {
        transactionSignersBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addTransactionSigners(org.galilelj.wallet.Protos.TransactionSigner value) {
    if (transactionSignersBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTransactionSignersIsMutable();
        transactionSigners_.add(value);
        onChanged();
    } else {
        transactionSignersBuilder_.addMessage(value);
    }
    return this;
}

######


public Builder addTransactionSigners(int index, org.galilelj.wallet.Protos.TransactionSigner value) {
    if (transactionSignersBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureTransactionSignersIsMutable();
        transactionSigners_.add(index, value);
        onChanged();
    } else {
        transactionSignersBuilder_.addMessage(index, value);
    }
    return this;
}

######


public Builder addTransactionSigners(org.galilelj.wallet.Protos.TransactionSigner.Builder builderForValue) {
    if (transactionSignersBuilder_ == null) {
        ensureTransactionSignersIsMutable();
        transactionSigners_.add(builderForValue.build());
        onChanged();
    } else {
        transactionSignersBuilder_.addMessage(builderForValue.build());
    }
    return this;
}

######


public Builder addTransactionSigners(int index, org.galilelj.wallet.Protos.TransactionSigner.Builder builderForValue) {
    if (transactionSignersBuilder_ == null) {
        ensureTransactionSignersIsMutable();
        transactionSigners_.add(index, builderForValue.build());
        onChanged();
    } else {
        transactionSignersBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}

######


public Builder addAllTransactionSigners(java.lang.Iterable<? extends org.galilelj.wallet.Protos.TransactionSigner> values) {
    if (transactionSignersBuilder_ == null) {
        ensureTransactionSignersIsMutable();
        super.addAll(values, transactionSigners_);
        onChanged();
    } else {
        transactionSignersBuilder_.addAllMessages(values);
    }
    return this;
}

######


public Builder clearTransactionSigners() {
    if (transactionSignersBuilder_ == null) {
        transactionSigners_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00004000);
        onChanged();
    } else {
        transactionSignersBuilder_.clear();
    }
    return this;
}

######


public Builder removeTransactionSigners(int index) {
    if (transactionSignersBuilder_ == null) {
        ensureTransactionSignersIsMutable();
        transactionSigners_.remove(index);
        onChanged();
    } else {
        transactionSignersBuilder_.remove(index);
    }
    return this;
}

######


public org.galilelj.wallet.Protos.TransactionSigner.Builder getTransactionSignersBuilder(int index) {
    return getTransactionSignersFieldBuilder().getBuilder(index);
}

######


public org.galilelj.wallet.Protos.TransactionSignerOrBuilder getTransactionSignersOrBuilder(int index) {
    if (transactionSignersBuilder_ == null) {
        return transactionSigners_.get(index);
    } else {
        return transactionSignersBuilder_.getMessageOrBuilder(index);
    }
}

######


public java.util.List<? extends org.galilelj.wallet.Protos.TransactionSignerOrBuilder> getTransactionSignersOrBuilderList() {
    if (transactionSignersBuilder_ != null) {
        return transactionSignersBuilder_.getMessageOrBuilderList();
    } else {
        return java.util.Collections.unmodifiableList(transactionSigners_);
    }
}

######


public org.galilelj.wallet.Protos.TransactionSigner.Builder addTransactionSignersBuilder() {
    return getTransactionSignersFieldBuilder().addBuilder(org.galilelj.wallet.Protos.TransactionSigner.getDefaultInstance());
}

######


public org.galilelj.wallet.Protos.TransactionSigner.Builder addTransactionSignersBuilder(int index) {
    return getTransactionSignersFieldBuilder().addBuilder(index, org.galilelj.wallet.Protos.TransactionSigner.getDefaultInstance());
}

######


public java.util.List<org.galilelj.wallet.Protos.TransactionSigner.Builder> getTransactionSignersBuilderList() {
    return getTransactionSignersFieldBuilder().getBuilderList();
}

######


private com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.TransactionSigner, org.galilelj.wallet.Protos.TransactionSigner.Builder, org.galilelj.wallet.Protos.TransactionSignerOrBuilder> getTransactionSignersFieldBuilder() {
    if (transactionSignersBuilder_ == null) {
        transactionSignersBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<org.galilelj.wallet.Protos.TransactionSigner, org.galilelj.wallet.Protos.TransactionSigner.Builder, org.galilelj.wallet.Protos.TransactionSignerOrBuilder>(transactionSigners_, ((bitField0_ & 0x00004000) == 0x00004000), getParentForChildren(), isClean());
        transactionSigners_ = null;
    }
    return transactionSignersBuilder_;
}

######


boolean hasCoinValue();

######


long getCoinValue();

######


boolean hasFiatValue();

######


long getFiatValue();

######


boolean hasFiatCurrencyCode();

######


java.lang.String getFiatCurrencyCode();

######


com.google.protobuf.ByteString getFiatCurrencyCodeBytes();

######


public static ExchangeRate getDefaultInstance() {
    return defaultInstance;
}

######


public ExchangeRate getDefaultInstanceForType() {
    return defaultInstance;
}

######


@java.lang.Override
public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_ExchangeRate_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_ExchangeRate_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.ExchangeRate.class, org.galilelj.wallet.Protos.ExchangeRate.Builder.class);
}

######


public ExchangeRate parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return new ExchangeRate(input, extensionRegistry);
}

######


@java.lang.Override
public com.google.protobuf.Parser<ExchangeRate> getParserForType() {
    return PARSER;
}

######


public boolean hasCoinValue() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public long getCoinValue() {
    return coinValue_;
}

######


public boolean hasFiatValue() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public long getFiatValue() {
    return fiatValue_;
}

######


public boolean hasFiatCurrencyCode() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public java.lang.String getFiatCurrencyCode() {
    java.lang.Object ref = fiatCurrencyCode_;
    if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
    } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
            fiatCurrencyCode_ = s;
        }
        return s;
    }
}

######


public com.google.protobuf.ByteString getFiatCurrencyCodeBytes() {
    java.lang.Object ref = fiatCurrencyCode_;
    if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        fiatCurrencyCode_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


private void initFields() {
    coinValue_ = 0L;
    fiatValue_ = 0L;
    fiatCurrencyCode_ = "";
}

######


public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized != -1)
        return isInitialized == 1;
    if (!hasCoinValue()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (!hasFiatValue()) {
        memoizedIsInitialized = 0;
        return false;
    }
    if (!hasFiatCurrencyCode()) {
        memoizedIsInitialized = 0;
        return false;
    }
    memoizedIsInitialized = 1;
    return true;
}

######


public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt64(1, coinValue_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt64(2, fiatValue_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(3, getFiatCurrencyCodeBytes());
    }
    getUnknownFields().writeTo(output);
}

######


public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(1, coinValue_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(2, fiatValue_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(3, getFiatCurrencyCodeBytes());
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}

######


@java.lang.Override
protected java.lang.Object writeReplace() throws java.io.ObjectStreamException {
    return super.writeReplace();
}

######


public static org.galilelj.wallet.Protos.ExchangeRate parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.ExchangeRate parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.ExchangeRate parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
}

######


public static org.galilelj.wallet.Protos.ExchangeRate parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.ExchangeRate parseFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.ExchangeRate parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.ExchangeRate parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input);
}

######


public static org.galilelj.wallet.Protos.ExchangeRate parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseDelimitedFrom(input, extensionRegistry);
}

######


public static org.galilelj.wallet.Protos.ExchangeRate parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return PARSER.parseFrom(input);
}

######


public static org.galilelj.wallet.Protos.ExchangeRate parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    return PARSER.parseFrom(input, extensionRegistry);
}

######


public static Builder newBuilder() {
    return Builder.create();
}

######


public Builder newBuilderForType() {
    return newBuilder();
}

######


public static Builder newBuilder(org.galilelj.wallet.Protos.ExchangeRate prototype) {
    return newBuilder().mergeFrom(prototype);
}

######


public Builder toBuilder() {
    return newBuilder(this);
}

######


@java.lang.Override
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessage.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
}

######


public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return org.galilelj.wallet.Protos.internal_static_wallet_ExchangeRate_descriptor;
}

######


protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return org.galilelj.wallet.Protos.internal_static_wallet_ExchangeRate_fieldAccessorTable.ensureFieldAccessorsInitialized(org.galilelj.wallet.Protos.ExchangeRate.class, org.galilelj.wallet.Protos.ExchangeRate.Builder.class);
}

######


private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}

######


private static Builder create() {
    return new Builder();
}

######


public Builder clear() {
    super.clear();
    coinValue_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000001);
    fiatValue_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000002);
    fiatCurrencyCode_ = "";
    bitField0_ = (bitField0_ & ~0x00000004);
    return this;
}

######


public Builder clone() {
    return create().mergeFrom(buildPartial());
}

######


public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return org.galilelj.wallet.Protos.internal_static_wallet_ExchangeRate_descriptor;
}

######


public org.galilelj.wallet.Protos.ExchangeRate getDefaultInstanceForType() {
    return org.galilelj.wallet.Protos.ExchangeRate.getDefaultInstance();
}

######


public org.galilelj.wallet.Protos.ExchangeRate build() {
    org.galilelj.wallet.Protos.ExchangeRate result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}

######


public org.galilelj.wallet.Protos.ExchangeRate buildPartial() {
    org.galilelj.wallet.Protos.ExchangeRate result = new org.galilelj.wallet.Protos.ExchangeRate(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.coinValue_ = coinValue_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.fiatValue_ = fiatValue_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.fiatCurrencyCode_ = fiatCurrencyCode_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}

######


public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof org.galilelj.wallet.Protos.ExchangeRate) {
        return mergeFrom((org.galilelj.wallet.Protos.ExchangeRate) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}

######


public Builder mergeFrom(org.galilelj.wallet.Protos.ExchangeRate other) {
    if (other == org.galilelj.wallet.Protos.ExchangeRate.getDefaultInstance())
        return this;
    if (other.hasCoinValue()) {
        setCoinValue(other.getCoinValue());
    }
    if (other.hasFiatValue()) {
        setFiatValue(other.getFiatValue());
    }
    if (other.hasFiatCurrencyCode()) {
        bitField0_ |= 0x00000004;
        fiatCurrencyCode_ = other.fiatCurrencyCode_;
        onChanged();
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}

######


public final boolean isInitialized() {
    if (!hasCoinValue()) {
        return false;
    }
    if (!hasFiatValue()) {
        return false;
    }
    if (!hasFiatCurrencyCode()) {
        return false;
    }
    return true;
}

######


public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    org.galilelj.wallet.Protos.ExchangeRate parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (org.galilelj.wallet.Protos.ExchangeRate) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}

######


public boolean hasCoinValue() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}

######


public long getCoinValue() {
    return coinValue_;
}

######


public Builder setCoinValue(long value) {
    bitField0_ |= 0x00000001;
    coinValue_ = value;
    onChanged();
    return this;
}

######


public Builder clearCoinValue() {
    bitField0_ = (bitField0_ & ~0x00000001);
    coinValue_ = 0L;
    onChanged();
    return this;
}

######


public boolean hasFiatValue() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}

######


public long getFiatValue() {
    return fiatValue_;
}

######


public Builder setFiatValue(long value) {
    bitField0_ |= 0x00000002;
    fiatValue_ = value;
    onChanged();
    return this;
}

######


public Builder clearFiatValue() {
    bitField0_ = (bitField0_ & ~0x00000002);
    fiatValue_ = 0L;
    onChanged();
    return this;
}

######


public boolean hasFiatCurrencyCode() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}

######


public java.lang.String getFiatCurrencyCode() {
    java.lang.Object ref = fiatCurrencyCode_;
    if (!(ref instanceof java.lang.String)) {
        java.lang.String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();
        fiatCurrencyCode_ = s;
        return s;
    } else {
        return (java.lang.String) ref;
    }
}

######


public com.google.protobuf.ByteString getFiatCurrencyCodeBytes() {
    java.lang.Object ref = fiatCurrencyCode_;
    if (ref instanceof String) {
        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        fiatCurrencyCode_ = b;
        return b;
    } else {
        return (com.google.protobuf.ByteString) ref;
    }
}

######


public Builder setFiatCurrencyCode(java.lang.String value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000004;
    fiatCurrencyCode_ = value;
    onChanged();
    return this;
}

######


public Builder clearFiatCurrencyCode() {
    bitField0_ = (bitField0_ & ~0x00000004);
    fiatCurrencyCode_ = getDefaultInstance().getFiatCurrencyCode();
    onChanged();
    return this;
}

######


public Builder setFiatCurrencyCodeBytes(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000004;
    fiatCurrencyCode_ = value;
    onChanged();
    return this;
}

######


public static com.google.protobuf.Descriptors.FileDescriptor getDescriptor() {
    return descriptor;
}

######


public com.google.protobuf.ExtensionRegistry assignDescriptors(com.google.protobuf.Descriptors.FileDescriptor root) {
    descriptor = root;
    internal_static_wallet_PeerAddress_descriptor = getDescriptor().getMessageTypes().get(0);
    internal_static_wallet_PeerAddress_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_PeerAddress_descriptor, new java.lang.String[] { "IpAddress", "Port", "Services" });
    internal_static_wallet_EncryptedData_descriptor = getDescriptor().getMessageTypes().get(1);
    internal_static_wallet_EncryptedData_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_EncryptedData_descriptor, new java.lang.String[] { "InitialisationVector", "EncryptedPrivateKey" });
    internal_static_wallet_DeterministicKey_descriptor = getDescriptor().getMessageTypes().get(2);
    internal_static_wallet_DeterministicKey_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_DeterministicKey_descriptor, new java.lang.String[] { "ChainCode", "Path", "IssuedSubkeys", "LookaheadSize", "IsFollowing", "SigsRequiredToSpend" });
    internal_static_wallet_Key_descriptor = getDescriptor().getMessageTypes().get(3);
    internal_static_wallet_Key_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_Key_descriptor, new java.lang.String[] { "Type", "SecretBytes", "EncryptedData", "PublicKey", "Label", "CreationTimestamp", "DeterministicKey", "DeterministicSeed", "EncryptedDeterministicSeed" });
    internal_static_wallet_Script_descriptor = getDescriptor().getMessageTypes().get(4);
    internal_static_wallet_Script_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_Script_descriptor, new java.lang.String[] { "Program", "CreationTimestamp" });
    internal_static_wallet_TransactionInput_descriptor = getDescriptor().getMessageTypes().get(5);
    internal_static_wallet_TransactionInput_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_TransactionInput_descriptor, new java.lang.String[] { "TransactionOutPointHash", "TransactionOutPointIndex", "ScriptBytes", "Sequence", "Value" });
    internal_static_wallet_TransactionOutput_descriptor = getDescriptor().getMessageTypes().get(6);
    internal_static_wallet_TransactionOutput_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_TransactionOutput_descriptor, new java.lang.String[] { "Value", "ScriptBytes", "SpentByTransactionHash", "SpentByTransactionIndex" });
    internal_static_wallet_TransactionConfidence_descriptor = getDescriptor().getMessageTypes().get(7);
    internal_static_wallet_TransactionConfidence_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_TransactionConfidence_descriptor, new java.lang.String[] { "Type", "AppearedAtHeight", "OverridingTransaction", "Depth", "BroadcastBy", "LastBroadcastedAt", "Source", "IxType" });
    internal_static_wallet_Transaction_descriptor = getDescriptor().getMessageTypes().get(8);
    internal_static_wallet_Transaction_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_Transaction_descriptor, new java.lang.String[] { "Version", "Hash", "Pool", "LockTime", "UpdatedAt", "TransactionInput", "TransactionOutput", "BlockHash", "BlockRelativityOffsets", "Confidence", "Purpose", "ExchangeRate", "Memo" });
    internal_static_wallet_ScryptParameters_descriptor = getDescriptor().getMessageTypes().get(9);
    internal_static_wallet_ScryptParameters_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_ScryptParameters_descriptor, new java.lang.String[] { "Salt", "N", "R", "P" });
    internal_static_wallet_Extension_descriptor = getDescriptor().getMessageTypes().get(10);
    internal_static_wallet_Extension_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_Extension_descriptor, new java.lang.String[] { "Id", "Data", "Mandatory" });
    internal_static_wallet_Tag_descriptor = getDescriptor().getMessageTypes().get(11);
    internal_static_wallet_Tag_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_Tag_descriptor, new java.lang.String[] { "Tag", "Data" });
    internal_static_wallet_TransactionSigner_descriptor = getDescriptor().getMessageTypes().get(12);
    internal_static_wallet_TransactionSigner_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_TransactionSigner_descriptor, new java.lang.String[] { "ClassName", "Data" });
    internal_static_wallet_Wallet_descriptor = getDescriptor().getMessageTypes().get(13);
    internal_static_wallet_Wallet_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_Wallet_descriptor, new java.lang.String[] { "NetworkIdentifier", "LastSeenBlockHash", "LastSeenBlockHeight", "LastSeenBlockTimeSecs", "Key", "Transaction", "WatchedScript", "EncryptionType", "EncryptionParameters", "Version", "Extension", "Description", "KeyRotationTime", "Tags", "TransactionSigners" });
    internal_static_wallet_ExchangeRate_descriptor = getDescriptor().getMessageTypes().get(14);
    internal_static_wallet_ExchangeRate_fieldAccessorTable = new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_wallet_ExchangeRate_descriptor, new java.lang.String[] { "CoinValue", "FiatValue", "FiatCurrencyCode" });
    return null;
}

######


public void insertar(Proveedor vo) throws SQLException {
    PreparedStatement sentencia = cnn.prepareStatement("INSERT INTO proveedor (nombre,apellido,celular,correo,empresa,direccionempresa,fecharegistro) " + "VALUES(?,?,?,?,?,?,?)");
    sentencia.setString(1, vo.getNombre());
    sentencia.setString(2, vo.getApellido());
    sentencia.setString(3, vo.getCelular());
    sentencia.setString(4, vo.getCorreo());
    sentencia.setString(5, vo.getEmpresa());
    sentencia.setString(6, vo.getDireccionempresa());
    sentencia.setDate(7, new java.sql.Date(vo.getFecharegistro().getTime()));
    sentencia.executeUpdate();
}

######


public List<Proveedor> consultar() throws SQLException {
    List<Proveedor> listaProveedor = new ArrayList<>();
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM proveedor");
    ResultSet resultado = sentencia.executeQuery();
    while (resultado.next()) {
        Proveedor voTemp = new Proveedor();
        voTemp.setIdproveedor(resultado.getInt("idproveedor"));
        voTemp.setNombre(resultado.getString("nombre"));
        voTemp.setApellido(resultado.getString("apellido"));
        voTemp.setCelular(resultado.getString("celular"));
        voTemp.setCorreo(resultado.getString("correo"));
        voTemp.setEmpresa(resultado.getString("empresa"));
        voTemp.setDireccionempresa(resultado.getString("direccionempresa"));
        voTemp.setFecharegistro(resultado.getDate("fecharegistro"));
        listaProveedor.add(voTemp);
    }
    if (listaProveedor.size() > 0) {
        return listaProveedor;
    } else {
        return null;
    }
}

######


public List<Proveedor> consultarnombre(String nombre) throws SQLException {
    List<Proveedor> listaProveedor = new ArrayList<>();
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM proveedor");
    ResultSet resultado = sentencia.executeQuery();
    while (resultado.next()) {
        Proveedor voTemp = new Proveedor();
        voTemp.setIdproveedor(resultado.getInt("idproveedor"));
        voTemp.setNombre(resultado.getString("nombre"));
        voTemp.setApellido(resultado.getString("apellido"));
        voTemp.setCelular(resultado.getString("celular"));
        voTemp.setCorreo(resultado.getString("correo"));
        voTemp.setEmpresa(resultado.getString("empresa"));
        voTemp.setDireccionempresa(resultado.getString("direccionempresa"));
        voTemp.setFecharegistro(resultado.getDate("fecharegistro"));
        listaProveedor.add(voTemp);
    }
    if (listaProveedor.size() > 0) {
        return listaProveedor;
    } else {
        return null;
    }
}

######


public Proveedor queryNombre(String nombre) throws SQLException, ParseException {
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM proveedor WHERE nombre=?");
    sentencia.setString(1, nombre);
    ResultSet resultado = sentencia.executeQuery();
    if (resultado.next()) {
        return getVo(resultado);
    }
    return null;
}

######


public Proveedor consultaridProveedor(int idproveedor) throws SQLException, ParseException {
    PreparedStatement sentencia = cnn.prepareStatement("SELECT * FROM proveedor WHERE idproveedor=?");
    sentencia.setInt(1, idproveedor);
    ResultSet resultado = sentencia.executeQuery();
    if (resultado.next()) {
        return getVo(resultado);
    }
    return null;
}

######


public Proveedor getVo(ResultSet resultado) throws SQLException, ParseException {
    Proveedor vot = new Proveedor();
    vot.setIdproveedor(resultado.getInt("idproveedor"));
    vot.setNombre(resultado.getString("nombre"));
    vot.setApellido(resultado.getString("apellido"));
    vot.setCelular(resultado.getString("celular"));
    vot.setEmpresa(resultado.getString("empresa"));
    vot.setDireccionempresa(resultado.getString("direccionempresa"));
    vot.setCorreo(resultado.getString("correo"));
    SimpleDateFormat formato = new SimpleDateFormat("yyyy-MM-dd");
    vot.setFecharegistro(formato.parse(resultado.getString("fecharegistro")));
    return vot;
}

######


public void modificar(Proveedor vo) throws SQLException {
    PreparedStatement sentencia = cnn.prepareStatement("UPDATE proveedor SET nombre= ?,apellido= ?,celular= ?,correo= ?,empresa= ?,direccionempresa=?,fecharegistro=? " + "WHERE idproveedor = ?");
    sentencia.setString(1, vo.getNombre());
    sentencia.setString(2, vo.getApellido());
    sentencia.setString(3, vo.getCelular());
    sentencia.setString(4, vo.getCorreo());
    sentencia.setString(5, vo.getEmpresa());
    sentencia.setString(6, vo.getDireccionempresa());
    sentencia.setDate(7, new java.sql.Date(vo.getFecharegistro().getTime()));
    sentencia.setInt(8, vo.getIdproveedor());
    sentencia.executeUpdate();
}

######


@Override
public void setUp() throws Exception {
    super.setUp();
    db.db().execSQL("insert into currency(_id,title,name,symbol) values(0,'Default','?','$')");
}

######


public void test_should_import_empty_account() throws IOException {
    qifParserTest.test_should_parse_empty_account();
    doImport();
    List<Account> accounts = db.getAllAccountsList();
    assertEquals(1, accounts.size());
    assertEquals("My Cash Account", accounts.get(0).title);
    assertEquals(AccountType.CASH.name(), accounts.get(0).type);
}

######


public void test_should_import_a_couple_of_empty_accounts() throws IOException {
    qifParserTest.test_should_parse_a_couple_of_empty_accounts();
    doImport();
    List<Account> accounts = db.getAllAccountsList();
    sortAccountsById(accounts);
    assertEquals(2, accounts.size());
    assertEquals("My Cash Account", accounts.get(0).title);
    assertEquals(AccountType.CASH.name(), accounts.get(0).type);
    assertEquals("My Bank Account", accounts.get(1).title);
    assertEquals(AccountType.BANK.name(), accounts.get(1).type);
}

######


public void test_should_import_categories() throws Exception {
    QifParser p = new QifParser(null, QifDateFormat.EU_FORMAT);
    p.categories.add(new QifCategory("P1:cc1:c1", true));
    p.categories.add(new QifCategory("P1:cc1", true));
    p.categories.add(new QifCategory("P1:cc1:c2", true));
    p.categories.add(new QifCategory("P2", false));
    p.categories.add(new QifCategory("P2:x1", false));
    p.categories.add(new QifCategory("P1", false));
    p.categories.add(new QifCategory("P1:cc2", true));
    doImport(p);
    CategoryTree categories = categoryRepository.loadCategories();
    assertNotNull(categories);
    assertEquals(2, categories.getRoot().childrenCount());
    Category c = categories.rootAt(0);
    assertCategory("P1", true, c);
    assertEquals(2, c.children.size());
    assertCategory("cc1", true, c.childAt(0));
    assertEquals(2, c.childAt(0).children.size());
    assertCategory("cc2", true, c.childAt(1));
    assertFalse(c.childAt(1).hasChildren());
    c = categories.rootAt(1);
    assertCategory("P2", false, c);
    assertEquals(1, c.children.size());
    assertCategory("x1", false, c.childAt(0));
}

######


public void test_should_import_classes_as_projects() throws Exception {
    qifParserTest.test_should_parse_classes();
    doImport();
    List<Project> projects = db.getAllProjectsList(false);
    assertEquals(3, projects.size());
    List<Account> accounts = db.getAllAccountsList();
    assertEquals(1, accounts.size());
    List<TransactionInfo> transactions = db.getTransactionsForAccount(accounts.get(0).id);
    assertEquals(4, transactions.size());
    TransactionInfo t = transactions.get(0);
    assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime);
    assertEquals(1000, t.fromAmount);
    assertEquals("P1", t.category.title);
    assertEquals("Class1", t.project.title);
    t = transactions.get(1);
    assertEquals(DateTime.date(2011, 2, 7).atMidnight().asLong(), t.dateTime);
    assertEquals(-2345, t.fromAmount);
    assertEquals("c1", t.category.title);
    assertEquals("Class1", t.project.title);
    t = transactions.get(2);
    assertEquals(DateTime.date(2011, 1, 1).atMidnight().asLong(), t.dateTime);
    assertEquals(-6780, t.fromAmount);
    assertEquals("c1", t.category.title);
    assertEquals("Class1:Subclass1", t.project.title);
    t = transactions.get(3);
    assertEquals(DateTime.date(2010, 1, 1).atMidnight().asLong(), t.dateTime);
    assertEquals(-120, t.fromAmount);
    assertEquals("Class2", t.project.title);
}

######


public void test_should_import_account_with_a_couple_of_transactions() throws Exception {
    qifParserTest.test_should_parse_account_with_a_couple_of_transactions();
    doImport();
    List<Account> accounts = db.getAllAccountsList();
    assertEquals(1, accounts.size());
    List<TransactionInfo> transactions = db.getTransactionsForAccount(accounts.get(0).id);
    assertEquals(2, transactions.size());
    TransactionInfo t = transactions.get(0);
    assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime);
    assertEquals(1000, t.fromAmount);
    assertEquals("P1", t.category.title);
    assertNull(t.payee);
    t = transactions.get(1);
    assertEquals(DateTime.date(2011, 2, 7).atMidnight().asLong(), t.dateTime);
    assertEquals(-2056, t.fromAmount);
    assertEquals("Payee 1", t.payee.title);
    assertEquals("c1", t.category.title);
    assertEquals("Some note here...", t.note);
}

######


public void test_should_import_multiple_accounts() throws Exception {
    qifParserTest.test_should_parse_multiple_accounts();
    doImport();
    List<Account> accounts = db.getAllAccountsList();
    assertEquals(2, accounts.size());
    Account a = accounts.get(0);
    assertEquals("My Bank Account", a.title);
    assertEquals(AccountType.BANK.name(), a.type);
    List<TransactionInfo> transactions = db.getTransactionsForAccount(a.id);
    assertEquals(2, transactions.size());
    TransactionInfo t = transactions.get(0);
    assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime);
    assertEquals(-2000, t.fromAmount);
    t = transactions.get(1);
    assertEquals(DateTime.date(2011, 1, 2).atMidnight().asLong(), t.dateTime);
    assertEquals(5400, t.fromAmount);
    a = accounts.get(1);
    assertEquals("My Cash Account", a.title);
    assertEquals(AccountType.CASH.name(), a.type);
    transactions = db.getTransactionsForAccount(a.id);
    assertEquals(3, transactions.size());
    t = transactions.get(0);
    assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime);
    assertEquals(1000, t.fromAmount);
    t = transactions.get(1);
    assertEquals(DateTime.date(2011, 2, 7).atMidnight().asLong(), t.dateTime);
    assertEquals(-2345, t.fromAmount);
    t = transactions.get(2);
    assertEquals(DateTime.date(2011, 1, 1).atMidnight().asLong(), t.dateTime);
    assertEquals(-6780, t.fromAmount);
}

######


public void test_should_import_transfers() throws Exception {
    qifParserTest.test_should_parse_transfers();
    doImport();
    List<Account> accounts = db.getAllAccountsList();
    assertEquals(2, accounts.size());
    Account a = accounts.get(0);
    assertEquals("My Bank Account", a.title);
    assertEquals(AccountType.BANK.name(), a.type);
    List<TransactionInfo> transactions = db.getTransactionsForAccount(a.id);
    assertEquals(1, transactions.size());
    TransactionInfo t = transactions.get(0);
    assertTrue("Should be a transfer from bank to cash", t.isTransfer());
    assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime);
    assertEquals("My Bank Account", t.fromAccount.title);
    assertEquals(-2000, t.fromAmount);
    assertEquals("My Cash Account", t.toAccount.title);
    assertEquals(2000, t.toAmount);
    assertEquals("Vacation", t.project.title);
    a = accounts.get(1);
    assertEquals("My Cash Account", a.title);
    assertEquals(AccountType.CASH.name(), a.type);
    transactions = db.getTransactionsForAccount(a.id);
    assertEquals(0, transactions.size());
}

######


public void test_should_import_convert_unknown_transfers_into_regular_transactions_with_a_special_note() throws Exception {
    qifParserTest.parseQif("!Account\n" + "NMy Cash Account\n" + "TCash\n" + "^\n" + "!Type:Cash\n" + "D08/02/2011\n" + "T25.00\n" + "L[My Bank Account]\n" + "^\n" + "D07/02/2011\n" + "T55.00\n" + "L[Some Account 1]\n" + "^\n" + "!Account\n" + "NMy Bank Account\n" + "TBank\n" + "^\n" + "!Type:Bank\n" + "D08/02/2011\n" + "T-20.00\n" + "MNote on transfer\n" + "L[Some Account 2]\n" + "^\n" + "D07/02/2011\n" + "T-30.00\n" + "L[My Cash Account]\n" + "^\n");
    doImport();
    List<Account> accounts = db.getAllAccountsList();
    assertEquals(2, accounts.size());
    Account a = accounts.get(0);
    assertEquals("My Bank Account", a.title);
    assertEquals(AccountType.BANK.name(), a.type);
    List<TransactionInfo> transactions = db.getTransactionsForAccount(a.id);
    assertEquals(2, transactions.size());
    TransactionInfo t = transactions.get(0);
    assertFalse("Should not be a transfer", t.isTransfer());
    assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime);
    assertEquals("My Bank Account", t.fromAccount.title);
    assertEquals(-2000, t.fromAmount);
    assertEquals("Transfer: Some Account 2 | Note on transfer", t.note);
    t = transactions.get(1);
    assertFalse("Should not be a transfer", t.isTransfer());
    assertEquals(DateTime.date(2011, 2, 7).atMidnight().asLong(), t.dateTime);
    assertEquals("My Bank Account", t.fromAccount.title);
    assertEquals(-3000, t.fromAmount);
    assertEquals("Transfer: My Cash Account", t.note);
    a = accounts.get(1);
    assertEquals("My Cash Account", a.title);
    assertEquals(AccountType.CASH.name(), a.type);
    transactions = db.getTransactionsForAccount(a.id);
    assertEquals(2, transactions.size());
    t = transactions.get(0);
    assertFalse("Should not be a transfer", t.isTransfer());
    assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime);
    assertEquals("My Cash Account", t.fromAccount.title);
    assertEquals(2500, t.fromAmount);
    assertEquals("Transfer: My Bank Account", t.note);
    t = transactions.get(1);
    assertFalse("Should not be a transfer", t.isTransfer());
    assertEquals(DateTime.date(2011, 2, 7).atMidnight().asLong(), t.dateTime);
    assertEquals("My Cash Account", t.fromAccount.title);
    assertEquals(5500, t.fromAmount);
    assertEquals("Transfer: Some Account 1", t.note);
}

######


public void test_should_import_splits() throws Exception {
    qifParserTest.test_should_parse_splits();
    doImport();
    List<Account> accounts = db.getAllAccountsList();
    assertEquals(1, accounts.size());
    Account a = accounts.get(0);
    assertEquals("My Cash Account", a.title);
    assertEquals(AccountType.CASH.name(), a.type);
    List<TransactionInfo> transactions = db.getTransactionsForAccount(a.id);
    assertEquals(1, transactions.size());
    TransactionInfo t = transactions.get(0);
    assertEquals(-260066, t.fromAmount);
    List<TransactionInfo> splits = getSplitsForTransaction(t.id);
    assertEquals(3, splits.size());
    TransactionInfo s = splits.get(0);
    assertEquals("A1", s.category.title);
    assertEquals(-110056, s.fromAmount);
    assertEquals("Note on first split", s.note);
    s = splits.get(1);
    assertEquals("A2", s.category.title);
    assertEquals(-100000, s.fromAmount);
    s = splits.get(2);
    assertEquals("No category", s.category.title);
    assertEquals(50010, s.fromAmount);
    assertEquals("Note on third split", s.note);
}

######


public void test_should_import_transfer_splits() throws Exception {
    qifParserTest.test_should_parse_transfer_splits();
    doImport();
    List<Account> accounts = db.getAllAccountsList();
    assertEquals(2, accounts.size());
    Account a = accounts.get(0);
    assertEquals("My Bank Account", a.title);
    assertEquals(AccountType.BANK.name(), a.type);
    List<TransactionInfo> transactions = db.getTransactionsForAccount(a.id);
    assertEquals(0, transactions.size());
    a = accounts.get(1);
    assertEquals("My Cash Account", a.title);
    assertEquals(AccountType.CASH.name(), a.type);
    transactions = db.getTransactionsForAccount(a.id);
    assertEquals(1, transactions.size());
    TransactionInfo t = transactions.get(0);
    assertEquals(-210000, t.fromAmount);
    List<TransactionInfo> splits = getSplitsForTransaction(t.id);
    assertEquals(2, splits.size());
    TransactionInfo s = splits.get(0);
    assertEquals("A1", s.category.title);
    assertEquals(-110000, s.fromAmount);
    assertEquals("Note on first split", s.note);
    s = splits.get(1);
    assertTrue(s.isTransfer());
    assertEquals("My Bank Account", s.toAccount.title);
    assertEquals(-100000, s.fromAmount);
    assertEquals(100000, s.toAmount);
}

######


private List<TransactionInfo> getSplitsForTransaction(long transactionId) {
    Query<TransactionInfo> q = db.createQuery(TransactionInfo.class);
    q.where(Expressions.eq("parentId", transactionId));
    return q.list();
}

######


@Override
public int compare(Account a1, Account a2) {
    return a1.id == a2.id ? 0 : (a1.id > a2.id ? 1 : -1);
}

######


private void sortAccountsById(List<Account> accounts) {
    Collections.sort(accounts, new Comparator<Account>() {

        @Override
        public int compare(Account a1, Account a2) {
            return a1.id == a2.id ? 0 : (a1.id > a2.id ? 1 : -1);
        }
    });
}

######


private void doImport() {
    doImport(qifParserTest.p);
}

######


private void doImport(QifParser p) {
    QifImportOptions options = new QifImportOptions("", EU_FORMAT, Currency.EMPTY);
    qifImport = new QifImport(getContext(), db, categoryRepository, options);
    qifImport.doImport(p);
}

######


@Override
public void setUp() throws Exception {
    super.setUp();
    db.db().execSQL("insert into currency(_id,title,name,symbol) values(0,'Default','?','$')");
}

######


public void test_should_import_homebank_case_1() throws Exception {
    doImport("!Account\n" + "NMy Bank Account\n" + "^\n" + "!Type:Bank\n" + "D02/11/2011\n" + "T14.00\n" + "C\n" + "PP2\n" + "M(null)\n" + "LC2\n" + "^\n" + "D01/11/2011\n" + "T-35.40\n" + "C\n" + "P\n" + "M(null)\n" + "L[My Cash Account]\n" + "^\n" + "!Account\n" + "NMy Cash Account\n" + "^\n" + "!Type:Cash\n" + "D03/11/2011\n" + "T19.50\n" + "C\n" + "PP1\n" + "M(null)\n" + "LC1:c1\n" + "^\n" + "D01/11/2011\n" + "T35.40\n" + "C\n" + "P\n" + "M(null)\n" + "L[My Bank Account]\n" + "^");
    List<Account> accounts = db.getAllAccountsList();
    assertEquals(2, accounts.size());
    Account a = accounts.get(0);
    assertEquals("My Bank Account", a.title);
    assertEquals(AccountType.BANK.name(), a.type);
    assertAccountTotal(a, -2140);
    assertFinalBalanceForAccount(a, -2140);
    List<TransactionInfo> transactions = db.getTransactionsForAccount(a.id);
    assertEquals(2, transactions.size());
    TransactionInfo t = transactions.get(0);
    assertEquals(DateTime.date(2011, 11, 2).atMidnight().asLong(), t.dateTime);
    assertEquals(1400, t.fromAmount);
    assertEquals("P2", t.payee.title);
    assertEquals("C2", t.category.title);
    t = transactions.get(1);
    assertTrue("Should be a transfer from bank to cash", t.isTransfer());
    assertEquals(DateTime.date(2011, 11, 1).atMidnight().asLong(), t.dateTime);
    assertEquals("My Bank Account", t.fromAccount.title);
    assertEquals(-3540, t.fromAmount);
    assertEquals("My Cash Account", t.toAccount.title);
    assertEquals(3540, t.toAmount);
    a = accounts.get(1);
    assertEquals("My Cash Account", a.title);
    assertEquals(AccountType.CASH.name(), a.type);
    assertAccountTotal(a, 5490);
    assertFinalBalanceForAccount(a, 5490);
    transactions = db.getTransactionsForAccount(a.id);
    assertEquals(1, transactions.size());
    t = transactions.get(0);
    assertEquals(DateTime.date(2011, 11, 3).atMidnight().asLong(), t.dateTime);
    assertEquals(1950, t.fromAmount);
    assertEquals("P1", t.payee.title);
    assertEquals("c1", t.category.title);
}

######


public void test_should_import_financisto_qif_export_case_1() throws IOException {
    doImport("!Type:Cat\n" + "NA1\n" + "E\n" + "^\n" + "NA1:aa1\n" + "E\n" + "^\n" + "NA1:aa1:aaa1\n" + "E\n" + "^\n" + "NA1:aa2\n" + "E\n" + "^\n" + "NB1\n" + "I\n" + "^\n" + "NB1:bb1\n" + "I\n" + "^\n" + "NC1\n" + "E\n" + "^\n" + "ND1\n" + "E\n" + "^\n" + "!Account\n" + "NAAA\n" + "TCash\n" + "^\n" + "!Type:Cash\n" + "D17/02/2011\n" + "T15.00\n" + "L[BBB]\n" + "^\n" + "D17/02/2011\n" + "T-10.00\n" + "LA1\n" + "Pp1\n" + "^\n" + "D17/02/2011\n" + "T100.00\n" + "MOpening amount (AAA)\n" + "^\n" + "!Account\n" + "NBBB\n" + "TCash\n" + "^\n" + "!Type:Cash\n" + "D17/02/2011\n" + "T-14.00\n" + "LB1:bb1\n" + "^\n" + "D17/02/2011\n" + "T-15.00\n" + "L[AAA]\n" + "^\n" + "D17/02/2011\n" + "T-16.50\n" + "Pp2\n" + "^\n" + "D17/02/2011\n" + "T40.00\n" + "MOpening amount (BBB)\n" + "^");
    List<Account> accounts = db.getAllAccountsList();
    assertEquals(2, accounts.size());
    Account a = accounts.get(0);
    assertEquals("AAA", a.title);
    assertAccountTotal(a, 10500);
    a = accounts.get(1);
    assertEquals("BBB", a.title);
    assertAccountTotal(a, -550);
}

######


@Override
public int compare(Account a1, Account a2) {
    return a1.id == a2.id ? 0 : (a1.id > a2.id ? 1 : -1);
}

######


private void sortAccountsById(List<Account> accounts) {
    Collections.sort(accounts, new Comparator<Account>() {

        @Override
        public int compare(Account a1, Account a2) {
            return a1.id == a2.id ? 0 : (a1.id > a2.id ? 1 : -1);
        }
    });
}

######


private void doImport(String qif) throws IOException {
    File tmp = File.createTempFile("backup", ".qif");
    FileWriter w = new FileWriter(tmp);
    w.write(qif);
    w.close();
    Log.d("Financisto", "Created a temporary backup file: " + tmp.getAbsolutePath());
    QifImportOptions options = new QifImportOptions(tmp.getAbsolutePath(), EU_FORMAT, Currency.EMPTY);
    qifImport = new QifImport(getContext(), db, categoryRepository, options);
    qifImport.importDatabase();
}

######


public List<String> getIndexQueries() {
    return mIndexQueries;
}

######


private String[] getAttributes() {
    try {
        FileReader fileReader = new FileReader(mTextFile);
        BufferedReader bufferedReader = new BufferedReader(fileReader);
        String firstLine = bufferedReader.readLine();
        firstLine = firstLine.replace("\uFEFF", "");
        String[] fileAttributes = firstLine.split(",");
        for (int i = 0; i < fileAttributes.length; i++) {
            fileAttributes[i] = fileAttributes[i].toLowerCase().replaceAll("[^a-z_]", "");
        }
        mBufferedReader = bufferedReader;
        return fileAttributes;
    } catch (IOException ioe) {
        return null;
    }
}

######


private String generateCreateTableQuery() throws IOException, JSONException {
    StringBuilder createTableQuery = new StringBuilder("CREATE TABLE IF NOT EXISTS " + mTableName + " (\n");
    for (int i = 0; i < mFileAttributes.length; i++) {
        String attribute = mFileAttributes[i];
        boolean endOfAttributes;
        if (mTextFileSpec.has(attribute)) {
            String attributeDefinition = mTextFileSpec.getString(attribute);
            attributeDefinition = processDefinition(attribute, attributeDefinition);
            createTableQuery.append("\t" + attribute + " " + attributeDefinition);
            endOfAttributes = i >= mLargestValidIndex;
            if (!endOfAttributes) {
                createTableQuery.append(",\n");
            } else {
                if (!mCompositeKey.isEmpty()) {
                    createTableQuery.append(",\n");
                    StringBuilder privateKeyDeclaration = new StringBuilder("\tPRIMARY KEY(");
                    for (int j = 0; j < mCompositeKey.size(); j++) {
                        privateKeyDeclaration.append(mCompositeKey.get(j));
                        if (j != (mCompositeKey.size() - 1)) {
                            privateKeyDeclaration.append(", ");
                        }
                    }
                    privateKeyDeclaration.append(")");
                    createTableQuery.append(privateKeyDeclaration);
                }
                if (!mForeignKeys.isEmpty()) {
                    createTableQuery.append(",\n");
                    for (int k = 0; k < mForeignKeys.size(); k++) {
                        createTableQuery.append(mForeignKeys.get(k));
                        if (k != (mForeignKeys.size() - 1)) {
                            createTableQuery.append(",\n");
                        }
                    }
                }
            }
        }
    }
    createTableQuery.append("\n);");
    String query = createTableQuery.toString();
    return query;
}

######


private List<String> generateCreateIndexQueries() {
    List<String> indexQueries = new ArrayList<>();
    String table = getTableName();
    for (String[] entry : mDependencies) {
        String referenceAttribute = entry[0];
        String referenceTable = entry[1];
        StringBuilder query = new StringBuilder("CREATE INDEX fk_" + table + "_" + referenceTable + "_" + referenceAttribute + " ON " + table + "(" + referenceAttribute + ");");
        indexQueries.add(query.toString());
    }
    return indexQueries;
}

######


private String processDefinition(String attribute, String definition) {
    String foreignKeyPattern = ".+, FOREIGN KEY\\(\\) REFERENCES .+\\(?.+\\)";
    String multiplePrimaryKeysPattern = ".+, PRIMARY KEY";
    if (definition.matches(foreignKeyPattern)) {
        definition = definition.replaceAll("\\(\\)", "(" + attribute + ")");
        String[] args = definition.split(", ");
        definition = args[0];
        StringBuilder foreignKey = new StringBuilder("\t" + args[1]);
        mForeignKeys.add(foreignKey.toString());
    } else if (definition.matches(multiplePrimaryKeysPattern)) {
        definition = definition.replaceAll(", PRIMARY KEY", "");
        mCompositeKey.add(attribute);
    }
    return definition;
}

######


public void executeInsertQueries(Connection connection) {
    String query = "";
    try {
        CSVParser parser = new CSVParser(mBufferedReader, CSVFormat.EXCEL);
        Statement insertStatement = connection.createStatement();
        for (CSVRecord record : parser) {
            if (record.size() - 1 < mLargestValidIndex) {
                String warning = "Warning: Row number <" + record.getRecordNumber() + "> in <" + getTableName() + ".txt> only has " + (record.size() - 1) + " attributes. Expected " + mValidAttributes.size() + " valid attributes at indices " + mValidAttributes.toString() + " Skipping row.";
                Main.print(warning);
                continue;
            }
            StringBuilder queryBuild = new StringBuilder("INSERT INTO " + getTableName());
            StringBuilder columns = new StringBuilder(" ( ");
            StringBuilder values = new StringBuilder("VALUES( ");
            for (int i = 0; i < mValidAttributes.size(); i++) {
                Integer validIndex = mValidAttributes.get(i);
                String attribute = mFileAttributes[validIndex];
                columns.append(attribute);
                String value = record.get(validIndex);
                values.append("\"" + value + "\"");
                boolean endOfAttributes = i + 1 >= mValidAttributes.size();
                if (!endOfAttributes) {
                    String seperator = ", ";
                    columns.append(seperator);
                    values.append(seperator);
                } else {
                    columns.append(") ");
                    values.append(");");
                }
            }
            queryBuild.append(columns).append(values);
            query = queryBuild.toString();
            insertStatement.executeUpdate(query);
        }
        insertStatement.close();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (SQLException e) {
        Main.print(e.getMessage());
        Main.print(query);
        System.exit(-1);
    }
}

######


public String getTableName() {
    return mTableName;
}

######


public String getCreateQuery() {
    return mCreateQuery;
}

######


public List<String[]> getTableDependencies() {
    return mDependencies;
}

######


@Query("SELECT * FROM Question")
List<Question> getAllQuiz();

######


@Query("SELECT * FROM Question " + " WHERE week LIKE :week ORDER BY RANDOM() LIMIT 11")
List<Question> getSelectedQuiz(int week);

######


@Insert
void insertQuestion(Question... questions);

######


@Insert
void insertQuestionBatch(List<Question> question);

######


@Query("SELECT * FROM race")
List<Race> getAll();

######


@Query("SELECT * FROM Race WHERE id = (:raceId)")
Race getRaceById(long raceId);

######


@Query("SELECT * FROM Race WHERE event = (:eventId)")
List<Race> getRacesFromEvent(long eventId);

######


@Update
void update(Race race);

######


@Insert
long insert(Race race);

######


@Query("DELETE FROM race")
void deleteAllRaces();

######


@Delete
void delete(Race race);

######


@BeforeClass
public static void setUp() throws Exception {
    Reader reader = Resources.getResourceAsReader("org/apache/ibatis/submitted/raw_sql_source/mybatis-config.xml");
    sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
    reader.close();
    SqlSession session = sqlSessionFactory.openSession();
    Connection conn = session.getConnection();
    reader = Resources.getResourceAsReader("org/apache/ibatis/submitted/raw_sql_source/CreateDB.sql");
    ScriptRunner runner = new ScriptRunner(conn);
    runner.setLogWriter(null);
    runner.runScript(reader);
    conn.close();
    reader.close();
    session.close();
}

######


@Test
public void shouldUseRawSqlSourceForAnStaticStatement() {
    test("getUser1", RawSqlSource.class);
}

######


@Test
public void shouldUseDynamicSqlSourceForAnStatementWithInlineArguments() {
    test("getUser2", DynamicSqlSource.class);
}

######


@Test
public void shouldUseDynamicSqlSourceForAnStatementWithXmlTags() {
    test("getUser3", DynamicSqlSource.class);
}

######


private void test(String statement, Class<? extends SqlSource> sqlSource) {
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
        Assert.assertEquals(sqlSource, sqlSession.getConfiguration().getMappedStatement(statement).getSqlSource().getClass());
        String sql = sqlSession.getConfiguration().getMappedStatement(statement).getSqlSource().getBoundSql('?').getSql();
        Assert.assertEquals("select * from users where id = ?", sql);
        User user = sqlSession.selectOne(statement, 1);
        Assert.assertEquals("User1", user.getName());
    } finally {
        sqlSession.close();
    }
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL("CREATE TABLE recent " + "(name TEXT PRIMARY KEY, " + "latitude REAL, " + "longitude REAL, " + "address TEXT);");
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
}

######


public void insert(String name, double latitude, double longitude, String address) {
    SQLiteDatabase db = getWritableDatabase();
    db.execSQL("INSERT INTO recent VALUES ('" + name + "', " + latitude + ", " + longitude + ", '" + address + "');");
    db.close();
}

######


public void delete() {
    SQLiteDatabase db = getWritableDatabase();
    db.execSQL("DELETE FROM recent");
    db.close();
}

######


public void showList(ArrayList<RecentDestination> recentDestinationArrayList) {
    SQLiteDatabase db = getReadableDatabase();
    Cursor cursor = db.rawQuery("SELECT * FROM recent", null);
    while (cursor.moveToNext()) {
        String name = cursor.getString(cursor.getColumnIndex("name"));
        double latitude = cursor.getDouble(cursor.getColumnIndex("latitude"));
        double longitude = cursor.getDouble(cursor.getColumnIndex("longitude"));
        String address = cursor.getString(cursor.getColumnIndex("address"));
        RecentDestination recentDestination = new RecentDestination(latitude, longitude, name, address);
        recentDestinationArrayList.add(0, recentDestination);
    }
}

######


public void addRecipe(Recipe recipe) {
    try {
        PreparedStatement preparedStatement = connection.prepareStatement("insert into recipe(recipename, dishtype, dishflavour, difficultylevel) values (?, ?, ?, ?)");
        preparedStatement.setString(1, recipe.getName());
        preparedStatement.setString(2, recipe.getType());
        preparedStatement.setString(3, recipe.getFlavour());
        preparedStatement.setString(4, recipe.getDifficulty());
        preparedStatement.executeUpdate();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public void deleteRecipe(int recipeId) {
    try {
        PreparedStatement preparedStatement = connection.prepareStatement("delete from recipe where recipeid=?");
        preparedStatement.setInt(1, recipeId);
        preparedStatement.executeUpdate();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public void updateRecipe(Recipe recipe) {
    try {
        PreparedStatement preparedStatement = connection.prepareStatement("update recipe set recipename=?, dishtype=?, dishflavour=?, difficultylevel=?" + " where recipeid=?");
        preparedStatement.setString(1, recipe.getName());
        preparedStatement.setString(2, recipe.getType());
        preparedStatement.setString(3, recipe.getFlavour());
        preparedStatement.setString(4, recipe.getDifficulty());
        preparedStatement.setInt(5, recipe.getRecipeId());
        preparedStatement.executeUpdate();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public List<Recipe> getAllRecipes() {
    List<Recipe> recipes = new ArrayList<Recipe>();
    try {
        Statement statement = connection.createStatement();
        ResultSet rs = statement.executeQuery("select * from recipe");
        while (rs.next()) {
            Recipe recipe = new Recipe();
            recipe.setRecipeId(rs.getInt("recipeid"));
            recipe.setName(rs.getString("recipename"));
            recipe.setType(rs.getString("dishtype"));
            recipe.setFlavour(rs.getString("dishflavour"));
            recipe.setDifficulty(rs.getString("difficultylevel"));
            recipes.add(recipe);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return recipes;
}

######


public Recipe getRecipeById(int recipeId) {
    Recipe recipe = new Recipe();
    try {
        PreparedStatement preparedStatement = connection.prepareStatement("select * from recipe where recipeid=?");
        preparedStatement.setInt(1, recipeId);
        ResultSet rs = preparedStatement.executeQuery();
        if (rs.next()) {
            recipe.setRecipeId(rs.getInt("recipeid"));
            recipe.setName(rs.getString("recipename"));
            recipe.setType(rs.getString("dishtype"));
            recipe.setFlavour(rs.getString("dishflavour"));
            recipe.setDifficulty(rs.getString("difficultylevel"));
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return recipe;
}

######


@Test
public void isolationLevelResets() throws SQLException {
    try (Connection connection = setConnection()) {
        long max = maxPacket(connection);
        if (max > Integer.MAX_VALUE - 10) {
            fail("max_allowed_packet too high for this test");
        }
        connection.prepareStatement("create table if not exists foo (x longblob)").execute();
        connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
        assertEquals("READ-UNCOMMITTED", level((MariaDbConnection) connection));
        try (PreparedStatement st = connection.prepareStatement("insert into foo (?)")) {
            st.setBytes(1, data((int) (max + 10)));
            st.execute();
            fail();
        } catch (SQLException e) {
            assertTrue(e.getMessage().contains("max_allowed_packet"));
            assertTrue(connection.isValid(0));
            assertEquals("READ-UNCOMMITTED", level((MariaDbConnection) connection));
        }
    }
}

######


private String level(MariaDbConnection connection) throws SQLException {
    String sql = "SELECT @@tx_isolation";
    if (!connection.isServerMariaDb() && connection.versionGreaterOrEqual(8, 0, 3)) {
        sql = "SELECT @@transaction_isolation";
    }
    try (ResultSet rs = connection.prepareStatement(sql).executeQuery()) {
        assertTrue(rs.next());
        return rs.getString(1);
    }
}

######


private long maxPacket(Connection connection) throws SQLException {
    try (ResultSet rs = connection.prepareStatement("select @@max_allowed_packet").executeQuery()) {
        assertTrue(rs.next());
        return rs.getLong(1);
    }
}

######


private byte[] data(int size) {
    byte[] data = new byte[size];
    Arrays.fill(data, (byte) 'a');
    return data;
}

######


public void actualizarContrasena(String pass, String usu) {
    String cont = "";
    try {
        HashedPasswordGenerator cifrado = new HashedPasswordGenerator();
        cont = cifrado.generateHash(pass);
        con = DataConnect.getConnection();
        ps = con.prepareStatement("update usuario set usu_password=?, usu_bloqueo_clave=0 where usu_usuario=?;");
        ps.setString(1, cont);
        ps.setString(2, usu);
        ps.execute();
    } catch (SQLException e) {
        System.out.println("Actualizar contraseña error -->" + e.getMessage());
    }
}

######


public String recuperarContrasena(String usu, String email) {
    String resp = null;
    try {
        con = DataConnect.getConnection();
        ps = con.prepareStatement("select usu_usuario from usuario,empleado where usu_usuario=? and eml_correo=? and usuario.usu_id_usuario=empleado.eml_id_usuario;");
        ps.setString(1, usu);
        ps.setString(2, email);
        ResultSet rs = ps.executeQuery();
        if (rs.next()) {
            resp = GenerarContrasena.getPassword(GenerarContrasena.MAYUSCULAS + GenerarContrasena.MINUSCULAS + GenerarContrasena.NUMEROS, 10);
            System.out.println("nueva contraseña: " + resp);
            return resp;
        }
    } catch (SQLException ex) {
        System.out.println("Recuperar contraseña error -->" + ex.getMessage());
        return resp = null;
    } finally {
        DataConnect.close(con);
    }
    return resp;
}

######


@Override
public int getCount() {
    return listData.size();
}

######


@Override
public Object getItem(int position) {
    return null;
}

######


@Override
public long getItemId(int position) {
    return 0;
}

######


@Override
public void onClick(DialogInterface dialog, int which) {
    for (Iterator iterator = AddTriggerJasaService.data.iterator(); iterator.hasNext(); ) {
        ServiceProvide deleteRow = (ServiceProvide) iterator.next();
        if (deleteRow.getServiceName().equalsIgnoreCase(jasaData.getServiceName())) {
            doDelete(deleteRow);
            AddTriggerJasaService.refreshAdapter();
        }
    }
}

######


@Override
public void onClick(View v) {
    new AlertDialog.Builder(context).setTitle("Hapus Item").setMessage("Anda yakin akan mengahapus " + jasaData.getServiceName() + " ?").setIcon(android.R.drawable.ic_dialog_alert).setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            for (Iterator iterator = AddTriggerJasaService.data.iterator(); iterator.hasNext(); ) {
                ServiceProvide deleteRow = (ServiceProvide) iterator.next();
                if (deleteRow.getServiceName().equalsIgnoreCase(jasaData.getServiceName())) {
                    doDelete(deleteRow);
                    AddTriggerJasaService.refreshAdapter();
                }
            }
        }
    }).setNegativeButton(android.R.string.no, null).show();
}

######


@Override
public View getView(int position, View convertView, ViewGroup parent) {
    final TextView jasa;
    inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View itemView = inflater.inflate(R.layout.recycle_view_tambah_jasa, parent, false);
    jasa = (TextView) itemView.findViewById(R.id.text_jasa);
    final ServiceProvide jasaData = listData.get(position);
    jasa.setText(jasaData.getServiceName());
    jasa.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            new AlertDialog.Builder(context).setTitle("Hapus Item").setMessage("Anda yakin akan mengahapus " + jasaData.getServiceName() + " ?").setIcon(android.R.drawable.ic_dialog_alert).setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {

                @Override
                public void onClick(DialogInterface dialog, int which) {
                    for (Iterator iterator = AddTriggerJasaService.data.iterator(); iterator.hasNext(); ) {
                        ServiceProvide deleteRow = (ServiceProvide) iterator.next();
                        if (deleteRow.getServiceName().equalsIgnoreCase(jasaData.getServiceName())) {
                            doDelete(deleteRow);
                            AddTriggerJasaService.refreshAdapter();
                        }
                    }
                }
            }).setNegativeButton(android.R.string.no, null).show();
        }
    });
    return itemView;
}

######


private void doDelete(ServiceProvide sp) {
    DatabaseHelper dbh = new DatabaseHelper(context);
    SQLiteDatabase db = dbh.getWritableDatabase();
    try {
        db.execSQL("DELETE FROM " + ServiceProvide.tbl_service_provice + " WHERE " + ServiceProvide.clm_id_service_provide + " = '" + sp.getIdServiceProvide() + "'");
    } catch (Exception e) {
        Log.e("Delete Error", e.toString());
    } finally {
        db.close();
    }
    try {
        deleteServiceProvideToServer addUser = new deleteServiceProvideToServer();
        addUser.setIpServer(ipServer);
        addUser.setActivity(activity);
        addUser.setServiceProvide(sp);
        addUser.setContext(context);
        addUser.execute();
    } catch (Exception e) {
        Log.e("Delete Error", e.toString());
    }
}

######


public ReferenceDTO getReferenceByPmid(List<ReferenceDTO> references, String pubMedId) throws SQLException {
    for (ReferenceDTO reference : references) {
        if (reference.getPmid().equals(pubMedId)) {
            return reference;
        }
    }
    return null;
}

######


public List<ReferenceDTO> getReferenceRows() throws SQLException {
    return getReferenceRows("");
}

######


public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType("text/html");
    PrintWriter out = response.getWriter();
    int e = Integer.parseInt(request.getParameter("empid"));
    String n = request.getParameter("user");
    String p = request.getParameter("pass");
    String a = request.getParameter("address");
    String c = request.getParameter("company");
    String code = request.getParameter("chargecode");
    try {
        Connection con = Connect.getconnection();
        PreparedStatement ps = con.prepareStatement("INSERT INTO registeruser (Emp_id,username,password,address,company,chargecode) VALUES (?,?,?,?,?,?)");
        ps.setInt(1, e);
        ps.setString(2, n);
        ps.setString(3, p);
        ps.setString(4, a);
        ps.setString(5, c);
        ps.setString(6, code);
        ps.executeUpdate();
        request.getRequestDispatcher("index_2.jsp").include(request, response);
    } catch (Exception e1) {
        e1.printStackTrace();
    }
    out.close();
}

######


private Connection getConnection() throws SQLException {
    java.sql.Connection con;
    con = ConnectionFactory.getInstance().getConnection();
    return con;
}

######


public String register() throws ClassNotFoundException, SQLException {
    connection = getConnection();
    this.addUser = this.connection.prepareStatement("INSERT INTO user(name, email, address, username, password) VALUES(?,?,?,?,?)");
    this.addUser.setString(1, getName());
    this.addUser.setString(2, getEmail());
    this.addUser.setString(3, getAddress());
    this.addUser.setString(4, getUsername());
    this.addUser.setString(5, getPassword());
    this.addUser.executeUpdate();
    return "success";
}

######


public String getAddress() {
    return address;
}

######


public void setAddress(String address) {
    this.address = address;
}

######


public String getName() {
    return name;
}

######


public void setName(String name) {
    this.name = name;
}

######


public String getEmail() {
    return email;
}

######


public void setEmail(String email) {
    this.email = email;
}

######


public String getUsername() {
    return username;
}

######


public void setUsername(String username) {
    this.username = username;
}

######


public String getPassword() {
    return password;
}

######


public void setPassword(String password) {
    this.password = password;
}

######


public void setSession(Map m) {
    this.m = m;
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    UserTxtActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    ClientCheckActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    ManagerCheckActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    RegisterBtnActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    ConfPasswordTxtActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jFrame1 = new javax.swing.JFrame();
    Title = new javax.swing.JLabel();
    jPanel1 = new javax.swing.JPanel();
    User = new javax.swing.JLabel();
    Password = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    UserTxt = new javax.swing.JTextField();
    ClientCheck = new javax.swing.JRadioButton();
    ManagerCheck = new javax.swing.JRadioButton();
    RegisterBtn = new javax.swing.JButton();
    ConfPasswordTxt = new javax.swing.JPasswordField();
    PasswordTxt = new javax.swing.JPasswordField();
    javax.swing.GroupLayout jFrame1Layout = new javax.swing.GroupLayout(jFrame1.getContentPane());
    jFrame1.getContentPane().setLayout(jFrame1Layout);
    jFrame1Layout.setHorizontalGroup(jFrame1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 400, Short.MAX_VALUE));
    jFrame1Layout.setVerticalGroup(jFrame1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 300, Short.MAX_VALUE));
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    setSize(getPreferredSize());
    Title.setFont(new java.awt.Font("Tahoma", 0, 24));
    Title.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Title.setText("RegisterPage");
    Title.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    User.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    User.setText("User");
    User.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Password.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Password.setText("Password");
    Password.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    jLabel3.setText("Confirm Password");
    jLabel3.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    UserTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    UserTxt.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            UserTxtActionPerformed(evt);
        }
    });
    ClientCheck.setSelected(true);
    ClientCheck.setText("Client");
    ClientCheck.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    ClientCheck.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            ClientCheckActionPerformed(evt);
        }
    });
    ManagerCheck.setText("Manager");
    ManagerCheck.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    ManagerCheck.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            ManagerCheckActionPerformed(evt);
        }
    });
    RegisterBtn.setText("Register");
    RegisterBtn.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    RegisterBtn.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            RegisterBtnActionPerformed(evt);
        }
    });
    ConfPasswordTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    ConfPasswordTxt.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            ConfPasswordTxtActionPerformed(evt);
        }
    });
    PasswordTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
    jPanel1.setLayout(jPanel1Layout);
    jPanel1Layout.setHorizontalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup().addGap(18, 18, 18).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addGroup(jPanel1Layout.createSequentialGroup().addComponent(ClientCheck, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(ManagerCheck, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addGroup(jPanel1Layout.createSequentialGroup().addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false).addComponent(Password, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(jLabel3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 135, Short.MAX_VALUE).addComponent(User, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addGap(18, 18, 18).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(ConfPasswordTxt).addComponent(UserTxt).addComponent(PasswordTxt)))).addGap(15, 15, 15)).addGroup(jPanel1Layout.createSequentialGroup().addGap(92, 92, 92).addComponent(RegisterBtn, javax.swing.GroupLayout.DEFAULT_SIZE, 185, Short.MAX_VALUE).addGap(99, 99, 99)));
    jPanel1Layout.setVerticalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addGap(20, 20, 20).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(UserTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(User, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(12, 12, 12).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(PasswordTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(Password, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel3).addComponent(ConfPasswordTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(18, 18, 18).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(ClientCheck).addComponent(ManagerCheck)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(RegisterBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap()));
    jPanel1Layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] { ConfPasswordTxt, Password, PasswordTxt, User, UserTxt, jLabel3 });
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(Title, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 378, Short.MAX_VALUE)).addContainerGap()));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(Title, javax.swing.GroupLayout.PREFERRED_SIZE, 46, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 250, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    pack();
    setLocationRelativeTo(null);
}

######


private void UserTxtActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void RegisterBtnActionPerformed(java.awt.event.ActionEvent evt) {
    int aux = (ManagerCheck.isSelected()) ? 1 : 0;
    String passw = new String(PasswordTxt.getPassword());
    String cpassw = new String(ConfPasswordTxt.getPassword());
    if (passw.length() > 0 && UserTxt.getText().length() > 0 && passw.equals(cpassw)) {
        ResultSet rs = null;
        try {
            String SQL = "select user,password " + "from users " + "where user='" + UserTxt.getText() + "' and password='" + passw + "'";
            Client sclav = new Client();
            sclav.connectToServer();
            sclav.Query(SQL);
            rs = sclav.rs;
        } catch (IOException ex) {
            Logger.getLogger(RegisterPage.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(RegisterPage.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            if (!rs.next()) {
                try {
                    Client sclav = new Client();
                    String SQL = "INSERT INTO users (user,password,isManager) values " + "('" + UserTxt.getText() + "','" + passw + "'," + aux + ")";
                    sclav.connectToServer();
                    sclav.Query(SQL);
                    int confExec = sclav.confExec;
                } catch (IOException ex) {
                    Logger.getLogger(RegisterPage.class.getName()).log(Level.SEVERE, null, ex);
                } catch (ClassNotFoundException ex) {
                    Logger.getLogger(RegisterPage.class.getName()).log(Level.SEVERE, null, ex);
                }
                Start JF = new Start();
                JF.setVisible(true);
                JF.setResizable(false);
                this.dispose();
            } else {
                JOptionPane.showMessageDialog(null, "Account already created", "Register Error", JOptionPane.ERROR_MESSAGE);
            }
        } catch (SQLException ex) {
            Logger.getLogger(RegisterPage.class.getName()).log(Level.SEVERE, null, ex);
        }
    } else {
        JOptionPane.showMessageDialog(null, "Invalid register details", "Register Error", JOptionPane.ERROR_MESSAGE);
        PasswordTxt.setText("");
        ConfPasswordTxt.setText("");
    }
}

######


private void ClientCheckActionPerformed(java.awt.event.ActionEvent evt) {
    ManagerCheck.setSelected(false);
}

######


private void ManagerCheckActionPerformed(java.awt.event.ActionEvent evt) {
    ClientCheck.setSelected(false);
}

######


private void ConfPasswordTxtActionPerformed(java.awt.event.ActionEvent evt) {
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(RegisterPage.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(RegisterPage.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(RegisterPage.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(RegisterPage.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
}

######


protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    Random rand = new Random();
    String user = request.getParameter("uname");
    String pwd1 = request.getParameter("pass");
    String repwd = request.getParameter("repassword");
    String email = request.getParameter("email");
    String securityQ1 = request.getParameter("securityQ1");
    String securityA1 = request.getParameter("securityA1");
    String securityQ2 = request.getParameter("securityQ2");
    String securityA2 = request.getParameter("securityA2");
    int salt = rand.nextInt(50) + 1;
    String pwd = null;
    try {
        pwd = Hashing.createHash(pwd1);
    } catch (NoSuchAlgorithmException | InvalidKeySpecException e1) {
        e1.printStackTrace();
    }
    try {
        Class.forName("com.mysql.jdbc.Driver");
        Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/userVerificationdb", "root", "root");
        Statement st = con.createStatement();
        int i = st.executeUpdate("insert into account(username, password, emailid, Squestion1, Sanswer1, Squestion2, Sanswer2, salt) values('" + user + "','" + pwd + "','" + email + "','" + securityQ1 + "','" + securityA1 + "','" + securityQ2 + "','" + securityA2 + "','" + salt + "')");
        if (i > 0) {
            response.sendRedirect("accountcreated.jsp");
        } else {
            response.sendRedirect("index.jsp");
        }
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


@Override
public void initialize(URL location, ResourceBundle resources) {
    btn_register.setOnAction(e -> registerClient());
}

######


private void registerClient() {
    try {
        if (passField_pass.getText().equals(passField_passSecur.getText())) {
            TCPConnection.getInstance().send("insert into mupp_user(login,pass,fullname,email)" + "values (\"" + txtField_login.getText() + "\"," + "\"" + passField_pass.getText() + "\", \"" + txtField_fio.getText() + "\",\"" + txtField_mail.getText() + "\");");
            System.out.println("USER CREATED!");
        } else {
            System.out.println("PASSWORD NOT CONFIRMED!");
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}

######


@Test
public void rePrepareTestSelectError() throws SQLException {
    createTable("rePrepareTestSelectError", "test int");
    try (Statement stmt = sharedConnection.createStatement()) {
        stmt.execute("INSERT INTO rePrepareTestSelectError(test) VALUES (1)");
        try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT * FROM rePrepareTestSelectError where test = ?")) {
            preparedStatement.setInt(1, 1);
            ResultSet rs = preparedStatement.executeQuery();
            assertTrue(rs.next());
            assertEquals(1, rs.getInt(1));
            assertFalse(rs.next());
            stmt.execute("ALTER TABLE rePrepareTestSelectError" + " CHANGE COLUMN `test` `test` VARCHAR(50) NULL DEFAULT NULL FIRST," + "ADD COLUMN `test2` VARCHAR(50) NULL DEFAULT NULL AFTER `test`;");
            ResultSet rs2 = preparedStatement.executeQuery();
            preparedStatement.setInt(1, 1);
            assertTrue(rs2.next());
            assertEquals("1", rs2.getString(1));
            assertFalse(rs2.next());
        }
    }
}

######


@Test
public void rePrepareTestInsertError() throws SQLException {
    Assume.assumeFalse(sharedIsAurora());
    Assume.assumeFalse(!isMariadbServer() && minVersion(8, 0, 0));
    createTable("rePrepareTestInsertError", "test int");
    try (Statement stmt = sharedConnection.createStatement()) {
        try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO rePrepareTestInsertError(test) values (?)")) {
            preparedStatement.setInt(1, 1);
            preparedStatement.execute();
            stmt.execute("ALTER TABLE rePrepareTestInsertError" + " CHANGE COLUMN `test` `test` VARCHAR(50) NULL DEFAULT NULL FIRST;");
            preparedStatement.setInt(1, 2);
            preparedStatement.execute();
            stmt.execute("ALTER TABLE rePrepareTestInsertError" + " CHANGE COLUMN `test` `test` VARCHAR(100) NULL DEFAULT NULL FIRST," + "ADD COLUMN `test2` VARCHAR(50) NULL DEFAULT NULL AFTER `test`;");
            stmt.execute("flush tables with read lock");
            stmt.execute("unlock tables");
            preparedStatement.setInt(1, 3);
            preparedStatement.execute();
        }
    }
}

######


@Test
public void cannotRePrepare() throws SQLException {
    createTable("cannotRePrepare", "test int");
    try (Statement stmt = sharedConnection.createStatement()) {
        try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO cannotRePrepare(test) values (?)")) {
            preparedStatement.setInt(1, 1);
            preparedStatement.execute();
            stmt.execute("ALTER TABLE cannotRePrepare" + " CHANGE COLUMN `test` `otherName` VARCHAR(50) NULL DEFAULT NULL FIRST;");
            preparedStatement.setInt(1, 2);
            try {
                preparedStatement.execute();
                fail();
            } catch (SQLException sqle) {
                assertTrue(sqle.getMessage().contains("Unknown column 'test' in 'field list'"));
            }
        }
    }
}

######


public static long insertNewRequest(long senderId, long receiverId, String city, String status) {
    return DataBase.sqlInsert("INSERT INTO " + tableName + " (id, id_sender, id_receiver, city, " + "status) VALUES (NULL, \"" + senderId + "\", \"" + receiverId + "\", \"" + city + "\", \"" + status + "\")");
}

######


public static long insertNewRequest(Request request) {
    String query;
    long senderId;
    long receiverId;
    long id;
    senderId = request.getSender().getId();
    receiverId = request.getReceiver().getId();
    query = "INSERT INTO " + tableName + " (";
    query += "id, id_sender, id_receiver, city, weight, special_condition, price, status) ";
    query += "VALUES ( NULL";
    query += ", " + senderId;
    query += ", " + receiverId;
    query += ", " + "\"" + request.getCity() + "\"";
    query += ", " + request.getWeight();
    query += ", " + request.getSpecialCondition();
    query += ", " + request.getPrice();
    query += ", " + "\"" + request.getStatus() + "\"";
    query += ")";
    id = DataBase.sqlInsert(query);
    request.setId((int) id);
    return id;
}

######


public static Vector<Integer> getRequests(int driver_id, Cities newCity) {
    SQLiteStatement sq;
    String query;
    Vector<Integer> requestsId = null;
    query = "SELECT request.id, MAX(status.id), status.current_city";
    query += " FROM " + tableName + ", " + StatusDataBase.tableName;
    query += " WHERE (request.status = 'In tranzit direct' OR request.status = 'In tranzit retur')";
    if (driver_id > 0)
        query += " AND request.driver_id = " + driver_id;
    query += " AND status.request_id = request.Id";
    query += " GROUP BY request.id";
    sq = sqlSelect(query);
    try {
        while (sq.step()) {
            if (requestsId == null)
                requestsId = new Vector<>();
            if (Cities.valueOf(sq.columnString(2)) != newCity)
                requestsId.add(sq.columnInt(0));
        }
        return requestsId;
    } catch (SQLiteException e) {
        err(e);
    }
    return null;
}

######


public static Vector<Integer> getOldRequests() {
    SQLiteStatement sq;
    String query;
    Vector<Integer> requestsId = null;
    Date nowDate = new Date();
    Date lastDate;
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    long daysBetween;
    int id;
    query = "SELECT request.id, MAX(status.id)";
    query += " FROM " + tableName + ", " + StatusDataBase.tableName;
    query += " WHERE (request.status = 'In asteptare destinatar')";
    query += " AND status.request_id = request.Id";
    query += " GROUP BY request.id";
    sq = sqlSelect(query);
    try {
        while (sq.step()) {
            if (requestsId == null)
                requestsId = new Vector<>();
            id = sq.columnInt(0);
            lastDate = dateFormat.parse(StatusDataBase.getLastDate(id));
            daysBetween = nowDate.getTime() - lastDate.getTime();
            daysBetween = TimeUnit.DAYS.convert(daysBetween, TimeUnit.MILLISECONDS);
            if (daysBetween >= 8)
                requestsId.add(id);
        }
        return requestsId;
    } catch (SQLiteException | ParseException e) {
        err(e);
    }
    return null;
}

######


public static Request getRequestById(int id) {
    SQLiteStatement sq;
    Request request;
    int auxId;
    sq = sqlSelect("SELECT id_sender, id_receiver, city, weight, special_condition" + ", price, driver_id, status  FROM " + tableName + " WHERE Id = " + id);
    try {
        if (sq.step()) {
            request = new Request();
            request.setId(id);
            auxId = sq.columnInt(0);
            request.setSender(ClientDataBase.getClientById(auxId));
            auxId = sq.columnInt(1);
            request.setReceiver(ClientDataBase.getClientById(auxId));
            request.setCity(sq.columnString(2));
            request.setWeight(sq.columnInt(3));
            request.setSpecialCondition(sq.columnInt(4));
            request.setPrice(sq.columnInt(5));
            request.setDriver_id(sq.columnString(6));
            request.setStatus(sq.columnString(7));
            return request;
        }
    } catch (SQLiteException e) {
        err(e);
    }
    return null;
}

######


public static void updateDriver(int requestId, int driverId) {
    String query;
    if (getRequestById(requestId) == null) {
        DataBase.err("Nu exista nici o cerere cu id-ul " + requestId + "!");
        return;
    }
    query = "UPDATE " + tableName + " SET driver_id = " + driverId;
    query += " WHERE id = " + requestId;
    DataBase.sqlUpdate(query);
}

######


public static void updateRequest(Request request) {
    String query;
    ClientDataBase.updateClient(request.getSender());
    ClientDataBase.updateClient(request.getReceiver());
    if (getRequestById(request.getId()) == null) {
        insertNewRequest(request);
        return;
    }
    query = "UPDATE " + tableName + " SET city = \"" + request.getCity();
    query += "\", weight = " + request.getWeight();
    query += ", special_condition = " + request.getSpecialCondition();
    query += ", price = " + request.getPrice();
    query += ", status = '" + request.getStatus();
    query += "', driver_id = ";
    if (request.getDriver_id() == 0)
        query += "NULL";
    else
        query += request.getDriver_id();
    query += " WHERE id = " + request.getId();
    DataBase.sqlUpdate(query);
}

######


public void requestInitialized(ServletRequestEvent sre) {
    HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();
    HttpSession session = request.getSession();
    String sessionId = session.getId();
    String ip = request.getRemoteAddr();
    String page = request.getRequestURI();
    String user = (String) session.getAttribute("user");
    user = (user == null) ? "�ο�" : user;
    try {
        DbDao dd = new DbDao("com.mysql.jdbc.Driver", "jdbc:mysql://localhost:3306/online_inf", "root", "32147");
        ResultSet rs = dd.query("select * from online_inf where session_id=?", true, sessionId);
        if (rs.next()) {
            rs.updateString(4, page);
            rs.updateLong(5, System.currentTimeMillis());
            rs.updateRow();
            rs.close();
        } else {
            dd.insert("insert into online_inf values(? , ? , ? , ? , ?)", sessionId, user, ip, page, System.currentTimeMillis());
        }
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

######


public void requestDestroyed(ServletRequestEvent sre) {
}

######


@GET
@Path("/hello")
@Produces("text/html")
public String getStartingPage() {
    String output = "<h1>Hello World!<h1>" + "<p>RESTful Service is running ... <br>Ping @ " + new Date().toString() + "</p<br>";
    return output;
}

######


@GET
@Path("/listnames")
@Produces("text/plain")
public String getNameList() {
    String output = "Steve,David,Mary,Alex,Sue";
    return output;
}

######


@POST
@Path("/login")
@Produces("text/plain")
public String validateLogin(@FormParam("email") String email, @FormParam("password") String password) {
    String output = "";
    Connection conn = null;
    Statement stmt = null;
    ResultSet resultSet = null;
    try {
        String dbPassword = "";
        conn = DBConnect.OpenConnection();
        stmt = conn.createStatement();
        resultSet = stmt.executeQuery("select password from auctionsite.user where username='" + email + "'");
        if (resultSet.next()) {
            dbPassword = resultSet.getString("password");
            if (password.equals(dbPassword)) {
                output = "OK";
            } else {
                output = "BADPASS";
            }
        } else {
            output = "NOUSER";
        }
    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        DBConnect.closeQuietly(resultSet);
        DBConnect.closeQuietly(stmt);
        DBConnect.closeQuietly(conn);
    }
    return output;
}

######


@Insert
void insertResult(Result... results);

######


@Insert
void insertBatchResults(List<Result> results);

######


@Query("SELECT SUM(score) FROM Result WHERE z_id LIKE :mZ_id")
int getSummedScore(int mZ_id);

######


public void addStats(long updateCount, long insertId, boolean moreResultAvailable) {
    if (cmdInformation == null) {
        if (batch) {
            cmdInformation = new CmdInformationBatch(expectedSize, autoIncrement);
        } else if (moreResultAvailable) {
            cmdInformation = new CmdInformationMultiple(expectedSize, autoIncrement);
        } else {
            cmdInformation = new CmdInformationSingle(insertId, updateCount, autoIncrement);
            return;
        }
    }
    cmdInformation.addSuccessStat(updateCount, insertId);
}

######


public void addStatsError(boolean moreResultAvailable) {
    if (cmdInformation == null) {
        if (batch) {
            cmdInformation = new CmdInformationBatch(expectedSize, autoIncrement);
        } else if (moreResultAvailable) {
            cmdInformation = new CmdInformationMultiple(expectedSize, autoIncrement);
        } else {
            cmdInformation = new CmdInformationSingle(0, Statement.EXECUTE_FAILED, autoIncrement);
            return;
        }
    }
    cmdInformation.addErrorStat();
}

######


public int getCurrentStatNumber() {
    return (cmdInformation == null) ? 0 : cmdInformation.getCurrentStatNumber();
}

######


public void addResultSet(SelectResultSet resultSet, boolean moreResultAvailable) {
    if (resultSet.isCallableResult()) {
        callableResultSet = resultSet;
        return;
    }
    if (executionResults == null) {
        executionResults = new ArrayDeque<>();
    }
    executionResults.add(resultSet);
    if (cmdInformation == null) {
        if (batch) {
            cmdInformation = new CmdInformationBatch(expectedSize, autoIncrement);
        } else if (moreResultAvailable) {
            cmdInformation = new CmdInformationMultiple(expectedSize, autoIncrement);
        } else {
            cmdInformation = new CmdInformationSingle(0, -1, autoIncrement);
            return;
        }
    }
    cmdInformation.addResultSetStat();
}

######


public CmdInformation getCmdInformation() {
    return cmdInformation;
}

######


protected void setCmdInformation(CmdInformation cmdInformation) {
    this.cmdInformation = cmdInformation;
}

######


public boolean commandEnd() {
    if (cmdInformation != null) {
        if (executionResults != null && !cmdInformation.isCurrentUpdateCount()) {
            resultSet = executionResults.poll();
        } else {
            resultSet = null;
        }
        cmdInformation.setRewrite(rewritten);
    } else {
        resultSet = null;
    }
    return cmdInformation != null;
}

######


public SelectResultSet getResultSet() {
    return resultSet;
}

######


public SelectResultSet getCallableResultSet() {
    return callableResultSet;
}

######


public void loadFully(boolean skip, Protocol protocol) throws SQLException {
    if (fetchSize != 0) {
        fetchSize = 0;
        if (resultSet != null) {
            if (skip) {
                resultSet.close();
            } else {
                resultSet.fetchRemaining();
            }
        } else {
            SelectResultSet firstResult = executionResults.peekFirst();
            if (firstResult != null) {
                if (skip) {
                    firstResult.close();
                } else {
                    firstResult.fetchRemaining();
                }
            }
        }
    }
    if (protocol.hasMoreResults()) {
        protocol.getResult(this);
    }
}

######


public void abort() throws SQLException {
    if (fetchSize != 0) {
        fetchSize = 0;
        if (resultSet != null) {
            resultSet.abort();
        } else {
            SelectResultSet firstResult = executionResults.peekFirst();
            if (firstResult != null) {
                firstResult.abort();
            }
        }
    }
}

######


public boolean isFullyLoaded(Protocol protocol) {
    if (fetchSize == 0 || resultSet == null) {
        return true;
    }
    return resultSet.isFullyLoaded() && executionResults.isEmpty() && !protocol.hasMoreResults();
}

######


public boolean getMoreResults(final int current, Protocol protocol) throws SQLException {
    if (fetchSize != 0 && resultSet != null) {
        protocol.getLock().lock();
        try {
            if (current == Statement.CLOSE_CURRENT_RESULT && resultSet != null) {
                resultSet.close();
            } else {
                resultSet.fetchRemaining();
            }
            if (protocol.hasMoreResults()) {
                protocol.getResult(this);
            }
        } catch (SQLException e) {
            ExceptionMapper.throwException(e, null, statement);
        } finally {
            protocol.getLock().unlock();
        }
    }
    if (cmdInformation.moreResults() && !batch) {
        if (current == Statement.CLOSE_CURRENT_RESULT && resultSet != null) {
            resultSet.close();
        }
        if (executionResults != null) {
            resultSet = executionResults.poll();
        }
        return resultSet != null;
    } else {
        if (current == Statement.CLOSE_CURRENT_RESULT && resultSet != null) {
            resultSet.close();
        }
        resultSet = null;
        return false;
    }
}

######


public int getFetchSize() {
    return fetchSize;
}

######


public MariaDbStatement getStatement() {
    return statement;
}

######


public boolean isBatch() {
    return batch;
}

######


public int getExpectedSize() {
    return expectedSize;
}

######


public boolean isBinaryFormat() {
    return binaryFormat;
}

######


public void removeFetchSize() {
    fetchSize = 0;
}

######


public int getResultSetScrollType() {
    return resultSetScrollType;
}

######


public ResultSet getGeneratedKeys(Protocol protocol) throws SQLException {
    if (autoGeneratedKeys != Statement.RETURN_GENERATED_KEYS) {
        throw new SQLException("Cannot return generated keys : query was not set with Statement.RETURN_GENERATED_KEYS");
    }
    if (cmdInformation != null) {
        if (batch) {
            return cmdInformation.getBatchGeneratedKeys(protocol);
        }
        return cmdInformation.getGeneratedKeys(protocol);
    }
    return SelectResultSet.createEmptyResultSet();
}

######


public void close() {
    statement = null;
    fetchSize = 0;
}

######


public int getMaxFieldSize() {
    return maxFieldSize;
}

######


public void setAutoIncrement(int autoIncrement) {
    this.autoIncrement = autoIncrement;
}

######


public int getResultSetConcurrency() {
    return resultSetConcurrency;
}

######


public int getAutoGeneratedKeys() {
    return autoGeneratedKeys;
}

######


public boolean isRewritten() {
    return rewritten;
}

######


public void setRewritten(boolean rewritten) {
    this.rewritten = rewritten;
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("test_rsmd", "id_col int not null primary key auto_increment, " + "nullable_col varchar(20),unikey_col int unique, char_col char(10), us  smallint unsigned");
    createTable("t1", "id int, name varchar(20)");
    createTable("t2", "id int, name varchar(20)");
    createTable("t3", "id int, name varchar(20)");
}

######


@Test
public void metaDataTest() throws SQLException {
    requireMinimumVersion(5, 0);
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("insert into test_rsmd (id_col,nullable_col,unikey_col) values (null, 'hej', 9)");
    ResultSet rs = stmt.executeQuery("select id_col, nullable_col, unikey_col as something, char_col,us from test_rsmd");
    assertTrue(rs.next());
    ResultSetMetaData rsmd = rs.getMetaData();
    assertEquals(true, rsmd.isAutoIncrement(1));
    assertEquals(5, rsmd.getColumnCount());
    assertEquals(ResultSetMetaData.columnNullable, rsmd.isNullable(2));
    assertEquals(ResultSetMetaData.columnNoNulls, rsmd.isNullable(1));
    assertEquals(String.class.getName(), rsmd.getColumnClassName(2));
    assertEquals(Integer.class.getName(), rsmd.getColumnClassName(1));
    assertEquals(Integer.class.getName(), rsmd.getColumnClassName(3));
    assertEquals("id_col", rsmd.getColumnLabel(1));
    assertEquals("nullable_col", rsmd.getColumnLabel(2));
    assertEquals("something", rsmd.getColumnLabel(3));
    assertEquals("unikey_col", rsmd.getColumnName(3));
    assertEquals(Types.CHAR, rsmd.getColumnType(4));
    assertEquals(Types.SMALLINT, rsmd.getColumnType(5));
    DatabaseMetaData md = sharedConnection.getMetaData();
    ResultSet cols = md.getColumns(null, null, "test\\_rsmd", null);
    cols.next();
    assertEquals("id_col", cols.getString("COLUMN_NAME"));
    assertEquals(Types.INTEGER, cols.getInt("DATA_TYPE"));
    cols.next();
    cols.next();
    cols.next();
    assertEquals("char_col", cols.getString("COLUMN_NAME"));
    assertEquals(Types.CHAR, cols.getInt("DATA_TYPE"));
    cols.next();
    assertEquals("us", cols.getString("COLUMN_NAME"));
    assertEquals(Types.SMALLINT, cols.getInt("DATA_TYPE"));
}

######


@Test
public void conj17() throws Exception {
    requireMinimumVersion(5, 0);
    ResultSet rs = sharedConnection.createStatement().executeQuery("select count(*),1 from information_schema.tables");
    assertTrue(rs.next());
    assertEquals(rs.getMetaData().getColumnName(1), "count(*)");
    assertEquals(rs.getMetaData().getColumnName(2), "1");
}

######


@Test
public void conj84() throws Exception {
    requireMinimumVersion(5, 0);
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("INSERT INTO t1 VALUES (1, 'foo')");
    stmt.execute("INSERT INTO t2 VALUES (2, 'bar')");
    ResultSet rs = sharedConnection.createStatement().executeQuery("select t1.*, t2.* FROM t1 join t2");
    assertTrue(rs.next());
    assertEquals(rs.findColumn("id"), 1);
    assertEquals(rs.findColumn("name"), 2);
    assertEquals(rs.findColumn("t1.id"), 1);
    assertEquals(rs.findColumn("t1.name"), 2);
    assertEquals(rs.findColumn("t2.id"), 3);
    assertEquals(rs.findColumn("t2.name"), 4);
}

######


@Test
public void testAlias() throws Exception {
    createTable("testAlias", "id int, name varchar(20)");
    createTable("testAlias2", "id2 int, name2 varchar(20)");
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("INSERT INTO testAlias VALUES (1, 'foo')");
    stmt.execute("INSERT INTO testAlias2 VALUES (2, 'bar')");
    ResultSet rs = sharedConnection.createStatement().executeQuery("select alias1.id as idalias1 , alias1.name as namealias1, id2 as idalias2 , name2, testAlias.id " + "FROM testAlias as alias1 join testAlias2 as alias2 join testAlias");
    assertTrue(rs.next());
    assertEquals(rs.findColumn("idalias1"), 1);
    assertEquals(rs.findColumn("alias1.idalias1"), 1);
    assertEquals(rs.findColumn("name"), 2);
    assertEquals(rs.findColumn("namealias1"), 2);
    assertEquals(rs.findColumn("alias1.namealias1"), 2);
    assertEquals(rs.findColumn("id2"), 3);
    assertEquals(rs.findColumn("idalias2"), 3);
    assertEquals(rs.findColumn("alias2.idalias2"), 3);
    assertEquals(rs.findColumn("testAlias2.id2"), 3);
    assertEquals(rs.findColumn("name2"), 4);
    assertEquals(rs.findColumn("testAlias2.name2"), 4);
    assertEquals(rs.findColumn("alias2.name2"), 4);
    assertEquals(rs.findColumn("id"), 5);
    assertEquals(rs.findColumn("testAlias.id"), 5);
    try {
        rs.findColumn("alias2.name22");
        fail("Must have thrown exception");
    } catch (SQLException sqle) {
    }
    try {
        assertEquals(rs.findColumn(""), 4);
        fail("Must have thrown exception");
    } catch (SQLException sqle) {
    }
    try {
        assertEquals(rs.findColumn(null), 4);
        fail("Must have thrown exception");
    } catch (SQLException sqle) {
    }
}

######


@Test
public void tableNameTest() throws Exception {
    ResultSet rs = sharedConnection.createStatement().executeQuery("SELECT id AS id_alias FROM t3 AS t1_alias");
    ResultSetMetaData rsmd = rs.getMetaData();
    logInfo(rsmd.getTableName(1));
    assertEquals(rsmd.getTableName(1), "t3");
    assertEquals(rsmd.getColumnLabel(1), "id_alias");
    assertEquals(rsmd.getColumnName(1), "id");
    try (Connection connection = setConnection("&useOldAliasMetadataBehavior=true")) {
        rs = connection.createStatement().executeQuery("SELECT id AS id_alias FROM t3 AS t1_alias");
        rsmd = rs.getMetaData();
        logInfo(rsmd.getTableName(1));
        assertEquals(rsmd.getTableName(1), "t1_alias");
        assertEquals(rsmd.getColumnLabel(1), "id_alias");
        assertEquals(rsmd.getColumnName(1), "id_alias");
    }
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("result_set_test", "id int not null primary key auto_increment, name char(20)");
}

######


@Test
public void isBeforeFirstFetchTest() throws SQLException {
    insertRows(1);
    Statement statement = sharedConnection.createStatement();
    statement.setFetchSize(1);
    ResultSet resultSet = statement.executeQuery("SELECT * FROM result_set_test");
    assertTrue(resultSet.isBeforeFirst());
    while (resultSet.next()) {
        assertFalse(resultSet.isBeforeFirst());
    }
    assertFalse(resultSet.isBeforeFirst());
    resultSet.close();
    try {
        resultSet.isBeforeFirst();
        fail("The above row should have thrown an SQLException");
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("closed"));
    }
}

######


@Test
public void testGeneratedKeysWithoutTableAutoIncrementCalledTwice() throws SQLException {
    createTable("gen_key_test_resultset", "name VARCHAR(40) NOT NULL, xml MEDIUMTEXT");
    String sql = "INSERT INTO gen_key_test_resultset (name, xml) VALUES (?, ?)";
    for (int i = 0; i < 2; i++) {
        try (PreparedStatement preparedStatement = sharedConnection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            preparedStatement.setString(1, "John");
            preparedStatement.setString(2, "<xml/>");
            preparedStatement.executeUpdate();
            try (ResultSet generatedKeysResultSet = preparedStatement.getGeneratedKeys()) {
                assertFalse(generatedKeysResultSet.next());
            }
        }
    }
}

######


@Test
public void isBeforeFirstFetchZeroRowsTest() throws SQLException {
    insertRows(2);
    Statement statement = sharedConnection.createStatement();
    statement.setFetchSize(1);
    try (ResultSet resultSet = statement.executeQuery("SELECT * FROM result_set_test")) {
        assertTrue(resultSet.isBeforeFirst());
        assertTrue(resultSet.next());
        assertFalse(resultSet.isBeforeFirst());
        resultSet.close();
        try {
            resultSet.isBeforeFirst();
            fail("The above row should have thrown an SQLException");
        } catch (SQLException e) {
            assertTrue(e.getMessage().contains("closed"));
        }
    }
}

######


@Test
public void isClosedTest() throws SQLException {
    insertRows(1);
    ResultSet resultSet = sharedConnection.createStatement().executeQuery("SELECT * FROM result_set_test");
    assertFalse(resultSet.isClosed());
    while (resultSet.next()) {
        assertFalse(resultSet.isClosed());
    }
    assertFalse(resultSet.isClosed());
    resultSet.close();
    assertTrue(resultSet.isClosed());
}

######


@Test
public void isBeforeFirstTest() throws SQLException {
    insertRows(1);
    ResultSet resultSet = sharedConnection.createStatement().executeQuery("SELECT * FROM result_set_test");
    assertTrue(resultSet.isBeforeFirst());
    while (resultSet.next()) {
        assertFalse(resultSet.isBeforeFirst());
    }
    assertFalse(resultSet.isBeforeFirst());
    resultSet.close();
    try {
        resultSet.isBeforeFirst();
        fail("The above row should have thrown an SQLException");
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("closed"));
    }
}

######


@Test
public void isFirstZeroRowsTest() throws SQLException {
    insertRows(0);
    Statement stmt = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    ResultSet resultSet = stmt.executeQuery("SELECT * FROM result_set_test");
    assertFalse(resultSet.isFirst());
    assertFalse(resultSet.next());
    assertFalse(resultSet.isFirst());
    assertFalse(resultSet.first());
    resultSet.close();
    try {
        resultSet.isFirst();
        fail("The above row should have thrown an SQLException");
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("closed"));
    }
}

######


@Test
public void isFirstOneRowsTest() throws SQLException {
    insertRows(1);
    Statement stmt = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    ResultSet resultSet = stmt.executeQuery("SELECT * FROM result_set_test");
    assertFalse(resultSet.isFirst());
    assertTrue(resultSet.next());
    assertTrue(resultSet.isFirst());
    assertFalse(resultSet.next());
    assertFalse(resultSet.isFirst());
    assertTrue(resultSet.first());
    assertEquals(1, resultSet.getInt(1));
    resultSet.close();
    try {
        resultSet.isFirst();
        fail("The above row should have thrown an SQLException");
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("closed"));
    }
}

######


@Test
public void isFirstTwoRowsTest() throws SQLException {
    isFirstTwoRowsTest(true);
    isFirstTwoRowsTest(false);
}

######


private void isFirstTwoRowsTest(boolean fetching) throws SQLException {
    insertRows(2);
    try (Statement statement = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {
        if (fetching) {
            statement.setFetchSize(1);
        }
        ResultSet resultSet = statement.executeQuery("SELECT * FROM result_set_test");
        assertFalse(resultSet.isFirst());
        assertTrue(resultSet.next());
        assertTrue(resultSet.isFirst());
        assertTrue(resultSet.next());
        assertFalse(resultSet.isFirst());
        assertFalse(resultSet.next());
        assertFalse(resultSet.isFirst());
        assertTrue(resultSet.first());
        assertEquals(1, resultSet.getInt(1));
        resultSet.close();
        try {
            resultSet.isFirst();
            fail("The above row should have thrown an SQLException");
        } catch (SQLException e) {
            assertTrue(e.getMessage().contains("closed"));
        }
    }
}

######


@Test
public void isLastZeroRowsTest() throws SQLException {
    insertRows(0);
    ResultSet resultSet = sharedConnection.createStatement().executeQuery("SELECT * FROM result_set_test");
    assertFalse(resultSet.isLast());
    assertFalse(resultSet.next());
    assertFalse(resultSet.isLast());
    assertFalse(resultSet.last());
    resultSet.close();
    try {
        resultSet.isLast();
        fail("The above row should have thrown an SQLException");
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("closed"));
    }
}

######


@Test
public void isLastOneRowsTest() throws SQLException {
    insertRows(1);
    ResultSet resultSet = sharedConnection.createStatement().executeQuery("SELECT * FROM result_set_test");
    assertFalse(resultSet.isLast());
    assertTrue(resultSet.next());
    assertTrue(resultSet.isLast());
    assertTrue(resultSet.last());
    assertFalse(resultSet.next());
    assertFalse(resultSet.isLast());
    assertTrue(resultSet.last());
    resultSet.close();
    try {
        resultSet.isLast();
        fail("The above row should have thrown an SQLException");
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("closed"));
    }
}

######


@Test
public void isLastTwoRowsTest() throws SQLException {
    isLastTwoRowsTest(true);
    isLastTwoRowsTest(false);
}

######


private void isLastTwoRowsTest(boolean fetching) throws SQLException {
    insertRows(2);
    try (Statement statement = sharedConnection.createStatement()) {
        if (fetching) {
            statement.setFetchSize(1);
        }
        ResultSet resultSet = statement.executeQuery("SELECT * FROM result_set_test");
        assertFalse(resultSet.isLast());
        assertTrue(resultSet.next());
        assertFalse(resultSet.isLast());
        assertTrue(resultSet.next());
        assertTrue(resultSet.isLast());
        assertFalse(resultSet.next());
        assertFalse(resultSet.isLast());
        assertTrue(resultSet.last());
        assertEquals(2, resultSet.getInt(1));
        resultSet.close();
        try {
            resultSet.isLast();
            fail("The above row should have thrown an SQLException");
        } catch (SQLException e) {
            assertTrue(e.getMessage().contains("closed"));
        }
    }
}

######


@Test
public void isAfterLastZeroRowsTest() throws SQLException {
    insertRows(0);
    ResultSet resultSet = sharedConnection.createStatement().executeQuery("SELECT * FROM result_set_test");
    assertFalse(resultSet.isAfterLast());
    assertFalse(resultSet.next());
    assertFalse(resultSet.isAfterLast());
    resultSet.close();
    try {
        resultSet.isAfterLast();
        fail("The above row should have thrown an SQLException");
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("closed"));
    }
}

######


@Test
public void isAfterLastTwoRowsTest() throws SQLException {
    insertRows(2);
    ResultSet resultSet = sharedConnection.createStatement().executeQuery("SELECT * FROM result_set_test");
    assertFalse(resultSet.isAfterLast());
    assertTrue(resultSet.next());
    assertFalse(resultSet.isAfterLast());
    assertTrue(resultSet.next());
    assertFalse(resultSet.isAfterLast());
    assertFalse(resultSet.next());
    assertTrue(resultSet.isAfterLast());
    assertTrue(resultSet.last());
    assertEquals(2, resultSet.getInt(1));
    resultSet.close();
    try {
        resultSet.isAfterLast();
        fail("The above row should have thrown an SQLException");
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("closed"));
    }
}

######


@Test
public void previousTest() throws SQLException {
    insertRows(2);
    Statement stmt = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    try (ResultSet rs = stmt.executeQuery("SELECT * FROM result_set_test")) {
        assertFalse(rs.previous());
        assertTrue(rs.next());
        assertEquals(1, rs.getInt(1));
        assertFalse(rs.previous());
        assertTrue(rs.next());
        assertEquals(1, rs.getInt(1));
        assertTrue(rs.next());
        assertEquals(2, rs.getInt(1));
        assertTrue(rs.previous());
        assertEquals(1, rs.getInt(1));
        assertTrue(rs.last());
        assertEquals(2, rs.getInt(1));
    }
}

######


@Test
public void firstTest() throws SQLException {
    insertRows(2);
    Statement stmt = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    ResultSet rs = stmt.executeQuery("SELECT * FROM result_set_test");
    assertTrue(rs.next());
    assertTrue(rs.next());
    assertTrue(rs.first());
    assertTrue(rs.isFirst());
    rs.close();
    try {
        rs.first();
        fail("cannot call first() on a closed result set");
    } catch (SQLException sqlex) {
    }
}

######


@Test
public void lastTest() throws SQLException {
    insertRows(2);
    Statement stmt = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    ResultSet rs = stmt.executeQuery("SELECT * FROM result_set_test");
    assertTrue(rs.last());
    assertTrue(rs.isLast());
    assertFalse(rs.next());
    rs.first();
    rs.close();
    try {
        rs.last();
        fail("cannot call last() on a closed result set");
    } catch (SQLException sqlex) {
    }
}

######


@Test
public void relativeForwardTest() throws SQLException {
    insertRows(3);
    Statement stmt = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    ResultSet rs = stmt.executeQuery("SELECT * FROM result_set_test");
    assertTrue(rs.isBeforeFirst());
    assertFalse(rs.isFirst());
    assertFalse(rs.isLast());
    assertFalse(rs.isAfterLast());
    assertTrue(rs.relative(2));
    assertFalse(rs.isBeforeFirst());
    assertFalse(rs.isFirst());
    assertFalse(rs.isLast());
    assertFalse(rs.isAfterLast());
    assertTrue(rs.relative(1));
    assertFalse(rs.isBeforeFirst());
    assertFalse(rs.isFirst());
    assertTrue(rs.isLast());
    assertFalse(rs.isAfterLast());
    assertFalse(rs.relative(1));
    assertFalse(rs.isBeforeFirst());
    assertFalse(rs.isFirst());
    assertFalse(rs.isLast());
    assertTrue(rs.isAfterLast());
    assertFalse(rs.next());
    rs.close();
}

######


@Test
public void relativeBackwardTest() throws SQLException {
    insertRows(3);
    Statement stmt = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    ResultSet rs = stmt.executeQuery("SELECT * FROM result_set_test");
    rs.afterLast();
    assertFalse(rs.isBeforeFirst());
    assertFalse(rs.isFirst());
    assertFalse(rs.isLast());
    assertTrue(rs.isAfterLast());
    assertTrue(rs.relative(-2));
    assertFalse(rs.isBeforeFirst());
    assertFalse(rs.isFirst());
    assertFalse(rs.isLast());
    assertFalse(rs.isAfterLast());
    assertTrue(rs.relative(-1));
    assertFalse(rs.isBeforeFirst());
    assertTrue(rs.isFirst());
    assertFalse(rs.isLast());
    assertFalse(rs.isAfterLast());
    assertFalse(rs.relative(-1));
    assertTrue(rs.isBeforeFirst());
    assertFalse(rs.isFirst());
    assertFalse(rs.isLast());
    assertFalse(rs.isAfterLast());
    assertFalse(rs.previous());
    rs.close();
}

######


private void insertRows(int numberOfRowsToInsert) throws SQLException {
    sharedConnection.createStatement().execute("truncate result_set_test ");
    for (int i = 1; i <= numberOfRowsToInsert; i++) {
        sharedConnection.createStatement().executeUpdate("INSERT INTO result_set_test VALUES(" + i + ", 'row" + i + "')");
    }
}

######


@Test
public void generatedKeyNpe() throws SQLException {
    createTable("generatedKeyNpe", "id int not null primary key auto_increment, val int");
    Statement statement = sharedConnection.createStatement();
    statement.execute("INSERT INTO generatedKeyNpe(val) values (0)", Statement.RETURN_GENERATED_KEYS);
    try (ResultSet rs = statement.getGeneratedKeys()) {
        assertTrue(rs.next());
    }
}

######


@Test
public void generatedKeyError() throws SQLException {
    createTable("generatedKeyNpe", "id int not null primary key auto_increment, val int");
    Statement statement = sharedConnection.createStatement();
    statement.execute("INSERT INTO generatedKeyNpe(val) values (0)");
    try {
        statement.getGeneratedKeys();
        fail();
    } catch (SQLException sqle) {
        assertEquals("Cannot return generated keys : query was not set with Statement.RETURN_GENERATED_KEYS", sqle.getMessage());
    }
}

######


@Test
public void testResultSetAbsolute() throws Exception {
    insertRows(50);
    try (Statement statement = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {
        statement.setFetchSize(10);
        try (ResultSet rs = statement.executeQuery("SELECT * FROM result_set_test")) {
            assertFalse(rs.absolute(52));
            assertFalse(rs.absolute(-52));
            assertTrue(rs.absolute(42));
            assertEquals("row42", rs.getString(2));
            assertTrue(rs.absolute(-11));
            assertEquals("row40", rs.getString(2));
            assertTrue(rs.absolute(0));
            assertTrue(rs.isBeforeFirst());
            assertFalse(rs.absolute(51));
            assertTrue(rs.isAfterLast());
            assertTrue(rs.absolute(-1));
            assertEquals("row50", rs.getString(2));
            assertTrue(rs.absolute(-50));
            assertEquals("row1", rs.getString(2));
        }
    }
}

######


@Test
public void testResultSetIsAfterLast() throws Exception {
    insertRows(2);
    try (Statement statement = sharedConnection.createStatement()) {
        statement.setFetchSize(1);
        try (ResultSet rs = statement.executeQuery("SELECT * FROM result_set_test")) {
            assertFalse(rs.isLast());
            assertFalse(rs.isAfterLast());
            assertTrue(rs.next());
            assertFalse(rs.isLast());
            assertFalse(rs.isAfterLast());
            assertTrue(rs.next());
            assertTrue(rs.isLast());
            assertFalse(rs.isAfterLast());
            assertFalse(rs.next());
            assertFalse(rs.isLast());
            assertTrue(rs.isAfterLast());
        }
        insertRows(0);
        try (ResultSet rs = statement.executeQuery("SELECT * FROM result_set_test")) {
            assertFalse(rs.isAfterLast());
            assertFalse(rs.isLast());
            assertFalse(rs.next());
            assertFalse(rs.isLast());
            assertFalse(rs.isAfterLast());
        }
    }
}

######


@Test
public void testResultSetAfterLast() throws Exception {
    try (Statement statement = sharedConnection.createStatement()) {
        checkLastResultSet(statement);
        statement.setFetchSize(1);
        checkLastResultSet(statement);
    }
}

######


private void checkLastResultSet(Statement statement) throws SQLException {
    insertRows(10);
    try (ResultSet rs = statement.executeQuery("SELECT * FROM result_set_test")) {
        assertTrue(rs.last());
        assertFalse(rs.isAfterLast());
        assertTrue(rs.isLast());
        rs.afterLast();
        assertTrue(rs.isAfterLast());
        assertFalse(rs.isLast());
    }
    insertRows(0);
    try (ResultSet rs = statement.executeQuery("SELECT * FROM result_set_test")) {
        assertFalse(rs.last());
        assertFalse(rs.isAfterLast());
        assertFalse(rs.isLast());
        rs.afterLast();
        assertFalse(rs.isAfterLast());
        assertFalse(rs.isLast());
    }
}

######


@Test
public void testStreamInsensitive() throws Exception {
    createTable("testStreamInsensitive", "s1 varchar(20)");
    for (int r = 0; r < 20; r++) {
        sharedConnection.createStatement().executeUpdate("insert into testStreamInsensitive values('V" + r + "')");
    }
    Statement stmt = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    stmt.setFetchSize(10);
    ResultSet rs = stmt.executeQuery("select * from testStreamInsensitive");
    for (int i = 0; i < 20; i++) {
        assertTrue(rs.next());
        assertEquals("V" + i, rs.getString(1));
    }
    assertFalse(rs.next());
    rs = stmt.executeQuery("select * from testStreamInsensitive");
    for (int i = 0; i < 20; i++) {
        assertFalse(rs.isAfterLast());
        assertTrue(rs.next());
        assertEquals("V" + i, rs.getString(1));
        assertFalse(rs.isAfterLast());
    }
    assertFalse(rs.isAfterLast());
    assertFalse(rs.next());
    assertTrue(rs.isAfterLast());
    rs = stmt.executeQuery("select * from testStreamInsensitive");
    assertTrue(rs.absolute(20));
    assertEquals("V19", rs.getString(1));
    assertFalse(rs.isAfterLast());
    assertFalse(rs.absolute(21));
    assertTrue(rs.isAfterLast());
    rs = stmt.executeQuery("select * from testStreamInsensitive");
    rs.afterLast();
    for (int i = 19; i >= 0; i--) {
        assertTrue(rs.previous());
        assertEquals("V" + i, rs.getString(1));
    }
    assertFalse(rs.previous());
    rs = stmt.executeQuery("select * from testStreamInsensitive");
    assertTrue(rs.last());
    assertEquals("V19", rs.getString(1));
    assertTrue(rs.first());
    assertEquals("V0", rs.getString(1));
}

######


@Test
public void testStreamForward() throws Exception {
    createTable("testStreamForward", "s1 varchar(20)");
    for (int r = 0; r < 20; r++) {
        sharedConnection.createStatement().executeUpdate("insert into testStreamForward values('V" + r + "')");
    }
    Statement stmt = sharedConnection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    stmt.setFetchSize(10);
    ResultSet rs = stmt.executeQuery("select * from testStreamForward");
    for (int i = 0; i < 20; i++) {
        assertTrue(rs.next());
        assertEquals("V" + i, rs.getString(1));
    }
    assertFalse(rs.next());
    rs = stmt.executeQuery("select * from testStreamForward");
    for (int i = 0; i < 20; i++) {
        assertFalse(rs.isAfterLast());
        assertTrue(rs.next());
        assertEquals("V" + i, rs.getString(1));
        assertFalse(rs.isAfterLast());
    }
    assertFalse(rs.isAfterLast());
    assertFalse(rs.next());
    assertTrue(rs.isAfterLast());
    rs = stmt.executeQuery("select * from testStreamForward");
    rs.afterLast();
    try {
        rs.previous();
        fail("Must have thrown exception since previous is not possible when fetching");
    } catch (SQLException sqle) {
        assertTrue(sqle.getMessage().contains("Invalid operation for result set type TYPE_FORWARD_ONLY"));
    }
    rs = stmt.executeQuery("select * from testStreamForward");
    assertTrue(rs.last());
    assertEquals("V19", rs.getString(1));
    try {
        rs.first();
        fail("Must have thrown exception since previous is not possible when fetching");
    } catch (SQLException sqle) {
        assertTrue(sqle.getMessage().contains("Invalid operation for result set type TYPE_FORWARD_ONLY"));
    }
}

######


@Test
public void leadingZeroTest() throws SQLException {
    createTable("leadingZero", "t1 TINYINT(3) unsigned zerofill" + ", t2 TINYINT(8) unsigned zerofill" + ", t3 TINYINT unsigned zerofill" + ", t4 smallint(3) unsigned zerofill" + ", t5 smallint(8) unsigned zerofill" + ", t6 smallint unsigned zerofill" + ", t7 MEDIUMINT(3) unsigned zerofill" + ", t8 MEDIUMINT(8) unsigned zerofill" + ", t9 MEDIUMINT unsigned zerofill" + ", t10 INT(3) unsigned zerofill" + ", t11 INT(8) unsigned zerofill" + ", t12 INT unsigned zerofill" + ", t13 BIGINT(3) unsigned zerofill" + ", t14 BIGINT(8) unsigned zerofill" + ", t15 BIGINT unsigned zerofill" + ", t16 DECIMAL(6,3) unsigned zerofill" + ", t17 DECIMAL(11,3) unsigned zerofill" + ", t18 DECIMAL unsigned zerofill" + ", t19 FLOAT(6,3) unsigned zerofill" + ", t20 FLOAT(11,3) unsigned zerofill" + ", t21 FLOAT unsigned zerofill" + ", t22 DOUBLE(6,3) unsigned zerofill" + ", t23 DOUBLE(11,3) unsigned zerofill" + ", t24 DOUBLE unsigned zerofill");
    Statement stmt = sharedConnection.createStatement();
    stmt.executeUpdate("insert into leadingZero values (1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1.1,1.1,1.1,1.1,1.1,1.1,1.1,1.1,1.1), " + "(20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20.2,20.2,20.2,20.2,20.2,20.2,20.2,20.2,20.2)");
    testLeadingZeroResult(stmt.executeQuery("select * from leadingZero"));
    if (!sharedUsePrepare()) {
        PreparedStatement pst1 = sharedConnection.prepareStatement("select * from leadingZero");
        ResultSet rs1 = pst1.executeQuery();
        testLeadingZeroResult(rs1);
    }
}

######


private void testLeadingZeroResult(ResultSet rs1) throws SQLException {
    assertTrue(rs1.next());
    assertEquals("001", rs1.getString(1));
    assertEquals("00000001", rs1.getString(2));
    assertEquals("001", rs1.getString(3));
    assertEquals("001", rs1.getString(4));
    assertEquals("00000001", rs1.getString(5));
    assertEquals("00001", rs1.getString(6));
    assertEquals("001", rs1.getString(7));
    assertEquals("00000001", rs1.getString(8));
    assertEquals("00000001", rs1.getString(9));
    assertEquals("001", rs1.getString(10));
    assertEquals("00000001", rs1.getString(11));
    assertEquals("0000000001", rs1.getString(12));
    assertEquals("001", rs1.getString(13));
    assertEquals("00000001", rs1.getString(14));
    assertEquals("00000000000000000001", rs1.getString(15));
    assertEquals("001.100", rs1.getString(16));
    assertEquals("00000001.100", rs1.getString(17));
    assertEquals("0000000001", rs1.getString(18));
    assertEquals("01.100", rs1.getString(19));
    assertEquals("0000001.100", rs1.getString(20));
    assertEquals("0000000001.1", rs1.getString(21));
    assertEquals("01.100", rs1.getString(22));
    assertEquals("0000001.100", rs1.getString(23));
    assertEquals("00000000000000000001.1", rs1.getString(24));
    assertTrue(rs1.next());
    assertEquals("020", rs1.getString(1));
    assertEquals("00000020", rs1.getString(2));
    assertEquals("020", rs1.getString(3));
    assertEquals("020", rs1.getString(4));
    assertEquals("00000020", rs1.getString(5));
    assertEquals("00020", rs1.getString(6));
    assertEquals("020", rs1.getString(7));
    assertEquals("00000020", rs1.getString(8));
    assertEquals("00000020", rs1.getString(9));
    assertEquals("020", rs1.getString(10));
    assertEquals("00000020", rs1.getString(11));
    assertEquals("0000000020", rs1.getString(12));
    assertEquals("020", rs1.getString(13));
    assertEquals("00000020", rs1.getString(14));
    assertEquals("00000000000000000020", rs1.getString(15));
    assertEquals("020.200", rs1.getString(16));
    assertEquals("00000020.200", rs1.getString(17));
    assertEquals("0000000020", rs1.getString(18));
    assertEquals("20.200", rs1.getString(19));
    assertEquals("0000020.200", rs1.getString(20));
    assertEquals("0000000020.2", rs1.getString(21));
    assertEquals("20.200", rs1.getString(22));
    assertEquals("0000020.200", rs1.getString(23));
    assertEquals("00000000000000000020.2", rs1.getString(24));
    assertFalse(rs1.next());
}

######


@Test
public void firstForwardTest() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    ResultSet rs = stmt.executeQuery("SELECT 1");
    assertTrue(rs.first());
    assertFalse(rs.previous());
    assertTrue(rs.absolute(1));
    assertFalse(rs.relative(-1));
    stmt.setFetchSize(1);
    rs = stmt.executeQuery("SELECT 1");
    try {
        rs.first();
        fail("absolute operation must fail when TYPE_FORWARD_ONLY and streaming");
    } catch (SQLException sqle) {
        assertTrue(sqle.getMessage().contains("Invalid operation for result set type TYPE_FORWARD_ONLY"));
    }
    try {
        rs.previous();
        fail("absolute operation must fail when TYPE_FORWARD_ONLY and streaming");
    } catch (SQLException sqle) {
        assertTrue(sqle.getMessage().contains("Invalid operation for result set type TYPE_FORWARD_ONLY"));
    }
    try {
        rs.absolute(1);
        fail("absolute operation must fail when TYPE_FORWARD_ONLY and streaming");
    } catch (SQLException sqle) {
        assertTrue(sqle.getMessage().contains("Invalid operation for result set type TYPE_FORWARD_ONLY"));
    }
    try {
        rs.relative(-1);
        fail("absolute operation must fail when TYPE_FORWARD_ONLY and streaming");
    } catch (SQLException sqle) {
        assertTrue(sqle.getMessage().contains("Invalid operation for result set type TYPE_FORWARD_ONLY"));
    }
}

######


@Test
public void testNumericType() throws SQLException {
    createTable("numericTypeTable", "t1 tinyint, " + "t2 boolean, " + "t3 smallint,  " + "t4 mediumint, " + "t5 int, " + "t6 bigint, " + "t7 decimal, " + "t8 float, " + "t9 double, " + "t10 bit," + "t11 char(10)," + "t12 varchar(10)," + "t13 binary(10)," + "t14 varbinary(10)," + "t15 text," + "t16 blob," + "t17 date");
    try (Statement stmt = sharedConnection.createStatement()) {
        stmt.execute("INSERT into numericTypeTable values (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'a', 'a', 'a', 'a', 'a', 'a', now())");
        try (ResultSet rs = stmt.executeQuery("select * from numericTypeTable")) {
            assertTrue(rs.next());
            floatDoubleCheckResult(rs);
        }
    }
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("select * from numericTypeTable")) {
        try (ResultSet rs = preparedStatement.executeQuery()) {
            assertTrue(rs.next());
            floatDoubleCheckResult(rs);
        }
    }
}

######


private void floatDoubleCheckResult(ResultSet rs) throws SQLException {
    for (int i = 1; i < 11; i++) {
        rs.getDouble(i);
        rs.getFloat(i);
    }
    for (int i = 11; i < 16; i++) {
        try {
            rs.getDouble(i);
            fail();
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage().contains("Incorrect format "));
        }
        try {
            rs.getFloat(i);
            fail();
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage().contains("Incorrect format "));
        }
    }
    for (int i = 16; i < 18; i++) {
        try {
            rs.getDouble(i);
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage().contains("not available"));
        }
        try {
            rs.getFloat(i);
            fail();
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage().contains("not available"));
        }
    }
}

######


@Test
public void numericTestWithDecimal() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    ResultSet rs = stmt.executeQuery("SELECT 1 as test");
    assertTrue(rs.next());
    assertTrue(rs.getInt("test") == 1);
    assertTrue(rs.getByte("test") == 1);
    assertTrue(rs.getShort("test") == 1);
    rs = stmt.executeQuery("SELECT 1.3333 as test");
    assertTrue(rs.next());
    assertTrue(rs.getInt("test") == 1);
    assertTrue(rs.getByte("test") == 1);
    assertTrue(rs.getShort("test") == 1);
    assertTrue(rs.getLong("test") == 1);
    assertTrue(rs.getFloat("test") == 1.3333F);
    rs = stmt.executeQuery("SELECT 1.0 as test");
    assertTrue(rs.next());
    assertTrue(rs.getInt("test") == 1);
    assertTrue(rs.getByte("test") == 1);
    assertTrue(rs.getShort("test") == 1);
    assertTrue(rs.getLong("test") == 1);
    assertTrue(rs.getFloat("test") == 1.0F);
    rs = stmt.executeQuery("SELECT -1 as test");
    assertTrue(rs.next());
    assertTrue(rs.getInt("test") == -1);
    assertTrue(rs.getByte("test") == -1);
    assertTrue(rs.getShort("test") == -1);
    assertTrue(rs.getLong("test") == -1);
    rs = stmt.executeQuery("SELECT -1.0 as test");
    assertTrue(rs.next());
    assertTrue(rs.getInt("test") == -1);
    assertTrue(rs.getByte("test") == -1);
    assertTrue(rs.getShort("test") == -1);
    assertTrue(rs.getLong("test") == -1);
    assertTrue(rs.getFloat("test") == -1.0F);
    rs = stmt.executeQuery("SELECT -1.3333 as test");
    assertTrue(rs.next());
    assertTrue(rs.getInt("test") == -1);
    assertTrue(rs.getByte("test") == -1);
    assertTrue(rs.getShort("test") == -1);
    assertTrue(rs.getLong("test") == -1);
    assertTrue(rs.getFloat("test") == -1.3333F);
}

######


@Test
public void nullField() throws SQLException {
    Assume.assumeTrue(isMariadbServer());
    createTable("nullField", "t1 varchar(50), t2 timestamp NULL, t3 date, t4 year(4)");
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("INSERT INTO nullField(t1,t2,t3,t4) values " + "(null, '0000-00-00 00:00:00', '0000-00-00', '0000'), " + "(null, null, null, null)," + "('aa', now(), now(), '2017')");
    ResultSet rs = stmt.executeQuery("SELECT * FROM nullField");
    assertTrue(rs.next());
    if (!sharedOptions().useServerPrepStmts) {
        assertNull(rs.getString(1));
        assertTrue(rs.wasNull());
        assertNull(rs.getTimestamp(2));
        assertTrue(rs.wasNull());
        assertEquals("0000-00-00 00:00:00", rs.getString(2));
        assertFalse(rs.wasNull());
        assertNull(rs.getDate(3));
        assertTrue(rs.wasNull());
        assertEquals("0000-00-00", rs.getString(3));
        assertFalse(rs.wasNull());
        assertEquals(Date.valueOf("0000-01-01"), rs.getDate(4));
        assertFalse(rs.wasNull());
        assertEquals(0, rs.getInt(4));
        assertFalse(rs.wasNull());
        assertEquals("0001-01-01", rs.getString(4));
        assertFalse(rs.wasNull());
    }
    assertTrue(rs.next());
    assertNull(rs.getTimestamp(2));
    assertTrue(rs.wasNull());
    assertNull(rs.getString(2));
    assertTrue(rs.wasNull());
    assertNull(rs.getDate(3));
    assertTrue(rs.wasNull());
    assertNull(rs.getString(3));
    assertTrue(rs.wasNull());
    assertNull(rs.getDate(4));
    assertTrue(rs.wasNull());
    assertNull(rs.getString(2));
    assertTrue(rs.wasNull());
    assertTrue(rs.next());
    assertNotNull(rs.getTimestamp(2));
    assertFalse(rs.wasNull());
    assertNotNull(rs.getString(2));
    assertFalse(rs.wasNull());
    assertNotNull(rs.getDate(3));
    assertFalse(rs.wasNull());
    assertNotNull(rs.getString(3));
    assertFalse(rs.wasNull());
    assertNotNull(rs.getDate(4));
    assertFalse(rs.wasNull());
    assertNotNull(rs.getString(2));
    assertFalse(rs.wasNull());
}

######


@Test
public void doubleStringResults() throws SQLException {
    createTable("doubleStringResults", "i double, j float");
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("INSERT INTO doubleStringResults VALUES (1.1, 1.2), (23, 24)");
    ResultSet rs = stmt.executeQuery("SELECT * FROM doubleStringResults");
    assertTrue(rs.next());
    assertEquals("1.1", rs.getString(1));
    assertEquals(1, rs.getInt(1));
    assertEquals(1.1, rs.getDouble(1), 0.0001);
    assertEquals("1.2", rs.getString(2));
    assertEquals(1, rs.getInt(2));
    assertEquals(1.2, rs.getFloat(2), 0.0001);
    assertTrue(rs.next());
    assertEquals("23", rs.getString(1));
    assertEquals(23, rs.getInt(1));
    assertEquals(23, rs.getDouble(1), 0.0001);
    assertEquals("24", rs.getString(2));
    assertEquals(24, rs.getInt(2));
    assertEquals(24, rs.getFloat(2), 0.0001);
}

######


@Test
public void invisibleColumn() throws SQLException {
    Assume.assumeTrue(isMariadbServer() && minVersion(10, 3));
    cancelForVersion(10, 3, 0);
    cancelForVersion(10, 3, 1);
    cancelForVersion(10, 3, 2);
    createTable("invisible", "x INT, y INT INVISIBLE, z INT INVISIBLE NOT NULL DEFAULT 4");
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("INSERT INTO invisible(x,y) VALUES (1,2)");
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT * FROM invisible WHERE x = ?")) {
        ResultSetMetaData resultSetMetaData = preparedStatement.getMetaData();
        Assert.assertEquals(1, resultSetMetaData.getColumnCount());
        Assert.assertEquals("x", resultSetMetaData.getColumnName(1));
    }
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT x,z FROM invisible WHERE x = ?")) {
        ResultSetMetaData resultSetMetaData = preparedStatement.getMetaData();
        Assert.assertEquals(2, resultSetMetaData.getColumnCount());
        Assert.assertEquals("x", resultSetMetaData.getColumnName(1));
        Assert.assertEquals("z", resultSetMetaData.getColumnName(2));
    }
}

######


@Test
public void checkInvisibleMetaData() throws SQLException {
    Assume.assumeTrue(isMariadbServer() && minVersion(10, 3));
    cancelForVersion(10, 3, 0);
    cancelForVersion(10, 3, 1);
    cancelForVersion(10, 3, 2);
    createTable("checkInvisibleMetaData", "xx tinyint(1), x2 tinyint(1) unsigned INVISIBLE primary key auto_increment, yy year(4), zz bit, uu smallint");
    DatabaseMetaData meta = sharedConnection.getMetaData();
    ResultSet rs = meta.getColumns(null, null, "checkInvisibleMetaData", null);
    assertTrue(rs.next());
    assertEquals("BIT", rs.getString(6));
    assertTrue(rs.next());
    assertEquals("BIT", rs.getString(6));
    assertTrue(rs.next());
    assertEquals("YEAR", rs.getString(6));
    assertEquals(null, rs.getString(7));
    assertEquals(null, rs.getString(9));
}

######


@Test
public void columnNamesMappingError() throws SQLException {
    createTable("columnNamesMappingError", "xx tinyint(1)");
    Statement stmt = sharedConnection.createStatement();
    stmt.executeUpdate("INSERT INTO columnNamesMappingError VALUES (4)");
    ResultSet rs = stmt.executeQuery("SELECT * FROM columnNamesMappingError");
    assertTrue(rs.next());
    assertEquals(4, rs.getInt("xx"));
    try {
        rs.getInt("wrong_column_name");
        fail("must have fail, column 'wrong_column_name' does not exists");
    } catch (SQLException e) {
        assertEquals("42S22", e.getSQLState());
        assertEquals(1054, e.getErrorCode());
        assertEquals("No such column: wrong_column_name", e.getMessage());
    }
}

######


@Test
public void emptyColumnName() throws SQLException {
    try (Connection connection = setConnection("")) {
        Statement stmt = connection.createStatement();
        stmt.execute("CREATE TEMPORARY TABLE emptyColumn (id int)");
        stmt.execute("INSERT INTO emptyColumn value (1)");
        ResultSet rs = stmt.executeQuery("SELECT '' FROM emptyColumn");
        while (rs.next()) {
            Assert.assertEquals("", rs.getString(1));
            Assert.assertEquals("", rs.getString(""));
        }
        ResultSetMetaData meta = rs.getMetaData();
        Assert.assertEquals(1, meta.getColumnCount());
        Assert.assertEquals("", meta.getColumnName(1));
    }
}

######


public final void fetchParameters(@Body String retrieverCommand) throws IOException {
    final int TIMESTAMP_OVERLAPPING = 1000;
    long startTimeStamp = 0;
    long endTimeStamp = 0;
    String parameterName = "";
    String[] command;
    if (!retrieverCommand.matches("^[A-Za-z][0-9A-Za-z-_]*(;([0-9]{1,13});([0-9]{1,13}))?$")) {
        throw new IOException(errorMessageFaultyInputstring + "\n###" + retrieverCommand);
    }
    command = retrieverCommand.split(";");
    switch(command.length) {
        case 1:
            startTimeStamp = 0;
            endTimeStamp = System.currentTimeMillis();
            parameterName = command[0];
            break;
        case 3:
            parameterName = command[0];
            startTimeStamp = Long.parseLong(command[1]);
            endTimeStamp = Long.parseLong(command[2]);
            break;
    }
    if (startTimeStamp >= endTimeStamp) {
        throw new IOException(errorMessageIncorrectTimestamps + "\n###" + retrieverCommand);
    }
    String sqlSelect;
    List<Map<String, Object>> result;
    sqlSelect = "select * from " + parameterName + " where TIMESTAMP >= " + startTimeStamp + " and TIMESTAMP < " + (endTimeStamp - TIMESTAMP_OVERLAPPING) + ";";
    result = template.queryForList(sqlSelect);
    processResults(result);
    sqlSelect = "select * from " + parameterName + " where TIMESTAMP >= " + (endTimeStamp - TIMESTAMP_OVERLAPPING) + " and TIMESTAMP < " + endTimeStamp + ";";
    result = template.queryForList(sqlSelect);
    processResults(result);
}

######


private void processResults(List<Map<String, Object>> result) {
    Exchange exchange;
    Map<String, Object> element = null;
    while (!result.isEmpty()) {
        element = result.remove(0);
        exchange = new DefaultExchange(context);
        exchange.getIn().setBody(element.get("body"));
        producer.send(destination, exchange);
    }
}

######


public List<ReviewsAboutDoctorsModel> getReviewsAboutDoctor(DoctorModel doctorModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM ReviewsAboutDoctorsModel e WHERE e.doctor = :DOCTOR_MODEL AND e.isAppropriate = :IS_APPROPRIATE ORDER BY e.creationTime DESC");
    query.setParameter("DOCTOR_MODEL", doctorModel);
    query.setParameter("IS_APPROPRIATE", '1');
    return query.getResultList();
}

######


public List<ReviewsAboutDoctorsModel> getReviewsOfPatient(PatientModel patientModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM ReviewsAboutDoctorsModel e WHERE e.patient = :PATIENT_MODEL ORDER BY e.creationTime DESC");
    query.setParameter("PATIENT_MODEL", patientModel);
    return query.getResultList();
}

######


public ReviewsAboutDoctorsModel getPatientReviewAboutDoctor(PatientModel patientModel, DoctorModel doctorModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM ReviewsAboutDoctorsModel e WHERE e.patient = :PATIENT AND e.doctor = :DOCTOR");
    query.setParameter("PATIENT", patientModel);
    query.setParameter("DOCTOR", doctorModel);
    if (query.getResultList().size() > 0) {
        return (ReviewsAboutDoctorsModel) query.getResultList().get(0);
    } else {
        return null;
    }
}

######


public void setRoleDao(IRoleDAO roleDao) {
    this.roleDao = roleDao;
}

######


public Long addRole(Role role) {
    updateLevel(role);
    this.roleDao.save(role);
    if (role != null && role.getId() != null) {
        return role.getId();
    }
    return null;
}

######


public Role getRole(Long id) {
    Role role = this.roleDao.get(id);
    return role;
}

######


public boolean delRole(Long id) {
    Role role = this.getRole(id);
    if (role != null) {
        this.roleDao.remove(id);
        return true;
    }
    return false;
}

######


public boolean batchDelRoles(List<Serializable> roleIds) {
    for (Serializable id : roleIds) {
        delRole((Long) id);
    }
    return true;
}

######


public IPageList getRoleBy(IQueryObject queryObject) {
    return QueryUtil.query(queryObject, Role.class, this.roleDao);
}

######


public boolean updateRole(Long id, Role role) {
    if (id != null) {
        role.setId(id);
    } else {
        return false;
    }
    updateLevel(role);
    this.roleDao.update(role);
    return true;
}

######


public String loadTree(Integer currentNodeId) {
    String result = "[";
    String sql;
    if (new Integer(0).equals(currentNodeId))
        sql = "select o from Role o where o.parent is null and o.disabled=0";
    else
        sql = "select o from Role o where o.parent.id=" + currentNodeId + " and o.disabled=0";
    List list = roleDao.query(sql, null, 0, AppContext.RESULTSIZE);
    for (int i = 0; i < list.size(); i++) {
        Role role = (Role) list.get(i);
        Long id = role.getId();
        result += "{id:" + id + ",text:'" + role.getName() + "(" + role.getCode() + ")',";
        if (isLeaf(id))
            result += "leaf:true}";
        else
            result += "leaf:false}";
        if (i < list.size() - 1)
            result += ",";
    }
    return result + "]";
}

######


private boolean isLeaf(Long nodeId) {
    String sql = "select o from Role o where o.parent.id=" + nodeId + " and o.disabled=false";
    List list = roleDao.query(sql, null, 0, 1);
    return list.isEmpty();
}

######


private void updateLevel(Role role) {
    Role parent = role.getParent();
    if (null != parent)
        role.setLevel(parent.getLevel() + "-" + role.getCode());
    else
        role.setLevel(role.getCode());
}

######


@Query("SELECT * FROM Room1 WHERE id = :id")
List<Room1> getRoom1ById(int id);

######


@Insert(onConflict = OnConflictStrategy.REPLACE)
void addRoom1(Room1 room1);

######


@Update
void update(Room1... room1s);

######


@Query("UPDATE Room1 set temperature=:temperature,humidity=:humidity where id=:room_id")
void updateTemperatureAndHumidity(int room_id, int temperature, int humidity);

######


@Query("UPDATE Room1 set temperature=:temperature where id=:room_id")
void updateTemperature(int room_id, int temperature);

######


@Query("UPDATE Room1 set humidity=:humidity where id=:room_id")
void updateHumidity(int room_id, int humidity);

######


@Query("UPDATE Room1 set air_quality=:air_quality where id=:room_id")
void updateAirQuality(int room_id, int air_quality);

######


@Query("UPDATE Room1 set beam=:beam where id=:room_id")
void updateBeam(int room_id, int beam);

######


@Query("UPDATE Room1 set warn_temperature_max=:temperature_max, warn_temperature_min=:temperature_min, warn_humidity_max=:humidity_max, warn_humidity_min=:humidity_min where id=:room_id")
void updateWarn(int room_id, int temperature_max, int temperature_min, int humidity_max, int humidity_min);

######


@Query("SELECT * FROM Room1")
List<Room1> selectAll();

######


@Insert(onConflict = OnConflictStrategy.REPLACE)
void addRoomFurniture(RoomFurniture roomFurniture);

######


@Query("UPDATE RoomFurniture set switch_status=:switch_status where room_id=:room_id AND sf_id=:sf_id")
void updateSwitchStatus(int room_id, int sf_id, int switch_status);

######


@Delete
void deleteRoomFurniture(RoomFurniture roomFurniture);

######


@Query("DELETE FROM RoomFurniture WHERE room_id=:room_id AND sf_id=:sf_id")
void deleteRoomFurnitureByIds(int room_id, int sf_id);

######


@Query("SELECT sf_id,sf_name,switch_status FROM RoomFurniture INNER JOIN SmartFurniture ON RoomFurniture.sf_id=SmartFurniture.id WHERE room_id=:roomId")
List<RoomFurnitureResult> getAllRoomFurnituresByRoomId(int roomId);

######


@Query("SELECT sf_id,sf_name,switch_status FROM RoomFurniture INNER JOIN SmartFurniture ON RoomFurniture.sf_id=SmartFurniture.id WHERE room_id=:roomId AND sf_id=:sfId")
List<RoomFurnitureResult> getRoomFurnitureByRoomIdAndSfId(int roomId, int sfId);

######


@Query("SELECT * FROM RoomFurniture")
List<RoomFurniture> selectAll();

######


public List<Rule> getAllActiveRules() {
    Query query = em.createQuery("SELECT e FROM Rule e where (e.sms is null or e.sms=false) and e.active=true and (e.nextTimeExecution is null or e.nextTimeExecution<:nowDate)");
    query.setParameter("nowDate", new Date());
    return (List<Rule>) query.getResultList();
}

######


public List<Rule> getAllActiveSMSRules() {
    Query query = em.createQuery("SELECT e FROM Rule e where e.sms=true and e.active=true");
    return (List<Rule>) query.getResultList();
}

######


public Rule getRuleById(Integer actualRuleId) {
    return em.find(Rule.class, actualRuleId);
}

######


@Transactional
public void update(Rule r) {
    em.merge(r);
}

######


public List<Rule> getAllActiveRulesByPhase(Integer phaseId) {
    Query query = em.createQuery("SELECT e FROM Rule e where (e.sms is null or e.sms=false) and e.active=true and (e.nextTimeExecution is null or e.nextTimeExecution<:nowDate) and (e.phase is null or e.phase.id=:phaseId)");
    query.setParameter("nowDate", new Date());
    query.setParameter("phaseId", phaseId);
    return (List<Rule>) query.getResultList();
}

######


public static void main(String[] args) {
    try {
    } catch (Exception ex) {
        System.out.println(ex.getMessage());
    }
}

######


@Override
public void setUp() throws Exception {
    super.setUp();
    a1 = AccountBuilder.createDefault(db);
    a2 = AccountBuilder.createDefault(db);
    a3 = AccountBuilder.createDefault(db);
    categoriesMap = CategoryBuilder.createDefaultHierarchy(categoryRepository);
}

######


public void test_should_update_running_balance_for_single_account() {
    Transaction t1 = TransactionBuilder.withDb(db).account(a1).amount(1000).create();
    Transaction t2 = TransactionBuilder.withDb(db).account(a1).amount(1234).create();
    db.rebuildRunningBalanceForAccount(a1);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a1, 2234);
    assertFinalBalanceForAccount(a1, 2234);
}

######


public void test_should_update_running_balance_for_single_account_with_transactions_having_exactly_the_same_datetime() {
    DateTime dt = DateTime.fromTimestamp(System.currentTimeMillis());
    Transaction t1 = TransactionBuilder.withDb(db).account(a1).amount(1000).dateTime(dt).create();
    Transaction t2 = TransactionBuilder.withDb(db).account(a1).amount(2000).dateTime(dt).create();
    Transaction t3 = TransactionBuilder.withDb(db).account(a1).amount(3000).dateTime(dt).create();
    Transaction t4 = TransactionBuilder.withDb(db).account(a1).amount(4000).dateTime(dt).create();
    Transaction t5 = TransactionBuilder.withDb(db).account(a1).amount(5000).dateTime(dt).create();
    assertFinalBalanceForAccount(a1, 15000);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a1, 3000);
    assertAccountBalanceForTransaction(t3, a1, 6000);
    assertAccountBalanceForTransaction(t4, a1, 10000);
    assertAccountBalanceForTransaction(t5, a1, 15000);
    db.rebuildRunningBalanceForAccount(a1);
    assertFinalBalanceForAccount(a1, 15000);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a1, 3000);
    assertAccountBalanceForTransaction(t3, a1, 6000);
    assertAccountBalanceForTransaction(t4, a1, 10000);
    assertAccountBalanceForTransaction(t5, a1, 15000);
}

######


public void test_should_not_duplicate_running_balance_with_splits() {
    Transaction t1 = TransactionBuilder.withDb(db).account(a1).amount(2000).create();
    db.rebuildRunningBalanceForAccount(a1);
    Transaction t2 = TransactionBuilder.withDb(db).account(a1).amount(1000).withSplit(categoriesMap.get("A"), 600).withSplit(categoriesMap.get("B"), 400).create();
    assertAccountBalanceForTransaction(t1, a1, 2000);
    assertAccountBalanceForTransaction(t2, a1, 3000);
    assertFinalBalanceForAccount(a1, 3000);
    Transaction t3 = TransactionBuilder.withDb(db).account(a1).amount(-1500).create();
    assertAccountBalanceForTransaction(t1, a1, 2000);
    assertAccountBalanceForTransaction(t2, a1, 3000);
    assertAccountBalanceForTransaction(t3, a1, 1500);
    assertFinalBalanceForAccount(a1, 1500);
    db.rebuildRunningBalances();
    assertAccountBalanceForTransaction(t1, a1, 2000);
    assertAccountBalanceForTransaction(t2, a1, 3000);
    assertAccountBalanceForTransaction(t3, a1, 1500);
    assertFinalBalanceForAccount(a1, 1500);
}

######


public void test_should_update_running_balance_for_two_accounts() {
    Transaction t1 = TransactionBuilder.withDb(db).account(a1).amount(1000).create();
    Transaction t2 = TransactionBuilder.withDb(db).account(a2).amount(2000).create();
    Transaction t3 = TransferBuilder.withDb(db).fromAccount(a1).fromAmount(-500).toAccount(a2).toAmount(500).create();
    db.rebuildRunningBalances();
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a2, 2000);
    assertAccountBalanceForTransaction(t3, a1, 500);
    assertAccountBalanceForTransaction(t3, a2, 2500);
    assertFinalBalanceForAccount(a1, 500);
    assertFinalBalanceForAccount(a2, 2500);
}

######


public void test_should_update_running_balance_for_account_which_has_transfer_to_the_same_account() {
    Transaction t1 = TransactionBuilder.withDb(db).account(a1).amount(1000).create();
    Transaction t2 = TransactionBuilder.withDb(db).account(a2).amount(2000).create();
    Transaction t3 = TransferBuilder.withDb(db).fromAccount(a1).fromAmount(-500).toAccount(a1).toAmount(500).create();
    db.rebuildRunningBalances();
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a2, 2000);
    assertAccountBalanceForTransaction(t3, a1, 0);
    assertFinalBalanceForAccount(a1, 1000);
    assertFinalBalanceForAccount(a2, 2000);
}

######


public void test_should_update_running_balance_for_two_accounts_with_transfer_split() {
    Transaction t1 = TransactionBuilder.withDb(db).account(a1).amount(1000).create();
    Transaction t2 = TransactionBuilder.withDb(db).account(a2).amount(2000).create();
    db.rebuildRunningBalances();
    Transaction t3 = TransactionBuilder.withDb(db).account(a1).amount(-100).withTransferSplit(a2, -100, 50).create();
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a2, 2000);
    assertAccountBalanceForTransaction(t3, a1, 900);
    List<Transaction> splits = db.getSplitsForTransaction(t3.id);
    assertEquals(1, splits.size());
    assertAccountBalanceForTransaction(splits.get(0), a2, 2050);
    assertFinalBalanceForAccount(a1, 900);
    assertFinalBalanceForAccount(a2, 2050);
    db.rebuildRunningBalances();
    assertAccountBalanceForTransaction(splits.get(0), a2, 2050);
    assertFinalBalanceForAccount(a1, 900);
    assertFinalBalanceForAccount(a2, 2050);
}

######


public void test_should_update_running_balance_for_two_accounts_with_transfer_split_with_multiple_transfers() {
    TransactionBuilder.withDb(db).account(a1).amount(2000).create();
    TransactionBuilder.withDb(db).account(a2).amount(3000).create();
    TransactionBuilder.withDb(db).account(a3).amount(4000).create();
    db.rebuildRunningBalances();
    Transaction t4 = TransactionBuilder.withDb(db).account(a1).amount(-1000).withTransferSplit(a2, -100, 50).withTransferSplit(a2, -200, 60).withTransferSplit(a2, -300, 70).withTransferSplit(a3, -100, 80).withTransferSplit(a3, -300, 90).create();
    assertFinalBalanceForAccount(a1, 1000);
    assertFinalBalanceForAccount(a2, 3180);
    assertFinalBalanceForAccount(a3, 4170);
    List<Transaction> splits = db.getSplitsForTransaction(t4.id);
    assertEquals(5, splits.size());
    assertAccountBalanceForTransaction(splits.get(0), a2, 3050);
    assertAccountBalanceForTransaction(splits.get(1), a2, 3110);
    assertAccountBalanceForTransaction(splits.get(2), a2, 3180);
    assertAccountBalanceForTransaction(splits.get(3), a3, 4080);
    assertAccountBalanceForTransaction(splits.get(4), a3, 4170);
    db.rebuildRunningBalances();
    assertFinalBalanceForAccount(a1, 1000);
    assertFinalBalanceForAccount(a2, 3180);
    assertFinalBalanceForAccount(a3, 4170);
    db.deleteTransaction(t4.id);
    assertFinalBalanceForAccount(a1, 2000);
    assertFinalBalanceForAccount(a2, 3000);
    assertFinalBalanceForAccount(a3, 4000);
}

######


public void test_should_update_running_balance_for_two_accounts_when_updating_transfer_split() {
    Transaction t1 = TransactionBuilder.withDb(db).account(a1).amount(1000).create();
    Transaction t2 = TransactionBuilder.withDb(db).account(a2).amount(2000).create();
    Transaction t3 = TransactionBuilder.withDb(db).account(a1).amount(-100).withTransferSplit(a2, -100, 50).create();
    Transaction t4 = TransactionBuilder.withDb(db).account(a1).amount(-100).create();
    Transaction t5 = TransactionBuilder.withDb(db).account(a2).amount(-100).create();
    db.rebuildRunningBalances();
    assertFinalBalanceForAccount(a1, 800);
    assertFinalBalanceForAccount(a2, 1950);
    List<Transaction> splits = db.getSplitsForTransaction(t3.id);
    t3.fromAmount = -200;
    splits.get(0).fromAmount = -200;
    splits.get(0).toAmount = 100;
    t3.splits = splits;
    db.insertOrUpdate(t3);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a2, 2000);
    assertAccountBalanceForTransaction(t3, a1, 800);
    assertAccountBalanceForTransaction(t4, a1, 700);
    assertAccountBalanceForTransaction(t5, a2, 2000);
    assertFinalBalanceForAccount(a1, 700);
    assertFinalBalanceForAccount(a2, 2000);
    db.rebuildRunningBalances();
    assertFinalBalanceForAccount(a1, 700);
    assertFinalBalanceForAccount(a2, 2000);
}

######


public void test_should_update_running_balance_when_deleting_transfer_split() {
    Transaction t1 = TransactionBuilder.withDb(db).account(a1).amount(1000).create();
    Transaction t2 = TransactionBuilder.withDb(db).account(a2).amount(2000).create();
    db.rebuildRunningBalances();
    assertFinalBalanceForAccount(a1, 1000);
    assertFinalBalanceForAccount(a2, 2000);
    Transaction t3 = TransactionBuilder.withDb(db).account(a1).amount(-200).withTransferSplit(a2, -200, 100).create();
    assertFinalBalanceForAccount(a1, 800);
    assertFinalBalanceForAccount(a2, 2100);
    db.deleteTransaction(t3.id);
    assertFinalBalanceForAccount(a1, 1000);
    assertFinalBalanceForAccount(a2, 2000);
    db.rebuildRunningBalances();
    assertFinalBalanceForAccount(a1, 1000);
    assertFinalBalanceForAccount(a2, 2000);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a2, 2000);
}

######


public void test_should_update_running_balance_when_inserting_new_transaction() {
    Transaction t1 = TransactionBuilder.withDb(db).account(a1).amount(1000).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    Transaction t2 = TransactionBuilder.withDb(db).account(a1).amount(-500).dateTime(DateTime.today().at(11, 5, 0, 0)).create();
    Transaction t3 = TransactionBuilder.withDb(db).account(a1).amount(-250).dateTime(DateTime.today().at(12, 0, 0, 0)).create();
    db.rebuildRunningBalanceForAccount(a1);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a1, 500);
    assertAccountBalanceForTransaction(t3, a1, 250);
    assertFinalBalanceForAccount(a1, 250);
    assertLastTransactionDate(a1, DateTime.today().at(12, 0, 0, 0));
    Transaction t4 = TransactionBuilder.withDb(db).account(a1).amount(100).dateTime(DateTime.today().at(13, 20, 0, 0)).create();
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a1, 500);
    assertAccountBalanceForTransaction(t3, a1, 250);
    assertAccountBalanceForTransaction(t4, a1, 350);
    assertFinalBalanceForAccount(a1, 350);
    assertLastTransactionDate(a1, DateTime.today().at(13, 20, 0, 0));
    Transaction t5 = TransactionBuilder.withDb(db).account(a1).amount(-50).dateTime(DateTime.today().at(11, 10, 0, 0)).create();
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a1, 500);
    assertAccountBalanceForTransaction(t5, a1, 450);
    assertAccountBalanceForTransaction(t3, a1, 200);
    assertAccountBalanceForTransaction(t4, a1, 300);
    assertFinalBalanceForAccount(a1, 300);
    assertLastTransactionDate(a1, DateTime.today().at(13, 20, 0, 0));
    Transaction t6 = TransactionBuilder.withDb(db).account(a1).amount(150).dateTime(DateTime.today().at(10, 0, 0, 0)).create();
    assertAccountBalanceForTransaction(t6, a1, 150);
    assertAccountBalanceForTransaction(t1, a1, 1150);
    assertAccountBalanceForTransaction(t2, a1, 650);
    assertAccountBalanceForTransaction(t5, a1, 600);
    assertAccountBalanceForTransaction(t3, a1, 350);
    assertAccountBalanceForTransaction(t4, a1, 450);
    assertFinalBalanceForAccount(a1, 450);
    assertLastTransactionDate(a1, DateTime.today().at(13, 20, 0, 0));
}

######


public void test_should_update_running_balance_when_updating_amount_on_existing_transaction() {
    Transaction t1 = TransactionBuilder.withDb(db).account(a1).amount(1000).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    Transaction t2 = TransactionBuilder.withDb(db).account(a1).amount(-500).dateTime(DateTime.today().at(11, 5, 0, 0)).create();
    Transaction t3 = TransactionBuilder.withDb(db).account(a1).amount(-250).dateTime(DateTime.today().at(12, 0, 0, 0)).create();
    db.rebuildRunningBalanceForAccount(a1);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a1, 500);
    assertAccountBalanceForTransaction(t3, a1, 250);
    assertFinalBalanceForAccount(a1, 250);
    assertLastTransactionDate(a1, DateTime.today().at(12, 0, 0, 0));
    t3.fromAmount = -350;
    db.insertOrUpdate(t3);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a1, 500);
    assertAccountBalanceForTransaction(t3, a1, 150);
    assertFinalBalanceForAccount(a1, 150);
    assertLastTransactionDate(a1, DateTime.today().at(12, 0, 0, 0));
    t2.fromAmount = -400;
    db.insertOrUpdate(t2);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a1, 600);
    assertAccountBalanceForTransaction(t3, a1, 250);
    assertFinalBalanceForAccount(a1, 250);
    assertLastTransactionDate(a1, DateTime.today().at(12, 0, 0, 0));
    t1.fromAmount = 1200;
    db.insertOrUpdate(t1);
    assertAccountBalanceForTransaction(t1, a1, 1200);
    assertAccountBalanceForTransaction(t2, a1, 800);
    assertAccountBalanceForTransaction(t3, a1, 450);
    assertFinalBalanceForAccount(a1, 450);
    assertLastTransactionDate(a1, DateTime.today().at(12, 0, 0, 0));
}

######


public void test_should_update_running_balance_when_updating_datetime_on_existing_transaction() {
    Transaction t1 = TransactionBuilder.withDb(db).account(a1).amount(1000).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    Transaction t2 = TransactionBuilder.withDb(db).account(a1).amount(-500).dateTime(DateTime.today().at(11, 5, 0, 0)).create();
    Transaction t3 = TransactionBuilder.withDb(db).account(a1).amount(-250).dateTime(DateTime.today().at(12, 0, 0, 0)).create();
    db.rebuildRunningBalanceForAccount(a1);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a1, 500);
    assertAccountBalanceForTransaction(t3, a1, 250);
    assertFinalBalanceForAccount(a1, 250);
    assertLastTransactionDate(a1, DateTime.today().at(12, 0, 0, 0));
    t3.dateTime = DateTime.today().at(11, 1, 0, 0).asLong();
    db.insertOrUpdate(t3);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t3, a1, 750);
    assertAccountBalanceForTransaction(t2, a1, 250);
    assertFinalBalanceForAccount(a1, 250);
    assertLastTransactionDate(a1, DateTime.today().at(11, 5, 0, 0));
    t3.dateTime = DateTime.today().at(12, 5, 0, 0).asLong();
    db.insertOrUpdate(t3);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a1, 500);
    assertAccountBalanceForTransaction(t3, a1, 250);
    assertFinalBalanceForAccount(a1, 250);
    assertLastTransactionDate(a1, DateTime.today().at(12, 5, 0, 0));
}

######


public void test_should_update_running_balance_when_updating_account_on_existing_transaction() {
    Transaction t11 = TransactionBuilder.withDb(db).account(a1).amount(1000).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    Transaction t12 = TransactionBuilder.withDb(db).account(a1).amount(-500).dateTime(DateTime.today().at(11, 5, 0, 0)).create();
    Transaction t21 = TransactionBuilder.withDb(db).account(a2).amount(900).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    Transaction t22 = TransactionBuilder.withDb(db).account(a2).amount(-100).dateTime(DateTime.today().at(13, 0, 0, 0)).create();
    db.rebuildRunningBalances();
    assertFinalBalanceForAccount(a1, 500);
    assertFinalBalanceForAccount(a2, 800);
    assertLastTransactionDate(a1, DateTime.today().at(11, 5, 0, 0));
    assertLastTransactionDate(a2, DateTime.today().at(13, 0, 0, 0));
    t22.fromAccountId = a1.id;
    db.insertOrUpdate(t22);
    assertAccountBalanceForTransaction(t11, a1, 1000);
    assertAccountBalanceForTransaction(t12, a1, 500);
    assertAccountBalanceForTransaction(t22, a1, 400);
    assertFinalBalanceForAccount(a1, 400);
    assertAccountBalanceForTransaction(t21, a2, 900);
    assertFinalBalanceForAccount(a2, 900);
    assertLastTransactionDate(a1, DateTime.today().at(13, 0, 0, 0));
    assertLastTransactionDate(a2, DateTime.today().at(11, 0, 0, 0));
}

######


public void test_should_update_running_balance_when_deleting_existing_transaction() {
    Transaction t1 = TransactionBuilder.withDb(db).account(a1).amount(1000).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    Transaction t2 = TransactionBuilder.withDb(db).account(a1).amount(-500).dateTime(DateTime.today().at(11, 5, 0, 0)).create();
    Transaction t3 = TransactionBuilder.withDb(db).account(a1).amount(-250).dateTime(DateTime.today().at(12, 0, 0, 0)).create();
    Transaction t4 = TransactionBuilder.withDb(db).account(a1).amount(-50).dateTime(DateTime.today().at(13, 0, 0, 0)).create();
    db.rebuildRunningBalanceForAccount(a1);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a1, 500);
    assertAccountBalanceForTransaction(t3, a1, 250);
    assertAccountBalanceForTransaction(t4, a1, 200);
    assertFinalBalanceForAccount(a1, 200);
    assertLastTransactionDate(a1, DateTime.today().at(13, 0, 0, 0));
    db.deleteTransaction(t4.id);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t2, a1, 500);
    assertAccountBalanceForTransaction(t3, a1, 250);
    assertFinalBalanceForAccount(a1, 250);
    assertLastTransactionDate(a1, DateTime.today().at(12, 0, 0, 0));
    db.deleteTransaction(t2.id);
    assertAccountBalanceForTransaction(t1, a1, 1000);
    assertAccountBalanceForTransaction(t3, a1, 750);
    assertFinalBalanceForAccount(a1, 750);
    assertLastTransactionDate(a1, DateTime.today().at(12, 0, 0, 0));
    db.deleteTransaction(t1.id);
    assertAccountBalanceForTransaction(t3, a1, -250);
    assertFinalBalanceForAccount(a1, -250);
    assertLastTransactionDate(a1, DateTime.today().at(12, 0, 0, 0));
}

######


public void test_should_update_running_balance_when_inserting_new_transfer() {
    Transaction t11 = TransactionBuilder.withDb(db).account(a1).amount(1000).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    Transaction t12 = TransactionBuilder.withDb(db).account(a1).amount(-500).dateTime(DateTime.today().at(11, 5, 0, 0)).create();
    Transaction t13 = TransactionBuilder.withDb(db).account(a1).amount(-250).dateTime(DateTime.today().at(12, 0, 0, 0)).create();
    db.rebuildRunningBalanceForAccount(a1);
    assertAccountBalanceForTransaction(t11, a1, 1000);
    assertAccountBalanceForTransaction(t12, a1, 500);
    assertAccountBalanceForTransaction(t13, a1, 250);
    assertFinalBalanceForAccount(a1, 250);
    Transaction t21 = TransactionBuilder.withDb(db).account(a2).amount(900).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    Transaction t22 = TransactionBuilder.withDb(db).account(a2).amount(-100).dateTime(DateTime.today().at(13, 0, 0, 0)).create();
    db.rebuildRunningBalanceForAccount(a2);
    assertAccountBalanceForTransaction(t21, a2, 900);
    assertAccountBalanceForTransaction(t22, a2, 800);
    assertFinalBalanceForAccount(a2, 800);
    Transaction t14 = TransferBuilder.withDb(db).fromAccount(a1).fromAmount(-100).toAccount(a2).toAmount(100).dateTime(DateTime.today().at(12, 30, 0, 0)).create();
    assertAccountBalanceForTransaction(t11, a1, 1000);
    assertAccountBalanceForTransaction(t12, a1, 500);
    assertAccountBalanceForTransaction(t13, a1, 250);
    assertAccountBalanceForTransaction(t14, a1, 150);
    assertFinalBalanceForAccount(a1, 150);
    assertAccountBalanceForTransaction(t21, a2, 900);
    assertAccountBalanceForTransaction(t14, a2, 1000);
    assertAccountBalanceForTransaction(t22, a2, 900);
    assertFinalBalanceForAccount(a2, 900);
    Transaction t15 = TransferBuilder.withDb(db).fromAccount(a1).fromAmount(-50).toAccount(a2).toAmount(20).dateTime(DateTime.today().at(13, 30, 0, 0)).create();
    assertAccountBalanceForTransaction(t15, a1, 100);
    assertFinalBalanceForAccount(a1, 100);
    assertAccountBalanceForTransaction(t15, a2, 920);
    assertFinalBalanceForAccount(a2, 920);
}

######


public void test_should_update_running_balance_when_updating_amount_on_existing_transfer() {
    Transaction t11 = TransactionBuilder.withDb(db).account(a1).amount(1000).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    Transaction t12 = TransactionBuilder.withDb(db).account(a1).amount(-500).dateTime(DateTime.today().at(11, 5, 0, 0)).create();
    Transaction t13 = TransactionBuilder.withDb(db).account(a1).amount(-250).dateTime(DateTime.today().at(12, 0, 0, 0)).create();
    Transaction t21 = TransactionBuilder.withDb(db).account(a2).amount(900).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    Transaction t22 = TransactionBuilder.withDb(db).account(a2).amount(-100).dateTime(DateTime.today().at(13, 0, 0, 0)).create();
    Transaction t14 = TransferBuilder.withDb(db).fromAccount(a1).fromAmount(-100).toAccount(a2).toAmount(100).dateTime(DateTime.today().at(12, 30, 0, 0)).create();
    db.rebuildRunningBalanceForAccount(a1);
    db.rebuildRunningBalanceForAccount(a2);
    assertAccountBalanceForTransaction(t11, a1, 1000);
    assertAccountBalanceForTransaction(t12, a1, 500);
    assertAccountBalanceForTransaction(t13, a1, 250);
    assertAccountBalanceForTransaction(t14, a1, 150);
    assertFinalBalanceForAccount(a1, 150);
    assertAccountBalanceForTransaction(t21, a2, 900);
    assertAccountBalanceForTransaction(t14, a2, 1000);
    assertAccountBalanceForTransaction(t22, a2, 900);
    assertFinalBalanceForAccount(a2, 900);
    t14.fromAmount = -200;
    t14.toAmount = +250;
    db.insertOrUpdate(t14);
    assertAccountBalanceForTransaction(t11, a1, 1000);
    assertAccountBalanceForTransaction(t12, a1, 500);
    assertAccountBalanceForTransaction(t13, a1, 250);
    assertAccountBalanceForTransaction(t14, a1, 50);
    assertFinalBalanceForAccount(a1, 50);
    assertAccountBalanceForTransaction(t21, a2, 900);
    assertAccountBalanceForTransaction(t14, a2, 1150);
    assertAccountBalanceForTransaction(t22, a2, 1050);
    assertFinalBalanceForAccount(a2, 1050);
}

######


public void test_should_update_running_balance_when_updating_datetime_on_existing_transfer() {
    Transaction t11 = TransactionBuilder.withDb(db).account(a1).amount(1000).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    Transaction t12 = TransactionBuilder.withDb(db).account(a1).amount(-500).dateTime(DateTime.today().at(11, 5, 0, 0)).create();
    Transaction t13 = TransactionBuilder.withDb(db).account(a1).amount(-250).dateTime(DateTime.today().at(12, 0, 0, 0)).create();
    Transaction t21 = TransactionBuilder.withDb(db).account(a2).amount(900).dateTime(DateTime.today().at(12, 0, 0, 0)).create();
    Transaction t22 = TransactionBuilder.withDb(db).account(a2).amount(-100).dateTime(DateTime.today().at(13, 0, 0, 0)).create();
    Transaction t14 = TransferBuilder.withDb(db).fromAccount(a1).fromAmount(-100).toAccount(a2).toAmount(100).dateTime(DateTime.today().at(12, 30, 0, 0)).create();
    db.rebuildRunningBalanceForAccount(a1);
    db.rebuildRunningBalanceForAccount(a2);
    assertAccountBalanceForTransaction(t11, a1, 1000);
    assertAccountBalanceForTransaction(t12, a1, 500);
    assertAccountBalanceForTransaction(t13, a1, 250);
    assertAccountBalanceForTransaction(t14, a1, 150);
    assertFinalBalanceForAccount(a1, 150);
    assertAccountBalanceForTransaction(t21, a2, 900);
    assertAccountBalanceForTransaction(t14, a2, 1000);
    assertAccountBalanceForTransaction(t22, a2, 900);
    assertFinalBalanceForAccount(a2, 900);
    t14.dateTime = DateTime.today().at(11, 10, 0, 0).asLong();
    db.insertOrUpdate(t14);
    assertAccountBalanceForTransaction(t11, a1, 1000);
    assertAccountBalanceForTransaction(t12, a1, 500);
    assertAccountBalanceForTransaction(t14, a1, 400);
    assertAccountBalanceForTransaction(t13, a1, 150);
    assertFinalBalanceForAccount(a1, 150);
    assertAccountBalanceForTransaction(t14, a2, 100);
    assertAccountBalanceForTransaction(t21, a2, 1000);
    assertAccountBalanceForTransaction(t22, a2, 900);
    assertFinalBalanceForAccount(a2, 900);
}

######


public void test_should_update_running_balance_when_updating_account_on_existing_transfer() {
    Transaction t11 = TransactionBuilder.withDb(db).account(a1).amount(1000).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    Transaction t21 = TransactionBuilder.withDb(db).account(a2).amount(500).dateTime(DateTime.today().at(12, 0, 0, 0)).create();
    Transaction t12 = TransferBuilder.withDb(db).fromAccount(a1).fromAmount(-100).toAccount(a2).toAmount(100).dateTime(DateTime.today().at(12, 30, 0, 0)).create();
    Transaction t31 = TransactionBuilder.withDb(db).account(a3).amount(100).dateTime(DateTime.today().at(13, 0, 0, 0)).create();
    db.rebuildRunningBalanceForAccount(a1);
    db.rebuildRunningBalanceForAccount(a2);
    db.rebuildRunningBalanceForAccount(a3);
    assertAccountBalanceForTransaction(t11, a1, 1000);
    assertAccountBalanceForTransaction(t12, a1, 900);
    assertFinalBalanceForAccount(a1, 900);
    assertAccountBalanceForTransaction(t21, a2, 500);
    assertAccountBalanceForTransaction(t12, a2, 600);
    assertFinalBalanceForAccount(a2, 600);
    assertAccountBalanceForTransaction(t31, a3, 100);
    assertFinalBalanceForAccount(a3, 100);
    t12.toAccountId = a3.id;
    db.insertOrUpdate(t12);
    assertAccountBalanceForTransaction(t11, a1, 1000);
    assertAccountBalanceForTransaction(t12, a1, 900);
    assertFinalBalanceForAccount(a1, 900);
    assertAccountBalanceForTransaction(t21, a2, 500);
    assertFinalBalanceForAccount(a2, 500);
    assertAccountBalanceForTransaction(t12, a3, 100);
    assertAccountBalanceForTransaction(t31, a3, 200);
    assertFinalBalanceForAccount(a3, 200);
}

######


public void test_should_update_accounts_last_transaction_date() {
    TransactionBuilder.withDb(db).account(a1).amount(1000).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    TransactionBuilder.withDb(db).account(a1).amount(-500).dateTime(DateTime.today().at(11, 5, 0, 0)).create();
    TransactionBuilder.withDb(db).account(a2).amount(900).dateTime(DateTime.today().at(11, 0, 0, 0)).create();
    TransactionBuilder.withDb(db).account(a2).amount(-100).dateTime(DateTime.today().at(13, 0, 0, 0)).create();
    resetLastTransaction(a1);
    resetLastTransaction(a2);
    assertLastTransactionDate(a1, DateTime.NULL_DATE);
    assertLastTransactionDate(a2, DateTime.NULL_DATE);
    db.updateAccountsLastTransactionDate();
    assertLastTransactionDate(a1, DateTime.today().at(11, 5, 0, 0));
    assertLastTransactionDate(a2, DateTime.today().at(13, 0, 0, 0));
}

######


private void resetLastTransaction(Account a) {
    db.db().execSQL("update account set last_transaction_date=0 where _id=?", new String[] { String.valueOf(a.id) });
}

######


@Override
public void validateBuild() throws IndexerException {
    Long numFound = getDocumentCount(sangerImagesCore);
    if (numFound <= MINIMUM_DOCUMENT_COUNT)
        throw new IndexerException(new ValidationException("Actual images document count is " + numFound + "."));
    if (numFound != documentCount)
        logger.warn("WARNING: Added " + documentCount + " images documents but SOLR reports " + numFound + " documents.");
    else
        logger.info("validateBuild(): Indexed " + documentCount + " images documents.");
}

######


@Override
public void initialise(String[] args) throws IndexerException {
    super.initialise(args);
    try {
        komp2DbConnection = komp2DbDataSource.getConnection();
        ontoDbConnection = ontodbDataSource.getConnection();
        populateMAs();
        try {
            populateDcfMap();
            populateMouseMv();
        } catch (SQLException e) {
            e.printStackTrace();
            throw new IndexerException(e);
        }
        populateAlleleMpi();
        populateSynonyms();
        populateGenomicFeature2();
        populateExperiments();
        populateTAGS();
        populateAnnotations();
        populateSubType();
        populateMpSynonyms();
        populateMaNodeToTerms();
        populateMaNodeToTopLevel();
        populateMaSynonyms();
        populateMpNode2TopLevelTerms();
        populateMpTermInfo();
        populateAlleles();
        populateMpToHpTermsMap();
    } catch (SQLException e) {
        throw new IndexerException(e);
    }
    printConfiguration();
}

######


public static void main(String[] args) throws IndexerException {
    SangerImagesIndexer main = new SangerImagesIndexer();
    main.initialise(args);
    main.run();
    main.validateBuild();
    logger.info("Process finished.  Exiting.");
}

######


@Override
protected Logger getLogger() {
    return logger;
}

######


@Override
public void run() throws IndexerException {
    logger.info("run method started");
    Long start = System.currentTimeMillis();
    try {
        populateSangerImagesCore();
    } catch (Exception e) {
        e.printStackTrace();
        throw new IndexerException(e);
    }
    logger.info("Populating experiment solr core - done [took: {}s]", (System.currentTimeMillis() - start) / 1000.0);
}

######


public void populateSangerImagesCore() throws SQLException, IOException, SolrServerException {
    int count = 0;
    sangerImagesCore.deleteByQuery("*:*");
    String query = "SELECT 'images' as dataType, IMA_IMAGE_RECORD.ID, FOREIGN_TABLE_NAME, FOREIGN_KEY_ID, ORIGINAL_FILE_NAME, CREATOR_ID, CREATED_DATE, EDITED_BY, EDIT_DATE, CHECK_NUMBER, FULL_RESOLUTION_FILE_PATH, SMALL_THUMBNAIL_FILE_PATH, LARGE_THUMBNAIL_FILE_PATH, SUBCONTEXT_ID, QC_STATUS_ID, PUBLISHED_STATUS_ID, o.name as institute, IMA_EXPERIMENT_DICT.ID as experiment_dict_id FROM IMA_IMAGE_RECORD, IMA_SUBCONTEXT, IMA_EXPERIMENT_DICT, organisation o  WHERE IMA_IMAGE_RECORD.organisation=o.id AND IMA_IMAGE_RECORD.subcontext_id=IMA_SUBCONTEXT.id AND IMA_SUBCONTEXT.experiment_dict_id=IMA_EXPERIMENT_DICT.id AND IMA_EXPERIMENT_DICT.name!='Mouse Necropsy' ";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(query, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY)) {
        p.setFetchSize(Integer.MIN_VALUE);
        ResultSet r = p.executeQuery();
        while (r.next()) {
            SangerImageDTO o = new SangerImageDTO();
            int imageRecordId = r.getInt("IMA_IMAGE_RECORD.ID");
            o.setId(String.valueOf(imageRecordId));
            o.setDataType(r.getString("dataType"));
            o.setFullResolutionFilePath(r.getString("FULL_RESOLUTION_FILE_PATH"));
            o.setLargeThumbnailFilePath(r.getString("LARGE_THUMBNAIL_FILE_PATH"));
            o.setOriginalFileName(r.getString("ORIGINAL_FILE_NAME"));
            o.setSmallThumbnailFilePath(r.getString("SMALL_THUMBNAIL_FILE_PATH"));
            o.setInstitute(r.getString("institute"));
            DcfBean dcfInfo = dcfMap.get(imageRecordId);
            if (dcfInfo != null) {
                o.setDcfId(dcfInfo.dcfId);
                o.setDcfExpId(dcfInfo.dcfExpId);
                o.setSangerProcedureName(dcfInfo.sangerProcedureName);
                o.setExpNameExp(Arrays.asList(dcfInfo.sangerProcedureName + "_exp"));
                o.setSangerProcedureId(dcfInfo.sangerProcedureId);
            }
            MouseBean mb = mouseMvMap.get(r.getInt("FOREIGN_KEY_ID"));
            if (mb != null) {
                o.setAgeInWeeks(mb.ageInWeeks);
                o.setGenotypeString(mb.genotypeString);
                o.setGenotype(mb.genotype);
                AlleleBean alBean = alleleMpiMap.get(mb.genotypeString);
                o.setMouseId(mb.mouseId);
                o.setSex(mb.sex);
                o.setColonyId(mb.colonyId);
                if (alBean != null) {
                    o.setAllele_accession(alBean.allele_accession);
                    o.setSangerSymbol(Arrays.asList(alBean.sangerSymbol));
                    if (featuresMap.containsKey(alBean.gf_acc)) {
                        GenomicFeatureBean feature = featuresMap.get(alBean.gf_acc);
                        o.setSymbol(Arrays.asList(feature.getSymbol()));
                        String symbolGene = feature.getSymbol() + "_" + feature.getAccession();
                        o.setAccession(feature.getAccession());
                        List<String> symbolGeneList = new ArrayList<>();
                        symbolGeneList.add(symbolGene);
                        o.setSymbolGene(symbolGeneList);
                        String subtypeKey = feature.getSubtypeAccession() + "_" + feature.getSubtypeDbId();
                        if (subtypeMap.containsKey(subtypeKey)) {
                            o.setSubtype(Arrays.asList(subtypeMap.get(subtypeKey)));
                        }
                        o.setGeneName(Arrays.asList(feature.getName()));
                        this.populateImageDtoStatuses(o, feature.getAccession());
                        if (synonyms.containsKey(feature.getAccession())) {
                            List<String> syns = synonyms.get(feature.getAccession());
                            o.setSynonyms(syns);
                            o.setMarkerSynonym(syns);
                        }
                    }
                }
            }
            if (expMap.containsKey(new Integer(r.getInt("ID")))) {
                ExperimentDict expBean = expMap.get(r.getInt("ID"));
                o.setExpName(Arrays.asList(expBean.name));
                o.setSangerProcedureName(expBean.name);
                List<String> procedureList = new ArrayList<String>();
                procedureList.add(SangerProcedureMapper.getImpcProcedureFromSanger(expBean.name));
                o.setProcedureName(procedureList);
            }
            if (tags.containsKey(imageRecordId)) {
                List<Tag> annotationList = tags.get(imageRecordId);
                List<String> tagNames = new ArrayList<>();
                List<String> tagValues = new ArrayList<>();
                for (Tag tag : annotationList) {
                    tagNames.add(tag.tagName);
                    tagValues.add(tag.tagValue);
                    if (annotationsMap.containsKey(tag.tagId)) {
                        List<Annotation> annotations = annotationsMap.get(tag.tagId);
                        List<String> annotationTermIds = new ArrayList<>();
                        List<String> annotationTermNames = new ArrayList<>();
                        List<String> ma_ids = new ArrayList<>();
                        List<String> ma_terms = new ArrayList<>();
                        List<String> mp_ids = new ArrayList<>();
                        List<String> mp_terms = new ArrayList<>();
                        ArrayList<String> maTopLevelTermIds = new ArrayList<>();
                        ArrayList<String> maTopLevelTerms = new ArrayList<>();
                        ArrayList<String> ma_term_synonyms = new ArrayList<>();
                        ArrayList<String> selected_top_level_ma_term_synonym = new ArrayList<>();
                        ArrayList<String> annotatedHigherLevelMpTermId = new ArrayList<>();
                        ArrayList<String> annotatedHigherLevelMpTermName = new ArrayList<>();
                        List<String> topLevelMpTermSynonym = new ArrayList<>();
                        for (Annotation annotation : annotations) {
                            annotationTermIds.add(annotation.annotationTermId);
                            if (annotation.ma_id != null) {
                                annotationTermNames.add(uptoDateMaMap.get(annotation.ma_id));
                                ma_ids.add(annotation.ma_id);
                                ma_terms.add(annotation.ma_term);
                                if (maNode2TermMap.containsKey(annotation.ma_id)) {
                                    for (Integer nodeId : maNode2TermMap.get(annotation.ma_id)) {
                                        if (maNodeToTopLevel.containsKey(nodeId)) {
                                            TopLevelBean maTopLevelBean = maNodeToTopLevel.get(nodeId);
                                            maTopLevelTermIds.add(maTopLevelBean.termId);
                                            maTopLevelTerms.add(maTopLevelBean.termName);
                                            if (termIdToMaSynonyms.containsKey(nodeId)) {
                                                ma_term_synonyms.addAll(termIdToMaSynonyms.get(nodeId));
                                            }
                                        }
                                    }
                                }
                            }
                            if (annotation.mp_id != null) {
                                annotationTermNames.add(annotation.mp_term);
                                mp_ids.add(annotation.mp_id);
                                mp_terms.add(annotation.mp_term);
                                if (mpToHpMap.containsKey(annotation.mp_id)) {
                                    List<Map<String, String>> hpMap = mpToHpMap.get(annotation.mp_id);
                                    List<String> hpIds = new ArrayList<>();
                                    List<String> hpTerms = new ArrayList<>();
                                    for (Map<String, String> map : hpMap) {
                                        String hpId = map.get("hp_id");
                                        String hpTerm = map.get("hp_term");
                                        if (hpId != null) {
                                            hpIds.add(hpId);
                                        }
                                        if (hpTerm != null) {
                                            hpTerms.add(hpTerm);
                                        }
                                    }
                                    if (hpIds != null && !hpIds.isEmpty()) {
                                        o.setHpId(hpIds);
                                    }
                                    if (hpTerms != null && !hpTerms.isEmpty()) {
                                        o.setHpTerm(hpTerms);
                                    }
                                }
                                if (mpNode2termTopLevel.containsKey(annotation.mp_id)) {
                                    TopLevelBean topLevelBean = mpNode2termTopLevel.get(annotation.mp_id);
                                    if (nodeIdToMpTermInfo.containsKey(topLevelBean.topLevelNodeId)) {
                                        TopLevelBean realTopLevel = nodeIdToMpTermInfo.get(topLevelBean.topLevelNodeId);
                                        annotatedHigherLevelMpTermId.add(realTopLevel.termId);
                                        annotatedHigherLevelMpTermName.add(realTopLevel.termName);
                                        if (mpSynMap.containsKey(realTopLevel.termId)) {
                                            List<String> topLevelSynonyms = mpSynMap.get(realTopLevel.termId);
                                            topLevelMpTermSynonym.addAll(topLevelSynonyms);
                                        }
                                    }
                                } else {
                                    logger.info("No top level for " + annotation.mp_id);
                                }
                                if (mpSynMap.containsKey(annotation.mp_id)) {
                                    o.setMpSyns(mpSynMap.get(annotation.mp_id));
                                }
                            }
                        }
                        o.setTopLevelMpTermSynonym(topLevelMpTermSynonym);
                        o.setAnnotatedHigherLevelMpTermId(annotatedHigherLevelMpTermId);
                        o.setAnnotatedHigherLevelMpTermName(annotatedHigherLevelMpTermName);
                        o.setAnnotationTermId(annotationTermIds);
                        o.setAnnotationTermName(annotationTermNames);
                        o.setMaTopLevelTermIds(maTopLevelTermIds);
                        o.setMaTopLevelTerms(maTopLevelTerms);
                        o.setSelectedTopLevelMaTermSynonym(selected_top_level_ma_term_synonym);
                        o.setMaId(ma_ids);
                        o.setMaTerm(ma_terms);
                        o.setMaTermName(ma_terms);
                        o.setMpId(mp_ids);
                        o.setMpTerm(mp_terms);
                        o.setMp_id(mp_ids);
                        o.setMpTermName(mp_terms);
                        for (String maId : ma_ids) {
                            if (maTermToNodeMap.containsKey(maId)) {
                                int nodeId = maTermToNodeMap.get(maId);
                                if (termIdToMaSynonyms.containsKey(nodeId)) {
                                    List<String> maSyns = termIdToMaSynonyms.get(nodeId);
                                    o.setMaTermSynonym(maSyns);
                                }
                            }
                        }
                    }
                }
                o.setTagNames(tagNames);
                o.setTagValues(tagValues);
            }
            documentCount++;
            sangerImagesCore.addBean(o, 10000);
            count++;
            if (count % 10000 == 0) {
                logger.info(" added " + count + " beans");
            }
        }
        sangerImagesCore.commit();
    } catch (Exception e) {
        logger.error("Big error {}", e.getMessage(), e);
    }
}

######


public void populateMaSynonyms() {
    logger.info("populating MA synonyms");
    String query = "select * from ma_synonyms";
    try (PreparedStatement p = ontoDbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            String termId = resultSet.getString("term_id");
            String synName = resultSet.getString("syn_name");
            if (termIdToMaSynonyms.containsKey(termId)) {
                List<String> maSynonyms = termIdToMaSynonyms.get(termId);
                maSynonyms.add(synName);
            } else {
                List<String> maSynonyms = new ArrayList<>();
                maSynonyms.add(synName);
                termIdToMaSynonyms.put(termId, maSynonyms);
            }
        }
        logger.info("termIdToMaSynonyms size=" + termIdToMaSynonyms.size());
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void populateDcfMap() throws SQLException {
    List<String> queries = new ArrayList<>();
    queries.add("SELECT ir.id as id, DCF_ID, NAME, PROCEDURE_ID, EXPERIMENT_ID, MOUSE_ID FROM `IMA_DCF_IMAGE_VW` dcf, IMA_IMAGE_RECORD ir, PHN_STD_OPERATING_PROCEDURE stdOp WHERE dcf.id=ir.id and dcf.dcf_id=stdOp.id");
    for (String query : queries) {
        try (PreparedStatement p = komp2DbConnection.prepareStatement(query)) {
            ResultSet resultSet = p.executeQuery();
            while (resultSet.next()) {
                DcfBean b = new DcfBean();
                b.dcfId = resultSet.getString("DCF_ID");
                b.dcfExpId = resultSet.getString("EXPERIMENT_ID");
                b.sangerProcedureName = resultSet.getString("NAME");
                b.sangerProcedureId = resultSet.getInt("PROCEDURE_ID");
                dcfMap.put(resultSet.getInt("id"), b);
            }
        }
    }
}

######


public void populateMAs() {
    logger.info("populating MAs");
    String query = "select ma_term_infos.term_id, ma_term_infos.name, ma_node2term.node_id, ma_node2term.term_id from ma_term_infos, ma_node2term where ma_term_infos.term_id=ma_node2term.term_id";
    try (PreparedStatement p = ontoDbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            String termId = resultSet.getString("term_id");
            String termName = resultSet.getString("name");
            int nodeId = resultSet.getInt("node_id");
            maTermToNodeMap.put(termId, nodeId);
            uptoDateMaMap.put(termId, termName);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void populateMouseMv() throws SQLException {
    logger.info("populating MouseMv");
    String query = "select MOUSE_ID, AGE_IN_WEEKS, ALLELE, GENOTYPE, GENDER, COLONY_ID from IMPC_MOUSE_ALLELE_MV";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            MouseBean b = new MouseBean();
            b.mouseId = resultSet.getInt("MOUSE_ID");
            b.ageInWeeks = resultSet.getString("AGE_IN_WEEKS");
            b.genotypeString = resultSet.getString("ALLELE");
            b.genotype = resultSet.getString("GENOTYPE");
            b.sex = resultSet.getString("gender");
            b.colonyId = resultSet.getInt("COLONY_ID");
            mouseMvMap.put(b.mouseId, b);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void populateAlleleMpi() {
    logger.info("populating alleleMpi");
    String query = "select * from `allele`";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            AlleleBean b = new AlleleBean();
            b.gf_acc = resultSet.getString("gf_acc");
            b.sangerSymbol = resultSet.getString("symbol");
            b.allele_accession = resultSet.getString("acc");
            alleleMpiMap.put(b.sangerSymbol, b);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void populateGenomicFeature2() {
    logger.info("populating genomicFeature2");
    String query = "select * from `genomic_feature";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            GenomicFeatureBean gf = new GenomicFeatureBean();
            gf.setSymbol(resultSet.getString("symbol"));
            gf.setAccession(resultSet.getString("acc"));
            gf.setName(resultSet.getString("name"));
            gf.setSubtypeAccession(resultSet.getString("subtype_acc"));
            gf.setSubtypeDbId(resultSet.getString("subtype_db_id"));
            featuresMap.put(resultSet.getString("acc"), gf);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


protected void populateExperiments() {
    logger.info("populating experiments");
    String query = "select IMA_IMAGE_RECORD.ID, IMA_EXPERIMENT_DICT.NAME, IMA_EXPERIMENT_DICT.DESCRIPTION, concat(IMA_EXPERIMENT_DICT.NAME,'_exp') as expName_exp FROM IMA_EXPERIMENT_DICT, IMA_SUBCONTEXT, IMA_IMAGE_RECORD where IMA_SUBCONTEXT.ID=IMA_IMAGE_RECORD.SUBCONTEXT_ID and IMA_EXPERIMENT_DICT.ID=IMA_SUBCONTEXT.EXPERIMENT_DICT_ID";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            ExperimentDict exp = new ExperimentDict();
            exp.name = resultSet.getString("NAME");
            exp.description = resultSet.getString("DESCRIPTION");
            expMap.put(resultSet.getInt("ID"), exp);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


protected void populateSynonyms() {
    logger.info("populating synonyms");
    String query = "select * from synonym";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            String accession = resultSet.getString("acc");
            String symb = resultSet.getString("symbol");
            if (synonyms.containsKey(accession)) {
                List<String> list = synonyms.get(accession);
                list.add(symb);
            } else {
                List<String> synList = new ArrayList<>();
                synList.add(symb);
                synonyms.put(accession, synList);
            }
        }
        logger.info("synonyms size=" + synonyms.size());
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


private void populateTAGS() {
    logger.info("populating TAGS");
    String query = "select * from IMA_IMAGE_TAG";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            int irId = resultSet.getInt("IMAGE_RECORD_ID");
            Tag tag = new Tag();
            tag.tagId = resultSet.getInt("ID");
            tag.tagName = resultSet.getString("TAG_NAME");
            tag.tagValue = resultSet.getString("TAG_VALUE");
            if (tags.containsKey(irId)) {
                List<Tag> list = tags.get(irId);
                list.add(tag);
            } else {
                List<Tag> list = new ArrayList<>();
                list.add(tag);
                tags.put(irId, list);
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


protected void populateAnnotations() {
    logger.info("populating Annotations");
    String query = "select * from ANN_ANNOTATION";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            int id = resultSet.getInt("FOREIGN_KEY_ID");
            Annotation ann = new Annotation();
            String annotationTermId = resultSet.getString("TERM_ID");
            String annotationTermName = resultSet.getString("TERM_NAME");
            ann.annotationTermId = annotationTermId;
            if (annotationTermId.startsWith("MA:")) {
                ann.ma_id = annotationTermId;
                ann.ma_term = annotationTermName;
            }
            if (annotationTermId.startsWith("MP:")) {
                ann.mp_id = annotationTermId;
                ann.mp_term = annotationTermName;
            }
            if (annotationsMap.containsKey(id)) {
                List<Annotation> list = annotationsMap.get(id);
                list.add(ann);
            } else {
                List<Annotation> list = new ArrayList<>();
                list.add(ann);
                annotationsMap.put(id, list);
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


protected void populateSubType() {
    logger.info("populating subtype");
    String query = "select  * from ontology_term";
    try (PreparedStatement p = komp2DbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            String subtype = resultSet.getString("name");
            String acc = resultSet.getString("acc");
            int db_id = resultSet.getInt("db_id");
            String key = acc + "_" + db_id;
            subtypeMap.put(key, subtype);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public Map<String, Map<String, String>> getTranslateCategoryNames() {
    return translateCategoryNames;
}

######


@Override
public String toString() {
    return "dcf=" + dcfId + " " + dcfExpId + " " + sangerProcedureName + " " + sangerProcedureId;
}

######


@Override
public String toString() {
    return "mouseId=" + mouseId + " " + ageInWeeks + " " + genotypeString;
}

######


public void populateMpSynonyms() {
    logger.info("populating MP synonyms");
    String query = "select * from mp_synonyms";
    try (PreparedStatement p = ontoDbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            String termId = resultSet.getString("term_id");
            String mp_term_synonym = resultSet.getString("syn_name");
            if (mpSynMap.containsKey(termId)) {
                List<String> syns = mpSynMap.get(termId);
                syns.add(mp_term_synonym);
            } else {
                List<String> syns = new ArrayList<>();
                syns.add(mp_term_synonym);
                mpSynMap.put(termId, syns);
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void populateMaNodeToTerms() {
    logger.info("populating ma_node2term");
    String query = "select * from ma_node2term";
    try (PreparedStatement p = ontoDbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            Integer nodeId = resultSet.getInt("node_id");
            String termId = resultSet.getString("term_id");
            if (maNode2TermMap.containsKey(termId)) {
                Set<Integer> nodeIds = maNode2TermMap.get(termId);
                nodeIds.add(nodeId);
            } else {
                Set<Integer> nodeIds = new HashSet<>();
                nodeIds.add(nodeId);
                maNode2TermMap.put(termId, nodeIds);
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void populateMaNodeToTopLevel() {
    logger.info("populating ma_node2topLevel");
    String query = "select distinct m.node_id, ti.term_id, ti.name from ma_node2term nt, ma_node_2_selected_top_level_mapping m, ma_term_infos ti where nt.node_id=m.node_id and m.top_level_term_id=ti.term_id";
    try (PreparedStatement p = ontoDbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            int nodeId = resultSet.getInt("node_id");
            String termId = resultSet.getString("term_id");
            String termName = resultSet.getString("name");
            if (!maNodeToTopLevel.containsKey(nodeId)) {
                maNodeToTopLevel.put(nodeId, new TopLevelBean(nodeId, termId, termName));
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


private void populateMpNode2TopLevelTerms() {
    logger.info("populating mpNode2termTopLevel");
    String query = "SELECT * FROM `mp_node2term` mp, mp_node_top_level tl WHERE mp.node_id=tl.node_id";
    try (PreparedStatement p = ontoDbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            int nodeId = resultSet.getInt("node_id");
            String termId = resultSet.getString("term_id");
            int topLevelNodeId = resultSet.getInt("top_level_node_id");
            if (!mpNode2termTopLevel.containsKey(termId)) {
                mpNode2termTopLevel.put(termId, new TopLevelBean(nodeId, termId, null, topLevelNodeId));
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


private void populateMpTermInfo() {
    logger.info("populating mpTermInfo");
    String query = "SELECT mp.node_id, mp.term_id as mpTerm, inf.term_id, name FROM `mp_node2term` mp , `mp_term_infos` inf WHERE  inf.term_id=mp.term_id";
    try (PreparedStatement p = ontoDbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            int nodeId = resultSet.getInt("node_id");
            String termId = resultSet.getString("term_id");
            String termName = resultSet.getString("name");
            if (!nodeIdToMpTermInfo.containsKey(nodeId)) {
                nodeIdToMpTermInfo.put(nodeId, new TopLevelBean(nodeId, termId, termName));
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public void populateAlleles() throws IndexerException {
    alleles = IndexerMap.getGeneToAlleles(alleleCore);
}

######


private void populateImageDtoStatuses(SangerImageDTO img, String geneAccession) {
    if (alleles.containsKey(geneAccession)) {
        List<AlleleDTO> localAlleles = alleles.get(geneAccession);
        for (AlleleDTO allele : localAlleles) {
            if (allele.getMgiAccessionId() != null) {
                img.addMgiAccessionId(allele.getMgiAccessionId());
            }
            if (allele.getMarkerSymbol() != null) {
                img.addMarkerSymbol(allele.getMarkerSymbol());
            }
            if (allele.getMarkerName() != null) {
                img.addMarkerName(allele.getMarkerName());
            }
            if (allele.getMarkerSynonym() != null) {
                img.addMarkerSynonym(allele.getMarkerSynonym());
            }
            if (allele.getMarkerType() != null) {
                img.addMarkerType(allele.getMarkerType());
            }
            if (allele.getHumanGeneSymbol() != null) {
                img.addHumanGeneSymbol(allele.getHumanGeneSymbol());
            }
            if (allele.getStatus() != null) {
                img.addStatus(allele.getStatus());
            }
            if (allele.getImitsPhenotypeStarted() != null) {
                img.addImitsPhenotypeStarted(allele.getImitsPhenotypeStarted());
            }
            if (allele.getImitsPhenotypeComplete() != null) {
                img.addImitsPhenotypeComplete(allele.getImitsPhenotypeComplete());
            }
            if (allele.getImitsPhenotypeStatus() != null) {
                img.addImitsPhenotypeStatus(allele.getImitsPhenotypeStatus());
            }
            if (allele.getLegacyPhenotypeStatus() != null) {
                img.setLegacyPhenotypeStatus(allele.getLegacyPhenotypeStatus());
            }
            img.setLatestProductionCentre(allele.getLatestProductionCentre());
            img.setLatestPhenotypingCentre(allele.getLatestPhenotypingCentre());
            img.setAlleleName(allele.getAlleleName());
        }
    }
}

######


private void populateMpToHpTermsMap() throws IndexerException {
    logger.info("populating Mp To Hp Term map");
    mpToHpMap = IndexerMap.getMpToHpTerms(phenodigmServer);
}

######


private void populateMpToNode() {
    logger.info("populating mpTermToNode");
    String query = "select nt.node_id, ti.term_id from mp_term_infos ti, mp_node2term nt where ti.term_id=nt.term_id and ti.term_id !='MP:0000001'";
    try (PreparedStatement p = ontoDbConnection.prepareStatement(query)) {
        ResultSet resultSet = p.executeQuery();
        while (resultSet.next()) {
            int nodeId = resultSet.getInt("node_id");
            String termId = resultSet.getString("term_id");
            if (!nodeToMp.containsKey(nodeId)) {
                nodeToMp.put(nodeId, nodeToMp.get(termId));
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public Lokasi getLokasi() {
    return lokasi;
}

######


public void setLokasi(Lokasi lokasi) {
    this.lokasi = lokasi;
}

######


public String getNamaDept() {
    return namaDept;
}

######


public void setNamaDept(String namaDept) {
    this.namaDept = namaDept;
}

######


public String getNamaUnit() {
    return namaUnit;
}

######


public void setNamaUnit(String namaUnit) {
    this.namaUnit = namaUnit;
}

######


public String getNamaSatker() {
    return namaSatker;
}

######


public void setNamaSatker(String namaSatker) {
    this.namaSatker = namaSatker;
}

######


public String getKodeDept() {
    return kodeDept;
}

######


public void setKodeDept(String kodeDept) {
    this.kodeDept = kodeDept;
}

######


public String getKodeSatker() {
    return kodeSatker;
}

######


public void setKodeSatker(String kodeSatker) {
    this.kodeSatker = kodeSatker;
}

######


public String getKodeUnit() {
    return kodeUnit;
}

######


public void setKodeUnit(String kodeUnit) {
    this.kodeUnit = kodeUnit;
}

######


public Long getId() {
    return id;
}

######


public void setId(Long id) {
    this.id = id;
}

######


@Override
public int hashCode() {
    int hash = 0;
    hash += (id != null ? id.hashCode() : 0);
    return hash;
}

######


@Override
public boolean equals(Object object) {
    if (!(object instanceof SatuanKerja)) {
        return false;
    }
    SatuanKerja other = (SatuanKerja) object;
    if ((this.id == null && other.id != null) || (this.id != null && !this.id.equals(other.id))) {
        return false;
    }
    return true;
}

######


@Override
public String toString() {
    return "apdol.entity.SatuanKerja[ id=" + id + " ]";
}

######


public boolean isKodeNoChange(String kode) {
    if (kode.equalsIgnoreCase(this.kodeSatker)) {
        return true;
    } else {
        return false;
    }
}

######


public boolean isNamaSatkerNoChange(String nama) {
    if (nama.equalsIgnoreCase(this.namaSatker)) {
        return true;
    } else {
        return false;
    }
}

######


public void init(ServletConfig config) throws ServletException {
}

######


protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    doPost(request, response);
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    HttpSession session = request.getSession(true);
    String user_number = (String) session.getAttribute("nowusername");
    String tabkeName = request.getParameter("tableName");
    String xmlTable = request.getParameter("xmlTable");
    String xmlNews = request.getParameter("xmlNews");
    String xmlRules = request.getParameter("xmlRules");
    String sql = "insert into manager_xmltable ( `user_number`, `table_name`, `tableXml`, `scorerule`, `newXml`, `usied`) " + "VALUES ('" + user_number + "', '" + tabkeName + "', '" + xmlTable + "', '" + xmlNews + "', '" + xmlRules + "', '1');";
    System.out.println(sql);
    Mysql_operation optr = new Mysql_operation();
    optr.sql_opWord(sql);
}

######


public void create(Connection connection) throws SQLException {
    try (Statement s = connection.createStatement()) {
        s.executeUpdate("CREATE TABLE " + tableName + " (id text PRIMARY KEY NOT NULL CHECK (id <> ''), installed timestamp DEFAULT now());");
    }
}

######


public void addApplied(Connection connection, String key) throws SQLException {
    try (PreparedStatement p = connection.prepareStatement("INSERT INTO " + tableName + " (id) VALUES (?);")) {
        p.setString(1, key);
        p.executeUpdate();
    }
}

######


public boolean isApplied(Connection connection, String key) throws SQLException {
    try (PreparedStatement p = connection.prepareStatement("SELECT count(id) FROM " + tableName + " WHERE id = ?;")) {
        p.setString(1, key);
        try (ResultSet r = p.executeQuery()) {
            r.next();
            return r.getInt(1) == 1;
        }
    }
}

######


public boolean exists(Connection connection) throws SQLException {
    try (PreparedStatement ps = connection.prepareStatement("select count(tablename) from pg_tables where schemaname='public' AND tablename=?;")) {
        ps.setString(1, tableName);
        try (ResultSet r = ps.executeQuery()) {
            r.next();
            return r.getInt(1) == 1;
        }
    }
}

######


@Test
@Ignore("This fails with HSQLDB 2.0 due to the create index statements in the schema script")
public void shouldRunScriptsBySendingFullScriptAtOnce() throws Exception {
    DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES);
    Connection conn = ds.getConnection();
    ScriptRunner runner = new ScriptRunner(conn);
    runner.setSendFullScript(true);
    runner.setAutoCommit(true);
    runner.setStopOnError(false);
    runner.setErrorLogWriter(null);
    runner.setLogWriter(null);
    conn.close();
    runJPetStoreScripts(runner);
    assertProductsTableExistsAndLoaded();
}

######


@Test
public void shouldRunScriptsUsingConnection() throws Exception {
    DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES);
    Connection conn = ds.getConnection();
    ScriptRunner runner = new ScriptRunner(conn);
    runner.setAutoCommit(true);
    runner.setStopOnError(false);
    runner.setErrorLogWriter(null);
    runner.setLogWriter(null);
    runJPetStoreScripts(runner);
    conn.close();
    assertProductsTableExistsAndLoaded();
}

######


@Test
public void shouldRunScriptsUsingProperties() throws Exception {
    Properties props = Resources.getResourceAsProperties(JPETSTORE_PROPERTIES);
    DataSource dataSource = new UnpooledDataSource(props.getProperty("driver"), props.getProperty("url"), props.getProperty("username"), props.getProperty("password"));
    ScriptRunner runner = new ScriptRunner(dataSource.getConnection());
    runner.setAutoCommit(true);
    runner.setStopOnError(false);
    runner.setErrorLogWriter(null);
    runner.setLogWriter(null);
    runJPetStoreScripts(runner);
    assertProductsTableExistsAndLoaded();
}

######


@Test
public void shouldReturnWarningIfEndOfLineTerminatorNotFound() throws Exception {
    DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES);
    Connection conn = ds.getConnection();
    ScriptRunner runner = new ScriptRunner(conn);
    runner.setAutoCommit(true);
    runner.setStopOnError(false);
    runner.setErrorLogWriter(null);
    runner.setLogWriter(null);
    String resource = "org/apache/ibatis/jdbc/ScriptMissingEOLTerminator.sql";
    Reader reader = Resources.getResourceAsReader(resource);
    try {
        runner.runScript(reader);
        fail("Expected script runner to fail due to missing end of line terminator.");
    } catch (Exception e) {
        assertTrue(e.getMessage().contains("end-of-line terminator"));
    }
    reader.close();
    conn.close();
}

######


@Test
public void commentAferStatementDelimiterShouldNotCauseRunnerFail() throws Exception {
    DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES);
    Connection conn = ds.getConnection();
    ScriptRunner runner = new ScriptRunner(conn);
    runner.setAutoCommit(true);
    runner.setStopOnError(true);
    runner.setErrorLogWriter(null);
    runner.setLogWriter(null);
    runJPetStoreScripts(runner);
    String resource = "org/apache/ibatis/jdbc/ScriptCommentAfterEOLTerminator.sql";
    Reader reader = Resources.getResourceAsReader(resource);
    try {
        runner.runScript(reader);
    } catch (Exception e) {
        fail(e.getMessage());
    }
    reader.close();
    conn.close();
}

######


@Test
public void shouldReturnWarningIfNotTheCurrentDelimiterUsed() throws Exception {
    DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES);
    Connection conn = ds.getConnection();
    ScriptRunner runner = new ScriptRunner(conn);
    runner.setAutoCommit(false);
    runner.setStopOnError(true);
    runner.setErrorLogWriter(null);
    runner.setLogWriter(null);
    String resource = "org/apache/ibatis/jdbc/ScriptChangingDelimiterMissingDelimiter.sql";
    Reader reader = Resources.getResourceAsReader(resource);
    try {
        runner.runScript(reader);
        fail("Expected script runner to fail due to the usage of invalid delimiter.");
    } catch (Exception e) {
        assertTrue(e.getMessage().contains("end-of-line terminator"));
    }
    reader.close();
    conn.close();
}

######


@Test
public void changingDelimiterShouldNotCauseRunnerFail() throws Exception {
    DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES);
    Connection conn = ds.getConnection();
    ScriptRunner runner = new ScriptRunner(conn);
    runner.setAutoCommit(false);
    runner.setStopOnError(true);
    runner.setErrorLogWriter(null);
    runner.setLogWriter(null);
    runJPetStoreScripts(runner);
    String resource = "org/apache/ibatis/jdbc/ScriptChangingDelimiter.sql";
    Reader reader = Resources.getResourceAsReader(resource);
    try {
        runner.runScript(reader);
    } catch (Exception e) {
        fail(e.getMessage());
    }
    reader.close();
    conn.close();
}

######


@Test
public void testLogging() throws Exception {
    DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES);
    Connection conn = ds.getConnection();
    ScriptRunner runner = new ScriptRunner(conn);
    runner.setAutoCommit(true);
    runner.setStopOnError(false);
    runner.setErrorLogWriter(null);
    runner.setSendFullScript(false);
    StringWriter sw = new StringWriter();
    PrintWriter logWriter = new PrintWriter(sw);
    runner.setLogWriter(logWriter);
    Reader reader = new StringReader("select userid from account where userid = 'j2ee';");
    runner.runScript(reader);
    conn.close();
    assertEquals("select userid from account where userid = 'j2ee'" + System.getProperty("line.separator") + System.getProperty("line.separator") + "USERID\t" + System.getProperty("line.separator") + "j2ee\t" + System.getProperty("line.separator"), sw.toString());
}

######


@Test
public void testLoggingFullScipt() throws Exception {
    DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES);
    Connection conn = ds.getConnection();
    ScriptRunner runner = new ScriptRunner(conn);
    runner.setAutoCommit(true);
    runner.setStopOnError(false);
    runner.setErrorLogWriter(null);
    runner.setSendFullScript(true);
    StringWriter sw = new StringWriter();
    PrintWriter logWriter = new PrintWriter(sw);
    runner.setLogWriter(logWriter);
    Reader reader = new StringReader("select userid from account where userid = 'j2ee';");
    runner.runScript(reader);
    conn.close();
    assertEquals("select userid from account where userid = 'j2ee';" + System.getProperty("line.separator") + System.getProperty("line.separator") + "USERID\t" + System.getProperty("line.separator") + "j2ee\t" + System.getProperty("line.separator"), sw.toString());
}

######


private void runJPetStoreScripts(ScriptRunner runner) throws IOException, SQLException {
    runScript(runner, JPETSTORE_DDL);
    runScript(runner, JPETSTORE_DATA);
}

######


private void assertProductsTableExistsAndLoaded() throws IOException, SQLException {
    PooledDataSource ds = createPooledDataSource(JPETSTORE_PROPERTIES);
    try {
        Connection conn = ds.getConnection();
        SqlRunner executor = new SqlRunner(conn);
        List<Map<String, Object>> products = executor.selectAll("SELECT * FROM PRODUCT");
        assertEquals(16, products.size());
        conn.close();
    } finally {
        ds.forceCloseAll();
    }
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("resultsSetReadingTest", "id int not null primary key auto_increment, test int");
    if (testSingleHost) {
        Statement st = sharedConnection.createStatement();
        st.execute("INSERT INTO resultsSetReadingTest (test) values (1), (2), (3)");
    }
}

######


@Test
public void scrollInsensitivePrepareStmt() throws SQLException {
    try (PreparedStatement stmt = sharedConnection.prepareStatement("SELECT * FROM resultsSetReadingTest", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {
        stmt.setFetchSize(2);
        try (ResultSet rs = stmt.executeQuery()) {
            rs.beforeFirst();
        } catch (SQLException sqle) {
            fail("beforeFirst() should work on a TYPE_SCROLL_INSENSITIVE result set");
        }
    }
}

######


@Test
public void scrollInsensitiveStmt() throws SQLException {
    try (Statement stmt = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {
        stmt.setFetchSize(2);
        try (ResultSet rs = stmt.executeQuery("SELECT * FROM resultsSetReadingTest")) {
            rs.beforeFirst();
        } catch (SQLException sqle) {
            fail("beforeFirst() should work on a TYPE_SCROLL_INSENSITIVE result set");
        }
    }
}

######


@Test(expected = SQLException.class)
public void scrollForwardOnlyPrepareStmt() throws SQLException {
    Assume.assumeFalse(sharedIsRewrite());
    try (PreparedStatement stmt = sharedConnection.prepareStatement("SELECT * FROM resultsSetReadingTest", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {
        stmt.setFetchSize(2);
        try (ResultSet rs = stmt.executeQuery()) {
            rs.beforeFirst();
            fail("beforeFirst() shouldn't work on a TYPE_FORWARD_ONLY result set");
        }
    }
}

######


@Test(expected = SQLException.class)
public void scrollForwardOnlyStmt() throws SQLException {
    try (Statement stmt = sharedConnection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {
        stmt.setFetchSize(2);
        try (ResultSet rs = stmt.executeQuery("SELECT * FROM resultsSetReadingTest")) {
            rs.beforeFirst();
            fail("beforeFirst() shouldn't work on a TYPE_FORWARD_ONLY result set");
        }
    }
}

######


@Test
public void scrollMultipleFetch() throws SQLException {
    createTable("scrollMultipleFetch", "intvalue int");
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("INSERT INTO scrollMultipleFetch values (1), (2), (3)");
    stmt.setFetchSize(1);
    ResultSet rs = stmt.executeQuery("Select * from scrollMultipleFetch");
    rs.next();
    assertEquals(1, rs.getFetchSize());
    ResultSet rs2 = stmt.executeQuery("Select * from scrollMultipleFetch");
    assertEquals(1, rs2.getFetchSize());
    assertEquals(1, rs.getFetchSize());
}

######


@Override
public void handle(ActionEvent event) {
    try {
        JavaFXApplication4 b = new JavaFXApplication4();
        b.start(primaryStage);
        primaryStage.show();
    } catch (Exception e) {
        System.out.println(e.toString());
    }
}

######


@Override
public void handle(ActionEvent event) {
    count1++;
    tablodoldur1();
}

######


@Override
public void start(final Stage primaryStage) throws Exception {
    primaryStage.setTitle("DataBase Project");
    GridPane grid = new GridPane();
    grid.setPadding(new Insets(10, 10, 10, 10));
    grid.setVgap(5);
    grid.setHgap(5);
    Image ımage1 = new Image("file:search.png");
    ImageView ıv1 = new ImageView();
    ıv1.setImage(ımage1);
    ıv1.setTranslateX(170);
    ıv1.setTranslateY(15);
    Font LabelFont = new Font(11);
    Font LabelFont1 = new Font(15);
    label1 = new Label("Select Area:");
    label1.setFont(LabelFont1);
    label1.setTranslateY(90);
    GridPane.setConstraints(label1, 0, 1);
    combo1 = new ComboBox();
    combo1.setMinSize(300, 20);
    combo1.setTranslateX(30);
    combo1.setTranslateY(90);
    combo1.setPromptText("select area...");
    combo1.setEditable(true);
    combo1.getItems().addAll("TC", "NAME", "SURNAME");
    GridPane.setConstraints(combo1, 1, 1);
    label2 = new Label("Keyword");
    label2.setFont(LabelFont1);
    label2.setTranslateY(95);
    GridPane.setConstraints(label2, 0, 2);
    text2 = new TextField();
    text2.setMinSize(300, 20);
    text2.setTranslateX(30);
    text2.setTranslateY(95);
    GridPane.setConstraints(text2, 1, 2);
    btn5 = new Button("Back");
    btn5.setFont(LabelFont);
    btn5.setMinSize(30, 30);
    btn5.setTranslateX(10);
    btn5.setTranslateY(20);
    btn5.setOnAction(new EventHandler<ActionEvent>() {

        @Override
        public void handle(ActionEvent event) {
            try {
                JavaFXApplication4 b = new JavaFXApplication4();
                b.start(primaryStage);
                primaryStage.show();
            } catch (Exception e) {
                System.out.println(e.toString());
            }
        }
    });
    btn4 = new Button("Search");
    btn4.getStyleClass().add("button1-blue");
    btn4.setMinSize(100, 50);
    btn4.setTranslateX(50);
    btn4.setTranslateY(110);
    GridPane.setConstraints(btn4, 3, 1);
    btn4.setOnAction(new EventHandler<ActionEvent>() {

        @Override
        public void handle(ActionEvent event) {
            count1++;
            tablodoldur1();
        }
    });
    grid.getChildren().addAll(label1, label2, text2, btn4, combo1);
    tableview1 = new TableView();
    tableview1.setMinSize(500, 200);
    tableview1.setMaxSize(550, 150);
    tableview1.setTranslateX(15);
    tableview1.setTranslateY(220);
    Group root = new Group();
    root.getChildren().addAll(grid, tableview1, btn5, ıv1);
    Scene scene2 = new Scene(root, 590, 470);
    scene2.getStylesheets().add(getClass().getResource("Viper2.css").toExternalForm());
    primaryStage.setScene(scene2);
    primaryStage.setResizable(false);
    primaryStage.show();
}

######


public ObservableValue<String> call(TableColumn.CellDataFeatures<ObservableList, String> param) {
    return new SimpleStringProperty(param.getValue().get(j).toString());
}

######


@Override
public void handle(ActionEvent event) {
    try {
        JavaFXApplication4 b = new JavaFXApplication4();
        b.start(primaryStage);
        primaryStage.show();
    } catch (Exception e) {
        System.out.println(e.toString());
    }
}

######


@Override
public void handle(ActionEvent event) {
    count1++;
    tablodoldur1();
}

######


@Override
public void start(final Stage primaryStage) throws Exception {
    primaryStage.setTitle("DataBase Project");
    GridPane grid = new GridPane();
    grid.setPadding(new Insets(10, 10, 10, 10));
    grid.setVgap(5);
    grid.setHgap(5);
    Image ımage1 = new Image("file:search.png");
    ImageView ıv1 = new ImageView();
    ıv1.setImage(ımage1);
    ıv1.setTranslateX(170);
    ıv1.setTranslateY(15);
    Font LabelFont = new Font(11);
    Font LabelFont1 = new Font(15);
    label1 = new Label("Select Area:");
    label1.setFont(LabelFont1);
    label1.setTranslateY(90);
    GridPane.setConstraints(label1, 0, 1);
    combo1 = new ComboBox();
    combo1.setMinSize(300, 20);
    combo1.setTranslateX(30);
    combo1.setTranslateY(90);
    combo1.setPromptText("select area...");
    combo1.setEditable(true);
    combo1.getItems().addAll("TC", "NAME", "SURNAME");
    GridPane.setConstraints(combo1, 1, 1);
    label2 = new Label("Keyword");
    label2.setFont(LabelFont1);
    label2.setTranslateY(95);
    GridPane.setConstraints(label2, 0, 2);
    text2 = new TextField();
    text2.setMinSize(300, 20);
    text2.setTranslateX(30);
    text2.setTranslateY(95);
    GridPane.setConstraints(text2, 1, 2);
    btn5 = new Button("Back");
    btn5.setFont(LabelFont);
    btn5.setMinSize(30, 30);
    btn5.setTranslateX(10);
    btn5.setTranslateY(20);
    btn5.setOnAction(new EventHandler<ActionEvent>() {

        @Override
        public void handle(ActionEvent event) {
            try {
                JavaFXApplication4 b = new JavaFXApplication4();
                b.start(primaryStage);
                primaryStage.show();
            } catch (Exception e) {
                System.out.println(e.toString());
            }
        }
    });
    btn4 = new Button("Search");
    btn4.getStyleClass().add("button1-blue");
    btn4.setMinSize(100, 50);
    btn4.setTranslateX(50);
    btn4.setTranslateY(110);
    GridPane.setConstraints(btn4, 3, 1);
    btn4.setOnAction(new EventHandler<ActionEvent>() {

        @Override
        public void handle(ActionEvent event) {
            count1++;
            tablodoldur1();
        }
    });
    grid.getChildren().addAll(label1, label2, text2, btn4, combo1);
    tableview1 = new TableView();
    tableview1.setMinSize(500, 200);
    tableview1.setMaxSize(550, 150);
    tableview1.setTranslateX(15);
    tableview1.setTranslateY(220);
    Group root = new Group();
    root.getChildren().addAll(grid, tableview1, btn5, ıv1);
    Scene scene2 = new Scene(root, 590, 470);
    scene2.getStylesheets().add(getClass().getResource("Viper2.css").toExternalForm());
    primaryStage.setScene(scene2);
    primaryStage.setResizable(false);
    primaryStage.show();
}

######


public ObservableValue<String> call(TableColumn.CellDataFeatures<ObservableList, String> param) {
    return new SimpleStringProperty(param.getValue().get(j).toString());
}

######


@Override
public Set<String> getAccessionsBySecondaryProjectId(String projectId) throws SQLException {
    Set<String> accessions = new TreeSet<>();
    String query = "select * from genes_secondary_project where secondary_project_id=" + "\"" + projectId + "\"";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            String result = resultSet.getString(1);
            System.out.println("result +++ " + result);
            accessions.add(result);
        }
    }
    return accessions;
}

######


@Override
public List<GeneRowForHeatMap> getGeneRowsForHeatMap(HttpServletRequest request) throws SolrServerException {
    List<GeneRowForHeatMap> geneRows = new ArrayList<>();
    List<BasicBean> parameters = this.getXAxisForHeatMap();
    try {
        System.out.println("getGeneHeatMap called");
        Set<String> accessions = this.getAccessionsBySecondaryProjectId("idg");
        Map<String, String> geneToMouseStatusMap = geneService.getProductionStatusForGeneSet(accessions, request);
        Map<String, List<String>> geneToTopLevelMpMap = geneService.getTopLevelMpForGeneSet(accessions);
        for (String accession : accessions) {
            GenomicFeature gene = genesDao.getGenomicFeatureByAccession(accession);
            GeneRowForHeatMap row = genotypePhenotypeService.getResultsForGeneHeatMap(accession, gene, parameters, geneToTopLevelMpMap);
            if (geneToMouseStatusMap.containsKey(accession)) {
                row.setMiceProduced(geneToMouseStatusMap.get(accession));
                if (row.getMiceProduced().equals("Neither production nor phenotyping status available ")) {
                    for (HeatMapCell cell : row.getXAxisToCellMap().values()) {
                        cell.setStatus("No Data Available");
                    }
                }
            } else {
                row.setMiceProduced("No");
            }
            geneRows.add(row);
        }
    } catch (SQLException ex) {
        Logger.getLogger(GeneHeatmapController.class.getName()).log(Level.SEVERE, null, ex);
    }
    Collections.sort(geneRows);
    return geneRows;
}

######


@Override
public List<BasicBean> getXAxisForHeatMap() {
    List<BasicBean> mp = new ArrayList<>();
    try {
        Set<BasicBean> topLevelPhenotypes = mpService.getAllTopLevelPhenotypesAsBasicBeans();
        mp.addAll(topLevelPhenotypes);
    } catch (SolrServerException e) {
        e.printStackTrace();
    }
    return mp;
}

######


@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.jdbcAuthentication().dataSource(dataSource).usersByUsernameQuery("select username, password from sys_user where username = ?").authoritiesByUsernameQuery("select username from sys_role where username=?0");
    auth.userDetailsService(userService);
}

######


@Override
public void configure(WebSecurity web) throws Exception {
    super.configure(web);
}

######


@Override
protected void configure(HttpSecurity http) throws Exception {
    http.formLogin().loginPage("/login").and().httpBasic().realmName("aaa").and().logout().logoutSuccessUrl("/").logoutUrl("/signout").and().rememberMe().tokenValiditySeconds(100000).key("userKey").and().authorizeRequests().antMatchers("/auth/me").authenticated().antMatchers(HttpMethod.POST, "/auth").authenticated().antMatchers(HttpMethod.POST, "/auth").hasRole("role").anyRequest().permitAll().and().requiresChannel().antMatchers("/aaa").requiresSecure().antMatchers("/").requiresSecure().and().csrf().disable();
}

######


protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
}

######


protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setContentType("text/html;charset=utf-8");
    DBConnect dbConnect = new DBConnect();
    String URI = request.getRequestURI();
    int index = URI.lastIndexOf('/');
    String courseIDStr = URI.substring(index + 1);
    courseIDStr = URLDecoder.decode(courseIDStr, "utf-8");
    String userToken = (request.getParameter("userToken") == null) ? "" : request.getParameter("userToken");
    String account = (request.getParameter("account") == null) ? "" : request.getParameter("account");
    Status status = new Status();
    if (!Widgets.isInteger(courseIDStr) || courseIDStr.equals("") || userToken.equals("") || account.equals("")) {
        status.setStatus(false);
        status.setInfo("选课参数出问题");
    } else {
        try {
            String sql = "INSERT INTO selection (courseid, studentid,score) VALUES (?, ?, '0');";
            PreparedStatement pstm = dbConnect.prepareStatement(sql);
            pstm.setInt(1, Integer.parseInt(courseIDStr));
            pstm.setString(2, account);
            pstm.executeUpdate();
            status.setStatus(true);
            status.setInfo("选课成功");
        } catch (SQLException e) {
            e.printStackTrace();
            status.setStatus(false);
            status.setInfo("选课失败");
        }
    }
    JSONObject jsonRet = JSONObject.fromObject(status);
    PrintWriter out = response.getWriter();
    out.print(jsonRet.toString());
    dbConnect.close();
}

######


@Override
public int findColumn(String name) {
    return 1;
}

######


public static ResultSet createGeneratedData(long[] data, Protocol protocol, boolean findColumnReturnsOne) {
    ColumnInformation[] columns = new ColumnInformation[1];
    columns[0] = ColumnInformation.create("insert_id", ColumnType.BIGINT);
    List<byte[]> rows = new ArrayList<>();
    for (long rowData : data) {
        if (rowData != 0) {
            rows.add(StandardPacketInputStream.create(String.valueOf(rowData).getBytes()));
        }
    }
    if (findColumnReturnsOne) {
        return new SelectResultSet(columns, rows, protocol, TYPE_SCROLL_SENSITIVE) {

            @Override
            public int findColumn(String name) {
                return 1;
            }
        };
    }
    return new SelectResultSet(columns, rows, protocol, TYPE_SCROLL_SENSITIVE);
}

######


public static ResultSet createResultSet(String[] columnNames, ColumnType[] columnTypes, String[][] data, Protocol protocol) {
    int columnNameLength = columnNames.length;
    ColumnInformation[] columns = new ColumnInformation[columnNameLength];
    for (int i = 0; i < columnNameLength; i++) {
        columns[i] = ColumnInformation.create(columnNames[i], columnTypes[i]);
    }
    List<byte[]> rows = new ArrayList<>();
    for (String[] rowData : data) {
        assert rowData.length == columnNameLength;
        byte[][] rowBytes = new byte[rowData.length][];
        for (int i = 0; i < rowData.length; i++) {
            if (rowData[i] != null) {
                rowBytes[i] = rowData[i].getBytes();
            }
        }
        rows.add(StandardPacketInputStream.create(rowBytes, columnTypes));
    }
    return new SelectResultSet(columns, rows, protocol, TYPE_SCROLL_SENSITIVE);
}

######


public static SelectResultSet createEmptyResultSet() {
    return new SelectResultSet(INSERT_ID_COLUMNS, new ArrayList<>(), null, TYPE_SCROLL_SENSITIVE);
}

######


public boolean isFullyLoaded() {
    return isEof;
}

######


private void fetchAllResults() throws IOException, SQLException {
    dataSize = 0;
    while (readNextValue()) {
    }
    dataFetchTime++;
}

######


public void fetchRemaining() throws SQLException {
    if (!isEof) {
        lock.lock();
        try {
            lastRowPointer = -1;
            while (!isEof) {
                addStreamingValue();
            }
        } catch (SQLException queryException) {
            throw ExceptionMapper.getException(queryException, null, statement, false);
        } catch (IOException ioe) {
            throw handleIoException(ioe);
        } finally {
            lock.unlock();
        }
        dataFetchTime++;
    }
}

######


private SQLException handleIoException(IOException ioe) {
    return ExceptionMapper.getException(new SQLException("Server has closed the connection. " + "If result set contain huge amount of data, Server expects client to" + " read off the result set relatively fast. " + "In this case, please consider increasing net_wait_timeout session variable" + " / processing your result set faster (check Streaming result sets documentation for more information)", CONNECTION_EXCEPTION.getSqlState(), ioe), null, statement, false);
}

######


private void nextStreamingValue() throws IOException, SQLException {
    lastRowPointer = -1;
    if (resultSetScrollType == TYPE_FORWARD_ONLY) {
        dataSize = 0;
    }
    addStreamingValue();
}

######


private void addStreamingValue() throws IOException, SQLException {
    int fetchSizeTmp = fetchSize;
    while (fetchSizeTmp > 0 && readNextValue()) {
        fetchSizeTmp--;
    }
    dataFetchTime++;
}

######


private boolean readNextValue() throws IOException, SQLException {
    byte[] buf = reader.getPacketArray(false);
    if (buf[0] == ERROR) {
        protocol.removeActiveStreamingResult();
        protocol.removeHasMoreResults();
        protocol.setHasWarnings(false);
        ErrorPacket errorPacket = new ErrorPacket(new Buffer(buf));
        resetVariables();
        throw ExceptionMapper.get(errorPacket.getMessage(), errorPacket.getSqlState(), errorPacket.getErrorNumber(), null, false);
    }
    if (buf[0] == EOF && ((eofDeprecated && buf.length < 0xffffff) || (!eofDeprecated && buf.length < 8))) {
        int serverStatus;
        int warnings;
        if (!eofDeprecated) {
            warnings = (buf[1] & 0xff) + ((buf[2] & 0xff) << 8);
            serverStatus = ((buf[3] & 0xff) + ((buf[4] & 0xff) << 8));
            if (callableResult) {
                serverStatus |= MORE_RESULTS_EXISTS;
            }
        } else {
            int pos = skipLengthEncodedValue(buf, 1);
            pos = skipLengthEncodedValue(buf, pos);
            serverStatus = ((buf[pos++] & 0xff) + ((buf[pos++] & 0xff) << 8));
            warnings = (buf[pos++] & 0xff) + ((buf[pos] & 0xff) << 8);
            callableResult = (serverStatus & PS_OUT_PARAMETERS) != 0;
        }
        protocol.setServerStatus((short) serverStatus);
        protocol.setHasWarnings(warnings > 0);
        if ((serverStatus & MORE_RESULTS_EXISTS) == 0) {
            protocol.removeActiveStreamingResult();
        }
        resetVariables();
        return false;
    }
    if (dataSize + 1 >= data.length) {
        growDataArray();
    }
    data[dataSize++] = buf;
    return true;
}

######


protected byte[] getCurrentRowData() {
    return data[rowPointer];
}

######


protected void updateRowData(byte[] rawData) {
    data[rowPointer] = rawData;
    row.resetRow(data[rowPointer]);
}

######


protected void deleteCurrentRowData() throws SQLException {
    System.arraycopy(data, rowPointer + 1, data, rowPointer, dataSize - 1 - rowPointer);
    data[dataSize - 1] = null;
    dataSize--;
    lastRowPointer = -1;
    previous();
}

######


protected void addRowData(byte[] rawData) {
    if (dataSize + 1 >= data.length) {
        growDataArray();
    }
    data[dataSize] = rawData;
    rowPointer = dataSize;
    dataSize++;
}

######


private int skipLengthEncodedValue(byte[] buf, int pos) {
    int type = buf[pos++] & 0xff;
    switch(type) {
        case 251:
            return pos;
        case 252:
            return pos + 2 + (0xffff & (((buf[pos] & 0xff) + ((buf[pos + 1] & 0xff) << 8))));
        case 253:
            return pos + 3 + (0xffffff & ((buf[pos] & 0xff) + ((buf[pos + 1] & 0xff) << 8) + ((buf[pos + 2] & 0xff) << 16)));
        case 254:
            return (int) (pos + 8 + ((buf[pos] & 0xff) + ((long) (buf[pos + 1] & 0xff) << 8) + ((long) (buf[pos + 2] & 0xff) << 16) + ((long) (buf[pos + 3] & 0xff) << 24) + ((long) (buf[pos + 4] & 0xff) << 32) + ((long) (buf[pos + 5] & 0xff) << 40) + ((long) (buf[pos + 6] & 0xff) << 48) + ((long) (buf[pos + 7] & 0xff) << 56)));
        default:
            return pos + type;
    }
}

######


private void growDataArray() {
    int newCapacity = data.length + (data.length >> 1);
    if (newCapacity - MAX_ARRAY_SIZE > 0) {
        newCapacity = MAX_ARRAY_SIZE;
    }
    data = Arrays.copyOf(data, newCapacity);
}

######


public void abort() throws SQLException {
    isClosed = true;
    resetVariables();
    for (int i = 0; i < data.length; i++) {
        data[i] = null;
    }
    if (statement != null) {
        statement.checkCloseOnCompletion(this);
        statement = null;
    }
}

######


public void close() throws SQLException {
    isClosed = true;
    if (!isEof) {
        lock.lock();
        try {
            while (!isEof) {
                dataSize = 0;
                readNextValue();
            }
        } catch (SQLException queryException) {
            throw ExceptionMapper.getException(queryException, null, this.statement, false);
        } catch (IOException ioe) {
            throw handleIoException(ioe);
        } finally {
            resetVariables();
            lock.unlock();
        }
    }
    resetVariables();
    for (int i = 0; i < data.length; i++) {
        data[i] = null;
    }
    if (statement != null) {
        statement.checkCloseOnCompletion(this);
        statement = null;
    }
}

######


private void resetVariables() {
    protocol = null;
    reader = null;
    isEof = true;
}

######


@Override
public boolean next() throws SQLException {
    if (isClosed) {
        throw new SQLException("Operation not permit on a closed resultSet", "HY000");
    }
    if (rowPointer < dataSize - 1) {
        rowPointer++;
        return true;
    } else {
        if (streaming && !isEof) {
            lock.lock();
            try {
                if (!isEof) {
                    nextStreamingValue();
                }
            } catch (IOException ioe) {
                throw handleIoException(ioe);
            } finally {
                lock.unlock();
            }
            if (resultSetScrollType == TYPE_FORWARD_ONLY) {
                rowPointer = 0;
                return dataSize > 0;
            } else {
                rowPointer++;
                return dataSize > rowPointer;
            }
        }
        rowPointer = dataSize;
        return false;
    }
}

######


private void checkObjectRange(int position) throws SQLException {
    if (rowPointer < 0) {
        throw new SQLDataException("Current position is before the first row", "22023");
    }
    if (rowPointer >= dataSize) {
        throw new SQLDataException("Current position is after the last row", "22023");
    }
    if (position <= 0 || position > columnInformationLength) {
        throw new SQLDataException("No such column: " + position, "22023");
    }
    if (lastRowPointer != rowPointer) {
        row.resetRow(data[rowPointer]);
        lastRowPointer = rowPointer;
    }
    row.setPosition(position - 1);
}

######


@Override
public SQLWarning getWarnings() throws SQLException {
    if (this.statement == null) {
        return null;
    }
    return this.statement.getWarnings();
}

######


@Override
public void clearWarnings() {
    if (this.statement != null) {
        this.statement.clearWarnings();
    }
}

######


@Override
public boolean isBeforeFirst() throws SQLException {
    checkClose();
    return (dataFetchTime > 0) ? rowPointer == -1 && dataSize > 0 : rowPointer == -1;
}

######


@Override
public boolean isAfterLast() throws SQLException {
    checkClose();
    if (rowPointer < dataSize) {
        return false;
    } else {
        if (streaming && !isEof) {
            lock.lock();
            try {
                if (!isEof) {
                    addStreamingValue();
                }
            } catch (IOException ioe) {
                throw handleIoException(ioe);
            } finally {
                lock.unlock();
            }
            return dataSize == rowPointer;
        }
        return dataSize > 0 || dataFetchTime > 1;
    }
}

######


@Override
public boolean isFirst() throws SQLException {
    checkClose();
    return dataFetchTime == 1 && rowPointer == 0 && dataSize > 0;
}

######


@Override
public boolean isLast() throws SQLException {
    checkClose();
    if (rowPointer < dataSize - 1) {
        return false;
    } else if (isEof) {
        return rowPointer == dataSize - 1 && dataSize > 0;
    } else {
        lock.lock();
        try {
            if (!isEof) {
                addStreamingValue();
            }
        } catch (IOException ioe) {
            throw handleIoException(ioe);
        } finally {
            lock.unlock();
        }
        if (isEof) {
            return rowPointer == dataSize - 1 && dataSize > 0;
        }
        return false;
    }
}

######


@Override
public void beforeFirst() throws SQLException {
    checkClose();
    if (streaming && resultSetScrollType == TYPE_FORWARD_ONLY) {
        throw new SQLException("Invalid operation for result set type TYPE_FORWARD_ONLY");
    }
    rowPointer = -1;
}

######


@Override
public void afterLast() throws SQLException {
    checkClose();
    fetchRemaining();
    rowPointer = dataSize;
}

######


@Override
public boolean first() throws SQLException {
    checkClose();
    if (streaming && resultSetScrollType == TYPE_FORWARD_ONLY) {
        throw new SQLException("Invalid operation for result set type TYPE_FORWARD_ONLY");
    }
    rowPointer = 0;
    return dataSize > 0;
}

######


@Override
public boolean last() throws SQLException {
    checkClose();
    fetchRemaining();
    rowPointer = dataSize - 1;
    return dataSize > 0;
}

######


@Override
public int getRow() throws SQLException {
    checkClose();
    if (streaming && resultSetScrollType == TYPE_FORWARD_ONLY) {
        return 0;
    }
    return rowPointer + 1;
}

######


@Override
public boolean absolute(int row) throws SQLException {
    checkClose();
    if (streaming && resultSetScrollType == TYPE_FORWARD_ONLY) {
        throw new SQLException("Invalid operation for result set type TYPE_FORWARD_ONLY");
    }
    if (row >= 0 && row <= dataSize) {
        rowPointer = row - 1;
        return true;
    }
    fetchRemaining();
    if (row >= 0) {
        if (row <= dataSize) {
            rowPointer = row - 1;
            return true;
        }
        rowPointer = dataSize;
        return false;
    } else {
        if (dataSize + row >= 0) {
            rowPointer = dataSize + row;
            return true;
        }
        rowPointer = -1;
        return false;
    }
}

######


@Override
public boolean relative(int rows) throws SQLException {
    checkClose();
    if (streaming && resultSetScrollType == TYPE_FORWARD_ONLY) {
        throw new SQLException("Invalid operation for result set type TYPE_FORWARD_ONLY");
    }
    int newPos = rowPointer + rows;
    if (newPos <= -1) {
        rowPointer = -1;
        return false;
    } else if (newPos >= dataSize) {
        rowPointer = dataSize;
        return false;
    } else {
        rowPointer = newPos;
        return true;
    }
}

######


@Override
public boolean previous() throws SQLException {
    checkClose();
    if (streaming && resultSetScrollType == TYPE_FORWARD_ONLY) {
        throw new SQLException("Invalid operation for result set type TYPE_FORWARD_ONLY");
    }
    if (rowPointer > -1) {
        rowPointer--;
        return rowPointer != -1;
    }
    return false;
}

######


@Override
public int getFetchDirection() {
    return FETCH_UNKNOWN;
}

######


@Override
public void setFetchDirection(int direction) throws SQLException {
    if (direction == FETCH_REVERSE) {
        throw new SQLException("Invalid operation. Allowed direction are ResultSet.FETCH_FORWARD and ResultSet.FETCH_UNKNOWN");
    }
}

######


@Override
public int getFetchSize() {
    return this.fetchSize;
}

######


@Override
public void setFetchSize(int fetchSize) throws SQLException {
    if (streaming && fetchSize == 0) {
        lock.lock();
        try {
            while (!isEof) {
                addStreamingValue();
            }
        } catch (IOException ioe) {
            throw handleIoException(ioe);
        } finally {
            lock.unlock();
        }
        streaming = dataFetchTime == 1;
    }
    this.fetchSize = fetchSize;
}

######


@Override
public int getType() {
    return resultSetScrollType;
}

######


@Override
public int getConcurrency() {
    return CONCUR_READ_ONLY;
}

######


private void checkClose() throws SQLException {
    if (isClosed) {
        throw new SQLException("Operation not permit on a closed resultSet", "HY000");
    }
}

######


public boolean isCallableResult() {
    return callableResult;
}

######


public boolean isClosed() {
    return isClosed;
}

######


public MariaDbStatement getStatement() {
    return statement;
}

######


public void setStatement(MariaDbStatement statement) {
    this.statement = statement;
}

######


public boolean wasNull() {
    return row.wasNull();
}

######


public InputStream getAsciiStream(String columnLabel) throws SQLException {
    return getAsciiStream(findColumn(columnLabel));
}

######


public InputStream getAsciiStream(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    if (row.lastValueWasNull()) {
        return null;
    }
    return new ByteArrayInputStream(new String(row.buf, row.pos, row.getLengthMaxFieldSize(), StandardCharsets.UTF_8).getBytes());
}

######


public String getString(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalString(columnsInformation[columnIndex - 1], null, timeZone);
}

######


public String getString(String columnLabel) throws SQLException {
    return getString(findColumn(columnLabel));
}

######


private String zeroFillingIfNeeded(String value, ColumnInformation columnInformation) {
    if (columnInformation.isZeroFill()) {
        StringBuilder zeroAppendStr = new StringBuilder();
        long zeroToAdd = columnInformation.getDisplaySize() - value.length();
        while (zeroToAdd-- > 0) {
            zeroAppendStr.append("0");
        }
        return zeroAppendStr.append(value).toString();
    }
    return value;
}

######


public InputStream getBinaryStream(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    if (row.lastValueWasNull()) {
        return null;
    }
    return new ByteArrayInputStream(row.buf, row.pos, row.getLengthMaxFieldSize());
}

######


public InputStream getBinaryStream(String columnLabel) throws SQLException {
    return getBinaryStream(findColumn(columnLabel));
}

######


public int getInt(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalInt(columnsInformation[columnIndex - 1]);
}

######


public int getInt(String columnLabel) throws SQLException {
    return getInt(findColumn(columnLabel));
}

######


public long getLong(String columnLabel) throws SQLException {
    return getLong(findColumn(columnLabel));
}

######


public long getLong(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalLong(columnsInformation[columnIndex - 1]);
}

######


public float getFloat(String columnLabel) throws SQLException {
    return getFloat(findColumn(columnLabel));
}

######


public float getFloat(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalFloat(columnsInformation[columnIndex - 1]);
}

######


public double getDouble(String columnLabel) throws SQLException {
    return getDouble(findColumn(columnLabel));
}

######


public double getDouble(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalDouble(columnsInformation[columnIndex - 1]);
}

######


public BigDecimal getBigDecimal(String columnLabel, int scale) throws SQLException {
    return getBigDecimal(findColumn(columnLabel), scale);
}

######


public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalBigDecimal(columnsInformation[columnIndex - 1]);
}

######


public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalBigDecimal(columnsInformation[columnIndex - 1]);
}

######


public BigDecimal getBigDecimal(String columnLabel) throws SQLException {
    return getBigDecimal(findColumn(columnLabel));
}

######


public byte[] getBytes(String columnLabel) throws SQLException {
    return getBytes(findColumn(columnLabel));
}

######


public byte[] getBytes(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    if (row.lastValueWasNull()) {
        return null;
    }
    byte[] data = new byte[row.getLengthMaxFieldSize()];
    System.arraycopy(row.buf, row.pos, data, 0, row.getLengthMaxFieldSize());
    return data;
}

######


public Date getDate(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalDate(columnsInformation[columnIndex - 1], null, timeZone);
}

######


public Date getDate(String columnLabel) throws SQLException {
    return getDate(findColumn(columnLabel));
}

######


public Date getDate(int columnIndex, Calendar cal) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalDate(columnsInformation[columnIndex - 1], cal, timeZone);
}

######


public Date getDate(String columnLabel, Calendar cal) throws SQLException {
    return getDate(findColumn(columnLabel), cal);
}

######


public Time getTime(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalTime(columnsInformation[columnIndex - 1], null, timeZone);
}

######


public Time getTime(String columnLabel) throws SQLException {
    return getTime(findColumn(columnLabel));
}

######


public Time getTime(int columnIndex, Calendar cal) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalTime(columnsInformation[columnIndex - 1], cal, timeZone);
}

######


public Time getTime(String columnLabel, Calendar cal) throws SQLException {
    return getTime(findColumn(columnLabel), cal);
}

######


public Timestamp getTimestamp(String columnLabel) throws SQLException {
    return getTimestamp(findColumn(columnLabel));
}

######


public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalTimestamp(columnsInformation[columnIndex - 1], cal, timeZone);
}

######


public Timestamp getTimestamp(String columnLabel, Calendar cal) throws SQLException {
    return getTimestamp(findColumn(columnLabel), cal);
}

######


public Timestamp getTimestamp(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalTimestamp(columnsInformation[columnIndex - 1], null, timeZone);
}

######


public InputStream getUnicodeStream(String columnLabel) throws SQLException {
    return getUnicodeStream(findColumn(columnLabel));
}

######


public InputStream getUnicodeStream(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    if (row.lastValueWasNull()) {
        return null;
    }
    return new ByteArrayInputStream(new String(row.buf, row.pos, row.getLengthMaxFieldSize(), StandardCharsets.UTF_8).getBytes());
}

######


public String getCursorName() throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("Cursors not supported");
}

######


public ResultSetMetaData getMetaData() {
    return new MariaDbResultSetMetaData(columnsInformation, options, returnTableAlias);
}

######


public Object getObject(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    return row.getInternalObject(columnsInformation[columnIndex - 1], timeZone);
}

######


public Object getObject(String columnLabel) throws SQLException {
    return getObject(findColumn(columnLabel));
}

######


public Object getObject(int columnIndex, Map<String, Class<?>> map) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("Method ResultSet.getObject(int columnIndex, Map<String, Class<?>> map) not supported");
}

######


public Object getObject(String columnLabel, Map<String, Class<?>> map) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("Method ResultSet.getObject(String columnLabel, Map<String, Class<?>> map) not supported");
}

######


@SuppressWarnings("unchecked")
public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
    if (type == null) {
        throw new SQLException("Class type cannot be null");
    }
    checkObjectRange(columnIndex);
    if (row.lastValueWasNull()) {
        return null;
    }
    ColumnInformation col = columnsInformation[columnIndex - 1];
    if (type.equals(String.class)) {
        return (T) row.getInternalString(col, null, timeZone);
    } else if (type.equals(Integer.class)) {
        return (T) (Integer) row.getInternalInt(col);
    } else if (type.equals(Long.class)) {
        return (T) (Long) row.getInternalLong(col);
    } else if (type.equals(Short.class)) {
        return (T) (Short) row.getInternalShort(col);
    } else if (type.equals(Double.class)) {
        return (T) (Double) row.getInternalDouble(col);
    } else if (type.equals(Float.class)) {
        return (T) (Float) row.getInternalFloat(col);
    } else if (type.equals(Byte.class)) {
        return (T) (Byte) row.getInternalByte(col);
    } else if (type.equals(byte[].class)) {
        byte[] data = new byte[row.getLengthMaxFieldSize()];
        System.arraycopy(row.buf, row.pos, data, 0, row.getLengthMaxFieldSize());
        return (T) data;
    } else if (type.equals(Date.class)) {
        return (T) row.getInternalDate(col, null, timeZone);
    } else if (type.equals(Time.class)) {
        return (T) row.getInternalTime(col, null, timeZone);
    } else if (type.equals(Timestamp.class) || type.equals(java.util.Date.class)) {
        return (T) row.getInternalTimestamp(col, null, timeZone);
    } else if (type.equals(Boolean.class)) {
        return (T) (Boolean) row.getInternalBoolean(col);
    } else if (type.equals(Calendar.class)) {
        Calendar calendar = Calendar.getInstance(timeZone);
        Timestamp timestamp = row.getInternalTimestamp(col, null, timeZone);
        if (timestamp == null) {
            return null;
        }
        calendar.setTimeInMillis(timestamp.getTime());
        return type.cast(calendar);
    } else if (type.equals(Clob.class) || type.equals(NClob.class)) {
        return (T) new MariaDbClob(row.buf, row.pos, row.getLengthMaxFieldSize());
    } else if (type.equals(InputStream.class)) {
        return (T) new ByteArrayInputStream(row.buf, row.pos, row.getLengthMaxFieldSize());
    } else if (type.equals(Reader.class)) {
        String value = row.getInternalString(col, null, timeZone);
        if (value == null) {
            return null;
        }
        return (T) new StringReader(value);
    } else if (type.equals(BigDecimal.class)) {
        return (T) row.getInternalBigDecimal(col);
    } else if (type.equals(BigInteger.class)) {
        return (T) row.getInternalBigInteger(col);
    } else if (type.equals(BigDecimal.class)) {
        return (T) row.getInternalBigDecimal(col);
    } else if (type.equals(LocalDateTime.class)) {
        ZonedDateTime zonedDateTime = row.getInternalZonedDateTime(col, LocalDateTime.class, timeZone);
        return zonedDateTime == null ? null : type.cast(zonedDateTime.withZoneSameInstant(ZoneId.systemDefault()).toLocalDateTime());
    } else if (type.equals(ZonedDateTime.class)) {
        ZonedDateTime zonedDateTime = row.getInternalZonedDateTime(col, ZonedDateTime.class, timeZone);
        if (zonedDateTime == null) {
            return null;
        }
        return type.cast(row.getInternalZonedDateTime(col, ZonedDateTime.class, timeZone));
    } else if (type.equals(OffsetDateTime.class)) {
        ZonedDateTime tmpZonedDateTime = row.getInternalZonedDateTime(col, OffsetDateTime.class, timeZone);
        return tmpZonedDateTime == null ? null : type.cast(tmpZonedDateTime.toOffsetDateTime());
    } else if (type.equals(OffsetDateTime.class)) {
        LocalDate localDate = row.getInternalLocalDate(col, timeZone);
        if (localDate == null) {
            return null;
        }
        return type.cast(localDate);
    } else if (type.equals(LocalDate.class)) {
        LocalDate localDate = row.getInternalLocalDate(col, timeZone);
        if (localDate == null) {
            return null;
        }
        return type.cast(localDate);
    } else if (type.equals(LocalTime.class)) {
        LocalTime localTime = row.getInternalLocalTime(col, timeZone);
        if (localTime == null) {
            return null;
        }
        return type.cast(localTime);
    } else if (type.equals(OffsetTime.class)) {
        OffsetTime offsetTime = row.getInternalOffsetTime(col, timeZone);
        if (offsetTime == null) {
            return null;
        }
        return type.cast(offsetTime);
    }
    throw ExceptionMapper.getFeatureNotSupportedException("Type class '" + type.getName() + "' is not supported");
}

######


@SuppressWarnings("unchecked")
public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {
    return type.cast(getObject(findColumn(columnLabel), type));
}

######


public int findColumn(String columnLabel) throws SQLException {
    return columnNameMap.getIndex(columnLabel) + 1;
}

######


public Reader getCharacterStream(String columnLabel) throws SQLException {
    return getCharacterStream(findColumn(columnLabel));
}

######


public Reader getCharacterStream(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    String value = row.getInternalString(columnsInformation[columnIndex - 1], null, timeZone);
    if (value == null) {
        return null;
    }
    return new StringReader(value);
}

######


public Reader getNCharacterStream(int columnIndex) throws SQLException {
    return getCharacterStream(columnIndex);
}

######


public Reader getNCharacterStream(String columnLabel) throws SQLException {
    return getCharacterStream(findColumn(columnLabel));
}

######


public Ref getRef(int columnIndex) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public Ref getRef(String columnLabel) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("Getting REFs not supported");
}

######


public Blob getBlob(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    if (row.lastValueWasNull()) {
        return null;
    }
    return new MariaDbBlob(row.buf, row.pos, row.length);
}

######


public Blob getBlob(String columnLabel) throws SQLException {
    return getBlob(findColumn(columnLabel));
}

######


public Clob getClob(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    if (row.lastValueWasNull()) {
        return null;
    }
    return new MariaDbClob(row.buf, row.pos, row.length);
}

######


public Clob getClob(String columnLabel) throws SQLException {
    return getClob(findColumn(columnLabel));
}

######


public Array getArray(int columnIndex) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("Arrays are not supported");
}

######


public Array getArray(String columnLabel) throws SQLException {
    return getArray(findColumn(columnLabel));
}

######


@Override
public URL getURL(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    if (row.lastValueWasNull()) {
        return null;
    }
    try {
        return new URL(row.getInternalString(columnsInformation[columnIndex - 1], null, timeZone));
    } catch (MalformedURLException e) {
        throw ExceptionMapper.getSqlException("Could not parse as URL");
    }
}

######


@Override
public URL getURL(String columnLabel) throws SQLException {
    return getURL(findColumn(columnLabel));
}

######


public RowId getRowId(int columnIndex) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("RowIDs not supported");
}

######


public RowId getRowId(String columnLabel) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("RowIDs not supported");
}

######


public NClob getNClob(int columnIndex) throws SQLException {
    checkObjectRange(columnIndex);
    if (row.lastValueWasNull()) {
        return null;
    }
    return new MariaDbClob(row.buf, row.pos, row.length);
}

######


public NClob getNClob(String columnLabel) throws SQLException {
    return getNClob(findColumn(columnLabel));
}

######


@Override
public SQLXML getSQLXML(int columnIndex) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("SQLXML not supported");
}

######


@Override
public SQLXML getSQLXML(String columnLabel) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("SQLXML not supported");
}

######


public String getNString(int columnIndex) throws SQLException {
    return getString(columnIndex);
}

######


public String getNString(String columnLabel) throws SQLException {
    return getString(findColumn(columnLabel));
}

######


public boolean getBoolean(int index) throws SQLException {
    checkObjectRange(index);
    return row.getInternalBoolean(columnsInformation[index - 1]);
}

######


public boolean getBoolean(String columnLabel) throws SQLException {
    return getBoolean(findColumn(columnLabel));
}

######


public byte getByte(int index) throws SQLException {
    checkObjectRange(index);
    return row.getInternalByte(columnsInformation[index - 1]);
}

######


public byte getByte(String columnLabel) throws SQLException {
    return getByte(findColumn(columnLabel));
}

######


public short getShort(int index) throws SQLException {
    checkObjectRange(index);
    return row.getInternalShort(columnsInformation[index - 1]);
}

######


public short getShort(String columnLabel) throws SQLException {
    return getShort(findColumn(columnLabel));
}

######


public boolean rowUpdated() throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("Detecting row updates are not supported");
}

######


public boolean rowInserted() throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("Detecting inserts are not supported");
}

######


public boolean rowDeleted() throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("Row deletes are not supported");
}

######


public void insertRow() throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("insertRow are not supported when using ResultSet.CONCUR_READ_ONLY");
}

######


public void deleteRow() throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("deleteRow are not supported when using ResultSet.CONCUR_READ_ONLY");
}

######


public void refreshRow() throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("refreshRow are not supported when using ResultSet.CONCUR_READ_ONLY");
}

######


public void cancelRowUpdates() throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void moveToInsertRow() throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void moveToCurrentRow() throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateNull(int columnIndex) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateNull(String columnLabel) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBoolean(int columnIndex, boolean bool) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBoolean(String columnLabel, boolean value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateByte(int columnIndex, byte value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateByte(String columnLabel, byte value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateShort(int columnIndex, short value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateShort(String columnLabel, short value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateInt(int columnIndex, int value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateInt(String columnLabel, int value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateFloat(int columnIndex, float value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateFloat(String columnLabel, float value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateDouble(int columnIndex, double value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateDouble(String columnLabel, double value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBigDecimal(int columnIndex, BigDecimal value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBigDecimal(String columnLabel, BigDecimal value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateString(int columnIndex, String value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateString(String columnLabel, String value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBytes(int columnIndex, byte[] value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBytes(String columnLabel, byte[] value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateDate(int columnIndex, Date date) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateDate(String columnLabel, Date value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateTime(int columnIndex, Time time) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateTime(String columnLabel, Time value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateTimestamp(int columnIndex, Timestamp timeStamp) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateTimestamp(String columnLabel, Timestamp value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateAsciiStream(int columnIndex, InputStream inputStream, int length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateAsciiStream(String columnLabel, InputStream inputStream) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateAsciiStream(String columnLabel, InputStream value, int length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateAsciiStream(int columnIndex, InputStream inputStream, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateAsciiStream(String columnLabel, InputStream inputStream, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateAsciiStream(int columnIndex, InputStream inputStream) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBinaryStream(int columnIndex, InputStream inputStream, int length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBinaryStream(int columnIndex, InputStream inputStream, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBinaryStream(String columnLabel, InputStream value, int length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBinaryStream(String columnLabel, InputStream inputStream, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBinaryStream(int columnIndex, InputStream inputStream) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBinaryStream(String columnLabel, InputStream inputStream) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateCharacterStream(int columnIndex, Reader value, int length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateCharacterStream(int columnIndex, Reader value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateCharacterStream(String columnLabel, Reader reader, int length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateCharacterStream(int columnIndex, Reader value, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateCharacterStream(String columnLabel, Reader reader) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateObject(int columnIndex, Object value, int scaleOrLength) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateObject(int columnIndex, Object value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateObject(String columnLabel, Object value, int scaleOrLength) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateObject(String columnLabel, Object value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateLong(String columnLabel, long value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateLong(int columnIndex, long value) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateRow() throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("updateRow are not supported when using ResultSet.CONCUR_READ_ONLY");
}

######


public void updateRef(int columnIndex, Ref ref) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateRef(String columnLabel, Ref ref) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBlob(int columnIndex, Blob blob) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBlob(String columnLabel, Blob blob) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBlob(int columnIndex, InputStream inputStream, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateBlob(String columnLabel, InputStream inputStream, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateClob(int columnIndex, Clob clob) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateClob(String columnLabel, Clob clob) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateClob(int columnIndex, Reader reader) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateClob(String columnLabel, Reader reader) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateArray(int columnIndex, Array array) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateArray(String columnLabel, Array array) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateRowId(int columnIndex, RowId rowId) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateRowId(String columnLabel, RowId rowId) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateNString(int columnIndex, String nstring) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateNString(String columnLabel, String nstring) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateNClob(int columnIndex, NClob nclob) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateNClob(String columnLabel, NClob nclob) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateNClob(int columnIndex, Reader reader) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateNClob(String columnLabel, Reader reader) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


@Override
public void updateSQLXML(int columnIndex, SQLXML xmlObject) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("SQLXML not supported");
}

######


@Override
public void updateSQLXML(String columnLabel, SQLXML xmlObject) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("SQLXML not supported");
}

######


public void updateNCharacterStream(int columnIndex, Reader value, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateNCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateNCharacterStream(int columnIndex, Reader reader) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public void updateNCharacterStream(String columnLabel, Reader reader) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException(NOT_UPDATABLE_ERROR);
}

######


public int getHoldability() {
    return ResultSet.HOLD_CURSORS_OVER_COMMIT;
}

######


public <T> T unwrap(final Class<T> iface) throws SQLException {
    try {
        if (isWrapperFor(iface)) {
            return iface.cast(this);
        } else {
            throw new SQLException("The receiver is not a wrapper for " + iface.getName());
        }
    } catch (Exception e) {
        throw new SQLException("The receiver is not a wrapper and does not implement the interface");
    }
}

######


public boolean isWrapperFor(final Class<?> iface) throws SQLException {
    return iface.isInstance(this);
}

######


public void setReturnTableAlias(boolean returnTableAlias) {
    this.returnTableAlias = returnTableAlias;
}

######


private void rangeCheck(Object className, long minValue, long maxValue, long value, ColumnInformation columnInfo) throws SQLException {
    if (value < minValue || value > maxValue) {
        throw new SQLException("Out of range value for column '" + columnInfo.getName() + "' : value " + value + " is not in " + className + " range", "22003", 1264);
    }
}

######


public int getRowPointer() {
    return rowPointer;
}

######


protected void setRowPointer(int pointer) {
    rowPointer = pointer;
}

######


public int getDataSize() {
    return dataSize;
}

######


public boolean isBinaryEncoded() {
    return row.isBinaryEncoded();
}

######


@Override
public void onClick(View v) {
    Intent intent = new Intent(Select_student_info.this, Student_detailed_info.class);
    intent.putExtra("name", student_info.getName());
    intent.putExtra("sex", student_info.getSex());
    intent.putExtra("id", student_info.getId());
    intent.putExtra("phone", student_info.getPhone());
    intent.putExtra("mathScore", student_info.getMathScore());
    intent.putExtra("chineseScore", student_info.getChineseScore());
    intent.putExtra("englishScore", student_info.getEnglishScore());
    intent.putExtra("ranking", student_info.getOrder());
    startActivity(intent);
}

######


@Override
public void onClick(DialogInterface dialog, int which) {
    SQLiteDatabase db = dbHelper.getReadableDatabase();
    db.execSQL("delete from student where id=?", new String[] { student_info.getId() });
    student_list.remove(position);
    adapter.notifyDataSetChanged();
}

######


@Override
public void onClick(View v) {
    AlertDialog.Builder delete_builder = new AlertDialog.Builder(Select_student_info.this);
    delete_builder.setTitle("警告! !!!");
    delete_builder.setMessage("您将删除该学生的信息,此操作不可以逆,请谨慎操作!");
    delete_builder.setNegativeButton("取消", null);
    delete_builder.setPositiveButton("确定", new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            SQLiteDatabase db = dbHelper.getReadableDatabase();
            db.execSQL("delete from student where id=?", new String[] { student_info.getId() });
            student_list.remove(position);
            adapter.notifyDataSetChanged();
        }
    });
    delete_builder.create().show();
}

######


@Override
public void onClick(View v) {
    Intent intent = new Intent(Select_student_info.this, Add_student_info.class);
    intent.putExtra("haveData", "true");
    intent.putExtra("name", student_info.getName());
    intent.putExtra("sex", student_info.getSex());
    intent.putExtra("id", student_info.getId());
    intent.putExtra("phone", student_info.getPhone());
    intent.putExtra("password", student_info.getPassword());
    intent.putExtra("mathScore", student_info.getMathScore());
    intent.putExtra("chineseScore", student_info.getChineseScore());
    intent.putExtra("englishScore", student_info.getEnglishScore());
    startActivity(intent);
}

######


@Override
public void onItemClick(AdapterView<?> parent, View view, final int position, long id) {
    final Student_info student_info = student_list.get(position);
    AlertDialog.Builder builder = new AlertDialog.Builder(Select_student_info.this);
    LayoutInflater factory = LayoutInflater.from(Select_student_info.this);
    View textEntryView = factory.inflate(R.layout.student_lv_dialog, null);
    builder.setView(textEntryView);
    builder.setTitle("请选择需要的操作");
    Button select_button = textEntryView.findViewById(R.id.student_info_select);
    select_button.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            Intent intent = new Intent(Select_student_info.this, Student_detailed_info.class);
            intent.putExtra("name", student_info.getName());
            intent.putExtra("sex", student_info.getSex());
            intent.putExtra("id", student_info.getId());
            intent.putExtra("phone", student_info.getPhone());
            intent.putExtra("mathScore", student_info.getMathScore());
            intent.putExtra("chineseScore", student_info.getChineseScore());
            intent.putExtra("englishScore", student_info.getEnglishScore());
            intent.putExtra("ranking", student_info.getOrder());
            startActivity(intent);
        }
    });
    Button delete_button = textEntryView.findViewById(R.id.student_info_delete);
    delete_button.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            AlertDialog.Builder delete_builder = new AlertDialog.Builder(Select_student_info.this);
            delete_builder.setTitle("警告! !!!");
            delete_builder.setMessage("您将删除该学生的信息,此操作不可以逆,请谨慎操作!");
            delete_builder.setNegativeButton("取消", null);
            delete_builder.setPositiveButton("确定", new DialogInterface.OnClickListener() {

                @Override
                public void onClick(DialogInterface dialog, int which) {
                    SQLiteDatabase db = dbHelper.getReadableDatabase();
                    db.execSQL("delete from student where id=?", new String[] { student_info.getId() });
                    student_list.remove(position);
                    adapter.notifyDataSetChanged();
                }
            });
            delete_builder.create().show();
        }
    });
    Button update_button = textEntryView.findViewById(R.id.student_info_update);
    update_button.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            Intent intent = new Intent(Select_student_info.this, Add_student_info.class);
            intent.putExtra("haveData", "true");
            intent.putExtra("name", student_info.getName());
            intent.putExtra("sex", student_info.getSex());
            intent.putExtra("id", student_info.getId());
            intent.putExtra("phone", student_info.getPhone());
            intent.putExtra("password", student_info.getPassword());
            intent.putExtra("mathScore", student_info.getMathScore());
            intent.putExtra("chineseScore", student_info.getChineseScore());
            intent.putExtra("englishScore", student_info.getEnglishScore());
            startActivity(intent);
        }
    });
    builder.create().show();
}

######


@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getSupportActionBar().hide();
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
    setContentView(R.layout.student_info_layout);
    dbHelper = MydatabaseHelper.getInstance(this);
    lv_student = findViewById(R.id.lv_student);
    initStudent();
    adapter = new StudentAdapter(Select_student_info.this, R.layout.student_info_item, student_list);
    lv_student.setAdapter(adapter);
    lv_student.setOnItemClickListener(new AdapterView.OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> parent, View view, final int position, long id) {
            final Student_info student_info = student_list.get(position);
            AlertDialog.Builder builder = new AlertDialog.Builder(Select_student_info.this);
            LayoutInflater factory = LayoutInflater.from(Select_student_info.this);
            View textEntryView = factory.inflate(R.layout.student_lv_dialog, null);
            builder.setView(textEntryView);
            builder.setTitle("请选择需要的操作");
            Button select_button = textEntryView.findViewById(R.id.student_info_select);
            select_button.setOnClickListener(new View.OnClickListener() {

                @Override
                public void onClick(View v) {
                    Intent intent = new Intent(Select_student_info.this, Student_detailed_info.class);
                    intent.putExtra("name", student_info.getName());
                    intent.putExtra("sex", student_info.getSex());
                    intent.putExtra("id", student_info.getId());
                    intent.putExtra("phone", student_info.getPhone());
                    intent.putExtra("mathScore", student_info.getMathScore());
                    intent.putExtra("chineseScore", student_info.getChineseScore());
                    intent.putExtra("englishScore", student_info.getEnglishScore());
                    intent.putExtra("ranking", student_info.getOrder());
                    startActivity(intent);
                }
            });
            Button delete_button = textEntryView.findViewById(R.id.student_info_delete);
            delete_button.setOnClickListener(new View.OnClickListener() {

                @Override
                public void onClick(View v) {
                    AlertDialog.Builder delete_builder = new AlertDialog.Builder(Select_student_info.this);
                    delete_builder.setTitle("警告! !!!");
                    delete_builder.setMessage("您将删除该学生的信息,此操作不可以逆,请谨慎操作!");
                    delete_builder.setNegativeButton("取消", null);
                    delete_builder.setPositiveButton("确定", new DialogInterface.OnClickListener() {

                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            SQLiteDatabase db = dbHelper.getReadableDatabase();
                            db.execSQL("delete from student where id=?", new String[] { student_info.getId() });
                            student_list.remove(position);
                            adapter.notifyDataSetChanged();
                        }
                    });
                    delete_builder.create().show();
                }
            });
            Button update_button = textEntryView.findViewById(R.id.student_info_update);
            update_button.setOnClickListener(new View.OnClickListener() {

                @Override
                public void onClick(View v) {
                    Intent intent = new Intent(Select_student_info.this, Add_student_info.class);
                    intent.putExtra("haveData", "true");
                    intent.putExtra("name", student_info.getName());
                    intent.putExtra("sex", student_info.getSex());
                    intent.putExtra("id", student_info.getId());
                    intent.putExtra("phone", student_info.getPhone());
                    intent.putExtra("password", student_info.getPassword());
                    intent.putExtra("mathScore", student_info.getMathScore());
                    intent.putExtra("chineseScore", student_info.getChineseScore());
                    intent.putExtra("englishScore", student_info.getEnglishScore());
                    startActivity(intent);
                }
            });
            builder.create().show();
        }
    });
}

######


public void initStudent() {
    SQLiteDatabase db = dbHelper.getReadableDatabase();
    Cursor cursor = db.rawQuery("select * from student order by id", null);
    while (cursor.moveToNext()) {
        String id = cursor.getString(cursor.getColumnIndex("id"));
        String name = cursor.getString(cursor.getColumnIndex("name"));
        String password = cursor.getString(cursor.getColumnIndex("password"));
        String sex = cursor.getString(cursor.getColumnIndex("sex"));
        String phone = cursor.getString(cursor.getColumnIndex("phone"));
        int mathScore = cursor.getInt(cursor.getColumnIndex("mathScore"));
        int chineseScore = cursor.getInt(cursor.getColumnIndex("chineseScore"));
        int englishScore = cursor.getInt(cursor.getColumnIndex("englishScore"));
        int order = cursor.getInt(cursor.getColumnIndex("ranking"));
        student_list.add(new Student_info(chineseScore, englishScore, mathScore, id, name, sex, phone, password, order));
    }
    cursor.close();
}

######


public List<Sensor> getAllCommandSensors() {
    Query query = em.createQuery("SELECT e FROM Sensor e where e.command is not null and e.mqttTopic is null and e.active=true");
    return (List<Sensor>) query.getResultList();
}

######


public List<Sensor> getAllMQTTSensors() {
    Query query = em.createQuery("SELECT e FROM Sensor e where e.mqttTopic is not null and e.command is null and e.active=true");
    return (List<Sensor>) query.getResultList();
}

######


public String getNameByNumber(Integer number) {
    return em.find(Sensor.class, number).getName();
}

######


public Sensor getSensorByNumber(Integer number) {
    return em.find(Sensor.class, number);
}

######


public List<Sensor> getSensorsWithCheck() {
    Query query = em.createQuery("SELECT e FROM Sensor e where e.checkChanges=true");
    return (List<Sensor>) query.getResultList();
}

######


public Sensor getSensorByMQTTTopic(String topic) {
    Query query = em.createQuery("SELECT e FROM Sensor e where e.mqttTopic=:topic");
    query.setParameter("topic", topic);
    List<Sensor> result = query.getResultList();
    if (result.size() > 0)
        return result.get(0);
    return null;
}

######


public List<SensorData> getAllSensorDataWithAlias() {
    Query query = em.createQuery("SELECT e FROM SensorData e where e.ruleAlias is not null");
    return (List<SensorData>) query.getResultList();
}

######


public Sensor getSensorByName(String name) {
    Query query = em.createQuery("SELECT e FROM Sensor e where e.name=:value");
    query.setParameter("value", name);
    List<Sensor> result = query.getResultList();
    if (result.size() > 0)
        return result.get(0);
    return null;
}

######


public void persist(SensorResultLog sensorResult) {
    em.persist(sensorResult);
}

######


public List<SensorResultLog> getResultsForDate(Date dateFrom, Date dateTo, Sensor sensor, String sensorDataName) {
    Query q = em.createQuery("SELECT e FROM SensorResultLog e where e.date>:dateFrom and e.date<=:dateTo and e.sensorData.parent=:sensor and e.sensorData.name=:sensorDataName order by id asc");
    q.setParameter("dateFrom", dateFrom);
    q.setParameter("dateTo", dateTo);
    q.setParameter("sensor", sensor);
    q.setParameter("sensorDataName", sensorDataName);
    return q.getResultList();
}

######


public float getAggregatedValue(String type, String func, Date dateFrom, Date dateTo, Sensor sensor) {
    Query q = em.createQuery("SELECT " + func + "(e.value) FROM SensorResultLog e where e.date>:dateFrom and e.date<=:dateTo and e.sensorData.parent=:sensor and e.sensorData.name=:type");
    System.out.println(dateFrom + " " + dateTo);
    q.setParameter("dateFrom", dateFrom);
    q.setParameter("dateTo", dateTo);
    q.setParameter("sensor", sensor);
    q.setParameter("type", type);
    Object result = q.getSingleResult();
    if (result instanceof Double) {
        return ((Double) result).floatValue();
    }
    if (result instanceof Float) {
        return ((Float) result).floatValue();
    }
    LOGGER.error("Nie można rozpoznać typu wyniku dla " + result + " . Parametry " + type + " func=" + func + " sensor=" + (sensor != null ? sensor.getName() : "null"));
    return 0;
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("ServerPrepareStatementTest", "id int not null primary key auto_increment, test boolean");
    createTable("ServerPrepareStatementTestt", "id int not null primary key auto_increment, test boolean");
    createTable("ServerPrepareStatementTestt2", "id int not null primary key auto_increment, test boolean");
    createTable("ServerPrepareStatementTestCache", "id int not null primary key auto_increment, test boolean");
    createTable("ServerPrepareStatementCacheSize3", "id int not null primary key auto_increment, test boolean");
    if (doPrecisionTest) {
        createTable("preparetestFactionnal", "time0 TIME(6) default '22:11:00', timestamp0 timestamp(6), datetime0 datetime(6) ");
    }
    createTable("ServerPrepareStatementCacheSize2", "id int not null primary key auto_increment, test boolean");
    createTable("ServerPrepareStatementCacheSize3", "id int not null primary key auto_increment, test blob");
    createTable("ServerPrepareStatementParameters", "id int, id2 int");
    createTable("ServerPrepareStatementCacheSize4", "id int not null primary key auto_increment, test LONGBLOB", "ROW_FORMAT=COMPRESSED ENGINE=INNODB");
    createTable("streamtest2", "id int primary key not null, strm text");
    createTable("testServerPrepareMeta", "id int not null primary key auto_increment, id2 int not null, id3 DEC(4,2), id4 BIGINT UNSIGNED ");
    createTable("ServerPrepareStatementSync", "id int not null primary key auto_increment, test varchar(1007), tt boolean");
}

######


@Test
public void testServerPrepareMeta() throws Throwable {
    PreparedStatement ps = sharedConnection.prepareStatement("INSERT INTO testServerPrepareMeta(id2, id3, id4) VALUES (?, ?, ?)");
    ParameterMetaData meta = ps.getParameterMetaData();
    assertEquals(3, meta.getParameterCount());
}

######


@Test
public void serverExecutionTest() throws SQLException {
    Assume.assumeTrue(sharedOptions().useServerPrepStmts);
    try (Connection connection = setConnection()) {
        Statement statement = connection.createStatement();
        ResultSet rs = statement.executeQuery("show global status like 'Prepared_stmt_count'");
        assertTrue(rs.next());
        final int nbStatementCount = rs.getInt(2);
        PreparedStatement ps = connection.prepareStatement("INSERT INTO ServerPrepareStatementTestt (test) VALUES (?)");
        ps.setBoolean(1, true);
        ps.addBatch();
        ps.execute();
        rs = statement.executeQuery("show global status like 'Prepared_stmt_count'");
        assertTrue(rs.next());
        assertEquals(nbStatementCount + 1, rs.getInt(2));
    }
}

######


@Test
public void serverCacheStatementTest() throws Throwable {
    Assume.assumeTrue(sharedUsePrepare());
    try (Connection connection = setConnection()) {
        Protocol protocol = getProtocolFromConnection(connection);
        int cacheSize = protocol.prepareStatementCache().size();
        PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO ServerPrepareStatementTestCache(test) VALUES (?)");
        preparedStatement.setBoolean(1, true);
        preparedStatement.execute();
        assertTrue(cacheSize + 1 == protocol.prepareStatementCache().size());
        PreparedStatement preparedStatement2 = connection.prepareStatement("INSERT INTO ServerPrepareStatementTestCache(test) VALUES (?)");
        preparedStatement2.setBoolean(1, true);
        preparedStatement2.execute();
        assertTrue(cacheSize + 1 == protocol.prepareStatementCache().size());
    }
}

######


@Test
public void prepStmtCacheSize() throws Throwable {
    Assume.assumeTrue(sharedOptions().useServerPrepStmts);
    try (Connection connection = setConnection("&prepStmtCacheSize=10")) {
        List<PreparedStatement> activePrepareStatement = new ArrayList<>(20);
        for (int i = 0; i < 20; i++) {
            PreparedStatement preparedStatement = connection.prepareStatement("SELECT " + i);
            preparedStatement.execute();
            activePrepareStatement.add(preparedStatement);
        }
        Protocol protocol = getProtocolFromConnection(connection);
        assertTrue("Prepared cache size must be 10", protocol.prepareStatementCache().size() == 10);
        for (int i = 0; i < 20; i++) {
            activePrepareStatement.get(i).execute();
        }
        assertTrue(protocol.prepareStatementCache().size() == 10);
        while (!activePrepareStatement.isEmpty()) {
            activePrepareStatement.get(0).close();
            activePrepareStatement.remove(0);
        }
        assertTrue("Prepared cache size must be 10", protocol.prepareStatementCache().size() == 10);
        assertEquals("ServerPrepareStatementCache.map[\n" + "testj-SELECT 10-0\n" + "testj-SELECT 11-0\n" + "testj-SELECT 12-0\n" + "testj-SELECT 13-0\n" + "testj-SELECT 14-0\n" + "testj-SELECT 15-0\n" + "testj-SELECT 16-0\n" + "testj-SELECT 17-0\n" + "testj-SELECT 18-0\n" + "testj-SELECT 19-0]", protocol.prepareStatementCache().toString());
        for (int i = 12; i < 15; i++) {
            PreparedStatement preparedStatement = connection.prepareStatement("SELECT " + i);
            preparedStatement.execute();
            activePrepareStatement.add(preparedStatement);
        }
        assertEquals("ServerPrepareStatementCache.map[\n" + "testj-SELECT 10-0\n" + "testj-SELECT 11-0\n" + "testj-SELECT 15-0\n" + "testj-SELECT 16-0\n" + "testj-SELECT 17-0\n" + "testj-SELECT 18-0\n" + "testj-SELECT 19-0\n" + "testj-SELECT 12-1\n" + "testj-SELECT 13-1\n" + "testj-SELECT 14-1]", protocol.prepareStatementCache().toString());
        for (int i = 1; i < 5; i++) {
            PreparedStatement preparedStatement = connection.prepareStatement("SELECT " + i);
            preparedStatement.execute();
            activePrepareStatement.add(preparedStatement);
        }
        assertEquals("ServerPrepareStatementCache.map[\n" + "testj-SELECT 17-0\n" + "testj-SELECT 18-0\n" + "testj-SELECT 19-0\n" + "testj-SELECT 12-1\n" + "testj-SELECT 13-1\n" + "testj-SELECT 14-1\n" + "testj-SELECT 1-1\n" + "testj-SELECT 2-1\n" + "testj-SELECT 3-1\n" + "testj-SELECT 4-1]", protocol.prepareStatementCache().toString());
        for (int i = 12; i < 15; i++) {
            PreparedStatement preparedStatement = connection.prepareStatement("SELECT " + i);
            preparedStatement.execute();
            activePrepareStatement.add(preparedStatement);
        }
        assertEquals("ServerPrepareStatementCache.map[\n" + "testj-SELECT 17-0\n" + "testj-SELECT 18-0\n" + "testj-SELECT 19-0\n" + "testj-SELECT 1-1\n" + "testj-SELECT 2-1\n" + "testj-SELECT 3-1\n" + "testj-SELECT 4-1\n" + "testj-SELECT 12-2\n" + "testj-SELECT 13-2\n" + "testj-SELECT 14-2]", protocol.prepareStatementCache().toString());
        for (int i = 20; i < 30; i++) {
            PreparedStatement preparedStatement = connection.prepareStatement("SELECT " + i);
            preparedStatement.execute();
            activePrepareStatement.add(preparedStatement);
        }
        assertEquals("ServerPrepareStatementCache.map[\n" + "testj-SELECT 20-1\n" + "testj-SELECT 21-1\n" + "testj-SELECT 22-1\n" + "testj-SELECT 23-1\n" + "testj-SELECT 24-1\n" + "testj-SELECT 25-1\n" + "testj-SELECT 26-1\n" + "testj-SELECT 27-1\n" + "testj-SELECT 28-1\n" + "testj-SELECT 29-1]", protocol.prepareStatementCache().toString());
        while (!activePrepareStatement.isEmpty()) {
            activePrepareStatement.get(0).execute();
            activePrepareStatement.get(0).close();
            activePrepareStatement.remove(0);
        }
        assertTrue(protocol.prepareStatementCache().size() == 10);
        assertEquals("ServerPrepareStatementCache.map[\n" + "testj-SELECT 20-0\n" + "testj-SELECT 21-0\n" + "testj-SELECT 22-0\n" + "testj-SELECT 23-0\n" + "testj-SELECT 24-0\n" + "testj-SELECT 25-0\n" + "testj-SELECT 26-0\n" + "testj-SELECT 27-0\n" + "testj-SELECT 28-0\n" + "testj-SELECT 29-0]", protocol.prepareStatementCache().toString());
    }
}

######


@Test
public void timeFractionnalSecondTest() throws SQLException {
    Assume.assumeTrue(doPrecisionTest);
    try (Connection connection = setConnection("&useFractionalSeconds=false")) {
        Time time0 = new Time(55549392);
        Time time1 = new Time(55549000);
        Timestamp timestamp0 = new Timestamp(55549392);
        Timestamp timestamp1 = new Timestamp(55549000);
        PreparedStatement ps = connection.prepareStatement("INSERT INTO preparetestFactionnal (time0, timestamp0, datetime0) VALUES (?, ?, ?)");
        ps.setTime(1, time0);
        ps.setTimestamp(2, timestamp0);
        ps.setTimestamp(3, timestamp0);
        ps.addBatch();
        ps.setTime(1, time1);
        ps.setTimestamp(2, timestamp1);
        ps.setTimestamp(3, timestamp1);
        ps.addBatch();
        ps.executeBatch();
        ResultSet rs = connection.createStatement().executeQuery("SELECT * from preparetestFactionnal");
        if (rs.next()) {
            assertEquals(rs.getTime(1), time1);
            assertEquals(rs.getTimestamp(2), timestamp1);
            assertEquals(rs.getTimestamp(3), timestamp1);
            assertTrue(rs.next());
            assertEquals(rs.getTime(1), time1);
            assertEquals(rs.getTimestamp(2), timestamp1);
            assertEquals(rs.getTimestamp(3), timestamp1);
        } else {
            fail("Error in query");
        }
    }
}

######


private void prepareTestTable() throws SQLException {
    createTable("preparetest", "bit1 BIT(1)," + "bit2 BIT(2)," + "tinyint1 TINYINT(1)," + "tinyint2 TINYINT(2)," + "bool0 BOOL default 1," + "smallint0 SMALLINT default 1," + "smallint_unsigned SMALLINT UNSIGNED default 0," + "mediumint0 MEDIUMINT default 1," + "mediumint_unsigned MEDIUMINT UNSIGNED default 0," + "int0 INT default 1," + "int_unsigned INT UNSIGNED default 0," + "bigint0 BIGINT default 1," + "bigint_unsigned BIGINT UNSIGNED default 0," + "float0 FLOAT default 0," + "double0 DOUBLE default 1," + "decimal0 DECIMAL default 0," + "decimal1 DECIMAL(15,4) default 0," + "date0 DATE default '2001-01-01'," + "datetime0 DATETIME(6) default '2001-01-01 00:00:00'," + "timestamp0 TIMESTAMP(6) default  '2001-01-01 00:00:00'," + "timestamp1 TIMESTAMP(0) null default  '2001-01-01 00:00:00'," + "timestamp_zero TIMESTAMP  null, " + "time0 TIME(6) default '22:11:00'," + ((!isMariadbServer() && minVersion(5, 6)) ? "year2 YEAR(4) default 99," : "year2 YEAR(2) default 99,") + "year4 YEAR(4) default 2011," + "char0 CHAR(1) default '0'," + "char_binary CHAR (1) binary default '0'," + "varchar0 VARCHAR(1) default '1'," + "varchar_binary VARCHAR(10) BINARY default 0x1," + "binary0 BINARY(10) default 0x1," + "varbinary0 VARBINARY(10) default 0x1, " + "id int not null AUTO_INCREMENT, PRIMARY KEY (id)");
}

######


@SuppressWarnings("ConstantConditions")
@Test
public void dataConformity() throws SQLException {
    Assume.assumeTrue(doPrecisionTest);
    TimeZone defaultTimeZone = TimeZone.getDefault();
    try {
        prepareTestTable();
        PreparedStatement ps = sharedConnection.prepareStatement("INSERT INTO preparetest (bit1,bit2,tinyint1," + "tinyint2,bool0,smallint0,smallint_unsigned,mediumint0,mediumint_unsigned,int0," + "int_unsigned,bigint0,bigint_unsigned, float0, double0, decimal0,decimal1, date0,datetime0, " + "timestamp0,timestamp1,timestamp_zero, time0," + "year2,year4,char0, char_binary, varchar0, varchar_binary, binary0, varbinary0)  " + "VALUES (?,?,?,?,?,?,?,?,?,?," + "?,?,?,?,?,?,?,?,?,?,?,?,?," + "?,?,?,?,?,?,?,?)");
        sharedConnection.createStatement().execute("truncate preparetest");
        boolean bit1 = Boolean.FALSE;
        ps.setBoolean(1, bit1);
        byte bit2 = (byte) 3;
        ps.setByte(2, bit2);
        byte tinyint1 = (byte) 127;
        ps.setByte(3, tinyint1);
        short tinyint2 = 127;
        ps.setShort(4, tinyint2);
        boolean bool0 = Boolean.FALSE;
        ps.setBoolean(5, bool0);
        short smallint0 = 5;
        ps.setShort(6, smallint0);
        short smallintUnsigned = Short.MAX_VALUE;
        ps.setShort(7, smallintUnsigned);
        int mediumint0 = 55000;
        ps.setInt(8, mediumint0);
        int mediumintUnsigned = 55000;
        ps.setInt(9, mediumintUnsigned);
        int int0 = Integer.MAX_VALUE;
        ps.setInt(10, int0);
        int intUnsigned = Integer.MAX_VALUE;
        ps.setInt(11, intUnsigned);
        long bigint0 = 5000L;
        ps.setLong(12, bigint0);
        BigInteger bigintUnsigned = new BigInteger("3147483647");
        ps.setObject(13, bigintUnsigned);
        float float0 = 3147483647.7527F;
        ps.setFloat(14, float0);
        double double0 = 3147483647.8527D;
        ps.setDouble(15, double0);
        BigDecimal decimal0 = new BigDecimal("3147483647");
        ps.setBigDecimal(16, decimal0);
        BigDecimal decimal1 = new BigDecimal("3147483647.9527");
        ps.setBigDecimal(17, decimal1);
        TimeZone.setDefault(TimeZone.getTimeZone("GMT+00:00"));
        Date date0 = new Date(1441238400000L);
        ps.setDate(18, date0);
        Timestamp datetime0 = new Timestamp(-2124690212000L);
        datetime0.setNanos(392005000);
        ps.setTimestamp(19, datetime0);
        Timestamp timestamp0 = new Timestamp(1441290349000L);
        timestamp0.setNanos(392005000);
        ps.setTimestamp(20, timestamp0);
        Timestamp timestamp1 = new Timestamp(1441290349000L);
        ps.setTimestamp(21, timestamp1);
        ps.setTimestamp(22, null);
        Time time0 = new Time(55549392);
        ps.setTime(23, time0);
        short year2 = 30;
        ps.setShort(24, year2);
        int year4 = 2050;
        ps.setInt(25, year4);
        String char0 = "\n";
        ps.setObject(26, char0, Types.CHAR);
        String charBinary = "\n";
        ps.setString(27, charBinary);
        String varchar0 = "\b";
        ps.setString(28, varchar0);
        String varcharBinary = "\b";
        ps.setString(29, varcharBinary);
        byte[] binary0 = "1234567890".getBytes();
        ps.setBytes(30, binary0);
        byte[] varbinary0 = "azerty".getBytes();
        ps.setBytes(31, varbinary0);
        ps.addBatch();
        ps.executeBatch();
        ResultSet rs = sharedConnection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE).executeQuery("SELECT * from preparetest");
        if (rs.next()) {
            assertEquals(rs.getBoolean(1), bit1);
            assertEquals(rs.getByte(2), bit2);
            assertEquals(rs.getByte(3), tinyint1);
            assertEquals(rs.getShort(4), tinyint2);
            assertEquals(rs.getBoolean(5), bool0);
            assertEquals(rs.getShort(6), smallint0);
            assertEquals(rs.getShort(7), smallintUnsigned);
            assertEquals(rs.getInt(8), mediumint0);
            assertEquals(rs.getInt(9), mediumintUnsigned);
            assertEquals(rs.getInt(10), int0);
            assertEquals(rs.getInt(11), intUnsigned);
            assertEquals(rs.getInt(12), bigint0);
            assertEquals(rs.getObject(13), bigintUnsigned);
            assertEquals(rs.getFloat(14), float0, 10000);
            assertEquals(rs.getDouble(15), double0, 10000);
            assertEquals(rs.getBigDecimal(16), decimal0);
            assertEquals(rs.getBigDecimal(17), decimal1);
            assertEquals(rs.getDate(18), date0);
            assertEquals(rs.getTimestamp(19), datetime0);
            assertEquals(rs.getTimestamp(20), timestamp0);
            assertEquals(rs.getTimestamp(21), timestamp1);
            assertNull(rs.getTimestamp(22));
            assertEquals(rs.getTime(23), time0);
            assertYear(rs, 24, year2);
            assertEquals(rs.getInt(25), year4);
            assertEquals(rs.getString(26), char0);
            assertEquals(rs.getString(27), charBinary);
            assertEquals(rs.getString(28), varchar0);
            assertEquals(rs.getString(29), varcharBinary);
            assertEquals(new String(rs.getBytes(30), StandardCharsets.UTF_8), new String(binary0, StandardCharsets.UTF_8));
            assertEquals(new String(rs.getBytes(31), StandardCharsets.UTF_8), new String(varbinary0, StandardCharsets.UTF_8));
            rs.updateBoolean(1, Boolean.TRUE);
            rs.updateByte(2, (byte) 2);
            rs.updateByte(3, (byte) 126);
            rs.updateShort(4, (short) 126);
            rs.updateBoolean(5, Boolean.TRUE);
            rs.updateShort(6, (short) 6);
            rs.updateShort(7, (short) 7);
            rs.updateInt(8, 55001);
            rs.updateInt(9, 55002);
            rs.updateInt(10, Integer.MAX_VALUE - 1);
            rs.updateInt(11, Integer.MAX_VALUE - 2);
            rs.updateInt(12, 59000);
            rs.updateObject(13, BigInteger.valueOf(555555));
            rs.updateFloat(14, 3148483647.6526F);
            rs.updateDouble(15, 3187483642.6527D);
            rs.updateBigDecimal(16, new BigDecimal("3897483647"));
            rs.updateBigDecimal(17, new BigDecimal("3197443647"));
            rs.updateDate(18, new Date(1499990400000L));
            rs.updateTimestamp(19, new Timestamp(-2124620212000L));
            rs.updateTimestamp(20, new Timestamp(1441222349000L));
            rs.updateTimestamp(21, null);
            rs.updateTimestamp(22, new Timestamp(1441290309000L));
            rs.updateTime(23, new Time(55549992));
            rs.updateInt(24, (short) 56);
            rs.updateInt(25, 2051);
            rs.updateString(26, "\\");
            rs.updateString(27, "\r");
            rs.updateString(28, "è");
            rs.updateString(29, "&");
            rs.updateBytes(30, "1234567899".getBytes());
            rs.updateRow();
            assertEquals(rs.getBoolean(1), Boolean.TRUE);
            assertEquals(rs.getByte(2), (byte) 2);
            assertEquals(rs.getByte(3), (byte) 126);
            assertEquals(rs.getShort(4), (byte) 126);
            assertEquals(rs.getBoolean(5), Boolean.TRUE);
            assertEquals(rs.getShort(6), (short) 6);
            assertEquals(rs.getShort(7), (short) 7);
            assertEquals(rs.getInt(8), 55001);
            assertEquals(rs.getInt(9), 55002);
            assertEquals(rs.getInt(10), Integer.MAX_VALUE - 1);
            assertEquals(rs.getInt(11), Integer.MAX_VALUE - 2);
            assertEquals(rs.getInt(12), 59000);
            assertEquals(rs.getObject(13), BigInteger.valueOf(555555));
            assertEquals(rs.getFloat(14), 3148483647.6526F, 10000);
            assertEquals(rs.getDouble(15), 3187483642.6527D, 10000);
            assertEquals(rs.getBigDecimal(16), new BigDecimal("3897483647"));
            assertEquals(rs.getBigDecimal(17), new BigDecimal("3197443647.0000"));
            assertEquals(rs.getDate(18).getTime(), new Date(1499990400000L).getTime());
            assertEquals(rs.getTimestamp(19), new Timestamp(-2124620212000L));
            assertEquals(rs.getTimestamp(20), new Timestamp(1441222349000L));
            assertNull(rs.getTimestamp(21));
            assertEquals(rs.getTimestamp(22), new Timestamp(1441290309000L));
            assertEquals(rs.getTime(23), new Time(55549992));
            assertYear(rs, 24, (short) 56);
            assertEquals(rs.getInt(25), 2051);
            assertEquals(rs.getString(26), "\\");
            assertEquals(rs.getString(27), "\r");
            assertEquals(rs.getString(28), "è");
            assertEquals(rs.getString(29), "&");
            assertEquals(new String(rs.getBytes(30), StandardCharsets.UTF_8), "1234567899");
            rs = sharedConnection.createStatement().executeQuery("SELECT * from preparetest");
            if (rs.next()) {
                assertEquals(rs.getBoolean(1), Boolean.TRUE);
                assertEquals(rs.getByte(2), (byte) 2);
                assertEquals(rs.getByte(3), (byte) 126);
                assertEquals(rs.getShort(4), (byte) 126);
                assertEquals(rs.getBoolean(5), Boolean.TRUE);
                assertEquals(rs.getShort(6), (short) 6);
                assertEquals(rs.getShort(7), (short) 7);
                assertEquals(rs.getInt(8), 55001);
                assertEquals(rs.getInt(9), 55002);
                assertEquals(rs.getInt(10), Integer.MAX_VALUE - 1);
                assertEquals(rs.getInt(11), Integer.MAX_VALUE - 2);
                assertEquals(rs.getInt(12), 59000);
                assertEquals(rs.getObject(13), BigInteger.valueOf(555555));
                assertEquals(rs.getFloat(14), 3148483647.6526F, 10000);
                assertEquals(rs.getDouble(15), 3187483642.6527D, 10000);
                assertEquals(rs.getBigDecimal(16), new BigDecimal("3897483647"));
                assertEquals(rs.getBigDecimal(17), new BigDecimal("3197443647.0000"));
                assertEquals(rs.getDate(18).getTime(), new Date(1499990400000L).getTime());
                assertEquals(rs.getTimestamp(19), new Timestamp(-2124620212000L));
                assertEquals(rs.getTimestamp(20), new Timestamp(1441222349000L));
                assertNull(rs.getTimestamp(21));
                assertEquals(rs.getTimestamp(22), new Timestamp(1441290309000L));
                assertEquals(rs.getTime(23), new Time(55549992));
                assertYear(rs, 24, (short) 56);
                assertEquals(rs.getInt(25), 2051);
                assertEquals(rs.getString(26), "\\");
                assertEquals(rs.getString(27), "\r");
                assertEquals(rs.getString(28), "è");
                assertEquals(rs.getString(29), "&");
                assertEquals(new String(rs.getBytes(30), StandardCharsets.UTF_8), "1234567899");
                assertFalse(rs.next());
            } else {
                fail();
            }
        } else {
            fail();
        }
    } finally {
        TimeZone.setDefault(defaultTimeZone);
    }
}

######


private void assertYear(ResultSet rs, int fieldNumber, int comparaison) throws SQLException {
    if (isMariadbServer()) {
        assertEquals(rs.getInt(fieldNumber), comparaison);
    } else {
        if (minVersion(5, 6)) {
            assertEquals(rs.getInt(fieldNumber), comparaison + 2000);
        } else {
            assertEquals(rs.getInt(fieldNumber), comparaison);
        }
    }
}

######


@Test
public void blobTest() throws Throwable {
    try (Connection connection = setConnection("&prepStmtCacheSize=10")) {
        PreparedStatement ps = connection.prepareStatement("INSERT INTO ServerPrepareStatementCacheSize3(test) VALUES (?)");
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        InputStream input = classLoader.getResourceAsStream("logback-test.xml");
        ps.setBlob(1, input);
        ps.addBatch();
        ps.executeBatch();
    }
}

######


@Test
public void readerTest() throws Throwable {
    try (Connection connection = setConnection("&prepStmtCacheSize=10")) {
        PreparedStatement ps = connection.prepareStatement("INSERT INTO ServerPrepareStatementCacheSize3(test) VALUES (?)");
        Reader reader = new BufferedReader(new InputStreamReader(ClassLoader.getSystemResourceAsStream("style.xml")));
        ps.setCharacterStream(1, reader);
        ps.addBatch();
        ps.executeBatch();
    }
}

######


@Test(expected = SQLException.class)
public void parametersNotSetTest() throws Throwable {
    Assume.assumeTrue(sharedUsePrepare());
    PreparedStatement ps = sharedConnection.prepareStatement("INSERT INTO ServerPrepareStatementParameters(id, id2) VALUES (?,?)");
    ps.setInt(1, 1);
    ps.addBatch();
    ps.executeBatch();
}

######


@Test
public void checkSendDifferentParameterTypeTest() throws Throwable {
    PreparedStatement ps = sharedConnection.prepareStatement("INSERT INTO ServerPrepareStatementParameters(id, id2) VALUES (?,?)");
    ps.setByte(1, (byte) 1);
    ps.setShort(2, (short) 1);
    ps.addBatch();
    ps.setInt(1, Integer.MIN_VALUE);
    ps.setInt(2, Integer.MAX_VALUE);
    ps.addBatch();
    ps.setInt(1, Integer.MIN_VALUE);
    ps.setInt(2, Integer.MAX_VALUE);
    ps.addBatch();
    ps.executeBatch();
}

######


@Test
public void blobMultipleSizeTest() throws Throwable {
    Assume.assumeTrue(checkMaxAllowedPacketMore40m("blobMultipleSizeTest"));
    Assume.assumeTrue(sharedUsePrepare());
    PreparedStatement ps = sharedConnection.prepareStatement("INSERT INTO ServerPrepareStatementCacheSize4(test) VALUES (?)");
    byte[] arr = new byte[20000000];
    Arrays.fill(arr, (byte) 'b');
    InputStream input = new ByteArrayInputStream(arr);
    InputStream input2 = new ByteArrayInputStream(arr);
    InputStream input3 = new ByteArrayInputStream(arr);
    ps.setBlob(1, input);
    ps.addBatch();
    ps.setBlob(1, input2);
    ps.addBatch();
    ps.setBlob(1, input3);
    ps.addBatch();
    ps.executeBatch();
    Statement statement = sharedConnection.createStatement();
    ResultSet rs = statement.executeQuery("select * from ServerPrepareStatementCacheSize4");
    assertTrue(rs.next());
    byte[] newBytes = rs.getBytes(2);
    assertEquals(arr.length, newBytes.length);
    for (int i = 0; i < arr.length; i++) {
        assertEquals(arr[i], newBytes[i]);
    }
}

######


@Test
public void executeNumber() throws Throwable {
    PreparedStatement ps = prepareInsert();
    ps.execute();
    ResultSet rs = ps.executeQuery("select count(*) from ServerPrepareStatementParameters");
    assertTrue(rs.next());
    assertEquals(rs.getInt(1), 1);
}

######


@Test
public void executeBatchNumber() throws Throwable {
    try (PreparedStatement ps = prepareInsert()) {
        ps.executeBatch();
        ResultSet rs = ps.executeQuery("select count(*) from ServerPrepareStatementParameters");
        assertTrue(rs.next());
        assertEquals(rs.getInt(1), 3);
    }
}

######


private PreparedStatement prepareInsert() throws Throwable {
    Statement statement = sharedConnection.createStatement();
    statement.execute("truncate ServerPrepareStatementParameters");
    PreparedStatement ps = sharedConnection.prepareStatement("INSERT INTO ServerPrepareStatementParameters(id, id2) VALUES (?,?)");
    ps.setByte(1, (byte) 1);
    ps.setShort(2, (short) 1);
    ps.addBatch();
    ps.setInt(1, Integer.MIN_VALUE);
    ps.setInt(2, Integer.MAX_VALUE);
    ps.addBatch();
    ps.setInt(1, Integer.MIN_VALUE);
    ps.setInt(2, Integer.MAX_VALUE);
    ps.addBatch();
    return ps;
}

######


@Test
public void directExecuteNumber() throws Throwable {
    sharedConnection.createStatement().execute("truncate ServerPrepareStatementParameters");
    PreparedStatement ps = sharedConnection.prepareStatement("INSERT INTO ServerPrepareStatementParameters(id, id2) VALUES (?,?)");
    ps.setByte(1, (byte) 1);
    ps.setShort(2, (short) 1);
    ps.execute();
    ResultSet rs = ps.executeQuery("select count(*) from ServerPrepareStatementParameters");
    assertTrue(rs.next());
    assertEquals(rs.getInt(1), 1);
}

######


@Test
public void dataConformity2() throws SQLException {
    Assume.assumeTrue(doPrecisionTest);
    prepareTestTable();
    PreparedStatement ps = sharedConnection.prepareStatement("INSERT INTO preparetest " + "(bit1,bit2,tinyint1,tinyint2,bool0,smallint0,smallint_unsigned,mediumint0,mediumint_unsigned,int0," + "int_unsigned,bigint0,bigint_unsigned, float0, double0, decimal0,decimal1, date0,datetime0, " + "timestamp0,timestamp1,timestamp_zero, time0," + "year2,year4,char0, char_binary, varchar0, varchar_binary, binary0, varbinary0)  " + "VALUES (?,?,?,?,?,?,?,?,?,?," + "?,?,?,?,?,?,?,?,?,?,?,?,?," + "?,?,?,?,?,?,?,?)");
    boolean bit1 = Boolean.FALSE;
    ps.setBoolean(1, bit1);
    byte bit2 = (byte) 3;
    ps.setByte(2, bit2);
    byte tinyint1 = (byte) 127;
    ps.setByte(3, tinyint1);
    short tinyint2 = 127;
    ps.setShort(4, tinyint2);
    boolean bool0 = Boolean.FALSE;
    ps.setBoolean(5, bool0);
    short smallint0 = 5;
    ps.setShort(6, smallint0);
    short smallintUnsigned = Short.MAX_VALUE;
    ps.setShort(7, smallintUnsigned);
    int mediumint0 = 55000;
    ps.setInt(8, mediumint0);
    int mediumintUnsigned = 55000;
    ps.setInt(9, mediumintUnsigned);
    int int0 = Integer.MAX_VALUE;
    ps.setInt(10, int0);
    int intUnsigned = Integer.MAX_VALUE;
    ps.setInt(11, intUnsigned);
    long bigint0 = 5000L;
    ps.setLong(12, bigint0);
    BigInteger bigintUnsigned = new BigInteger("3147483647");
    ps.setObject(13, bigintUnsigned);
    float float0 = 3147483647.7527F;
    ps.setFloat(14, float0);
    double double0 = 3147483647.8527D;
    ps.setDouble(15, double0);
    BigDecimal decimal0 = new BigDecimal("3147483647");
    ps.setBigDecimal(16, decimal0);
    BigDecimal decimal1 = new BigDecimal("3147483647.9527");
    ps.setBigDecimal(17, decimal1);
    Date date0 = Date.valueOf("2016-02-01");
    ps.setDate(18, date0);
    Timestamp datetime0 = new Timestamp(-2124690212000L);
    datetime0.setNanos(392005000);
    ps.setTimestamp(19, datetime0);
    Timestamp timestamp0 = new Timestamp(1441290349000L);
    timestamp0.setNanos(392005000);
    ps.setTimestamp(20, timestamp0);
    Timestamp timestamp1 = new Timestamp(1441290349000L);
    ps.setTimestamp(21, timestamp1);
    ps.setTimestamp(22, null);
    Time time0 = new Time(55549392);
    ps.setTime(23, time0);
    short year2 = 30;
    ps.setShort(24, year2);
    int year4 = 2050;
    ps.setInt(25, year4);
    String char0 = "\n";
    ps.setString(26, char0);
    String charBinary = "\n";
    ps.setString(27, charBinary);
    String varchar0 = "\b";
    ps.setString(28, varchar0);
    String varcharBinary = "\b";
    ps.setString(29, varcharBinary);
    byte[] binary0 = "1234567890".getBytes();
    ps.setBytes(30, binary0);
    byte[] varbinary0 = "azerty".getBytes();
    ps.setBytes(31, varbinary0);
    ps.addBatch();
    ps.executeBatch();
    PreparedStatement prepStmt = sharedConnection.prepareStatement("SELECT * from preparetest where bit1 = ?");
    prepStmt.setBoolean(1, false);
    ResultSet rs = prepStmt.executeQuery();
    if (rs.next()) {
        assertEquals(rs.getBoolean(1), bit1);
        assertEquals(rs.getByte(2), bit2);
        assertEquals(rs.getByte(3), tinyint1);
        assertEquals(rs.getShort(4), tinyint2);
        assertEquals(rs.getBoolean(5), bool0);
        assertEquals(rs.getShort(6), smallint0);
        assertEquals(rs.getShort(7), smallintUnsigned);
        assertEquals(rs.getInt(8), mediumint0);
        assertEquals(rs.getInt(9), mediumintUnsigned);
        assertEquals(rs.getInt(10), int0);
        assertEquals(rs.getInt(11), intUnsigned);
        assertEquals(rs.getInt(12), bigint0);
        assertEquals(rs.getObject(13), bigintUnsigned);
        assertEquals(rs.getFloat(14), float0, 10000);
        assertEquals(rs.getDouble(15), double0, 10000);
        assertEquals(rs.getBigDecimal(16), decimal0);
        assertEquals(rs.getBigDecimal(17), decimal1);
        assertEquals(rs.getDate(18), date0);
        assertEquals(rs.getTimestamp(19), datetime0);
        assertEquals(rs.getTimestamp(20), timestamp0);
        assertEquals(rs.getTimestamp(21), timestamp1);
        assertNull(rs.getTimestamp(22));
        assertEquals(rs.getTime(23), time0);
        assertYear(rs, 24, year2);
        assertEquals(rs.getInt(25), year4);
        assertEquals(rs.getString(26), char0);
        assertEquals(rs.getString(27), charBinary);
        assertEquals(rs.getString(28), varchar0);
        assertEquals(rs.getString(29), varcharBinary);
        assertEquals(new String(rs.getBytes(30), StandardCharsets.UTF_8), new String(binary0, StandardCharsets.UTF_8));
        assertEquals(new String(rs.getBytes(31), StandardCharsets.UTF_8), new String(varbinary0, StandardCharsets.UTF_8));
    } else {
        fail();
    }
}

######


@Test
public void testPrepareStatementCache() throws Throwable {
    Assume.assumeTrue(sharedOptions().useServerPrepStmts);
    try (Connection connection = setConnection()) {
        Protocol protocol = getProtocolFromConnection(connection);
        createTable("test_cache_table1", "id1 int auto_increment primary key, text1 varchar(20), text2 varchar(20)");
        PreparedStatement[] map = new PreparedStatement[280];
        for (int i = 0; i < 280; i++) {
            map[i] = connection.prepareStatement("INSERT INTO test_cache_table1 (text1, text2) values (" + i + ", ?)");
            map[i].setString(1, i + "");
            map[i].setString(2, i + "");
            map[i].addBatch();
            map[i].executeBatch();
            if (i < 250) {
                assertEquals(i + 1, protocol.prepareStatementCache().size());
            } else {
                assertEquals(250, protocol.prepareStatementCache().size());
            }
        }
    }
}

######


@Test
public void testRewriteMultiPacket() throws SQLException {
    createTable("PreparedStatementTest3", "id int");
    StringBuilder sql = new StringBuilder("INSERT INTO PreparedStatementTest3 VALUES (?)");
    for (int i = 1; i < 65535; i++) {
        sql.append(",(?)");
    }
    PreparedStatement pstmt = sharedConnection.prepareStatement(sql.toString());
    for (int i = 1; i < 65536; i++) {
        pstmt.setInt(i, i);
    }
    assertFalse(pstmt.execute());
}

######


@Test
public void serverPrepareStatementSync() throws Throwable {
    Assume.assumeTrue(!checkMaxAllowedPacketMore20m("serverPrepareStatementSync", false) && sharedIsRewrite());
    Statement st = sharedConnection.createStatement();
    ResultSet rs = st.executeQuery("select @@max_allowed_packet");
    if (rs.next()) {
        long maxAllowedPacket = rs.getInt(1);
        int totalInsertCommands = (int) Math.ceil(3 * maxAllowedPacket / 1000);
        try (Connection connection2 = setConnection()) {
            PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO ServerPrepareStatementSync(test, tt) values (?, false) ", Statement.RETURN_GENERATED_KEYS);
            PreparedStatement preparedStatement2 = connection2.prepareStatement("INSERT INTO ServerPrepareStatementSync(test, tt) values (?, true) ", Statement.RETURN_GENERATED_KEYS);
            char[] thousandChars = new char[1000];
            Arrays.fill(thousandChars, 'a');
            String thousandLength = new String(thousandChars);
            for (int counter = 0; counter < totalInsertCommands + 1; counter++) {
                preparedStatement.setString(1, "a" + counter + "_" + thousandLength);
                preparedStatement.addBatch();
                preparedStatement2.setString(1, "b" + counter + "_" + thousandLength);
                preparedStatement2.addBatch();
            }
            ExecutorService executor = Executors.newFixedThreadPool(2);
            BatchThread thread1 = new BatchThread(preparedStatement);
            BatchThread thread2 = new BatchThread(preparedStatement2);
            executor.execute(thread1);
            executor.execute(thread2);
            executor.shutdown();
            executor.awaitTermination(400, TimeUnit.SECONDS);
            ResultSet rs1 = preparedStatement.getGeneratedKeys();
            ResultSet rs2 = preparedStatement2.getGeneratedKeys();
            ResultSet rs3 = sharedConnection.createStatement().executeQuery("select id, tt from ServerPrepareStatementSync");
            while (rs3.next()) {
                if (rs3.getBoolean(2)) {
                    rs2.next();
                    if (rs3.getInt(1) != rs2.getInt(1)) {
                        System.out.println("1 : " + rs3.getInt(1) + " != " + rs2.getInt(1));
                        fail();
                    }
                } else {
                    rs1.next();
                    if (rs3.getInt(1) != rs1.getInt(1)) {
                        System.out.println("0 : " + rs3.getInt(1) + " != " + rs1.getInt(1));
                        fail();
                    }
                }
            }
        }
    } else {
        fail();
    }
}

######


@Test
public void ensureRowStateWithNullValues() throws SQLException {
    createTable("ensureRowStateWithNullValues", "t1 varchar(20), t2 varchar(20), t3 varchar(20), t4 varchar(20), t5 varchar(20), t6 varchar(20)");
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("INSERT INTO ensureRowStateWithNullValues VALUES ('12345678901234567890', null, 'otherString', '1234567890', null, '12345')");
    try (PreparedStatement ps = sharedConnection.prepareStatement("SELECT * FROM ensureRowStateWithNullValues")) {
        try (ResultSet rs = ps.executeQuery()) {
            assertTrue(rs.next());
            assertEquals("12345678901234567890", rs.getString(1));
            assertNull(rs.getString(2));
            assertNull(rs.getString(5));
            assertEquals("12345", rs.getString(6));
            assertFalse(rs.next());
        }
    }
}

######


@Test
public void ensureRowStateWithNullValuesSecond() throws Exception {
    createTable("ensureRowStateWithNullValuesSecond", " ID int(11) NOT NULL," + " COLUMN_1 varchar(11) COLLATE utf8_bin DEFAULT NULL," + " COLUMN_2 varchar(11) COLLATE utf8_bin DEFAULT NULL," + " COLUMN_3 varchar(11) COLLATE utf8_bin DEFAULT NULL," + " PRIMARY KEY (ID)", "ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin");
    if (testSingleHost) {
        Statement st = sharedConnection.createStatement();
        st.execute("INSERT INTO ensureRowStateWithNullValuesSecond VALUES(1,'col 1 value', 'col 2 value', null)");
    }
    String sql = "SELECT ID, COLUMN_2, COLUMN_1, COLUMN_3 FROM ensureRowStateWithNullValuesSecond";
    try (Connection tmpConnection = setConnection("&profileSql=true&useServerPrepStmts=true")) {
        Statement stmt = tmpConnection.createStatement();
        stmt.setQueryTimeout(1);
        stmt.execute(sql);
        try (final PreparedStatement preparedStatement = tmpConnection.prepareStatement(sql)) {
            ResultSet rs = preparedStatement.executeQuery();
            assertTrue(rs.next());
            String columnOne = rs.getString("COLUMN_1");
            String columnTwo = rs.getString("COLUMN_2");
            String columnThree = rs.getString("COLUMN_3");
            assertEquals("col 2 value", columnTwo);
            assertNull(columnThree);
            assertNotNull(columnOne);
            assertEquals("col 1 value", columnOne);
            columnThree = rs.getString("COLUMN_3");
            columnTwo = rs.getString("COLUMN_2");
            columnOne = rs.getString("COLUMN_1");
            assertEquals("col 2 value", columnTwo);
            assertNull(columnThree);
            assertNotNull(columnOne);
            assertEquals("col 1 value", columnOne);
            columnTwo = rs.getString("COLUMN_2");
            columnThree = rs.getString("COLUMN_3");
            columnOne = rs.getString("COLUMN_1");
            assertEquals("col 2 value", columnTwo);
            assertNull(columnThree);
            assertNotNull(columnOne);
            assertEquals("col 1 value", columnOne);
        }
    }
}

######


@Test
public void dateAsString() throws SQLException {
    if (!isMariadbServer()) {
        cancelForVersion(5, 5);
    }
    dateAddTest(false);
    dateAddTest(true);
}

######


private void dateAddTest(boolean useBinary) throws SQLException {
    try (Connection connection = setConnection("&log=true&useServerPrepStmts=" + (useBinary ? "true" : "false"))) {
        try (PreparedStatement preparedStatement = connection.prepareStatement("SELECT DATE_ADD('2010-12-31 23:59:59', INTERVAL 2 SECOND) as t")) {
            ResultSet rs = preparedStatement.executeQuery();
            while (rs.next()) {
                assertEquals(Date.valueOf("2011-01-01"), rs.getDate(1));
                assertEquals(Timestamp.valueOf("2011-01-01 00:00:01"), rs.getTimestamp(1));
                assertEquals("2011-01-01 00:00:01", rs.getString(1));
            }
        }
        try (PreparedStatement preparedStatement = connection.prepareStatement("SELECT DATE_ADD(CONVERT('2010-12-31 23:59:59',datetime(6)), INTERVAL 2 SECOND) as t")) {
            ResultSet rs = preparedStatement.executeQuery();
            while (rs.next()) {
                assertEquals("2011-01-01", rs.getDate(1).toString());
                assertEquals(Timestamp.valueOf("2011-01-01 00:00:01"), rs.getTimestamp(1));
                assertEquals("2011-01-01 00:00:01.0", rs.getString(1));
            }
        }
    }
}

######


@Override
public void run() {
    try {
        preparedStatement.executeBatch();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


@SqlUpdate("create table services (idt integer primary key autoincrement, libelle varchar(100), photo varchar(255), prix varchar(100), description varchar(240), idVendeur integer, promo integer, offreGroupe boolean, categorie varchar(100))")
public void createServiceTable();

######


@SqlUpdate("insert into services (libelle, photo, prix, description, idVendeur, promo, offreGroupe, categorie) values (:libelle, :photo, :prix, :description, :idVendeur, :promo, :offreGroupe, :categorie)")
@GetGeneratedKeys
public int insert(@BindBean Service s);

######


@SqlUpdate("update services set libelle = :libelle, photo = :photo, prix=:prix, description = :description, idVendeur = :idVendeur, promo = :promo, offreGroupe = :offreGroupe, categorie = :categorie")
public void update(@BindBean Service s);

######


@SqlQuery("select * from services where idt = :idt")
@RegisterMapperFactory(BeanMapperFactory.class)
public Service findByIdt(@Bind("idt") int idt);

######


@SqlQuery("select count(*) from services")
public int count();

######


@SqlQuery("select * from services where idVendeur = :idVendeur")
@RegisterMapperFactory(BeanMapperFactory.class)
public List<Service> listerServicesParIdClient(@Bind("idVendeur") int idVendeur);

######


@SqlUpdate("delete from services where idt = :idt")
public int deleteService(@Bind("idt") int idt);

######


@SqlUpdate("drop table if exists services")
public void dropServiceTable();

######


public void close();

######


@GET
@Path("/test")
@Produces("application/json")
public String test() {
    try {
        return new JSONObject().put("status", "success 1").toString();
    } catch (JSONException e) {
        e.printStackTrace();
    }
    return "error";
}

######


@GET
@Path("/addUser")
@Produces("application/json")
public String addUser(@QueryParam("token") String token, @QueryParam("institution") String institution, @QueryParam("username") String username, @QueryParam("password") String password) {
    try {
        Class.forName("com.mysql.jdbc.Driver");
        conn = DriverManager.getConnection(DB_URL, USER, PASS);
        stmt = conn.createStatement();
        String sql;
        sql = "Insert into users (username, password, token, institution) values (" + "'" + username + "'," + "'" + password + "'," + "'" + token + "'," + "'" + institution + "');";
        stmt.executeUpdate(sql);
        stmt.close();
        conn.close();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (stmt != null)
                stmt.close();
            if (conn != null)
                conn.close();
        } catch (SQLException se) {
            se.printStackTrace();
        }
    }
    try {
        return new JSONObject().put("status", "success").toString();
    } catch (JSONException e) {
        e.printStackTrace();
    }
    return null;
}

######


@GET
@Path("/users")
@Produces("application/json")
public String getUsers() {
    List<User> users = new ArrayList<>();
    try {
        Class.forName("com.mysql.jdbc.Driver");
        conn = DriverManager.getConnection(DB_URL, USER, PASS);
        stmt = conn.createStatement();
        String sql;
        sql = "SELECT * FROM users";
        ResultSet rs = stmt.executeQuery(sql);
        while (rs.next()) users.add(new User(rs.getInt("id") + "", rs.getString("username"), rs.getString("password"), rs.getString("token")));
        rs.close();
        stmt.close();
        conn.close();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (stmt != null)
                stmt.close();
            if (conn != null)
                conn.close();
        } catch (SQLException se) {
            se.printStackTrace();
        }
    }
    return users.toString();
}

######


@POST
@Path("/deleteAllUsers")
@Produces("application/json")
public String deleteAllUsers() {
    try {
        Class.forName("com.mysql.jdbc.Driver");
        conn = DriverManager.getConnection(DB_URL, USER, PASS);
        stmt = conn.createStatement();
        String sql;
        sql = "TRUNCATE table users ";
        stmt.executeUpdate(sql);
        stmt.close();
        conn.close();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (stmt != null)
                stmt.close();
            if (conn != null)
                conn.close();
        } catch (SQLException se) {
            se.printStackTrace();
        }
    }
    try {
        return new JSONObject().put("status", "success").toString();
    } catch (JSONException e) {
        e.printStackTrace();
    }
    return null;
}

######


@POST
@Path("/login")
@Consumes("application/x-www-form-urlencoded")
@Produces("application/json")
public String post(@QueryParam("username") String username, @QueryParam("password") String password) {
    int rowCount = 0;
    int id = -1;
    String institution = "";
    try {
        Class.forName("com.mysql.jdbc.Driver");
        conn = DriverManager.getConnection(DB_URL, USER, PASS);
        stmt = conn.createStatement();
        String sql;
        sql = "SELECT * FROM users Where username = '" + username + "' AND password ='" + password + "';";
        ResultSet rs = stmt.executeQuery(sql);
        while (rs.next()) {
            rowCount = rs.getInt(1);
            id = rs.getInt("id");
            institution = rs.getString("institution");
        }
        rs.close();
        stmt.close();
        conn.close();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (stmt != null)
                stmt.close();
            if (conn != null)
                conn.close();
        } catch (SQLException se) {
            se.printStackTrace();
        }
    }
    try {
        if (rowCount == 0) {
            return new JSONObject().put("status", "error").toString();
        } else {
            DateFormat dateFormat = new SimpleDateFormat("yyyyMMddHHmmss");
            Date date = new Date();
            String token = "";
            Random ran = new Random();
            int randomNumber = ran.nextInt(1000000);
            String random = randomNumber + "";
            token = random + username + "." + institution + "." + dateFormat.format(date);
            try {
                Class.forName("com.mysql.jdbc.Driver");
                conn = DriverManager.getConnection(DB_URL, USER, PASS);
                stmt = conn.createStatement();
                String sql;
                sql = "UPDATE users Set token='" + token + "' Where username = '" + username + "' AND password ='" + password + "';";
                stmt.executeUpdate(sql);
                stmt.close();
                conn.close();
                return new JSONObject().put("status", "success").put("id", id + "").put("token", token).toString();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                try {
                    if (stmt != null)
                        stmt.close();
                    if (conn != null)
                        conn.close();
                } catch (SQLException se) {
                    se.printStackTrace();
                }
            }
        }
    } catch (JSONException e) {
        e.printStackTrace();
        return "error";
    }
    return institution;
}

######


@GET
@Path("/checkToken")
@Consumes("application/x-www-form-urlencoded")
@Produces("application/json")
public String checkToken(@QueryParam("cnp") String cnp, @QueryParam("token") String token) {
    int expirationDateForToken = 60 * 1000;
    int rowCount = 0;
    String foundToken = "";
    try {
        Class.forName("com.mysql.jdbc.Driver");
        conn = DriverManager.getConnection(DB_URL, USER, PASS);
        stmt = conn.createStatement();
        String sql;
        sql = "SELECT token FROM users Where username = '" + cnp + "';";
        ResultSet rs = stmt.executeQuery(sql);
        while (rs.next()) {
            foundToken = rs.getString("token");
            if (token.equals(foundToken)) {
                int lastIndex = token.lastIndexOf(".");
                String givenTokenDate = token.substring(lastIndex + 1, token.length());
                DateFormat format = new SimpleDateFormat("yyyyMMddHHmmss");
                Date dateGiven = format.parse(givenTokenDate);
                Date dateDB = new Date();
                if (dateDB.getTime() - dateGiven.getTime() > expirationDateForToken) {
                    return new JSONObject().put("status", "error").put("reson", "token expired").toString();
                }
            } else {
                return new JSONObject().put("status", "error").put("reson", "token invalid").toString();
            }
        }
        rs.close();
        stmt.close();
        conn.close();
    } catch (Exception e) {
        e.printStackTrace();
        try {
            return new JSONObject().put("status", "error").put("reson", "token invalid").toString();
        } catch (Exception e1) {
            e1.printStackTrace();
        }
    } finally {
        try {
            if (stmt != null)
                stmt.close();
            if (conn != null)
                conn.close();
        } catch (SQLException se) {
            se.printStackTrace();
        }
    }
    try {
        return new JSONObject().put("status", "success").toString();
    } catch (JSONException e) {
        e.printStackTrace();
    }
    ;
    return null;
}

######


@GET
@Path("/getUserData")
@Consumes("application/x-www-form-urlencoded")
@Produces("application/json")
public String getUserData(@QueryParam("cnp") String cnp, @QueryParam("institutie") String institutie, @QueryParam("token") String token) {
    String permisiune = token.substring(token.indexOf(".") + 1, token.lastIndexOf("."));
    System.out.println(permisiune);
    try {
        String response = RestService.callMethod("gov/checkToken?token=" + token + "&cnp=" + cnp, "GET");
        JSONObject responseJson = new JSONObject(response);
        if (responseJson.get("status").equals("error"))
            return new JSONObject().put("status", "error").put("reson", responseJson.get("reson")).toString();
    } catch (Exception e1) {
        e1.printStackTrace();
        try {
            return new JSONObject().put("status", "error").put("reson", e1.toString()).toString();
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }
    try {
        if (institutie.toLowerCase().equals("primarie")) {
            return Primarie.getCityHallData(cnp, permisiune);
        } else if (institutie.toLowerCase().equals("casa de sanatate")) {
            return CasaDeSanatate.getHealthData(cnp);
        } else if (institutie.toLowerCase().equals("evidenta populatiei")) {
            return EvidentaPopulatiei.getPersonalData(cnp);
        } else if (institutie.toLowerCase().equals("invatamant")) {
            return Invatamant.getEducationData(cnp, permisiune);
        } else if (institutie.toLowerCase().equals("politie")) {
            return Politie.getScurityData(cnp);
        }
    } catch (Exception e) {
        try {
            return new JSONObject().put("status", "error").put("reason", e.toString()).toString();
        } catch (JSONException e1) {
            e1.printStackTrace();
        }
        return "{'status':'error1'}";
    }
    return "{'status':'error2'}";
}

######


@GET
@Path("/getAllDataForUser")
@Consumes("application/x-www-form-urlencoded")
@Produces("application/json")
public String getAllDataForUser(@QueryParam("cnp") String cnp, @QueryParam("token") String token) {
    String[] institutii = { "primarie", "casa de sanatate", "evidenta populatiei", "invatamant", "politie" };
    try {
        String response = RestService.callMethod("gov/checkToken?token=" + token + "&cnp=" + cnp, "GET");
        JSONObject responseJson = new JSONObject(response);
        if (responseJson.get("status").equals("error"))
            return new JSONObject().put("status", "error").put("reson", responseJson.get("reson")).toString();
    } catch (Exception e1) {
        e1.printStackTrace();
        try {
            return new JSONObject().put("status", "error").put("reson", e1.toString()).toString();
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }
    JSONObject finalResponse = new JSONObject();
    for (int i = 0; i < institutii.length; i++) {
        try {
            String response = RestService.callMethod("gov/getUserData?token=" + token + "&cnp=" + cnp + "&institutie=" + URLEncoder.encode(institutii[i], "UTF-8"), "GET");
            JSONObject responseJson = new JSONObject(response);
            finalResponse.put(institutii[i], responseJson);
        } catch (Exception e1) {
            e1.printStackTrace();
            try {
                return new JSONObject().put("status", "error").put("reson", e1.toString()).toString();
            } catch (JSONException e) {
                e.printStackTrace();
            }
        }
    }
    return finalResponse.toString();
}

######


@Insert
void insertUser(User... users);

######


@Query("SELECT MAX(metadata_start_time) FROM Session WHERE z_id LIKE :mZ_id")
String getMostRecentSession(int mZ_id);

######


@Insert
void insertUserSession(Session... sessions);

######


@Override
public void addShareCollect(ShareCollect shareCollect) {
    try {
        shareCollectDao.save(shareCollect);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


@Override
public boolean deleteShareCollectBySendId(int sendId) {
    String hql = "delete from ShareCollect where sendId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(sendId);
    if (shareCollectDao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public boolean deleteShareCollectByCollectId(int collectId) {
    String hql = "delete from ShareCollect where collectId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(collectId);
    if (shareCollectDao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public List<ShareCollect> findCollectsBySendIdAndCollectorId(int sendId, int collectorId) {
    String hql = "from ShareCollect where sendId=? and collectorId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(sendId);
    object.add(collectorId);
    List<ShareCollect> shareCollectList = shareCollectDao.find(hql, object);
    if (shareCollectList != null && shareCollectList.size() > 0) {
        return shareCollectList;
    } else {
        return null;
    }
}

######


@Override
public List<ShareDiscussDto> findAllShareDiscuss(int sendId) {
    List<ShareDiscussDto> discussDtoList = new ArrayList<ShareDiscussDto>();
    String hql = "from User where id=?";
    String hqlShareDiscuss = "from ShareDiscuss where sendId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(sendId);
    List<ShareDiscuss> shareDiscussList = shareDiscussDao.find(hqlShareDiscuss, object);
    if (shareDiscussList != null && shareDiscussList.size() > 0) {
        for (ShareDiscuss shareDiscuss : shareDiscussList) {
            ShareDiscussDto shareDiscussDto = new ShareDiscussDto();
            shareDiscussDto.setId(shareDiscuss.getId());
            shareDiscussDto.setSendId(shareDiscuss.getSendId());
            shareDiscussDto.setUserId(shareDiscuss.getDiscusserId());
            shareDiscussDto.setDiscussContent(shareDiscuss.getDiscussContent());
            shareDiscussDto.setDiscussTime(shareDiscuss.getDiscussTime());
            User user = userDao.get(hql, new Object[] { shareDiscuss.getDiscusserId() });
            if (user != null) {
                shareDiscussDto.setUserName(user.getName());
                shareDiscussDto.setUserNickName(user.getNickname());
                shareDiscussDto.setUserType(user.getType());
            }
            discussDtoList.add(shareDiscussDto);
        }
    }
    return discussDtoList;
}

######


@Override
public void addShareDiscuss(ShareDiscuss shareDiscuss) {
    try {
        shareDiscussDao.save(shareDiscuss);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


@Override
public boolean deleteShareDiscussBySendId(int sendId) {
    String hql = "delete from ShareDiscuss where sendId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(sendId);
    if (shareDiscussDao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public boolean deleteShareDiscussById(int id) {
    String hql = "delete from ShareDiscuss where id=?";
    List<Object> object = new ArrayList<Object>();
    object.add(id);
    if (shareDiscussDao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public void addShareLikes(ShareLikes shareLikes) {
    try {
        shareLikesDao.save(shareLikes);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


@Override
public boolean deleteShareLikesBySendId(int sendId) {
    String hql = "delete from ShareLikes where sendId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(sendId);
    if (shareLikesDao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public boolean deleteshareLikesById(int id) {
    String hql = "delete from ShareLikes where id=?";
    List<Object> object = new ArrayList<Object>();
    object.add(id);
    if (shareLikesDao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public List<ShareLikes> findLikesBySendIdAndLikeserId(int sendId, int likeserId) {
    String hql = "from ShareLikes where sendId=? and likeserId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(sendId);
    object.add(likeserId);
    List<ShareLikes> shareLikes = shareLikesDao.find(hql, object);
    if (shareLikes != null && shareLikes.size() > 0) {
        return shareLikes;
    } else {
        return null;
    }
}

######


@Override
public ShareHouseDto findUserShareInfo(int userId) {
    ShareHouseDto shareHouseDto = new ShareHouseDto();
    String hql = "from User where id=?";
    User user = userDao.get(hql, new Object[] { userId });
    if (user != null) {
        shareHouseDto.setUserId(userId);
        shareHouseDto.setUserName(user.getName());
        shareHouseDto.setUserNickName(user.getNickname());
        shareHouseDto.setUserType(user.getType());
        shareHouseDto.setUserJianjie(user.getIntroduction());
        String hqlShareSend = "from ShareSend where userId=?";
        List<Object> object = new ArrayList<Object>();
        object.add(userId);
        List<ShareSend> shareSendList = shareSendDao.find(hqlShareSend, object);
        int collectAmount = 0;
        int discussAmount = 0;
        int likesAmount = 0;
        if (shareSendList != null && shareSendList.size() > 0) {
            for (int i = 0; i < shareSendList.size(); i++) {
                collectAmount = collectAmount + shareSendList.get(i).getCollectAmount();
                discussAmount = discussAmount + shareSendList.get(i).getDiscussAmount();
                likesAmount = likesAmount + shareSendList.get(i).getLikesAmount();
            }
        }
        shareHouseDto.setCollectAmount(collectAmount);
        shareHouseDto.setDiscussAmount(discussAmount);
        shareHouseDto.setLikesAmount(likesAmount);
    }
    return shareHouseDto;
}

######


@Override
public List<ShareDto> findAllShare(int userId) {
    List<ShareDto> shareDtoList = new ArrayList<ShareDto>();
    String hqlShareSend = "from ShareSend";
    String hql = "from User where id=?";
    List<ShareSend> shareSends = shareSendDao.find(hqlShareSend);
    if (shareSends != null && shareSends.size() > 0) {
        List<ShareDto> shareDtoS = new ArrayList<ShareDto>();
        shareDtoS.clear();
        for (ShareSend shareSend : shareSends) {
            ShareDto shareDto = new ShareDto();
            shareDto.setSendId(shareSend.getSendId());
            shareDto.setSendTitle(shareSend.getSendTitle());
            shareDto.setSendContent(shareSend.getSendContent());
            shareDto.setSendTime(shareSend.getSendTime());
            shareDto.setLikesAmount(shareSend.getLikesAmount());
            shareDto.setDiscussAmount(shareSend.getDiscussAmount());
            shareDto.setCollectAmount(shareSend.getCollectAmount());
            shareDto.setUserId(shareSend.getUserId());
            User user = userDao.get(hql, new Object[] { shareSend.getUserId() });
            if (user != null) {
                shareDto.setUserName(user.getName());
                shareDto.setUserNickName(user.getNickname());
                shareDto.setUserType(user.getType());
            }
            List<ShareCollect> shareCollectList = shareCollectService.findCollectsBySendIdAndCollectorId(shareSend.getSendId(), userId);
            if (shareCollectList != null && shareCollectList.size() > 0) {
                shareDto.setCollectOrNot("true");
            } else {
                shareDto.setCollectOrNot("false");
            }
            List<ShareLikes> shareLikesList = shareLikesService.findLikesBySendIdAndLikeserId(shareSend.getSendId(), userId);
            if (shareLikesList != null && shareLikesList.size() > 0) {
                shareDto.setLikesOrNot("true");
            } else {
                shareDto.setLikesOrNot("false");
            }
            shareDtoS.add(shareDto);
        }
        shareDtoList.clear();
        if (shareDtoS != null && shareDtoS.size() > 0) {
            for (int i = shareDtoS.size() - 1; i >= 0; i--) {
                System.out.println("shareDtoS.size()=" + shareDtoS.size() + " i = " + i);
                shareDtoList.add(shareDtoS.get(i));
            }
        }
        shareDtoS.clear();
    }
    return shareDtoList;
}

######


@Override
public List<ShareDto> findMyShareHistory(int userId) {
    List<ShareDto> shareDtoList = new ArrayList<ShareDto>();
    String hql = "from User where id=?";
    User user = userDao.get(hql, new Object[] { userId });
    String hqlShareSend = "from ShareSend where userId=?";
    List<Object> objectShareSend = new ArrayList<Object>();
    objectShareSend.add(userId);
    List<ShareSend> shareSendList = shareSendDao.find(hqlShareSend, objectShareSend);
    if (shareSendList != null && shareSendList.size() > 0) {
        List<ShareDto> shareDtoS = new ArrayList<ShareDto>();
        shareDtoS.clear();
        for (ShareSend shareSend : shareSendList) {
            ShareDto shareDto = new ShareDto();
            shareDto.setSendId(shareSend.getSendId());
            shareDto.setSendTitle(shareSend.getSendTitle());
            shareDto.setSendContent(shareSend.getSendContent());
            shareDto.setSendTime(shareSend.getSendTime());
            shareDto.setLikesAmount(shareSend.getLikesAmount());
            shareDto.setDiscussAmount(shareSend.getDiscussAmount());
            shareDto.setCollectAmount(shareSend.getCollectAmount());
            shareDto.setUserId(shareSend.getUserId());
            if (user != null) {
                shareDto.setUserName(user.getName());
                shareDto.setUserNickName(user.getNickname());
                shareDto.setUserType(user.getType());
            }
            List<ShareCollect> shareCollectList = shareCollectService.findCollectsBySendIdAndCollectorId(shareSend.getSendId(), userId);
            if (shareCollectList != null && shareCollectList.size() > 0) {
                shareDto.setCollectOrNot("true");
            } else {
                shareDto.setCollectOrNot("false");
            }
            List<ShareLikes> shareLikesList = shareLikesService.findLikesBySendIdAndLikeserId(shareSend.getSendId(), userId);
            if (shareLikesList != null && shareLikesList.size() > 0) {
                shareDto.setLikesOrNot("true");
            } else {
                shareDto.setLikesOrNot("false");
            }
            shareDtoS.add(shareDto);
        }
        shareDtoList.clear();
        if (shareDtoS != null && shareDtoS.size() > 0) {
            for (int i = shareDtoS.size() - 1; i >= 0; i--) {
                shareDtoList.add(shareDtoS.get(i));
            }
        }
        shareDtoS.clear();
    }
    return shareDtoList;
}

######


@Override
public List<ShareDto> findMyCollectShares(int userId) {
    List<ShareDto> shareDtoList = new ArrayList<ShareDto>();
    String hqlShareSend = "from ShareSend where sendId=?";
    String hqlUser = "from User where id=?";
    String hqlCollect = "from ShareCollect where collectorId=?";
    List<Object> objectCollect = new ArrayList<Object>();
    objectCollect.add(userId);
    List<ShareCollect> shareCollectList = shareCollectDao.find(hqlCollect, objectCollect);
    if (shareCollectList != null && shareCollectList.size() > 0) {
        List<ShareDto> shareDtoS = new ArrayList<ShareDto>();
        for (ShareCollect shareCollect : shareCollectList) {
            ShareSend shareSend = shareSendDao.get(hqlShareSend, new Object[] { shareCollect.getSendId() });
            if (shareSend != null) {
                ShareDto shareDto = new ShareDto();
                shareDto.setSendId(shareSend.getSendId());
                shareDto.setSendTitle(shareSend.getSendTitle());
                shareDto.setSendContent(shareSend.getSendContent());
                shareDto.setSendTime(shareSend.getSendTime());
                shareDto.setLikesAmount(shareSend.getLikesAmount());
                shareDto.setDiscussAmount(shareSend.getDiscussAmount());
                shareDto.setCollectAmount(shareSend.getCollectAmount());
                shareDto.setUserId(shareSend.getUserId());
                String dateStr = TimeUtil.dateToString(shareCollect.getCollectTime());
                shareDto.setCollectOrNot(shareCollect.getCollectTime() + "");
                User user = userDao.get(hqlUser, new Object[] { shareSend.getUserId() });
                if (user != null) {
                    shareDto.setUserName(user.getName());
                    shareDto.setUserNickName(user.getNickname());
                    shareDto.setUserType(user.getType());
                }
                List<ShareLikes> shareLikesList = shareLikesService.findLikesBySendIdAndLikeserId(shareSend.getSendId(), userId);
                if (shareLikesList != null && shareLikesList.size() > 0) {
                    shareDto.setLikesOrNot("true");
                } else {
                    shareDto.setLikesOrNot("false");
                }
                shareDtoS.add(shareDto);
            }
        }
        shareDtoList.clear();
        if (shareDtoS != null && shareDtoS.size() > 0) {
            for (int i = shareDtoS.size() - 1; i >= 0; i--) {
                shareDtoList.add(shareDtoS.get(i));
            }
        }
        shareDtoS.clear();
    }
    return shareDtoList;
}

######


@Override
public List<ShareDto> findMyDiscussShares(int userId) {
    List<ShareDto> shareDtoList = new ArrayList<ShareDto>();
    String hqlShareSend = "from ShareSend where sendId=?";
    String hqlUser = "from User where id=?";
    String hqlCollect = "from ShareDiscuss where discusserId=?";
    List<Object> objectCollect = new ArrayList<Object>();
    objectCollect.add(userId);
    List<ShareDiscuss> shareCollectList = shareDiscussDao.find(hqlCollect, objectCollect);
    if (shareCollectList != null && shareCollectList.size() > 0) {
        List<ShareDto> shareDtoS = new ArrayList<ShareDto>();
        for (ShareDiscuss shareCollect : shareCollectList) {
            ShareSend shareSend = shareSendDao.get(hqlShareSend, new Object[] { shareCollect.getSendId() });
            if (shareSend != null) {
                ShareDto shareDto = new ShareDto();
                shareDto.setSendId(shareSend.getSendId());
                shareDto.setSendTitle(shareSend.getSendTitle());
                shareDto.setSendContent(shareSend.getSendContent());
                shareDto.setSendTime(shareSend.getSendTime());
                shareDto.setLikesAmount(shareSend.getLikesAmount());
                shareDto.setDiscussAmount(shareSend.getDiscussAmount());
                shareDto.setCollectAmount(shareSend.getCollectAmount());
                shareDto.setUserId(shareSend.getUserId());
                String dateStr = TimeUtil.dateToString(shareCollect.getDiscussTime());
                shareDto.setCollectOrNot(shareCollect.getDiscussTime() + "");
                shareDto.setLikesOrNot(shareCollect.getDiscussContent());
                User user = userDao.get(hqlUser, new Object[] { shareSend.getUserId() });
                if (user != null) {
                    shareDto.setUserName(user.getName());
                    shareDto.setUserNickName(user.getNickname());
                    shareDto.setUserType(user.getType());
                }
                shareDtoS.add(shareDto);
            }
        }
        shareDtoList.clear();
        if (shareDtoS != null && shareDtoS.size() > 0) {
            for (int i = shareDtoS.size() - 1; i >= 0; i--) {
                shareDtoList.add(shareDtoS.get(i));
            }
        }
        shareDtoS.clear();
    }
    return shareDtoList;
}

######


@Override
public void addShareSend(ShareSend shareSend) {
    try {
        shareSendDao.save(shareSend);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


@Override
public boolean deleteShareSendBySendId(int sendId) {
    String hql = "delete from ShareSend where sendId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(sendId);
    if (shareSendDao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public List<ShareSend> findShareSendBySendId(int sendId) {
    String hql = "from ShareSend where sendId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(sendId);
    List<ShareSend> shareSends = shareSendDao.find(hql, object);
    if (shareSends != null && shareSends.size() > 0) {
        return shareSends;
    } else {
        return null;
    }
}

######


@Override
public boolean updateLikesAmount(int sendId, int likesAmount) {
    String hql = "update ShareSend set likesAmount=? where sendId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(likesAmount);
    object.add(sendId);
    if (shareSendDao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public boolean updateDiscussAmount(int sendId, int discussAmount) {
    String hql = "update ShareSend set discussAmount=? where sendId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(discussAmount);
    object.add(sendId);
    if (shareSendDao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public boolean updateCollectAmount(int sendId, int collectAmount) {
    String hql = "update ShareSend set collectAmount=? where sendId=?";
    List<Object> object = new ArrayList<Object>();
    object.add(collectAmount);
    object.add(sendId);
    if (shareSendDao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
}

######


protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
}

######


@Override
public void onClick(View v) {
    Toast.makeText(getApplicationContext(), "Returning!", Toast.LENGTH_SHORT).show();
    finish();
}

######


@Override
public void onClick(View v) {
    if (validateFields(sqlDb_read)) {
        ContentValues userValues = new ContentValues();
        userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_ACCOUNT_NUMBER, advantage_number.getText().toString());
        userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_CREDIT_CARD, credit_card.getText().toString());
        userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_EMAIL, email.getText().toString());
        userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_FIRST_NAME, first_name.getText().toString());
        userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_LAST_NAME, last_name.getText().toString());
        userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_NAME_USER_NAME, user_name.getText().toString());
        userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_PASSWORD, password.getText().toString());
        long newRowId;
        newRowId = sqlDb_write.insert(QuickShoppeUserContract.UserEntry.TABLE_NAME, QuickShoppeUserContract.UserEntry.COLUMN_NAME_NULLABLE, userValues);
        Toast.makeText(getApplicationContext(), "Creating Account! Logging In", Toast.LENGTH_SHORT).show();
        startActivity(home_activity_intent);
        finish();
        sqlDb_write.close();
    }
}

######


@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_sign_up);
    UserDbHelper mDbHelper = new UserDbHelper(getApplicationContext());
    final SQLiteDatabase sqlDb_read = mDbHelper.getReadableDatabase();
    final SQLiteDatabase sqlDb_write = mDbHelper.getWritableDatabase();
    final Intent home_activity_intent = new Intent(this, HomeActivity.class);
    back_to_home_button = (Button) findViewById(R.id.return_to_home);
    back_to_home_button.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            Toast.makeText(getApplicationContext(), "Returning!", Toast.LENGTH_SHORT).show();
            finish();
        }
    });
    create_user_button = (Button) findViewById(R.id.create_account);
    password = (EditText) findViewById(R.id.registration_password);
    confirm_password = (EditText) findViewById(R.id.registration_confirm_password);
    first_name = (EditText) findViewById(R.id.registration_first_name);
    last_name = (EditText) findViewById(R.id.registration_last_name);
    advantage_number = (EditText) findViewById(R.id.registration_advantage_number);
    email = (EditText) findViewById(R.id.registration_email);
    credit_card = (EditText) findViewById(R.id.registration_credit_card);
    user_name = (EditText) findViewById(R.id.registration_user_name);
    create_user_button.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (validateFields(sqlDb_read)) {
                ContentValues userValues = new ContentValues();
                userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_ACCOUNT_NUMBER, advantage_number.getText().toString());
                userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_CREDIT_CARD, credit_card.getText().toString());
                userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_EMAIL, email.getText().toString());
                userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_FIRST_NAME, first_name.getText().toString());
                userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_LAST_NAME, last_name.getText().toString());
                userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_NAME_USER_NAME, user_name.getText().toString());
                userValues.put(QuickShoppeUserContract.UserEntry.COLUMN_PASSWORD, password.getText().toString());
                long newRowId;
                newRowId = sqlDb_write.insert(QuickShoppeUserContract.UserEntry.TABLE_NAME, QuickShoppeUserContract.UserEntry.COLUMN_NAME_NULLABLE, userValues);
                Toast.makeText(getApplicationContext(), "Creating Account! Logging In", Toast.LENGTH_SHORT).show();
                startActivity(home_activity_intent);
                finish();
                sqlDb_write.close();
            }
        }
    });
}

######


@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.menu_sign_up, menu);
    return true;
}

######


@Override
public boolean onOptionsItemSelected(MenuItem item) {
    int id = item.getItemId();
    if (id == R.id.action_settings) {
        return true;
    }
    return super.onOptionsItemSelected(item);
}

######


private boolean validateFields(SQLiteDatabase sqlDb_read) {
    boolean ret = true;
    if (!password.getText().toString().equals(confirm_password.getText().toString())) {
        Toast.makeText(getApplicationContext(), "Passwords don't match! Try again!", Toast.LENGTH_SHORT).show();
        ret = false;
    } else if (first_name.getText().toString().length() == 0) {
        Toast.makeText(getApplicationContext(), "First Name Empty!", Toast.LENGTH_SHORT).show();
        ret = false;
    } else if (last_name.getText().toString().length() == 0) {
        Toast.makeText(getApplicationContext(), "Last Name Empty!", Toast.LENGTH_SHORT).show();
        ret = false;
    } else if (user_name.getText().toString().length() == 0) {
        Toast.makeText(getApplicationContext(), "Username Empty!", Toast.LENGTH_SHORT).show();
        ret = false;
    } else if (advantage_number.getText().toString().length() == 0) {
        Toast.makeText(getApplicationContext(), "Advantage Number Empty!", Toast.LENGTH_SHORT).show();
        ret = false;
    } else if (email.getText().toString().length() == 0) {
        Toast.makeText(getApplicationContext(), "Email Empty!", Toast.LENGTH_SHORT).show();
        ret = false;
    } else if (credit_card.getText().toString().length() == 0) {
        Toast.makeText(getApplicationContext(), "Credit Card Empty", Toast.LENGTH_SHORT).show();
        ret = false;
    } else if (password.getText().toString().length() == 0) {
        Toast.makeText(getApplicationContext(), "Password Empty", Toast.LENGTH_SHORT).show();
        return false;
    } else if (confirm_password.getText().toString().length() == 0) {
        Toast.makeText(getApplicationContext(), "Confirm Password Empty", Toast.LENGTH_SHORT).show();
        ret = false;
    } else {
        String selectQuery = "SELECT " + QuickShoppeUserContract.UserEntry.COLUMN_NAME_USER_NAME + " FROM " + "user " + "WHERE " + QuickShoppeUserContract.UserEntry.COLUMN_NAME_USER_NAME + "=" + "'" + user_name.getText().toString() + "'";
        Cursor c = sqlDb_read.rawQuery(selectQuery, null);
        if (c.getCount() != 0) {
            Toast.makeText(getApplicationContext(), "Username already taken!", Toast.LENGTH_SHORT).show();
            ret = false;
        }
    }
    return ret;
}

######


@Before
public void setUp() throws Exception {
    Reader reader = Resources.getResourceAsReader("org/apache/ibatis/submitted/bringrags/mybatis-config.xml");
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
    reader.close();
    sqlSession = sqlSessionFactory.openSession();
    conn = sqlSession.getConnection();
    ScriptRunner runner = new ScriptRunner(conn);
    runner.setLogWriter(null);
    runner.runScript(new StringReader("DROP TABLE IF EXISTS SimpleObject;"));
    runner.runScript(new StringReader("DROP TABLE IF EXISTS SimpleChildObject;"));
    runner.runScript(new StringReader("CREATE TABLE SimpleObject (id VARCHAR(5) NOT NULL);"));
    runner.runScript(new StringReader("CREATE TABLE SimpleChildObject (id VARCHAR(5) NOT NULL, simple_object_id VARCHAR(5) NOT NULL);"));
    runner.runScript(new StringReader("INSERT INTO SimpleObject (id) values ('10000');"));
    runner.runScript(new StringReader("INSERT INTO SimpleChildObject (id, simple_object_id) values ('20000', '10000');"));
    reader.close();
    simpleChildObjectMapper = (SimpleChildObjectMapper) sqlSession.getMapper(SimpleChildObjectMapper.class);
}

######


@After
public void tearDown() throws Exception {
    conn.close();
    sqlSession.close();
}

######


@Test
public void testGetById() throws Exception {
    SimpleChildObject sc = simpleChildObjectMapper.getSimpleChildObjectById("20000");
    Assert.assertNotNull(sc);
    Assert.assertNotNull(sc.getSimpleObject());
}

######


@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("status")
public Response getStatus() {
    return Response.ok("{\"status\":\"Web Service is running...\"}").build();
}

######


@POST
@Path("/postAddUser")
@Consumes(MediaType.APPLICATION_JSON)
public Response postAddUser(User user) {
    String response = null;
    boolean closeAfter = false;
    try {
        closeAfter = HibernateHelper.beginTx();
        Session session = HibernateHelper.getSession();
        session.beginTransaction();
        boolean isExistUser = false;
        Criteria crt = session.createCriteria(User.class);
        crt.add(Restrictions.eq("email", user.getEmail()));
        List<User> existUser = crt.list();
        Criteria crt1 = session.createCriteria(User.class);
        crt1.add(Restrictions.eq("noTelp", user.getNoTelp()));
        List<User> existUser1 = crt.list();
        if ((existUser.size() > 0) && (existUser1.size() > 0)) {
            isExistUser = true;
            response = "Email dan No. Telpon anda sudah terdaftar \n Gunakan email dan No. Telp yang lain";
        } else {
            if (existUser.size() > 0) {
                isExistUser = true;
                response = "Email anda sudah terdaftar \n Gunakan email yang lain";
            }
            if (existUser1.size() > 0) {
                isExistUser = true;
                response = "No Telp. anda sudah terdaftar \n Gunakan No Telpon lain";
            }
        }
        if (!isExistUser) {
            session.save(user);
            session.flush();
            response = "Succes";
            PushNotificationToFirebase pushNotif = new PushNotificationToFirebase();
            pushNotif.setMsgTitle("Konfirmasi Pendaftaran");
            pushNotif.setMsgBody("Terimaksih, Pendaftaran Account anda berhasil");
            pushNotif.setToken(user.getToken());
            new Thread(pushNotif).start();
        }
        HibernateHelper.commitTx(closeAfter);
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
    }
    return Response.status(201).entity(response).build();
}

######


@POST
@Path("/postUpdateUser")
@Consumes(MediaType.APPLICATION_JSON)
public Response postUpdateUser(User user) {
    String response = null;
    boolean closeAfter = false;
    try {
        closeAfter = HibernateHelper.beginTx();
        Session session = HibernateHelper.getSession();
        session.beginTransaction();
        session.update(user);
        session.flush();
        response = "Succes";
        HibernateHelper.commitTx(closeAfter);
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
    }
    return Response.status(201).entity(response).build();
}

######


@GET
@Path("/getUser")
@Produces(MediaType.APPLICATION_JSON)
public Response postGetUser(@QueryParam("email") String email, @QueryParam("password") String password) {
    String response = null;
    String json = "";
    boolean closeAfter = false;
    try {
        closeAfter = HibernateHelper.beginTx();
        Session session = HibernateHelper.getSession();
        session.beginTransaction();
        Criteria crt = session.createCriteria(User.class).add(Restrictions.eq("email", email)).add(Restrictions.eq("password", password));
        User user = (User) crt.setMaxResults(1).uniqueResult();
        if (user != null) {
            json = new Gson().toJson(user);
            response = "Succes";
        } else {
            response = "Gagal";
        }
        HibernateHelper.commitTx(closeAfter);
        return Response.ok(response + "/" + json).build();
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
        return Response.serverError().build();
    }
}

######


@POST
@Path("/postAddServiceProvides")
@Consumes(MediaType.APPLICATION_JSON)
public Response postUpdateUser(String serviceProvides) {
    String response = null;
    boolean closeAfter = false;
    List<ServiceProvide> listServiceProvide = new ArrayList<>();
    try {
        if (!serviceProvides.isEmpty()) {
            JsonParser jp = new JsonParser();
            JsonObject jo = (JsonObject) jp.parse(serviceProvides);
            JsonArray ja = jo.getAsJsonArray("serviceProvides");
            Gson gson = new Gson();
            for (JsonElement jsonElement : ja) {
                ServiceProvide sp = gson.fromJson(jsonElement, ServiceProvide.class);
                String fidUser = sp.getIdServiceProvide().split("/")[0];
                sp.setFidUser(fidUser);
                listServiceProvide.add(sp);
            }
            closeAfter = HibernateHelper.beginTx();
            Session session = HibernateHelper.getSession();
            session.beginTransaction();
            for (ServiceProvide sp : listServiceProvide) {
                Criteria cr = session.createCriteria(ServiceProvide.class).add(Restrictions.eq("idServiceProvide", sp.getIdServiceProvide()));
                List<ServiceProvide> listSP = cr.list();
                if (listSP.size() == 0) {
                    session.save(sp);
                    session.flush();
                }
            }
            response = "Succes";
            HibernateHelper.commitTx(closeAfter);
        }
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
    }
    return Response.status(201).entity(response).build();
}

######


@POST
@Path("/postDeleteServiceProvides")
@Consumes(MediaType.APPLICATION_JSON)
public Response postDeleteServiceProvides(ServiceProvide serviceProvide) {
    String response = null;
    boolean closeAfter = false;
    try {
        closeAfter = HibernateHelper.beginTx();
        Session session = HibernateHelper.getSession();
        session.beginTransaction();
        session.delete(serviceProvide);
        session.flush();
        response = "Succes";
        HibernateHelper.commitTx(closeAfter);
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
    }
    return Response.status(201).entity(response).build();
}

######


@POST
@Path("/postAddRequestOrder")
@Consumes(MediaType.APPLICATION_JSON)
public Response postAddRequestOrder(String request) {
    String response = null;
    boolean closeAfter = false;
    String idRequest = "";
    try {
        closeAfter = HibernateHelper.beginTx();
        Session session = HibernateHelper.getSession();
        session.beginTransaction();
        String[] splitRequest = request.split("#");
        String requestO = splitRequest[0];
        String requestDet = splitRequest[1];
        Gson gson = new Gson();
        RequestOrder ro = gson.fromJson(requestO, RequestOrder.class);
        Request req = new Request(ro);
        idRequest = ro.getIdRequest();
        session.save(req);
        session.flush();
        JsonParser jp = new JsonParser();
        JsonObject jo = (JsonObject) jp.parse(requestDet);
        JsonArray jaRequestDetail = jo.getAsJsonArray("requestDetail");
        for (JsonElement jsonElement : jaRequestDetail) {
            RequestDetail rd = gson.fromJson(jsonElement, RequestDetail.class);
            session.save(rd);
            session.flush();
        }
        response = "Succes";
        HibernateHelper.commitTx(closeAfter);
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
    }
    if (response.equals("Succes")) {
        AssignmentService assignmentService = new AssignmentService();
        assignmentService.setIdRequest(idRequest);
        new Thread(assignmentService).start();
    }
    return Response.status(201).entity(response).build();
}

######


@GET
@Path("/getRequestAccept")
@Produces(MediaType.APPLICATION_JSON)
public Response getRequestAccept(@QueryParam("idRequest") String idRequest, @QueryParam("idUserPenyediaJasa") String idUserPenyediaJasa) {
    String response = null;
    String json = "";
    boolean closeAfter = false;
    try {
        closeAfter = HibernateHelper.beginTx();
        Session session = HibernateHelper.getSession();
        session.beginTransaction();
        String SQL = "EXECUTE DBO.SELECT_REQUEST_ACCEPT '" + idRequest + "','" + idUserPenyediaJasa + "'";
        List<Object[]> listObject = session.createSQLQuery(SQL).list();
        RequestAccepted ra = new RequestAccepted();
        for (Object[] objects : listObject) {
            ra.setIdRequest(objects[0].toString());
            ra.setFidService(objects[1].toString());
            ra.setFidServiceProvide(objects[2].toString());
            ra.setFidUserCreate(objects[3].toString());
            ra.setClientName(objects[4].toString());
            ra.setClientFotoProfil(objects[5] != null ? objects[5].toString() : "");
            ra.setClientNoTelfon(objects[6].toString());
            ra.setStatus(objects[7].toString());
            ra.setLongitude(objects[8].toString());
            ra.setLatitude(objects[9].toString());
        }
        Criteria criteria = session.createCriteria(RequestDetail.class).add(Restrictions.eq("fidRequest", idRequest)).addOrder(Order.asc("fidServiceItem"));
        List<RequestDetail> listRequestDetail = criteria.list();
        HibernateHelper.commitTx(closeAfter);
        Gson gson = new Gson();
        json = gson.toJson(ra) + "#{requestDetail : " + gson.toJson(listRequestDetail) + "}";
        return Response.ok(json).build();
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
        return Response.serverError().build();
    }
}

######


@POST
@Path("/postAcceptedRequestTask")
@Produces(MediaType.APPLICATION_JSON)
public Response postAcceptedRequestTask(@QueryParam("idRequest") String idRequest, @QueryParam("idUserAccepted") String idUserAccepted, @QueryParam("idUserCreate") String idUserCreate) {
    String response = null;
    boolean closeAfter = false;
    try {
        closeAfter = HibernateHelper.beginTx();
        Session session = HibernateHelper.getSession();
        session.beginTransaction();
        String SQL = "  UPDATE A                                                                                                   " + " \n SET		A.STATUS = 'PROCESS',                                                                          " + " \n 		A.FID_SERVICE_PROVIDE = B.ID_SERVICE_PROVIDE,                                                      " + " \n 		A.FID_USER_ACCEPT = '" + idUserAccepted + "'                                                           " + " \n                                                                                                          " + " \n FROM TBL_REQUEST A LEFT JOIN TBL_SERVICE_PROVIDE B 													   " + "\n		ON A.FID_SERVICE = B.FID_SERVICE AND B.FID_USER = '" + idUserAccepted + "'  						   " + " \n WHERE A.ID_REQUEST = '" + idRequest + "'                                                                     ";
        session.createSQLQuery(SQL).executeUpdate();
        HistoryRequest hr = new HistoryRequest();
        hr.setIdHistoryRequest(String.valueOf(System.currentTimeMillis()));
        hr.setFidRequest(idRequest);
        hr.setCreateBy(idUserAccepted);
        hr.setCreateDate(new Date());
        hr.setStatus("PROCESS");
        session.save(hr);
        session.flush();
        response = "Succes";
        HibernateHelper.commitTx(closeAfter);
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
    }
    if (response.equals("Succes")) {
        String token = "";
        String userNameAccepted = "";
        String userNoTelp = "";
        try {
            closeAfter = HibernateHelper.beginTx();
            Session session = HibernateHelper.getSession();
            session.beginTransaction();
            User user = (User) session.createCriteria(User.class).add(Restrictions.eq("idUser", idUserAccepted)).setMaxResults(1).uniqueResult();
            User userAcceptNotif = (User) session.createCriteria(User.class).add(Restrictions.eq("idUser", idUserCreate)).setMaxResults(1).uniqueResult();
            token = userAcceptNotif.getToken();
            userNameAccepted = user.getUserName();
            userNoTelp = user.getNoTelp();
            HibernateHelper.commitTx(closeAfter);
        } catch (Exception e) {
            HibernateHelper.rollbackTx(closeAfter);
            e.printStackTrace();
        }
        PushNotificationToFirebase pushNotif = new PushNotificationToFirebase();
        pushNotif.setMsgBody("Penyedia jasa terdekat sedang menuju ke tempat anda");
        pushNotif.setMsgTitle("PROCESS#" + idRequest + "#" + idUserAccepted + "#" + userNameAccepted + "#" + userNoTelp);
        pushNotif.setToken(token);
        new Thread(pushNotif).start();
    }
    return Response.status(201).entity(response).build();
}

######


@POST
@Path("/postIgnoreRequestTask")
@Produces(MediaType.APPLICATION_JSON)
public Response postIgnoreRequestTask(@QueryParam("idRequest") String idRequest, @QueryParam("idUserAccepted") String idUserAccepted) {
    String response = null;
    boolean closeAfter = false;
    try {
        closeAfter = HibernateHelper.beginTx();
        Session session = HibernateHelper.getSession();
        session.beginTransaction();
        HistoryRequest hr = new HistoryRequest();
        hr.setIdHistoryRequest(String.valueOf(System.currentTimeMillis()));
        hr.setFidRequest(idRequest);
        hr.setCreateBy(idUserAccepted);
        hr.setCreateDate(new Date());
        hr.setStatus("IGNORE");
        session.save(hr);
        session.flush();
        response = "Succes";
        HibernateHelper.commitTx(closeAfter);
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
    }
    if (response.equals("Succes")) {
        AssignmentService assignmentService = new AssignmentService();
        assignmentService.setIdRequest(idRequest);
        new Thread(assignmentService).start();
    }
    return Response.status(201).entity(response).build();
}

######


@POST
@Path("/postFinishRequestTask")
@Produces(MediaType.APPLICATION_JSON)
public Response postFinishRequestTask(@QueryParam("idRequest") String idRequest, @QueryParam("idUserAccepted") String idUserAccepted) {
    String response = null;
    boolean closeAfter = false;
    try {
        closeAfter = HibernateHelper.beginTx();
        Session session = HibernateHelper.getSession();
        session.beginTransaction();
        String SQL = "UPDATE TBL_REQUEST SET STATUS = 'FINISH' WHERE ID_REQUEST = '" + idRequest + "'";
        session.createSQLQuery(SQL).executeUpdate();
        HistoryRequest hr = new HistoryRequest();
        hr.setIdHistoryRequest(String.valueOf(System.currentTimeMillis()));
        hr.setFidRequest(idRequest);
        hr.setCreateBy(idUserAccepted);
        hr.setCreateDate(new Date());
        hr.setStatus("FINISH");
        session.save(hr);
        session.flush();
        response = "Succes";
        HibernateHelper.commitTx(closeAfter);
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
    }
    if (response.equals("Succes")) {
        String token = "";
        String userNameAccepted = "";
        String userNoTelp = "";
        String serviceName = "";
        try {
            closeAfter = HibernateHelper.beginTx();
            Session session = HibernateHelper.getSession();
            session.beginTransaction();
            Request request = (Request) session.createCriteria(Request.class).add(Restrictions.eq("idRequest", idRequest)).setMaxResults(1).uniqueResult();
            User user = (User) session.createCriteria(User.class).add(Restrictions.eq("idUser", request.getFidUserCreate())).setMaxResults(1).uniqueResult();
            token = user.getToken();
            userNameAccepted = user.getUserName();
            userNoTelp = user.getNoTelp();
            Service service = (Service) session.createCriteria(Service.class).add(Restrictions.eq("idService", request.getFidService())).setMaxResults(1).uniqueResult();
            serviceName = service.getServiceName();
            HibernateHelper.commitTx(closeAfter);
        } catch (Exception e) {
            HibernateHelper.rollbackTx(closeAfter);
            e.printStackTrace();
        }
        if (!token.isEmpty()) {
            PushNotificationToFirebase pushNotif = new PushNotificationToFirebase();
            pushNotif.setMsgBody("Terimakasih telah menggunakan layanan kami");
            pushNotif.setMsgTitle("FINISH#" + idRequest + "#" + serviceName);
            pushNotif.setToken(token);
            new Thread(pushNotif).start();
        }
    }
    return Response.status(201).entity(response).build();
}

######


@POST
@Path("/postCancelRequestTask")
@Produces(MediaType.APPLICATION_JSON)
public Response postCancelRequestTask(@QueryParam("idRequest") String idRequest, @QueryParam("idUserAccepted") String idUserAccepted, @QueryParam("idUserCreated") String idUserCreated, @QueryParam("reason") String reason) {
    String response = null;
    boolean closeAfter = false;
    try {
        closeAfter = HibernateHelper.beginTx();
        Session session = HibernateHelper.getSession();
        session.beginTransaction();
        HistoryRequest hr = new HistoryRequest();
        hr.setIdHistoryRequest(String.valueOf(System.currentTimeMillis()));
        hr.setFidRequest(idRequest);
        hr.setCreateBy(idUserAccepted);
        hr.setCreateDate(new Date());
        hr.setStatus("CANCEL1");
        hr.setReason(reason);
        session.save(hr);
        session.flush();
        response = "Succes";
        HibernateHelper.commitTx(closeAfter);
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
    }
    if (response.equals("Succes")) {
        String token = "";
        try {
            closeAfter = HibernateHelper.beginTx();
            Session session = HibernateHelper.getSession();
            session.beginTransaction();
            User user = (User) session.createCriteria(User.class).add(Restrictions.eq("idUser", idUserCreated)).setMaxResults(1).uniqueResult();
            token = user.getToken();
            PushNotificationToFirebase pushNotif = new PushNotificationToFirebase();
            pushNotif.setMsgBody("Maaf, tukang service kami tidak bisa datang \n Kami sedang mencari penggantinya");
            pushNotif.setMsgTitle("CANCEL1#" + idRequest);
            pushNotif.setToken(token);
            new Thread(pushNotif).start();
            HibernateHelper.commitTx(closeAfter);
        } catch (Exception e) {
            HibernateHelper.rollbackTx(closeAfter);
            e.printStackTrace();
        }
        AssignmentService assignmentService = new AssignmentService();
        assignmentService.setIdRequest(idRequest);
        new Thread(assignmentService).start();
    }
    return Response.status(201).entity(response).build();
}

######


@POST
@Path("/postCancelRequestOrder")
@Produces(MediaType.APPLICATION_JSON)
public Response postCancelRequestOrder(@QueryParam("idRequest") String idRequest, @QueryParam("idUserCreated") String idUserCreated, @QueryParam("reason") String reason) {
    String response = null;
    boolean closeAfter = false;
    try {
        closeAfter = HibernateHelper.beginTx();
        Session session = HibernateHelper.getSession();
        session.beginTransaction();
        HistoryRequest hr = new HistoryRequest();
        hr.setIdHistoryRequest(String.valueOf(System.currentTimeMillis()));
        hr.setFidRequest(idRequest);
        hr.setCreateBy(idUserCreated);
        hr.setCreateDate(new Date());
        hr.setStatus("CANCEL2");
        hr.setReason(reason);
        session.save(hr);
        session.flush();
        response = "Succes";
        HibernateHelper.commitTx(closeAfter);
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
    }
    if (response.equals("Succes")) {
        String token = "";
        try {
            closeAfter = HibernateHelper.beginTx();
            Session session = HibernateHelper.getSession();
            session.beginTransaction();
            Request req = (Request) session.createCriteria(Request.class).add(Restrictions.eq("idRequest", idRequest)).setMaxResults(1).uniqueResult();
            User user = (User) session.createCriteria(User.class).add(Restrictions.eq("idUser", req.getFidUserAccept())).setMaxResults(1).uniqueResult();
            if (user != null) {
                token = user.getToken();
                PushNotificationToFirebase pushNotif = new PushNotificationToFirebase();
                pushNotif.setMsgBody("Maaf, request task telah di cancel oleh client \n Alasan cancel karena \"" + reason + "\"");
                pushNotif.setMsgTitle("CANCEL2#" + idRequest);
                pushNotif.setToken(token);
                new Thread(pushNotif).start();
            }
            HibernateHelper.commitTx(closeAfter);
        } catch (Exception e) {
            HibernateHelper.rollbackTx(closeAfter);
            e.printStackTrace();
        }
    }
    return Response.status(201).entity(response).build();
}

######


@POST
@Path("/postComentarClient")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response postComentarClient(Request requestParam) {
    String response = null;
    boolean closeAfter = false;
    Request request = new Request();
    try {
        closeAfter = HibernateHelper.beginTx();
        Session session = HibernateHelper.getSession();
        session.beginTransaction();
        request = (Request) session.createCriteria(Request.class).add(Restrictions.eq("idRequest", requestParam.getIdRequest())).setMaxResults(1).uniqueResult();
        request.setFinishCommentUser(requestParam.getFinishCommentUser());
        request.setHasilService(requestParam.getHasilService());
        session.update(request);
        session.flush();
        response = "Succes";
        HibernateHelper.commitTx(closeAfter);
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
    }
    if (response.equals("Succes")) {
        String token = "";
        String userNameAccepted = "";
        String userNoTelp = "";
        try {
            closeAfter = HibernateHelper.beginTx();
            Session session = HibernateHelper.getSession();
            session.beginTransaction();
            User user = (User) session.createCriteria(User.class).add(Restrictions.eq("idUser", request.getFidUserAccept())).setMaxResults(1).uniqueResult();
            token = user.getToken();
            userNameAccepted = user.getUserName();
            userNoTelp = user.getNoTelp();
            HibernateHelper.commitTx(closeAfter);
        } catch (Exception e) {
            HibernateHelper.rollbackTx(closeAfter);
            e.printStackTrace();
        }
        if (!token.isEmpty()) {
            PushNotificationToFirebase pushNotif = new PushNotificationToFirebase();
            pushNotif.setMsgBody("Hasil service " + request.getHasilService() + " || Client : " + request.getFinishCommentUser());
            pushNotif.setMsgTitle("COMMENT#" + request.getIdRequest() + "#" + request.getHasilService() + "#" + request.getFinishCommentUser());
            pushNotif.setToken(token);
            new Thread(pushNotif).start();
        }
    }
    return Response.status(201).entity(response).build();
}

######


@GET
@Path("/getServiceProvide")
@Produces(MediaType.APPLICATION_JSON)
public Response postGetServiceProvide(@QueryParam("idUser") String idUser) {
    String response = null;
    String json = "";
    boolean closeAfter = false;
    try {
        closeAfter = HibernateHelper.beginTx();
        Session session = HibernateHelper.getSession();
        session.beginTransaction();
        Criteria crt = session.createCriteria(ServiceProvide.class).add(Restrictions.eq("fidUser", idUser));
        List<ServiceProvide> listServiceProvide = crt.list();
        if (listServiceProvide.size() > 0) {
            json = "{serviceProvide : " + new Gson().toJson(listServiceProvide) + "}";
            response = "Succes";
        } else {
            response = "Gagal";
        }
        HibernateHelper.commitTx(closeAfter);
        return Response.ok(response + "#" + json).build();
    } catch (Exception e) {
        HibernateHelper.rollbackTx(closeAfter);
        e.printStackTrace();
        response = "Error";
        return Response.serverError().build();
    }
}

######


public void bubbleSort(int[] intArray) {
    for (int x = intArray.length - 1; x >= 0; x--) {
        for (int y = 0; y <= x - 1; y++) {
            System.out.println(y);
            if (intArray[y] > intArray[y + 1]) {
                System.out.println("SWAP");
                swap(intArray, y, y + 1);
            }
        }
        System.out.println("Change");
    }
    System.out.println("ARRAY SORTED");
    showArray(intArray);
}

######


public void selectionSort(int[] intArray) {
    for (int x = 0; x < intArray.length; x++) {
        int minimun = x;
        for (int y = x + 1; y < intArray.length; y++) {
            if (intArray[minimun] > intArray[y]) {
                minimun = y;
            }
        }
        if (minimun != x) {
            swap(intArray, minimun, x);
        }
    }
    System.out.println("ARRAY SORTED");
    showArray(intArray);
}

######


public void swap(int[] intArray, int x, int y) {
    int tmp = intArray[x];
    intArray[x] = intArray[y];
    intArray[y] = tmp;
}

######


public void insertionSort(int[] intArray) {
    for (int x = 1; x <= intArray.length - 1; x++) {
        int tmp = intArray[x];
        int current = x;
        while (current != 0 && intArray[current - 1] > tmp) {
            intArray[current] = intArray[current - 1];
            current--;
        }
        intArray[current] = tmp;
    }
    System.out.println("ARRAY SORTED");
    showArray(intArray);
}

######


public void insertionSortLazyApproach(int[] intArray) {
    for (int x = 1; x <= intArray.length - 1; x++) {
        int mark = x;
        int tmp = intArray[x];
        System.out.println("Mark = " + mark);
        for (int y = 0; y < mark; y++) {
            System.out.println("cheking partial sorted ---> " + y);
            if (intArray[mark] < intArray[y]) {
                System.out.println("Insert = " + mark + " into = " + y);
                for (int z = mark; z > y; z--) {
                    intArray[z] = intArray[z - 1];
                }
                intArray[y] = tmp;
            }
        }
    }
    System.out.println("Array Sorted: ");
    showArray(intArray);
}

######


public void showArray(int[] intArray) {
    for (int x = 0; x <= intArray.length - 1; x++) {
        System.out.println(intArray[x]);
    }
}

######


public static void main(String[] args) {
    SimpleSorting ss = new SimpleSorting();
    int[] intArray = { 4, 1, 3, 7, 5, 6, 2, 8, 9, 10 };
    ss.insertionSort(intArray);
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
}

######


public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException {
    final java.lang.String _jspx_method = request.getMethod();
    if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method) && !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET POST or HEAD");
        return;
    }
    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;
    try {
        response.setContentType("text/html");
        pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true);
        _jspx_page_context = pageContext;
        application = pageContext.getServletContext();
        config = pageContext.getServletConfig();
        session = pageContext.getSession();
        out = pageContext.getOut();
        _jspx_out = out;
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        out.write("\r\n");
        out.write("\t");
        String slab = request.getParameter("slab");
        int min = Integer.parseInt(request.getParameter("min"));
        int max = Integer.parseInt(request.getParameter("max"));
        float nooftrip = Float.parseFloat(request.getParameter("nooftrip"));
        int minmonth = Integer.parseInt(request.getParameter("minmonth"));
        int maxmonth = Integer.parseInt(request.getParameter("maxmonth"));
        int mindaily = Integer.parseInt(request.getParameter("mindaily"));
        int maxdaily = Integer.parseInt(request.getParameter("maxdaily"));
        Float average = Float.parseFloat(request.getParameter("average"));
        String sql1 = "INSERT INTO slabtable (`Slab`, `Min Distance`, `Max Distance`, `NoofTrip`, `Min Monthly Distance`, `Max Monthly Distance`, `Min Daily Distance`, `Max Daily Distance`, `Average`)VALUES(?,?,?,?,?,?,?,?,?)";
        try {
            Connection con1 = Connect.getconnection();
            PreparedStatement ps1 = con1.prepareStatement(sql1);
            ps1.setString(1, slab);
            ps1.setInt(2, min);
            ps1.setInt(3, max);
            ps1.setFloat(4, nooftrip);
            ps1.setInt(5, minmonth);
            ps1.setInt(6, maxmonth);
            ps1.setInt(7, mindaily);
            ps1.setInt(8, maxdaily);
            ps1.setFloat(9, average);
            ps1.executeUpdate();
            RequestDispatcher ReqDis = request.getRequestDispatcher("trip.jsp");
            ReqDis.forward(request, response);
        } catch (Exception e) {
            RequestDispatcher ReqDis = request.getRequestDispatcher("error.jsp");
            ReqDis.forward(request, response);
        }
    } catch (java.lang.Throwable t) {
        if (!(t instanceof javax.servlet.jsp.SkipPageException)) {
            out = _jspx_out;
            if (out != null && out.getBufferSize() != 0)
                try {
                    if (response.isCommitted()) {
                        out.flush();
                    } else {
                        out.clearBuffer();
                    }
                } catch (java.io.IOException e) {
                }
            if (_jspx_page_context != null)
                _jspx_page_context.handlePageException(t);
            else
                throw new ServletException(t);
        }
    } finally {
        _jspxFactory.releasePageContext(_jspx_page_context);
    }
}

######


@Insert(onConflict = OnConflictStrategy.REPLACE)
void addSmartFurniture(SmartFurniture smartFurniture);

######


@Query("SELECT * FROM SmartFurniture")
List<SmartFurniture> selectAll();

######


@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL("CREATE TABLE " + TABLE_SNAPSHOTS + "(" + Snapshots._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," + Snapshots.TITLE + " TEXT," + Snapshots.URL + " TEXT NOT NULL," + Snapshots.DATE_CREATED + " INTEGER," + Snapshots.FAVICON + " BLOB," + Snapshots.THUMBNAIL + " BLOB," + Snapshots.BACKGROUND + " INTEGER," + Snapshots.VIEWSTATE + " BLOB NOT NULL," + Snapshots.VIEWSTATE_PATH + " TEXT," + Snapshots.VIEWSTATE_SIZE + " INTEGER" + ");");
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    if (oldVersion < 2) {
        db.execSQL("DROP TABLE " + TABLE_SNAPSHOTS);
        onCreate(db);
    }
    if (oldVersion < 3) {
        db.execSQL("ALTER TABLE " + TABLE_SNAPSHOTS + " ADD COLUMN " + Snapshots.VIEWSTATE_PATH + " TEXT");
        db.execSQL("ALTER TABLE " + TABLE_SNAPSHOTS + " ADD COLUMN " + Snapshots.VIEWSTATE_SIZE + " INTEGER");
        db.execSQL("UPDATE " + TABLE_SNAPSHOTS + " SET " + Snapshots.VIEWSTATE_SIZE + " = length(" + Snapshots.VIEWSTATE + ")");
    }
}

######


static File getOldDatabasePath(Context context) {
    File dir = context.getExternalFilesDir(null);
    return new File(dir, SnapshotDatabaseHelper.DATABASE_NAME);
}

######


private void migrateToDataFolder() {
    File dbPath = getContext().getDatabasePath(SnapshotDatabaseHelper.DATABASE_NAME);
    if (dbPath.exists())
        return;
    File oldPath = getOldDatabasePath(getContext());
    if (oldPath.exists()) {
        if (!oldPath.renameTo(dbPath)) {
            FileUtils.copyFile(oldPath, dbPath);
        }
        oldPath.delete();
    }
}

######


@Override
public boolean onCreate() {
    migrateToDataFolder();
    mOpenHelper = new SnapshotDatabaseHelper(getContext());
    return true;
}

######


SQLiteDatabase getWritableDatabase() {
    return mOpenHelper.getWritableDatabase();
}

######


SQLiteDatabase getReadableDatabase() {
    return mOpenHelper.getReadableDatabase();
}

######


@Override
public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
    SQLiteDatabase db = getReadableDatabase();
    if (db == null) {
        return null;
    }
    final int match = URI_MATCHER.match(uri);
    SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
    String limit = uri.getQueryParameter(BrowserContract.PARAM_LIMIT);
    switch(match) {
        case SNAPSHOTS_ID:
            selection = DatabaseUtils.concatenateWhere(selection, "_id=?");
            selectionArgs = DatabaseUtils.appendSelectionArgs(selectionArgs, new String[] { Long.toString(ContentUris.parseId(uri)) });
        case SNAPSHOTS:
            qb.setTables(TABLE_SNAPSHOTS);
            break;
        default:
            throw new UnsupportedOperationException("Unknown URL " + uri.toString());
    }
    Cursor cursor = qb.query(db, projection, selection, selectionArgs, null, null, sortOrder, limit);
    cursor.setNotificationUri(getContext().getContentResolver(), AUTHORITY_URI);
    return cursor;
}

######


@Override
public String getType(Uri uri) {
    return null;
}

######


@Override
public Uri insert(Uri uri, ContentValues values) {
    SQLiteDatabase db = getWritableDatabase();
    if (db == null) {
        return null;
    }
    int match = URI_MATCHER.match(uri);
    long id = -1;
    switch(match) {
        case SNAPSHOTS:
            if (!values.containsKey(Snapshots.VIEWSTATE)) {
                values.put(Snapshots.VIEWSTATE, NULL_BLOB_HACK);
            }
            id = db.insert(TABLE_SNAPSHOTS, Snapshots.TITLE, values);
            break;
        default:
            throw new UnsupportedOperationException("Unknown insert URI " + uri);
    }
    if (id < 0) {
        return null;
    }
    Uri inserted = ContentUris.withAppendedId(uri, id);
    getContext().getContentResolver().notifyChange(inserted, null, false);
    return inserted;
}

######


private void deleteDataFiles(SQLiteDatabase db, String selection, String[] selectionArgs) {
    Cursor c = db.query(TABLE_SNAPSHOTS, DELETE_PROJECTION, selection, selectionArgs, null, null, null);
    final Context context = getContext();
    while (c.moveToNext()) {
        String filename = c.getString(0);
        if (TextUtils.isEmpty(filename)) {
            continue;
        }
        File f = context.getFileStreamPath(filename);
        if (f.exists()) {
            if (!f.delete()) {
                f.deleteOnExit();
            }
        }
    }
    c.close();
}

######


@Override
public int delete(Uri uri, String selection, String[] selectionArgs) {
    SQLiteDatabase db = getWritableDatabase();
    if (db == null) {
        return 0;
    }
    int match = URI_MATCHER.match(uri);
    int deleted = 0;
    switch(match) {
        case SNAPSHOTS_ID:
            {
                selection = DatabaseUtils.concatenateWhere(selection, TABLE_SNAPSHOTS + "._id=?");
                selectionArgs = DatabaseUtils.appendSelectionArgs(selectionArgs, new String[] { Long.toString(ContentUris.parseId(uri)) });
            }
        case SNAPSHOTS:
            deleteDataFiles(db, selection, selectionArgs);
            deleted = db.delete(TABLE_SNAPSHOTS, selection, selectionArgs);
            break;
        default:
            throw new UnsupportedOperationException("Unknown delete URI " + uri);
    }
    if (deleted > 0) {
        getContext().getContentResolver().notifyChange(uri, null, false);
    }
    return deleted;
}

######


@Override
public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
    throw new UnsupportedOperationException("not implemented");
}

######


public int getId() {
    return id;
}

######


public String getSpecialty() {
    return specialty;
}

######


public List<Doctors> getDoctors() {
    try (Connection con = DB.sql2o.open()) {
        String sql = "SELECT * FROM doctors WHERE specialty_id = :id ORDER BY name ASC";
        return con.createQuery(sql).addParameter("id", id).executeAndFetch(Doctors.class);
    }
}

######


@Override
public boolean equals(Object otherSpecialtyInstance) {
    if (!(otherSpecialtyInstance instanceof Specialty)) {
        return false;
    } else {
        Specialty newSpecialtyInstance = (Specialty) otherSpecialtyInstance;
        return this.getSpecialty().equals(newSpecialtyInstance.getSpecialty()) && this.getId() == newSpecialtyInstance.getId();
    }
}

######


public static List<Specialty> all() {
    String sql = "SELECT * FROM specialties";
    try (Connection con = DB.sql2o.open()) {
        return con.createQuery(sql).executeAndFetch(Specialty.class);
    }
}

######


public void save() {
    try (Connection con = DB.sql2o.open()) {
        String sql = "INSERT INTO specialties (specialty) VALUES (:specialty)";
        this.id = (int) con.createQuery(sql, true).addParameter("specialty", specialty).executeUpdate().getKey();
    }
}

######


public static Specialty find(int id) {
    try (Connection con = DB.sql2o.open()) {
        String sql = "SELECT * FROM specialties where id=:id";
        Specialty specialty = con.createQuery(sql).addParameter("id", id).executeAndFetchFirst(Specialty.class);
        return specialty;
    }
}

######


public void delete() {
    try (Connection con = DB.sql2o.open()) {
        String sql = "DELETE FROM specialties WHERE id = :id";
        con.createQuery(sql).addParameter("id", id).executeUpdate();
    }
}

######


public static void initializeOACC(Connection connection, String dbSchema, char[] oaccRootPwd, PasswordEncryptor passwordEncryptor) throws SQLException {
    initializeOACC(connection, dbSchema, oaccRootPwd, passwordEncryptor, false);
}

######


public static void initializeOACC(Connection connection, String dbSchema, char[] oaccRootPwd, PasswordEncryptor passwordEncryptor, boolean isSilent) throws SQLException {
    final AuthenticationProvider authProvider = new SQLPasswordAuthenticationProvider(connection, dbSchema, passwordEncryptor);
    final Credentials oaccRootCredentials = PasswordCredentials.newInstance(oaccRootPwd);
    initializeOACC(connection, dbSchema, oaccRootCredentials, authProvider, isSilent);
}

######


public static void initializeOACC(Connection connection, String dbSchema, Credentials oaccRootCredentials, AuthenticationProvider authProvider, boolean isSilent) throws SQLException {
    SchemaNameValidator.assertValid(dbSchema);
    final String schemaNameAndTablePrefix = dbSchema != null ? dbSchema + ".OAC_" : "OAC_";
    if (!isSilent) {
        System.out.println("Checking database...needs empty tables");
    }
    PreparedStatement statement = null;
    ResultSet resultSet;
    try {
        statement = connection.prepareStatement("SELECT  DomainId FROM " + schemaNameAndTablePrefix + "Domain WHERE DomainId = 0");
        resultSet = statement.executeQuery();
        if (resultSet.next()) {
            if (!isSilent) {
                System.out.println("Cannot initialize, likely that this OACC is already initialized! (check: found a system domain)");
            }
            resultSet.close();
            return;
        }
        statement.close();
        if (!isSilent) {
            System.out.println("Initializing database...assuming empty tables (will fail safely if tables have data)");
        }
        statement = connection.prepareStatement("INSERT INTO " + schemaNameAndTablePrefix + "Domain( DomainId, DomainName ) VALUES ( 0, ? )");
        statement.setString(1, AccessControlContext.SYSTEM_DOMAIN);
        statement.executeUpdate();
        statement.close();
        statement = connection.prepareStatement("INSERT INTO " + schemaNameAndTablePrefix + "ResourceClass( ResourceClassId, ResourceClassName, IsAuthenticatable, IsUnauthenticatedCreateAllowed ) VALUES ( 0, ?, 1, 0 )");
        statement.setString(1, AccessControlContext.SYSTEM_RESOURCE_CLASS);
        statement.executeUpdate();
        statement.close();
        statement = connection.prepareStatement("INSERT INTO " + schemaNameAndTablePrefix + "Resource( ResourceId, ResourceClassId, DomainId ) VALUES ( 0, 0, 0 )");
        statement.executeUpdate();
        statement.close();
        authProvider.setCredentials(Resources.getInstance(0), oaccRootCredentials);
        statement = connection.prepareStatement("INSERT INTO " + schemaNameAndTablePrefix + "Grant_DomPerm_Sys( AccessorResourceId, GrantorResourceId, AccessedDomainId, SysPermissionId, IsWithGrant )" + " VALUES ( 0, 0, 0, ?, 1 )");
        statement.setLong(1, DomainPermissions.getInstance(DomainPermissions.SUPER_USER).getSystemPermissionId());
        statement.executeUpdate();
        statement.close();
        statement = connection.prepareStatement("INSERT INTO " + schemaNameAndTablePrefix + "Grant_DomCrPerm_Sys( AccessorResourceId, GrantorResourceId, SysPermissionId, IsWithGrant )" + " VALUES ( 0, 0, ?, 1 )");
        statement.setLong(1, DomainCreatePermissions.getInstance(DomainCreatePermissions.CREATE).getSystemPermissionId());
        statement.executeUpdate();
        statement.close();
        statement = connection.prepareStatement("INSERT INTO " + schemaNameAndTablePrefix + "Grant_DomCrPerm_PostCr_Sys( AccessorResourceId, GrantorResourceId, PostCreateSysPermissionId, PostCreateIsWithGrant, IsWithGrant )" + " VALUES ( 0, 0, ?, 1, 1 )");
        statement.setLong(1, DomainPermissions.getInstance(DomainPermissions.SUPER_USER).getSystemPermissionId());
        statement.executeUpdate();
        statement.setLong(1, DomainPermissions.getInstance(DomainPermissions.CREATE_CHILD_DOMAIN).getSystemPermissionId());
        statement.executeUpdate();
        statement.setLong(1, DomainPermissions.getInstance(DomainPermissions.DELETE).getSystemPermissionId());
        statement.executeUpdate();
        statement.close();
    } finally {
        if (statement != null) {
            statement.close();
        }
    }
}

######


public static void prepare() {
    connectToDatabase();
    System.out.println(ANSI_CYAN + "Создание таблицы для триггера..." + ANSI_RESET);
    createProcedure(Query.tableForTrigger);
    System.out.println(ANSI_CYAN + "Создание триггера..." + ANSI_RESET);
    createProcedure(Query.createTrigger);
    System.out.println(ANSI_CYAN + "Создание процедур..." + ANSI_RESET);
    createProcedure(Query.createDoctorProcedure);
    createProcedure(Query.createAnimalProcedure);
    createProcedure(Query.createCabinetProcedure);
    createProcedure(Query.createOwnerProcedure);
    createProcedure(Query.createKindProcedure);
    createProcedure(Query.createLastUpdateProcedure);
    System.out.println(ANSI_CYAN + "Создание завершено ✔" + ANSI_RESET);
}

######


private static void connectToDatabase() {
    try {
        Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/PetClinic", "h3x", "pass");
        stmt = con.createStatement();
    } catch (Exception e) {
        System.out.println(ANSI_RED + e.toString() + ANSI_RESET);
    }
}

######


public static void addOwner(String name, String lastname, String num, String gender, String login) {
    UpdateQuery("insert into `owner` values " + "(NULL,'" + name + "','" + lastname + "','" + num + "','" + gender + "'," + "TRUE,'" + login + "');");
}

######


public static void addUser(String username, String password, String role) {
    UpdateQuery("insert into `user` values " + "('" + username + "','" + password + "','" + role + "');");
}

######


public static void addAnimal(String animalNameText, String animalAgeText, String animalWeightText, String owner_id, String kind_id) {
    UpdateQuery("insert into `animal` values " + "(NULL,'" + animalNameText + "','" + animalAgeText + "','" + animalWeightText + "',TRUE,'" + kind_id + "','" + owner_id + "');");
}

######


public HashMap<String, Doctor> getDoctor() {
    ExecuteQuery(Query.callDoctorProcedure);
    try {
        while (rs.next()) {
            doctors.put(rs.getString("doctor_id"), new Doctor(DoctorSpecialization.Ветеринар, rs.getString("doctor_id"), rs.getString("doctor_name"), rs.getString("doctor_lastname"), rs.getString("doctor_num"), rs.getString("doctor_gender"), rs.getString("cabinet_id")));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return doctors;
}

######


public HashMap<String, Kind> getKind() {
    ExecuteQuery(Query.callKindProcedure);
    try {
        while (rs.next()) {
            kinds.put(rs.getString("kind_id"), new Kind(rs.getString("kind_id"), rs.getString("kind_name")));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return kinds;
}

######


public HashMap<String, Patient> getOwner() {
    ExecuteQuery(Query.callOwnerProcedure);
    try {
        while (rs.next()) {
            owners.put(rs.getString("owner_id"), new Patient(rs.getString("owner_id"), rs.getString("owner_name"), rs.getString("owner_lastname"), rs.getString("owner_num"), rs.getString("owner_gender"), rs.getString("user_login")));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return owners;
}

######


public HashMap<String, Animal> getAnimal() {
    ExecuteQuery(Query.callAnimalProcedure);
    try {
        while (rs.next()) {
            animals.put(rs.getString("animal_id"), new Animal(rs.getString("animal_id"), rs.getString("animal_name"), rs.getString("animal_age"), rs.getString("animal_weight"), rs.getString("animal_status"), rs.getString("kind_id"), rs.getString("owner_id")));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return animals;
}

######


public HashMap<String, Cabinet> getCabinet() {
    ExecuteQuery(Query.callCabinetProcedure);
    try {
        while (rs.next()) {
            cabinets.put(rs.getString("cabinet_id"), new Cabinet(rs.getString("cabinet_id"), rs.getString("cabinet_num"), rs.getString("cabinet_type"), rs.getString("cabinet_level")));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return cabinets;
}

######


public static void addTicket(String date_order, String time, String animal_id, String owner_id, String doctor_id) {
    UpdateQuery("insert into `ticket` values " + "(NULL,'" + date_order + "','" + time + "',1,'" + owner_id + "','" + animal_id + "'," + doctor_id + ");");
}

######


public static void RemoveOwnerAndAnimal(String id, String petid) {
    UpdateQuery("delete from ticket where owner_id='" + id + "';");
    UpdateQuery("delete from animal where animal_id ='" + petid + "';");
    UpdateQuery("delete from owner where owner_id ='" + id + "';");
}

######


private static void UpdateQuery(String query) {
    try {
        stmt.executeUpdate(query);
    } catch (Exception e) {
        System.out.println(ANSI_RED + e.toString() + ANSI_RESET);
    } finally {
        System.out.println(ANSI_BLUE + "Запрос на обновление: " + ANSI_CYAN + query + "    " + ANSI_BLUE + "✔" + ANSI_RESET);
    }
}

######


private static void createProcedure(String query) {
    try {
        stmt.executeUpdate(query);
    } catch (Exception e) {
        System.out.println(ANSI_RED + e.toString() + ANSI_RESET);
    } finally {
        System.out.println(ANSI_PURPLE + query + ANSI_RESET);
    }
}

######


private static void ExecuteQuery(String query) {
    try {
        rs = stmt.executeQuery(query);
    } catch (Exception e) {
        System.out.println(ANSI_RED + e.toString() + ANSI_RESET);
    } finally {
        System.out.println(ANSI_PURPLE + "Запрос на получение: " + ANSI_BLUE + query + "     " + ANSI_PURPLE + "✔" + ANSI_RESET);
    }
}

######


public static String Login(String login, String password) {
    String count = "";
    ExecuteQuery("select count(*) from user where user_login='" + login + "' and user_password='" + password + "';");
    try {
        while (rs.next()) {
            count = rs.getString("count(*)");
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return count;
}

######


public static String loginRole(String login, String password) {
    String count = "";
    ExecuteQuery("select user_role from user where user_login='" + login + "' and user_password='" + password + "';");
    try {
        while (rs.next()) {
            count = rs.getString("user_role");
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return count;
}

######


public Patient getPatientByLogin(String login) {
    Patient patient = null;
    ExecuteQuery("select * from owner where user_login='" + login + "';");
    try {
        while (rs.next()) {
            patient = new Patient(rs.getString("owner_id"), rs.getString("owner_name"), rs.getString("owner_lastname"), rs.getString("owner_num"), rs.getString("owner_gender"), rs.getString("user_login"));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return patient;
}

######


public Doctor getDoctorByLogin(String login) {
    Doctor doctor = new Doctor(null, null, null, null, null, null, null);
    ExecuteQuery("select * from doctor where user_login='" + login + "';");
    try {
        while (rs.next()) {
            doctor = new Doctor(DoctorSpecialization.Ветеринар, rs.getString("doctor_id"), rs.getString("doctor_name"), rs.getString("doctor_lastname"), rs.getString("doctor_num"), rs.getString("doctor_gender"), rs.getString("cabinet_id"));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return doctor;
}

######


public ObservableList<Pet> getPetsForTableView(String owner_id) {
    ObservableList<Pet> petlist = FXCollections.observableArrayList();
    ExecuteQuery("select * from animal where owner_id='" + owner_id + "' and animal_status = 1;");
    try {
        while (rs.next()) {
            petlist.add(new Pet(rs.getString("animal_name"), rs.getString("animal_age")));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return petlist;
}

######


public ObservableList<Ticket> getTicketsForTableView(String owner_id) {
    ObservableList<Ticket> ticketlist = FXCollections.observableArrayList();
    ExecuteQuery("select * from ticket where owner_id='" + owner_id + "' and ticket_status = 1;");
    try {
        while (rs.next()) {
            ticketlist.add(new Ticket(rs.getString("ticket_date") + '\n' + rs.getString("ticket_time"), getDoctorNameForTableView(rs.getString("doctor_id"))));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return ticketlist;
}

######


public ObservableList<Ticket> getTicketsForTableViewForDoctor(String doctor_id) {
    ObservableList<Ticket> ticketlist = FXCollections.observableArrayList();
    ExecuteQuery("select * from ticket join animal,kind where doctor_id ='" + doctor_id + "' and ticket.animal_id = animal.animal_id and animal.kind_id = kind.kind_id" + " and ticket_status = 1;");
    try {
        while (rs.next()) {
            ticketlist.add(new Ticket(rs.getString("ticket_date") + '\n' + rs.getString("ticket_time"), rs.getString("kind_name")));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return ticketlist;
}

######


private String getDoctorNameForTableView(String doctor_id) {
    String name = "";
    Map<String, Doctor> doctorssql = Data.doctors;
    for (Map.Entry<String, Doctor> entry : doctorssql.entrySet()) if (entry.getValue().getID().equals(doctor_id))
        name = entry.getValue().getName() + ' ' + entry.getValue().getLastName();
    return name;
}

######


public HashMap<String, Animal> getAnimalByOwnerId(String owner_id) {
    ExecuteQuery("select * from animal where owner_id='" + owner_id + "' and animal_status = 1;");
    try {
        while (rs.next()) {
            animals.put(rs.getString("animal_id"), new Animal(rs.getString("animal_id"), rs.getString("animal_name"), rs.getString("animal_age"), rs.getString("animal_weight"), rs.getString("animal_status"), rs.getString("kind_id"), rs.getString("owner_id")));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return animals;
}

######


public HashMap<String, TicketEntity> getTicketsByDoctorid(String doctor_id) {
    ExecuteQuery("select * from ticket where doctor_id='" + doctor_id + "' and ticket_status = 1;");
    try {
        while (rs.next()) {
            tickets.put(rs.getString("ticket_id"), new TicketEntity(rs.getString("ticket_id"), rs.getString("ticket_date"), rs.getString("ticket_time"), rs.getString("ticket_status"), rs.getString("owner_id"), rs.getString("animal_id"), rs.getString("doctor_id")));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return tickets;
}

######


public static String getNameOfAnimalById(String animal_id) {
    String out = "";
    ExecuteQuery("select animal_name from animal where animal_id='" + animal_id + "' and animal_status = 1;");
    try {
        while (rs.next()) {
            out = rs.getString("animal_name");
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return out;
}

######


public static String getOwnerNameById(String owner_id) {
    String out = "";
    ExecuteQuery("select owner_name,owner_lastname from owner where owner_id='" + owner_id + "' and owner_status = 1;");
    try {
        while (rs.next()) {
            out = rs.getString("owner_name");
            out += " " + rs.getString("owner_lastname");
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return out;
}

######


public static String getKindByAnimalId(String animal_id) {
    String out = "";
    ExecuteQuery("select kind_name from kind join animal where animal.kind_id = kind.kind_id and animal_id = '" + animal_id + "';");
    try {
        while (rs.next()) {
            out = rs.getString("kind_name");
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return out;
}

######


public static Patient getPatientByPatientId(String owner_id) {
    Patient p = null;
    ExecuteQuery("select * from owner where owner_id = '" + owner_id + "' and owner_status = 1;");
    try {
        while (rs.next()) {
            p = new Patient(rs.getString("owner_id"), rs.getString("owner_name"), rs.getString("owner_lastname"), rs.getString("owner_num"), rs.getString("owner_gender"), rs.getString("user_login"));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return p;
}

######


public static Animal getAnimalByAnimal_id(String animal_id) {
    Animal a = null;
    ExecuteQuery("select * from animal where animal_id = '" + animal_id + "' and animal_status= 1;");
    try {
        while (rs.next()) {
            a = new Animal(rs.getString("animal_id"), rs.getString("animal_name"), rs.getString("animal_age"), rs.getString("animal_weight"), rs.getString("animal_status"), rs.getString("kind_id"), rs.getString("owner_id"));
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return a;
}

######


public static void deleteTicket(String ticket_id) {
    UpdateQuery("update ticket set ticket_status='0' where ticket_id ='" + ticket_id + "';");
}

######


public static void updateTicket(String time, String date, String ticket_id) {
    UpdateQuery("update ticket set ticket_time='" + time + "', ticket_date='" + date + "' where ticket_id ='" + ticket_id + "';");
}

######


public void deleteAnimalById(String animal_id) {
    UpdateQuery("update animal set animal_status='0' where animal_id ='" + animal_id + "';");
    UpdateQuery("update ticket set ticket_status='0' where animal_id ='" + animal_id + "';");
}

######


public static void updateOwner(Patient p) {
    UpdateQuery("update owner set owner_name = '" + p.getName() + "',owner_lastname = '" + p.getLastName() + "',owner_gender ='" + p.getGender() + "',owner_num = '" + p.getNum() + "' where owner_id ='" + p.getID() + "';");
}

######


public static void deleteOwner(Patient p) {
    UpdateQuery("update owner set owner_status = 0 where owner_id ='" + p.getID() + "';");
}

######


public static String isAccountEnabled(String login) {
    String count = "";
    ExecuteQuery("select count(*) from owner,doctor where owner.user_login = '" + login + "' and owner.owner_status = 1 or" + " doctor.user_login = '" + login + "';");
    try {
        while (rs.next()) {
            count = rs.getString("count(*)");
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return count;
}

######


public static void updateDoctor(Doctor d) {
    UpdateQuery("update doctor set doctor_name= '" + d.getName() + "',doctor_lastname= '" + d.getLastName() + "',doctor_gender='" + d.getGender() + "',doctor_num= '" + d.getNum() + "' where doctor_id='" + d.getID() + "';");
}

######


public static String lastUpdate(String id) {
    String out = "";
    ExecuteQuery("call getLastUpdate('" + id + "');");
    try {
        while (rs.next()) {
            out = rs.getString("changedat");
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
    }
    return out;
}

######


public void generateTables(List<String> queryForCreateTables) {
    try (Statement statement = this.getStatement()) {
        for (String query : queryForCreateTables) statement.execute(query);
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public void disableCheckForeignKeys() {
    try (Statement statement = this.getStatement()) {
        statement.execute("SET FOREIGN_KEY_CHECKS = 0;");
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


public void enableCheckForeignKeys() {
    try (Statement statement = this.getStatement()) {
        statement.execute("SET FOREIGN_KEY_CHECKS = 1;");
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL("CREATE TABLE " + TABLE_MARKET + " (" + GLOBAL_ROWID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + MARKET_NAME + " TEXT NOT NULL, " + MARKET_COLOR + " TEXT NOT NULL, " + MARKET_IMAGE + " TEXT NOT NULL, " + MARKET_PRICE + " TEXT NOT NULL, " + MARKET_DATE + " TEXT NOT NULL, " + MARKET_LINK + " TEXT NOT NULL, " + MARKET_SUB_CATEGORY + " TEXT NOT NULL, " + MARKET_COLLECTION + " TEXT NOT NULL);");
    db.execSQL("CREATE TABLE " + TABLE_INVENTORY + " (" + GLOBAL_ROWID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + INVENTORY_ITEMS_ID + " TEXT NOT NULL, " + INVENTORY_ITEMS_QUANTITY + " TEXT NOT NULL);");
    db.execSQL("CREATE TABLE " + TABLE_MAIN_CATEGORY + " (" + GLOBAL_ROWID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + MAIN_CATEGORY_NAME + " TEXT NOT NULL);");
    db.execSQL("CREATE TABLE " + TABLE_SUB_CATEGORY + " (" + GLOBAL_ROWID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + SUB_CATEGORY_RELATED_ID + " TEXT NOT NULL, " + SUB_CATEGORY_NAME + " TEXT NOT NULL);");
    Log.e(TAG, "Created DB");
}

######


@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    db.execSQL("DROP TABLE IF EXISTS " + TABLE_MARKET);
    db.execSQL("DROP TABLE IF EXISTS " + TABLE_INVENTORY);
    db.execSQL("DROP TABLE IF EXISTS " + TABLE_MAIN_CATEGORY);
    db.execSQL("DROP TABLE IF EXISTS " + TABLE_SUB_CATEGORY);
    onCreate(db);
}

######


public SQLFunctions open() throws SQLException {
    ourHelper = new DbHelper(ourContext);
    ourDatabase = ourHelper.getWritableDatabase();
    return null;
}

######


public void close() {
    if (ourHelper != null) {
        ourHelper.close();
    } else {
        Log.e(TAG, "You did not open your database. Null error");
    }
}

######


public long unixTime() {
    return System.currentTimeMillis() / 1000L;
}

######


public boolean longerThanTwoHours(String pTime) {
    int prevTime = Integer.parseInt(pTime);
    int currentTime = (int) (System.currentTimeMillis() / 1000L);
    int seconds = currentTime - prevTime;
    int how_many;
    if (seconds > 3600 && seconds < 86400) {
        how_many = (int) seconds / 3600;
        if (how_many >= 2) {
            return true;
        } else {
            return false;
        }
    }
    return false;
}

######


public String getLastRowId() {
    String sql = "SELECT * FROM " + TABLE_MARKET + " ORDER BY " + GLOBAL_ROWID + " DESC LIMIT 1";
    Cursor cursor = ourDatabase.rawQuery(sql, null);
    if (cursor != null) {
        if (cursor.moveToFirst()) {
            String id = cursor.getString(cursor.getColumnIndex(GLOBAL_ROWID));
            cursor.close();
            Log.e("LATEST SQL ROW", id);
            return id;
        }
    }
    cursor.close();
    return "";
}

######


public HashMap<String, String> getItemInformation(String name) {
    HashMap<String, String> map = new HashMap<String, String>();
    String sql = "SELECT * FROM " + TABLE_MARKET + " WHERE " + MARKET_NAME + " = ?";
    Cursor cursor = ourDatabase.rawQuery(sql, new String[] { name });
    if (cursor != null) {
        if (cursor.moveToFirst()) {
            map.put("link", cursor.getString(cursor.getColumnIndex(MARKET_LINK)));
        }
    }
    cursor.close();
    return map;
}

######


public ArrayList<HashMap<String, String>> loadInventory() {
    ArrayList<HashMap<String, String>> map = new ArrayList<HashMap<String, String>>();
    Cursor cursor = ourDatabase.rawQuery("SELECT * FROM " + TABLE_MARKET + " m LEFT JOIN " + TABLE_INVENTORY + " i ON i." + INVENTORY_ITEMS_ID + " = m." + GLOBAL_ROWID, null);
    if (cursor != null) {
        if (cursor.moveToFirst()) {
            while (cursor.isAfterLast() == false) {
                HashMap<String, String> hash = new HashMap<String, String>();
                Log.e("IMAGE", cursor.getString(cursor.getColumnIndex(MARKET_IMAGE)));
                hash.put("image", cursor.getString(cursor.getColumnIndex(MARKET_IMAGE)));
                hash.put("quantity", cursor.getString(cursor.getColumnIndex(INVENTORY_ITEMS_QUANTITY)));
                map.add(hash);
                cursor.moveToNext();
            }
        }
    }
    cursor.close();
    return map;
}

######


public ArrayList<HashMap<String, String>> loadMarketPage(boolean loadByDate) {
    ArrayList<HashMap<String, String>> map = new ArrayList<HashMap<String, String>>();
    Cursor cursor;
    if (!loadByDate) {
        cursor = ourDatabase.rawQuery("SELECT * FROM " + TABLE_MARKET + " ORDER BY " + MARKET_NAME + " ASC", null);
    } else {
        cursor = ourDatabase.rawQuery("SELECT * FROM " + TABLE_MARKET + " ORDER BY " + MARKET_DATE + " DESC", null);
    }
    if (cursor != null) {
        if (cursor.moveToFirst()) {
            while (cursor.isAfterLast() == false) {
                HashMap<String, String> hash = new HashMap<String, String>();
                hash.put("name", cursor.getString(cursor.getColumnIndex(MARKET_NAME)));
                hash.put("price", cursor.getString(cursor.getColumnIndex(MARKET_PRICE)));
                hash.put("color", cursor.getString(cursor.getColumnIndex(MARKET_COLOR)));
                hash.put("image", cursor.getString(cursor.getColumnIndex(MARKET_IMAGE)));
                hash.put("id", cursor.getString(cursor.getColumnIndex(GLOBAL_ROWID)));
                map.add(hash);
                cursor.moveToNext();
            }
        }
    }
    cursor.close();
    return map;
}

######


public ArrayList<HashMap<String, String>> loadMarketPage(int page) {
    int previousLimit = 0;
    int nextLimit = page * Consts.ITEMS_LOAD_LIMIT;
    if (page > 1) {
        previousLimit = (page - 1) * Consts.ITEMS_LOAD_LIMIT + 1;
    }
    Log.e("LIMIT", previousLimit + "|" + nextLimit);
    ArrayList<HashMap<String, String>> map = new ArrayList<HashMap<String, String>>();
    Cursor cursor = ourDatabase.rawQuery("SELECT * FROM " + TABLE_MARKET + " ORDER BY " + MARKET_NAME + " ASC LIMIT " + previousLimit + " , " + nextLimit, null);
    if (cursor != null) {
        if (cursor.moveToFirst()) {
            while (cursor.isAfterLast() == false) {
                HashMap<String, String> hash = new HashMap<String, String>();
                hash.put("name", cursor.getString(cursor.getColumnIndex(MARKET_NAME)));
                hash.put("price", cursor.getString(cursor.getColumnIndex(MARKET_PRICE)));
                hash.put("color", cursor.getString(cursor.getColumnIndex(MARKET_COLOR)));
                hash.put("image", cursor.getString(cursor.getColumnIndex(MARKET_IMAGE)));
                hash.put("id", cursor.getString(cursor.getColumnIndex(GLOBAL_ROWID)));
                map.add(hash);
                cursor.moveToNext();
            }
        }
    }
    cursor.close();
    return map;
}

######


public void insertMainCategory(String mainCategory) {
    ContentValues cv = new ContentValues();
    String sql = "SELECT * FROM " + TABLE_MAIN_CATEGORY + " WHERE " + MAIN_CATEGORY_NAME + " = ?";
    Cursor cursor = ourDatabase.rawQuery(sql, new String[] { mainCategory });
    if (cursor.moveToFirst()) {
    } else {
        cv.put(MAIN_CATEGORY_NAME, mainCategory);
        try {
            ourDatabase.insert(TABLE_MAIN_CATEGORY, null, cv);
        } catch (Exception e) {
            Log.e(TAG, "Error creating main category");
        }
    }
    cursor.close();
}

######


public void insertSubCategory(String mainCategory, ArrayList<String> subCategory) {
    ContentValues cv = new ContentValues();
    String sql = "SELECT * FROM " + TABLE_MAIN_CATEGORY + " WHERE " + MAIN_CATEGORY_NAME + " = ?";
    Cursor cursor = ourDatabase.rawQuery(sql, new String[] { mainCategory });
    if (cursor.moveToFirst()) {
        String id = cursor.getString(cursor.getColumnIndex(GLOBAL_ROWID));
        for (String s : subCategory) {
            cv.put(SUB_CATEGORY_RELATED_ID, id);
            cv.put(SUB_CATEGORY_NAME, s);
            try {
                ourDatabase.insert(TABLE_SUB_CATEGORY, null, cv);
            } catch (Exception e) {
                Log.e(TAG, "Error creating sub category");
            }
        }
    } else {
        Log.e(TAG, "Tryin to create sub category without main category -> " + mainCategory);
    }
    cursor.close();
}

######


public void insertMarketItem(String name, String color, String image, String price, String date, String link, String subCategory, String collection) {
    ContentValues cv = new ContentValues();
    String sql = "SELECT * FROM " + TABLE_MARKET + " WHERE " + MARKET_NAME + " = ?";
    Cursor cursor = ourDatabase.rawQuery(sql, new String[] { name });
    if (cursor.moveToFirst()) {
    } else {
        cv.put(MARKET_NAME, name);
        cv.put(MARKET_COLOR, color);
        cv.put(MARKET_IMAGE, image);
        cv.put(MARKET_PRICE, price);
        cv.put(MARKET_DATE, date);
        cv.put(MARKET_LINK, link);
        cv.put(MARKET_SUB_CATEGORY, subCategory);
        cv.put(MARKET_COLLECTION, collection);
        try {
            ourDatabase.insert(TABLE_MARKET, null, cv);
        } catch (Exception e) {
            Log.e(TAG, "Error creating market entry", e);
        }
    }
    cursor.close();
}

######


public String getItemPrices(String id) {
    Cursor cursor = ourDatabase.rawQuery("SELECT * FROM " + TABLE_MARKET + " WHERE " + GLOBAL_ROWID + " = '" + id + "'", null);
    if (cursor != null) {
        if (cursor.moveToFirst()) {
            String value = cursor.getString(cursor.getColumnIndex(MARKET_PRICE));
            cursor.close();
            return value;
        }
    }
    cursor.close();
    return Consts.MARKET_ITEM_NOT_FOUND;
}

######


public void purchaseMarketItem(String id) {
    ContentValues cv = new ContentValues();
    String sql = "SELECT * FROM " + TABLE_INVENTORY + " WHERE " + INVENTORY_ITEMS_ID + " = '" + id + "'";
    Cursor cursor = ourDatabase.rawQuery(sql, null);
    if (cursor.moveToFirst()) {
        String squantity = cursor.getString(cursor.getColumnIndex(INVENTORY_ITEMS_QUANTITY));
        Log.e("BUYBUY", "User have " + squantity + " of this item");
        try {
            int quantity = Integer.parseInt(squantity);
            int newQuantity = quantity + 1;
            cv.put(INVENTORY_ITEMS_QUANTITY, String.valueOf(newQuantity));
            String whereClause = INVENTORY_ITEMS_ID + "=?";
            String[] whereArgs = new String[] { id };
            try {
                ourDatabase.update(TABLE_INVENTORY, cv, whereClause, whereArgs);
            } catch (Exception e) {
                Log.e(TAG, "Error updating purchaseMarketItem entry", e);
            }
            cursor.close();
        } catch (Exception e) {
            Log.e("purchaseMarketItem", "User tried to edit inventory quantity?");
        }
    } else {
        cv.put(INVENTORY_ITEMS_ID, id);
        cv.put(INVENTORY_ITEMS_QUANTITY, "1");
        try {
            ourDatabase.insert(TABLE_INVENTORY, null, cv);
        } catch (Exception e) {
            Log.e(TAG, "Error creating purchaseMarketItem entry", e);
        }
    }
    cursor.close();
}

######


public String insertTable3_2(Name name) {
    return "insert into table3 (id, name) values(#{nameId}, #{name})";
}

######


@Test
public void shouldSelectOne() throws Exception {
    DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES);
    runScript(ds, JPETSTORE_DDL);
    runScript(ds, JPETSTORE_DATA);
    Connection connection = ds.getConnection();
    SqlRunner exec = new SqlRunner(connection);
    Map<String, Object> row = exec.selectOne("SELECT * FROM PRODUCT WHERE PRODUCTID = ?", "FI-SW-01");
    connection.close();
    assertEquals("FI-SW-01", row.get("PRODUCTID"));
}

######


@Test
public void shouldSelectList() throws Exception {
    DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES);
    runScript(ds, JPETSTORE_DDL);
    runScript(ds, JPETSTORE_DATA);
    Connection connection = ds.getConnection();
    SqlRunner exec = new SqlRunner(connection);
    List<Map<String, Object>> rows = exec.selectAll("SELECT * FROM PRODUCT");
    connection.close();
    assertEquals(16, rows.size());
}

######


@Test
public void shouldInsert() throws Exception {
    DataSource ds = createUnpooledDataSource(BLOG_PROPERTIES);
    runScript(ds, BLOG_DDL);
    Connection connection = ds.getConnection();
    SqlRunner exec = new SqlRunner(connection);
    exec.setUseGeneratedKeySupport(true);
    int id = exec.insert("INSERT INTO author (username, password, email, bio) VALUES (?,?,?,?)", "someone", "******", "someone@apache.org", Null.LONGVARCHAR);
    Map<String, Object> row = exec.selectOne("SELECT * FROM author WHERE username = ?", "someone");
    connection.rollback();
    connection.close();
    assertTrue(SqlRunner.NO_GENERATED_KEY != id);
    assertEquals("someone", row.get("USERNAME"));
}

######


@Test
public void shouldUpdateCategory() throws Exception {
    DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES);
    runScript(ds, JPETSTORE_DDL);
    runScript(ds, JPETSTORE_DATA);
    Connection connection = ds.getConnection();
    SqlRunner exec = new SqlRunner(connection);
    int count = exec.update("update product set category = ? where productid = ?", "DOGS", "FI-SW-01");
    Map<String, Object> row = exec.selectOne("SELECT * FROM PRODUCT WHERE PRODUCTID = ?", "FI-SW-01");
    connection.close();
    assertEquals("DOGS", row.get("CATEGORY"));
    assertEquals(1, count);
}

######


@Test
public void shouldDeleteOne() throws Exception {
    DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES);
    runScript(ds, JPETSTORE_DDL);
    runScript(ds, JPETSTORE_DATA);
    Connection connection = ds.getConnection();
    SqlRunner exec = new SqlRunner(connection);
    int count = exec.delete("delete from item");
    List<Map<String, Object>> rows = exec.selectAll("SELECT * FROM ITEM");
    connection.close();
    assertEquals(28, count);
    assertEquals(0, rows.size());
}

######


@Test
public void shouldDemonstrateDDLThroughRunMethod() throws Exception {
    DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES);
    Connection connection = ds.getConnection();
    SqlRunner exec = new SqlRunner(connection);
    exec.run("CREATE TABLE BLAH(ID INTEGER)");
    exec.run("insert into BLAH values (1)");
    List<Map<String, Object>> rows = exec.selectAll("SELECT * FROM BLAH");
    exec.run("DROP TABLE BLAH");
    connection.close();
    assertEquals(1, rows.size());
}

######


public static List selectList(String sql, Class classFile) throws Exception {
    PreparedStatement ps = DBUtil.createStatement(sql);
    ResultSet rs = null;
    Field[] fieldArray = null;
    List list = new ArrayList();
    try {
        rs = ps.executeQuery();
        fieldArray = classFile.getDeclaredFields();
        while (rs.next()) {
            Object obj = classFile.newInstance();
            for (int i = 0; i < fieldArray.length; i++) {
                Field fieldObj = fieldArray[i];
                String fieldName = fieldObj.getName();
                String value = rs.getString(fieldName);
                init(obj, value, fieldObj);
            }
            list.add(obj);
        }
    } finally {
        DBUtil.close(rs);
    }
    return list;
}

######


private static void init(Object obj, String value, Field fieldObj) throws Exception {
    fieldObj.setAccessible(true);
    if (value == null) {
        fieldObj.set(obj, value);
    } else {
        String typeName = fieldObj.getType().getName();
        if ("java.lang.Integer".equals(typeName)) {
            fieldObj.set(obj, Integer.valueOf(value));
        } else if ("java.lang.Double".equals(typeName)) {
            fieldObj.set(obj, Double.valueOf(value));
        } else if ("java.lang.String".equals(typeName)) {
            fieldObj.set(obj, value);
        }
    }
}

######


public static int insert(Object obj) throws Exception {
    String tableName = null;
    StringBuffer columnStr = new StringBuffer("(");
    StringBuffer valueStr = new StringBuffer(" value(");
    StringBuffer sql = new StringBuffer("INSERT INTO  ");
    Field[] fieldArray = null;
    PreparedStatement ps = null;
    int flag = 0;
    tableName = getName(obj.getClass());
    try {
        fieldArray = obj.getClass().getDeclaredFields();
        for (int i = 0; i < fieldArray.length; i++) {
            Field fieldObj = fieldArray[i];
            fieldObj.setAccessible(true);
            Object value = fieldObj.get(obj);
            String typeName = fieldObj.getType().getName();
            if ("java.lang.String".equals(typeName)) {
                if (value != null && !"".equals(value)) {
                    if (columnStr.length() == 1) {
                        columnStr.append(fieldObj.getName());
                        valueStr.append("'");
                        valueStr.append(value);
                        valueStr.append("'");
                    } else {
                        columnStr.append(",");
                        columnStr.append(fieldObj.getName());
                        valueStr.append(",'");
                        valueStr.append(value);
                        valueStr.append("'");
                    }
                }
            } else if ("java.lang.Integer".equals(typeName) || "java.lang.Double".equals(typeName)) {
                if (value != null && ((Integer) value) != 0) {
                    if (columnStr.length() == 1) {
                        columnStr.append(fieldObj.getName());
                        valueStr.append(value);
                    } else {
                        columnStr.append(",");
                        columnStr.append(fieldObj.getName());
                        valueStr.append(",");
                        valueStr.append(value);
                    }
                }
            }
        }
        columnStr.append(")");
        valueStr.append(")");
        sql.append(tableName);
        sql.append(columnStr);
        sql.append(valueStr);
        System.out.println("sql: " + sql.toString());
        ps = DBUtil.createStatement(sql.toString());
        flag = ps.executeUpdate();
    } finally {
        DBUtil.close(null);
    }
    return flag;
}

######


private static String getName(Class classFile) {
    String classPath = classFile.getName();
    int index = classPath.lastIndexOf(".");
    String typeName = classPath.substring(index + 1);
    return typeName;
}

######


public static int update(Object obj, String primaryKey) throws Exception {
    String tableName = null;
    StringBuffer setBuffer = new StringBuffer(" set ");
    StringBuffer whereBuffer = new StringBuffer(" where ");
    StringBuffer sql = new StringBuffer("update ");
    Field[] fieldArray = null;
    int flag = 0;
    PreparedStatement ps = null;
    tableName = getName(obj.getClass());
    try {
        fieldArray = obj.getClass().getDeclaredFields();
        for (int i = 0; i < fieldArray.length; i++) {
            Field fieldObj = fieldArray[i];
            fieldObj.setAccessible(true);
            String fieldName = fieldObj.getName();
            String typeName = fieldObj.getType().getName();
            Object value = fieldObj.get(obj);
            if (value == null) {
                continue;
            }
            if (fieldName.equals(primaryKey)) {
                whereBuffer.append(fieldName);
                whereBuffer.append(" = ");
                if ("java.lang.String".equals(typeName) || "java.util.Date".equals(typeName)) {
                    whereBuffer.append("'");
                    whereBuffer.append(value);
                    whereBuffer.append("'");
                } else {
                    whereBuffer.append(value);
                }
            } else {
                if (setBuffer.length() > 5) {
                    setBuffer.append(",");
                }
                setBuffer.append(fieldName);
                setBuffer.append(" = ");
                if ("java.lang.String".equals(typeName) || "java.util.Date".equals(typeName)) {
                    setBuffer.append("'");
                    setBuffer.append(value);
                    setBuffer.append("'");
                } else {
                    setBuffer.append(value);
                }
            }
        }
        sql.append(tableName);
        sql.append(setBuffer);
        sql.append(whereBuffer);
        System.out.println("sql : " + sql);
        ps = DBUtil.createStatement(sql.toString());
        flag = ps.executeUpdate();
    } finally {
    }
    return flag;
}

######


public static int delete(String sql) throws Exception {
    PreparedStatement ps = DBUtil.createStatement(sql);
    int flag = 0;
    flag = ps.executeUpdate();
    return flag;
}

######


public static int delete(String tableName, String primary, String[] array) throws Exception {
    int result = 0;
    StringBuffer sql = new StringBuffer("delete from ");
    sql.append(tableName);
    sql.append(" where ");
    sql.append(primary);
    sql.append(" in (");
    for (int i = 0; i < array.length; i++) {
        String data = array[i];
        if (i > 0) {
            sql.append(",");
        }
        sql.append(data);
    }
    sql.append(")");
    System.out.println("delete :" + sql.toString());
    PreparedStatement ps = DBUtil.createStatement(sql.toString());
    try {
        result = ps.executeUpdate();
    } finally {
        DBUtil.close(null);
    }
    return result;
}

######


public static Object selectOne(String sql, Class classFile) throws Exception {
    PreparedStatement ps = DBUtil.createStatement(sql);
    ResultSet rs = null;
    String className = classFile.getName();
    Object obj = null;
    rs = ps.executeQuery();
    rs.next();
    if ("java.lang.Integer".equals(className)) {
        obj = rs.getInt(1);
    } else if ("java.lang.String".equals(className)) {
        return rs.getString(1);
    } else if ("java.lang.Long".equals(className)) {
        obj = rs.getLong(1);
    } else if ("java.lang.Double".equals(className)) {
        obj = rs.getDouble(1);
    } else {
        obj = classFile.newInstance();
        Field[] fieldArray = classFile.getDeclaredFields();
        for (int i = 0; i < fieldArray.length; i++) {
            Field fieldObj = fieldArray[i];
            String fieldName = fieldObj.getName();
            String value = rs.getString(fieldName);
            init(obj, value, fieldObj);
        }
    }
    return obj;
}

######


@Override
public void clear() {
    sqlHelper.execute("DELETE FROM resume");
}

######


@Override
public void update(Resume r) {
    sqlHelper.transactionalExecute(conn -> {
        try (PreparedStatement ps = conn.prepareStatement("UPDATE resume SET full_name = ? WHERE uuid = ?")) {
            ps.setString(1, r.getFullName());
            ps.setString(2, r.getUuid());
            if (ps.executeUpdate() != 1) {
                throw new NotExistStorageException(r.getUuid());
            }
        }
        deleteContacts(conn, r);
        deleteSections(conn, r);
        insertContacts(conn, r);
        insertSection(conn, r);
        return null;
    });
}

######


@Override
public void save(Resume r) {
    sqlHelper.transactionalExecute(conn -> {
        try (PreparedStatement ps = conn.prepareStatement("INSERT INTO resume(uuid, full_name)VALUES(?,?)")) {
            ps.setString(1, r.getUuid());
            ps.setString(2, r.getFullName());
            ps.execute();
        }
        insertContacts(conn, r);
        insertSection(conn, r);
        return null;
    });
}

######


@Override
public Resume get(String uuid) {
    return sqlHelper.transactionalExecute(conn -> {
        Resume r;
        try (PreparedStatement ps = conn.prepareStatement("SELECT * FROM resume WHERE uuid =?")) {
            ps.setString(1, uuid);
            ResultSet rs = ps.executeQuery();
            if (!rs.next()) {
                throw new NotExistStorageException(uuid);
            }
            r = new Resume(uuid, rs.getString("full_name"));
        }
        try (PreparedStatement ps = conn.prepareStatement("SELECT * FROM contact WHERE resume_uuid = ?")) {
            ps.setString(1, uuid);
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                addContact(rs, r);
            }
        }
        return r;
    });
}

######


@Override
public void delete(String uuid) {
    sqlHelper.execute("DELETE FROM resume WHERE uuid=?", ps -> {
        ps.setString(1, uuid);
        if (ps.executeUpdate() == 0) {
            throw new NotExistStorageException(uuid);
        }
        return null;
    });
}

######


@Override
public List<Resume> getAllSorted() {
    return sqlHelper.transactionalExecute(conn -> {
        Map<String, Resume> resumes = new LinkedHashMap<>();
        try (PreparedStatement ps = conn.prepareStatement("SELECT * FROM resume ORDER BY full_name, uuid")) {
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                String uuid = rs.getString("uuid");
                resumes.put(uuid, new Resume(uuid, rs.getString("full_name")));
            }
        }
        try (PreparedStatement ps = conn.prepareStatement("SELECT * FROM contacts")) {
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                Resume r = resumes.get(rs.getString("resume_uuid"));
                addContact(rs, r);
            }
        }
        try (PreparedStatement ps = conn.prepareStatement("SELECT * FROM contacts")) {
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                Resume r = resumes.get(rs.getString("resume_uuid"));
                addSection(rs, r);
            }
        }
        return new ArrayList<>(resumes.values());
    });
}

######


@Override
public int size() {
    return sqlHelper.execute("SELECT count(*) FROM resume", st -> {
        ResultSet rs = st.executeQuery();
        return rs.next() ? rs.getInt(1) : 0;
    });
}

######


private void insertContacts(Connection conn, Resume r) throws SQLException {
    try (PreparedStatement ps = conn.prepareStatement("INSERT INTO contact(resume_uuid,type,value)VALUES(?,?,?)")) {
        for (Map.Entry<ContactType, String> e : r.getContacts().entrySet()) {
            ps.setString(1, r.getUuid());
            ps.setString(1, e.getKey().name());
            ps.setString(3, e.getValue());
            ps.addBatch();
        }
        ps.executeBatch();
    }
}

######


private void insertSection(Connection conn, Resume r) throws SQLException {
    try (PreparedStatement ps = conn.prepareStatement("INSERT INTO section(resume_uuid,type,content)VALUES(?,?,?)")) {
        for (Map.Entry<SectionType, Section> e : r.getSections().entrySet()) {
            ps.setString(1, r.getUuid());
            ps.setString(2, e.getKey().name());
            Section section = e.getValue();
            ps.setString(3, JsonParser.write(section, Section.class));
            ps.addBatch();
        }
        ps.executeBatch();
    }
}

######


private void deleteContacts(Connection conn, Resume r) throws SQLException {
    deleteAtributes(conn, r, "DELETE FROM section WHERE resume_uuid=?");
}

######


private void deleteSections(Connection conn, Resume r) throws SQLException {
    deleteAtributes(conn, r, "DELETE FROM section WHERE resume_uuid=?");
}

######


private void deleteAtributes(Connection conn, Resume r, String sql) throws SQLException {
    try (PreparedStatement ps = conn.prepareStatement(sql)) {
        ps.setString(1, r.getUuid());
        ps.execute();
    }
}

######


private void addContact(ResultSet rs, Resume r) throws SQLException {
    String value = rs.getString("value");
    if (value != null) {
        r.setContact(ContactType.valueOf(rs.getString("type")), value);
    }
}

######


private void addSection(ResultSet rs, Resume r) throws SQLException {
    String content = rs.getString("content");
    if (content != null) {
        SectionType type = SectionType.valueOf(rs.getString("type"));
        r.setSection(type, JsonParser.read(content, Section.class));
    }
}

######


@Test
public void shouldDemonstrateProvidedStringBuilder() {
    final StringBuilder sb = new StringBuilder();
    final String sql = example1().usingAppender(sb).toString();
    assertEquals("SELECT P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME, P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON\n" + "FROM PERSON P, ACCOUNT A\n" + "INNER JOIN DEPARTMENT D on D.ID = P.DEPARTMENT_ID\n" + "INNER JOIN COMPANY C on D.COMPANY_ID = C.ID\n" + "WHERE (P.ID = A.ID AND P.FIRST_NAME like ?) \n" + "OR (P.LAST_NAME like ?)\n" + "GROUP BY P.ID\n" + "HAVING (P.LAST_NAME like ?) \n" + "OR (P.FIRST_NAME like ?)\n" + "ORDER BY P.ID, P.FULL_NAME", sql);
}

######


@Test
public void shouldDemonstrateMixedStyle() {
    final String sql = new SQL() {

        {
            SELECT("id, name");
            FROM("PERSON A");
            WHERE("name like ?").WHERE("id = ?");
        }
    }.toString();
    assertEquals("" + "SELECT id, name\n" + "FROM PERSON A\n" + "WHERE (name like ? AND id = ?)", sql);
}

######


@Test
public void shouldDemonstrateFluentStyle() {
    final String sql = new SQL().SELECT("id, name").FROM("PERSON A").WHERE("name like ?").WHERE("id = ?").toString();
    assertEquals("" + "SELECT id, name\n" + "FROM PERSON A\n" + "WHERE (name like ? AND id = ?)", sql);
}

######


@Test
public void shouldProduceExpectedSimpleSelectStatement() {
    final String expected = "SELECT P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME\n" + "FROM PERSON P\n" + "WHERE (P.ID like #id# AND P.FIRST_NAME like #firstName# AND P.LAST_NAME like #lastName#)\n" + "ORDER BY P.LAST_NAME";
    assertEquals(expected, example2("a", "b", "c"));
}

######


@Test
public void shouldProduceExpectedSimpleSelectStatementMissingFirstParam() {
    final String expected = "SELECT P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME\n" + "FROM PERSON P\n" + "WHERE (P.FIRST_NAME like #firstName# AND P.LAST_NAME like #lastName#)\n" + "ORDER BY P.LAST_NAME";
    assertEquals(expected, example2(null, "b", "c"));
}

######


@Test
public void shouldProduceExpectedSimpleSelectStatementMissingFirstTwoParams() {
    final String expected = "SELECT P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME\n" + "FROM PERSON P\n" + "WHERE (P.LAST_NAME like #lastName#)\n" + "ORDER BY P.LAST_NAME";
    assertEquals(expected, example2(null, null, "c"));
}

######


@Test
public void shouldProduceExpectedSimpleSelectStatementMissingAllParams() {
    final String expected = "SELECT P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME\n" + "FROM PERSON P\n" + "ORDER BY P.LAST_NAME";
    assertEquals(expected, example2(null, null, null));
}

######


@Test
public void shouldProduceExpectedComplexSelectStatement() {
    final String expected = "SELECT P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME, P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON\n" + "FROM PERSON P, ACCOUNT A\n" + "INNER JOIN DEPARTMENT D on D.ID = P.DEPARTMENT_ID\n" + "INNER JOIN COMPANY C on D.COMPANY_ID = C.ID\n" + "WHERE (P.ID = A.ID AND P.FIRST_NAME like ?) \n" + "OR (P.LAST_NAME like ?)\n" + "GROUP BY P.ID\n" + "HAVING (P.LAST_NAME like ?) \n" + "OR (P.FIRST_NAME like ?)\n" + "ORDER BY P.ID, P.FULL_NAME";
    assertEquals(expected, example1().toString());
}

######


private static SQL example1() {
    return new SQL() {

        {
            SELECT("P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME");
            SELECT("P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON");
            FROM("PERSON P");
            FROM("ACCOUNT A");
            INNER_JOIN("DEPARTMENT D on D.ID = P.DEPARTMENT_ID");
            INNER_JOIN("COMPANY C on D.COMPANY_ID = C.ID");
            WHERE("P.ID = A.ID");
            WHERE("P.FIRST_NAME like ?");
            OR();
            WHERE("P.LAST_NAME like ?");
            GROUP_BY("P.ID");
            HAVING("P.LAST_NAME like ?");
            OR();
            HAVING("P.FIRST_NAME like ?");
            ORDER_BY("P.ID");
            ORDER_BY("P.FULL_NAME");
        }
    };
}

######


private static String example2(final String id, final String firstName, final String lastName) {
    return new SQL() {

        {
            SELECT("P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME");
            FROM("PERSON P");
            if (id != null) {
                WHERE("P.ID like #id#");
            }
            if (firstName != null) {
                WHERE("P.FIRST_NAME like #firstName#");
            }
            if (lastName != null) {
                WHERE("P.LAST_NAME like #lastName#");
            }
            ORDER_BY("P.LAST_NAME");
        }
    }.toString();
}

######


@Test
public void variableLengthArgumentOnSelect() {
    final String sql = new SQL() {

        {
            SELECT("P.ID", "P.USERNAME");
        }
    }.toString();
    assertEquals("SELECT P.ID, P.USERNAME", sql);
}

######


@Test
public void variableLengthArgumentOnSelectDistinct() {
    final String sql = new SQL() {

        {
            SELECT_DISTINCT("P.ID", "P.USERNAME");
        }
    }.toString();
    assertEquals("SELECT DISTINCT P.ID, P.USERNAME", sql);
}

######


@Test
public void variableLengthArgumentOnFrom() {
    final String sql = new SQL() {

        {
            SELECT().FROM("TABLE_A a", "TABLE_B b");
        }
    }.toString();
    assertEquals("FROM TABLE_A a, TABLE_B b", sql);
}

######


@Test
public void variableLengthArgumentOnJoin() {
    final String sql = new SQL() {

        {
            SELECT().JOIN("TABLE_A b ON b.id = a.id", "TABLE_C c ON c.id = a.id");
        }
    }.toString();
    assertEquals("JOIN TABLE_A b ON b.id = a.id\n" + "JOIN TABLE_C c ON c.id = a.id", sql);
}

######


@Test
public void variableLengthArgumentOnInnerJoin() {
    final String sql = new SQL() {

        {
            SELECT().INNER_JOIN("TABLE_A b ON b.id = a.id", "TABLE_C c ON c.id = a.id");
        }
    }.toString();
    assertEquals("INNER JOIN TABLE_A b ON b.id = a.id\n" + "INNER JOIN TABLE_C c ON c.id = a.id", sql);
}

######


@Test
public void variableLengthArgumentOnOuterJoin() {
    final String sql = new SQL() {

        {
            SELECT().OUTER_JOIN("TABLE_A b ON b.id = a.id", "TABLE_C c ON c.id = a.id");
        }
    }.toString();
    assertEquals("OUTER JOIN TABLE_A b ON b.id = a.id\n" + "OUTER JOIN TABLE_C c ON c.id = a.id", sql);
}

######


@Test
public void variableLengthArgumentOnLeftOuterJoin() {
    final String sql = new SQL() {

        {
            SELECT().LEFT_OUTER_JOIN("TABLE_A b ON b.id = a.id", "TABLE_C c ON c.id = a.id");
        }
    }.toString();
    assertEquals("LEFT OUTER JOIN TABLE_A b ON b.id = a.id\n" + "LEFT OUTER JOIN TABLE_C c ON c.id = a.id", sql);
}

######


@Test
public void variableLengthArgumentOnRightOuterJoin() {
    final String sql = new SQL() {

        {
            SELECT().RIGHT_OUTER_JOIN("TABLE_A b ON b.id = a.id", "TABLE_C c ON c.id = a.id");
        }
    }.toString();
    assertEquals("RIGHT OUTER JOIN TABLE_A b ON b.id = a.id\n" + "RIGHT OUTER JOIN TABLE_C c ON c.id = a.id", sql);
}

######


@Test
public void variableLengthArgumentOnWhere() {
    final String sql = new SQL() {

        {
            SELECT().WHERE("a = #{a}", "b = #{b}");
        }
    }.toString();
    assertEquals("WHERE (a = #{a} AND b = #{b})", sql);
}

######


@Test
public void variableLengthArgumentOnGroupBy() {
    final String sql = new SQL() {

        {
            SELECT().GROUP_BY("a", "b");
        }
    }.toString();
    assertEquals("GROUP BY a, b", sql);
}

######


@Test
public void variableLengthArgumentOnHaving() {
    final String sql = new SQL() {

        {
            SELECT().HAVING("a = #{a}", "b = #{b}");
        }
    }.toString();
    assertEquals("HAVING (a = #{a} AND b = #{b})", sql);
}

######


@Test
public void variableLengthArgumentOnOrderBy() {
    final String sql = new SQL() {

        {
            SELECT().ORDER_BY("a", "b");
        }
    }.toString();
    assertEquals("ORDER BY a, b", sql);
}

######


@Test
public void variableLengthArgumentOnSet() {
    final String sql = new SQL() {

        {
            UPDATE("TABLE_A").SET("a = #{a}", "b = #{b}");
        }
    }.toString();
    assertEquals("UPDATE TABLE_A\n" + "SET a = #{a}, b = #{b}", sql);
}

######


@Test
public void variableLengthArgumentOnIntoColumnsAndValues() {
    final String sql = new SQL() {

        {
            INSERT_INTO("TABLE_A").INTO_COLUMNS("a", "b").INTO_VALUES("#{a}", "#{b}");
        }
    }.toString();
    System.out.println(sql);
    assertEquals("INSERT INTO TABLE_A\n (a, b)\nVALUES (#{a}, #{b})", sql);
}

######


@Test
public void fixFor903UpdateJoins() {
    final SQL sql = new SQL().UPDATE("table1 a").INNER_JOIN("table2 b USING (ID)").SET("a.value = b.value");
    assertThat(sql.toString()).isEqualTo("UPDATE table1 a\nINNER JOIN table2 b USING (ID)\nSET a.value = b.value");
}

######


public ResultSet Query(String sql) {
    System.out.println("调用Query函数...");
    System.out.println("进入try语句...");
    try {
        System.out.println("开始获取Connection...");
        connection = ConnUtils.getConnection();
        System.out.println("Connection获取完毕！");
        stmt = connection.createStatement();
        rs = stmt.executeQuery(sql);
        return rs;
    } catch (Exception ex) {
        ex.printStackTrace();
        return null;
    } finally {
    }
}

######


public int Query2(String sql) {
    stmt = null;
    rs = null;
    try {
        connection = ConnUtils.getConnection();
        stmt = connection.createStatement();
        int result = stmt.executeUpdate(sql);
        return result;
    } catch (Exception ex) {
        ex.printStackTrace();
        return -1;
    } finally {
    }
}

######


public int insert(String table, Map<String, String> data) {
    String key = "", value = "";
    for (Map.Entry<String, String> entry : data.entrySet()) {
        key += entry.getKey() + ",";
        value += entry.getValue() + "','";
        System.out.println(entry.getKey() + "--->" + entry.getValue());
    }
    key = key.substring(0, key.length() - 1);
    value = value.substring(0, value.length() - 3);
    String sql = "INSERT INTO " + table + " (" + key + ") VALUES ('" + value + "')";
    return Query2(sql);
}

######


public int delete(String table, String where) {
    String sql = "DELETE FROM " + table + " WHERE " + where;
    return Query2(sql);
}

######


public int update(String table, String str, String where) {
    String sql = "UPDATE " + table + " SET " + str + " WHERE " + where;
    return Query2(sql);
}

######


public ResultSet find(String table, String filed, String where) throws SQLException {
    String sql;
    if (where == null || where == "") {
        sql = "select " + filed + " from " + table;
    } else {
        sql = "select " + filed + " from " + table + " where " + where;
    }
    System.out.println("Sql_op.find: " + sql + "  接着执行程序...");
    ResultSet result = Query(sql);
    System.out.println("find函数执行完毕！");
    return result;
}

######


public String findToJson(String table, String filed, String where) throws SQLException, JSONException {
    String sql;
    if (where == null || where == "") {
        sql = "select " + filed + " from " + table;
    } else {
        sql = "select " + filed + " from " + table + " where " + where;
    }
    ResultSet result = Query(sql);
    return resultSetToJson(result);
}

######


public String resultSetToJson(ResultSet rs) throws SQLException, JSONException {
    JSONArray array = new JSONArray();
    ResultSetMetaData metaData = rs.getMetaData();
    int columnCount = metaData.getColumnCount();
    while (rs.next()) {
        JSONObject jsonObj = new JSONObject();
        for (int i = 1; i <= columnCount; i++) {
            String columnName = metaData.getColumnLabel(i);
            String value = rs.getString(columnName);
            jsonObj.put(columnName, value);
        }
        array.put(jsonObj);
    }
    return array.toString();
}

######


public void close() {
    if (rs != null) {
        try {
            rs.close();
            rs = null;
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
    if (stmt != null) {
        try {
            stmt.close();
            stmt = null;
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    UserTxtActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    PasswordTxtActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    Register_BtnActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    Login_BtnActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    Reset_BtnActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    ClientCheckActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    ManagerCheckActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    buttonGroup1 = new javax.swing.ButtonGroup();
    buttonGroup2 = new javax.swing.ButtonGroup();
    buttonGroup3 = new javax.swing.ButtonGroup();
    Panou = new javax.swing.JPanel();
    UserLabel = new javax.swing.JLabel();
    PasswordLabel = new javax.swing.JLabel();
    UserTxt = new javax.swing.JTextField();
    PasswordTxt = new javax.swing.JPasswordField();
    Register_Btn = new javax.swing.JButton();
    Login_Btn = new javax.swing.JButton();
    Reset_Btn = new javax.swing.JButton();
    ClientCheck = new javax.swing.JRadioButton();
    ManagerCheck = new javax.swing.JRadioButton();
    Title = new javax.swing.JLabel();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    setTitle("Start");
    setSize(getPreferredSize());
    Panou.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Panou.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
    Panou.setEnabled(false);
    Panou.setPreferredSize(new java.awt.Dimension(420, 260));
    UserLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    UserLabel.setLabelFor(UserTxt);
    UserLabel.setText("User");
    UserLabel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    PasswordLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    PasswordLabel.setLabelFor(PasswordTxt);
    PasswordLabel.setText("Password");
    PasswordLabel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    UserTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    UserTxt.setText("admin");
    UserTxt.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            UserTxtActionPerformed(evt);
        }
    });
    PasswordTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    PasswordTxt.setText("admin");
    PasswordTxt.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            PasswordTxtActionPerformed(evt);
        }
    });
    Register_Btn.setText("Register");
    Register_Btn.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            Register_BtnActionPerformed(evt);
        }
    });
    Login_Btn.setText("Login");
    Login_Btn.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            Login_BtnActionPerformed(evt);
        }
    });
    Reset_Btn.setText("Reset");
    Reset_Btn.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            Reset_BtnActionPerformed(evt);
        }
    });
    ClientCheck.setText("Client");
    ClientCheck.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    ClientCheck.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            ClientCheckActionPerformed(evt);
        }
    });
    ManagerCheck.setSelected(true);
    ManagerCheck.setText("Manager");
    ManagerCheck.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    ManagerCheck.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            ManagerCheckActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout PanouLayout = new javax.swing.GroupLayout(Panou);
    Panou.setLayout(PanouLayout);
    PanouLayout.setHorizontalGroup(PanouLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(PanouLayout.createSequentialGroup().addGap(19, 19, 19).addGroup(PanouLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(PanouLayout.createSequentialGroup().addComponent(Register_Btn, javax.swing.GroupLayout.DEFAULT_SIZE, 126, Short.MAX_VALUE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(Login_Btn, javax.swing.GroupLayout.DEFAULT_SIZE, 126, Short.MAX_VALUE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(Reset_Btn, javax.swing.GroupLayout.DEFAULT_SIZE, 128, Short.MAX_VALUE)).addGroup(PanouLayout.createSequentialGroup().addComponent(ClientCheck, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(ManagerCheck, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addGroup(PanouLayout.createSequentialGroup().addGroup(PanouLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(UserLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(PasswordLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)).addGroup(PanouLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(PanouLayout.createSequentialGroup().addGap(18, 18, 18).addComponent(UserTxt)).addGroup(PanouLayout.createSequentialGroup().addGap(18, 18, 18).addComponent(PasswordTxt))))).addContainerGap()));
    PanouLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] { PasswordLabel, UserLabel });
    PanouLayout.setVerticalGroup(PanouLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(PanouLayout.createSequentialGroup().addGap(22, 22, 22).addGroup(PanouLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(UserLabel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(UserTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(13, 13, 13).addGroup(PanouLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(PasswordLabel).addComponent(PasswordTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(13, 13, 13).addGroup(PanouLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(ClientCheck, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(ManagerCheck, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(PanouLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER).addComponent(Register_Btn, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(Login_Btn, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(Reset_Btn)).addGap(16, 16, 16)));
    PanouLayout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] { PasswordLabel, PasswordTxt, Reset_Btn, UserLabel, UserTxt });
    PanouLayout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] { ClientCheck, ManagerCheck });
    Title.setFont(new java.awt.Font("Tahoma", 1, 24));
    Title.setForeground(new java.awt.Color(240, 240, 240));
    Title.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Title.setText("Login System");
    Title.setToolTipText("");
    Title.setVerticalAlignment(javax.swing.SwingConstants.TOP);
    Title.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(0, 0, 0), 1, true));
    Title.setEnabled(false);
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(Title, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(Panou, javax.swing.GroupLayout.DEFAULT_SIZE, 427, Short.MAX_VALUE)).addContainerGap()));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(7, 7, 7).addComponent(Title, javax.swing.GroupLayout.PREFERRED_SIZE, 36, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(Panou, javax.swing.GroupLayout.PREFERRED_SIZE, 186, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    pack();
    setLocationRelativeTo(null);
}

######


@Override
public void windowClosing(java.awt.event.WindowEvent windowEvent) {
    Start JF = new Start();
    JF.setVisible(true);
    JF.setResizable(false);
    UF.dispose();
}

######


private void Reset_BtnActionPerformed(java.awt.event.ActionEvent evt) {
    UserForm UF = new UserForm();
    UF.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
    UF.addWindowListener(new java.awt.event.WindowAdapter() {

        @Override
        public void windowClosing(java.awt.event.WindowEvent windowEvent) {
            Start JF = new Start();
            JF.setVisible(true);
            JF.setResizable(false);
            UF.dispose();
        }
    });
    UF.setVisible(true);
    UF.setLocation(300, 200);
    this.dispose();
}

######


private void Login_BtnActionPerformed(java.awt.event.ActionEvent evt) {
    String User = UserTxt.getText();
    String Password = new String(PasswordTxt.getPassword());
    int Expectation = (ManagerCheck.isSelected()) ? 1 : 0;
    int Reality = 0;
    if (Password.length() > 0 && UserTxt.getText().length() > 0) {
        try {
            Client sclav = new Client();
            sclav.connectToServer();
            String SQL = "select * from users where user='" + User + "' and password='" + Password + "'";
            sclav.Query(SQL);
            ResultSet rs = sclav.rs;
            Reality = (rs.first()) ? rs.getInt(4) : 0;
            if (rs.first() && Expectation == Reality) {
                Halls HS = new Halls(User, Reality);
                HS.setVisible(true);
                HS.setResizable(false);
                this.dispose();
            } else {
                JOptionPane.showMessageDialog(null, "Invalid login details", "Login Error", JOptionPane.ERROR_MESSAGE);
            }
        } catch (SQLException ex) {
            Logger.getLogger(RegisterPage.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(Start.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(Start.class.getName()).log(Level.SEVERE, null, ex);
        }
    } else {
        JOptionPane.showMessageDialog(null, "Invalid login details", "Login Error", JOptionPane.ERROR_MESSAGE);
    }
}

######


@Override
public void windowClosing(java.awt.event.WindowEvent windowEvent) {
    Start JF = new Start();
    JF.setVisible(true);
    JF.setResizable(false);
    RegPg.dispose();
}

######


private void Register_BtnActionPerformed(java.awt.event.ActionEvent evt) {
    RegisterPage RegPg = new RegisterPage();
    RegPg.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
    RegPg.addWindowListener(new java.awt.event.WindowAdapter() {

        @Override
        public void windowClosing(java.awt.event.WindowEvent windowEvent) {
            Start JF = new Start();
            JF.setVisible(true);
            JF.setResizable(false);
            RegPg.dispose();
        }
    });
    RegPg.setVisible(true);
    RegPg.setResizable(false);
    this.dispose();
}

######


private void PasswordTxtActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void UserTxtActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void ManagerCheckActionPerformed(java.awt.event.ActionEvent evt) {
    ClientCheck.setSelected(false);
}

######


private void ClientCheckActionPerformed(java.awt.event.ActionEvent evt) {
    ManagerCheck.setSelected(false);
}

######


public static void main(String[] args) throws IOException, SQLException {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(Start.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(Start.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(Start.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(Start.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(() -> {
        Start JF = new Start();
        JF.setVisible(true);
        JF.setResizable(false);
    });
}

######


@Test
public void databaseStateChange() throws SQLException {
    Assume.assumeTrue((isMariadbServer() && minVersion(10, 2)) || (!isMariadbServer() && minVersion(5, 7)));
    try (Connection connection = setConnection()) {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("drop database if exists " + MariaDbConnection.quoteIdentifier("_test_db"));
            stmt.execute("create database " + MariaDbConnection.quoteIdentifier("_test_db"));
            assertEquals(database, connection.getCatalog());
            stmt.execute("USE " + MariaDbConnection.quoteIdentifier("_test_db"));
            assertEquals("_test_db", connection.getCatalog());
        }
    }
}

######


@Test
public void timeZoneChange() throws SQLException {
    Assume.assumeTrue((isMariadbServer() && minVersion(10, 2)) || (!isMariadbServer() && minVersion(5, 7)));
    try (Connection connection = setConnection()) {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("drop database if exists " + MariaDbConnection.quoteIdentifier("_test_db"));
            stmt.execute("create database " + MariaDbConnection.quoteIdentifier("_test_db"));
            assertEquals(database, connection.getCatalog());
            stmt.execute("USE " + MariaDbConnection.quoteIdentifier("_test_db"));
            assertEquals("_test_db", connection.getCatalog());
        }
    }
}

######


@Test
public void autocommitChange() throws SQLException {
    try (Connection connection = setConnection()) {
        try (Statement stmt = connection.createStatement()) {
            assertTrue(connection.getAutoCommit());
            stmt.execute("SET autocommit=false");
            assertFalse(connection.getAutoCommit());
        }
    }
}

######


@Test
public void autoIncrementChange() throws SQLException {
    Assume.assumeFalse(isGalera());
    Assume.assumeTrue((isMariadbServer() && minVersion(10, 2)) || (!isMariadbServer() && minVersion(5, 7)));
    createTable("autoIncrementChange", "id int not null primary key auto_increment, name char(20)");
    try (Connection connection = setConnection()) {
        try (Statement stmt = connection.createStatement()) {
            try (PreparedStatement preparedStatement = connection.prepareStatement("INSERT INTO autoIncrementChange(name) value (?)", Statement.RETURN_GENERATED_KEYS)) {
                preparedStatement.setString(1, "a");
                preparedStatement.execute();
                ResultSet rs = preparedStatement.getGeneratedKeys();
                assertTrue(rs.next());
                assertEquals(1, rs.getInt(1));
                preparedStatement.setString(1, "b");
                preparedStatement.execute();
                rs = preparedStatement.getGeneratedKeys();
                assertTrue(rs.next());
                assertEquals(2, rs.getInt(1));
                stmt.execute("SET @@session.auto_increment_increment=10");
                ResultSet rs2 = stmt.executeQuery("SHOW VARIABLES WHERE Variable_name like 'auto_increment_increment'");
                assertTrue(rs2.next());
                assertEquals(10, rs2.getInt(2));
                preparedStatement.setString(1, "c");
                preparedStatement.execute();
                rs = preparedStatement.getGeneratedKeys();
                assertTrue(rs.next());
                assertEquals(11, rs.getInt(1));
                rs2 = stmt.executeQuery("select * from autoIncrementChange");
                assertTrue(rs2.next());
                assertEquals("a", rs2.getString(2));
                assertEquals(1, rs2.getInt(1));
                assertTrue(rs2.next());
                assertEquals("b", rs2.getString(2));
                assertEquals(2, rs2.getInt(1));
                assertTrue(rs2.next());
                assertEquals("c", rs2.getString(2));
                assertEquals(11, rs2.getInt(1));
                assertFalse(rs2.next());
            }
        }
    }
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("vendor_code_test", "id int not null primary key auto_increment, test boolean");
    createTable("vendor_code_test2", "a INT", "PARTITION BY KEY (a) (PARTITION x0, PARTITION x1)");
    createTable("vendor_code_test3", "a INT", "PARTITION BY LIST(a) (PARTITION p0 VALUES IN (1))");
    createTable("StatementTestt1", "c1 INT, c2 VARCHAR(255)");
}

######


@Test
public void wrapperTest() throws SQLException {
    try (Statement statement = sharedConnection.createStatement()) {
        assertTrue(statement.isWrapperFor(Statement.class));
        assertFalse(statement.isWrapperFor(SQLException.class));
        assertThat(statement.unwrap(Statement.class), equalTo(statement));
        try {
            statement.unwrap(SQLException.class);
            fail("MariaDbStatement class unwrapped as SQLException class");
        } catch (SQLException sqle) {
        } catch (Exception e) {
            fail();
        }
    }
}

######


@Test
public void reexecuteStatementTest() throws SQLException {
    try (Connection connection = setConnection("&allowMultiQueries=true")) {
        try (PreparedStatement stmt = connection.prepareStatement("SELECT 1")) {
            stmt.setFetchSize(Integer.MIN_VALUE);
            ResultSet rs = stmt.executeQuery();
            assertTrue(rs.next());
            stmt.executeQuery();
        }
    }
}

######


@Test(expected = SQLException.class)
public void afterConnectionClosedTest() throws SQLException {
    Connection conn2 = DriverManager.getConnection("jdbc:mariadb://localhost:3306/test?user=root");
    Statement st1 = conn2.createStatement();
    st1.close();
    conn2.close();
    Statement st2 = conn2.createStatement();
    fail();
    st2.close();
}

######


@Test
public void testColumnsDoNotExist() {
    try {
        sharedConnection.createStatement().executeQuery("select * from vendor_code_test where crazy_column_that_does_not_exist = 1");
        fail("The above statement should result in an exception");
    } catch (SQLException sqlException) {
        assertEquals(ER_BAD_FIELD_ERROR, sqlException.getErrorCode());
        assertEquals(ER_BAD_FIELD_ERROR_STATE, sqlException.getSQLState());
    }
}

######


@Test
public void testNonInsertableTable() throws SQLException {
    Statement statement = sharedConnection.createStatement();
    statement.execute("create or replace view vendor_code_test_view as select id as id1, id as id2, test " + "from vendor_code_test");
    try {
        statement.executeQuery("insert into vendor_code_test_view VALUES (null, null, true)");
        fail("The above statement should result in an exception");
    } catch (SQLException sqlException) {
        assertEquals(ER_NON_INSERTABLE_TABLE, sqlException.getErrorCode());
        assertEquals(ER_NON_INSERTABLE_TABLE_STATE, sqlException.getSQLState());
    }
}

######


@Test
public void testNoSuchTable() throws SQLException {
    Statement statement = sharedConnection.createStatement();
    statement.execute("drop table if exists vendor_code_test_");
    try {
        statement.execute("SELECT * FROM vendor_code_test_");
        fail("The above statement should result in an exception");
    } catch (SQLException sqlException) {
        if (sqlException.getErrorCode() != ER_NO_SUCH_TABLE && sqlException.getErrorCode() != ER_CMD_NOT_PERMIT) {
            fail("Wrong error code message");
        }
        assertEquals(ER_NO_SUCH_TABLE_STATE, sqlException.getSQLState());
    }
}

######


@Test
public void testNoSuchTableBatchUpdate() throws SQLException {
    Statement statement = sharedConnection.createStatement();
    statement.execute("drop table if exists vendor_code_test_");
    statement.addBatch("INSERT INTO vendor_code_test_ VALUES('dummyValue')");
    try {
        statement.executeBatch();
        fail("The above statement should result in an exception");
    } catch (SQLException sqlException) {
        if (sqlException.getErrorCode() != ER_NO_SUCH_TABLE && sqlException.getErrorCode() != ER_CMD_NOT_PERMIT) {
            fail("Wrong error code message");
        }
        assertEquals(ER_NO_SUCH_TABLE_STATE, sqlException.getSQLState());
    }
}

######


@Test
public void testNonUpdateableColumn() throws SQLException {
    Statement statement = sharedConnection.createStatement();
    statement.execute("create or replace view vendor_code_test_view as select *," + " 1 as derived_column_that_does_no_exist from vendor_code_test");
    try {
        statement.executeQuery("UPDATE vendor_code_test_view SET derived_column_that_does_no_exist = 1");
        fail("The above statement should result in an exception");
    } catch (SQLException sqlException) {
        assertEquals(ER_NONUPDATEABLE_COLUMN, sqlException.getErrorCode());
        assertEquals(ER_NONUPDATEABLE_COLUMN_STATE, sqlException.getSQLState());
    }
}

######


@Test
public void testParseErrorAddPartitionNoNewPartition() throws SQLException {
    Statement statement = sharedConnection.createStatement();
    try {
        statement.execute("totally_not_a_sql_command_this_cannot_be_parsed");
        fail("The above statement should result in an exception");
    } catch (SQLException sqlException) {
        assertEquals(ER_PARSE_ERROR, sqlException.getErrorCode());
        assertEquals(ER_PARSE_ERROR_STATE, sqlException.getSQLState());
    }
}

######


@Test
public void testAddPartitionNoNewPartition() throws SQLException {
    Statement statement = sharedConnection.createStatement();
    try {
        statement.execute("ALTER TABLE vendor_code_test2 ADD PARTITION PARTITIONS 0");
        fail("The above statement should result in an exception");
    } catch (SQLException sqlException) {
        assertEquals(ER_ADD_PARTITION_NO_NEW_PARTITION, sqlException.getErrorCode());
        assertEquals(ER_ADD_PARTITION_NO_NEW_PARTITION_STATE, sqlException.getSQLState());
    }
}

######


@Test
public void testNoPartitionForGivenValue() throws SQLException {
    Statement statement = sharedConnection.createStatement();
    statement.execute("INSERT INTO vendor_code_test3 VALUES (1)");
    try {
        statement.execute("INSERT INTO vendor_code_test3 VALUES (2)");
        fail("The above statement should result in an exception");
    } catch (SQLException sqlException) {
        assertEquals(ER_NO_PARTITION_FOR_GIVEN_VALUE, sqlException.getErrorCode());
        assertEquals(ER_NO_PARTITION_FOR_GIVEN_VALUE_STATE, sqlException.getSQLState());
    }
}

######


@Test
public void testLoadDataInvalidColumn() throws SQLException {
    Assume.assumeFalse(!isMariadbServer() && minVersion(8, 0, 0));
    Statement statement = sharedConnection.createStatement();
    try {
        statement.execute("drop view if exists v2");
    } catch (SQLException e) {
    }
    statement.execute("CREATE VIEW v2 AS SELECT 1 + 2 AS c0, c1, c2 FROM StatementTestt1;");
    try {
        MariaDbStatement mysqlStatement;
        if (statement.isWrapperFor(MariaDbStatement.class)) {
            mysqlStatement = statement.unwrap(MariaDbStatement.class);
        } else {
            throw new SQLException("Mariadb JDBC adaptor must be used");
        }
        try {
            String data = "\"1\", \"string1\"\n" + "\"2\", \"string2\"\n" + "\"3\", \"string3\"\n";
            ByteArrayInputStream loadDataInfileFile = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
            mysqlStatement.setLocalInfileInputStream(loadDataInfileFile);
            mysqlStatement.executeUpdate("LOAD DATA LOCAL INFILE 'dummyFileName' INTO TABLE v2 " + "FIELDS ESCAPED BY '\\\\' " + "TERMINATED BY ',' " + "ENCLOSED BY '\"'" + "LINES TERMINATED BY '\n' (c0, c2)");
            fail("The above statement should result in an exception");
        } catch (SQLException sqlException) {
            if (sqlException.getErrorCode() != ER_LOAD_DATA_INVALID_COLUMN && sqlException.getErrorCode() != ER_NONUPDATEABLE_COLUMN) {
                fail();
            }
            assertEquals(ER_LOAD_DATA_INVALID_COLUMN_STATE, sqlException.getSQLState());
            mysqlStatement.setLocalInfileInputStream(null);
        }
    } finally {
        try {
            statement.execute("drop view if exists v2");
        } catch (SQLException e) {
        }
    }
}

######


@Test(timeout = 10000)
public void statementClose() throws SQLException {
    Assume.assumeTrue(sharedOptions().socketTimeout == null);
    Properties infos = new Properties();
    infos.put("socketTimeout", 1000);
    infos.put("usePipelineAuth", "false");
    try (Connection connection = createProxyConnection(infos)) {
        Statement statement = connection.createStatement();
        Statement otherStatement = null;
        try {
            otherStatement = connection.createStatement();
            stopProxy();
            otherStatement.execute("SELECT 1");
        } catch (SQLException e) {
            assertTrue(otherStatement != null && otherStatement.isClosed());
            assertTrue(connection.isClosed());
            try {
                statement.execute("SELECT 1");
            } catch (SQLException ee) {
                assertTrue(statement.isClosed());
                assertEquals("must be an SQLState 08000 exception", "08000", ee.getSQLState());
            }
        }
    } finally {
        closeProxy();
    }
}

######


@Test
public void closeOnCompletion() throws SQLException {
    Statement statement = sharedConnection.createStatement();
    assertFalse(statement.isCloseOnCompletion());
    try (ResultSet rs = statement.executeQuery("SELECT 1")) {
        statement.closeOnCompletion();
        assertTrue(statement.isCloseOnCompletion());
        assertFalse(statement.isClosed());
    }
    assertTrue(statement.isClosed());
}

######


@Test
public void testFractionalTimeBatch() throws SQLException {
    Assume.assumeTrue(doPrecisionTest);
    createTable("testFractionalTimeBatch", "tt TIMESTAMP(6)");
    Timestamp currTime = new Timestamp(System.currentTimeMillis());
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("INSERT INTO testFractionalTimeBatch (tt) values (?)")) {
        for (int i = 0; i < 2; i++) {
            preparedStatement.setTimestamp(1, currTime);
            preparedStatement.addBatch();
        }
        preparedStatement.executeBatch();
    }
    try (Statement statement = sharedConnection.createStatement()) {
        try (ResultSet resultSet = statement.executeQuery("SELECT * from testFractionalTimeBatch")) {
            assertTrue(resultSet.next());
            assertEquals(resultSet.getTimestamp(1).getNanos(), currTime.getNanos());
        }
    }
}

######


@Test
public void testFallbackBatchUpdate() throws SQLException {
    Assume.assumeTrue(doPrecisionTest);
    createTable("testFallbackBatchUpdate", "col int");
    Statement statement = sharedConnection.createStatement();
    StringBuilder sb = new StringBuilder("INSERT INTO testFallbackBatchUpdate(col) VALUES (0)");
    for (int i = 1; i < 100; i++) {
        sb.append(",(").append(i).append(")");
    }
    statement.execute(sb.toString());
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("DELETE FROM testFallbackBatchUpdate WHERE col = ?")) {
        preparedStatement.setInt(1, 10);
        preparedStatement.addBatch();
        preparedStatement.setInt(1, 15);
        preparedStatement.addBatch();
        int[] results = preparedStatement.executeBatch();
        assertEquals(2, results.length);
    }
    try (ResultSet rs = statement.executeQuery("SELECT * FROM testFallbackBatchUpdate")) {
        for (int i = 0; i < 100; i++) {
            if (i == 10 || i == 15) {
                continue;
            }
            assertTrue(rs.next());
            assertEquals(i, rs.getInt(1));
        }
        assertFalse(rs.next());
    }
}

######


@Test
public void testProperBatchUpdate() throws SQLException {
    Assume.assumeTrue(doPrecisionTest);
    createTable("testProperBatchUpdate", "col int, col2 int");
    Statement statement = sharedConnection.createStatement();
    StringBuilder sb = new StringBuilder("INSERT INTO testProperBatchUpdate(col, col2) VALUES (0,0)");
    for (int i = 1; i < 100; i++) {
        sb.append(",(").append(i).append(",0)");
    }
    statement.execute(sb.toString());
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("UPDATE testProperBatchUpdate set col2 = ? WHERE col = ? ")) {
        preparedStatement.setInt(1, 10);
        preparedStatement.setInt(2, 10);
        preparedStatement.addBatch();
        preparedStatement.setInt(1, 15);
        preparedStatement.setInt(2, 15);
        preparedStatement.addBatch();
        int[] results = preparedStatement.executeBatch();
        assertEquals(2, results.length);
    }
    try (ResultSet rs = statement.executeQuery("SELECT * FROM testProperBatchUpdate")) {
        for (int i = 0; i < 100; i++) {
            assertTrue(rs.next());
            assertEquals(i, rs.getInt(1));
            assertEquals((i == 10 || i == 15) ? i : 0, rs.getInt(2));
        }
        assertFalse(rs.next());
    }
}

######


@Test
public void deadLockInformation() throws SQLException {
    createTable("deadlock", "a int primary key", "engine=innodb");
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("insert into deadlock(a) values(0), (1)");
    try (Connection conn1 = setConnection("&includeInnodbStatusInDeadlockExceptions&includeThreadDumpInDeadlockExceptions")) {
        conn1.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
        Statement stmt1 = conn1.createStatement();
        try {
            stmt1.execute("SET SESSION idle_transaction_timeout=2");
        } catch (SQLException e) {
        }
        stmt.execute("start transaction");
        stmt.execute("update deadlock set a = 2 where a <> 0");
        try (Connection conn2 = setConnection("&includeInnodbStatusInDeadlockExceptions&includeThreadDumpInDeadlockExceptions")) {
            Statement stmt2 = conn2.createStatement();
            conn2.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
            try {
                stmt2.execute("SET SESSION idle_transaction_timeout=2");
            } catch (SQLException e) {
            }
            stmt2.execute("start transaction");
            try {
                stmt2.execute("update deadlock set a = 3 where a <> 1");
                fail("Must have thrown deadlock exception");
            } catch (SQLException sqle) {
                assertTrue(sqle.getMessage().contains("current threads:"));
                assertTrue(sqle.getMessage().contains("END OF INNODB MONITOR OUTPUT"));
            }
        }
    }
}

######


@Test
public void largeUpdate() throws SQLException {
    createTable("largeUpdate", "a int not null primary key auto_increment, t varchar(256)", "engine=innodb");
    Statement stmt = sharedConnection.createStatement();
    long updateRes = stmt.executeLargeUpdate("insert into largeUpdate(t) values('a'), ('b')");
    assertEquals(2L, updateRes);
    assertEquals(2L, stmt.getLargeUpdateCount());
    updateRes = stmt.executeLargeUpdate("insert into largeUpdate(t) values('c'), ('d')", Statement.RETURN_GENERATED_KEYS);
    assertEquals(2L, updateRes);
    ResultSet rs = stmt.getGeneratedKeys();
    assertEquals(2L, stmt.getLargeUpdateCount());
    assertTrue(rs.next());
    assertEquals(3, rs.getInt(1));
    updateRes = stmt.executeLargeUpdate("insert into largeUpdate(t) values('e'), ('f')", new int[] { 1 });
    assertEquals(2L, updateRes);
    assertEquals(2L, stmt.getLargeUpdateCount());
    rs = stmt.getGeneratedKeys();
    assertTrue(rs.next());
    assertEquals(5, rs.getInt(1));
    updateRes = stmt.executeLargeUpdate("insert into largeUpdate(t) values('g'), ('h')", new String[] { "1" });
    assertEquals(2L, updateRes);
    rs = stmt.getGeneratedKeys();
    assertTrue(rs.next());
    assertEquals(7, rs.getInt(1));
    assertEquals(0L, stmt.getLargeMaxRows());
    stmt.setLargeMaxRows(10_000L);
    assertEquals(10_000L, stmt.getLargeMaxRows());
}

######


@Test
public void closedStatement() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("SELECT 1");
    stmt.executeQuery("SELECT 1");
    stmt.executeUpdate("SELECT 1");
    stmt.close();
    try {
        stmt.execute("SELECT 1");
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("is called on closed statement"));
    }
    try {
        stmt.executeQuery("SELECT 1");
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("is called on closed statement"));
    }
    try {
        stmt.executeUpdate("SELECT 1");
        fail();
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("is called on closed statement"));
    }
}

######


@Test
public void largePrepareUpdate() throws SQLException {
    createTable("largePrepareUpdate", "a int not null primary key auto_increment, t varchar(256)", "engine=innodb");
    Statement stmt = sharedConnection.createStatement();
    stmt.addBatch("insert into largePrepareUpdate(t) values('a')");
    stmt.addBatch("insert into largePrepareUpdate(t) values('b')");
    stmt.addBatch("insert into largePrepareUpdate(t) values('b')");
    long[] batchRes = stmt.executeLargeBatch();
    assertArrayEquals(new long[] { 1, 1, 1 }, batchRes);
}

######


@Test
public void wrongParameterValues() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    try {
        stmt.setMaxRows(-1);
        fail();
    } catch (SQLException e) {
        e.getMessage().contains("max rows cannot be negative");
    }
    try {
        stmt.setLargeMaxRows(-1);
        fail();
    } catch (SQLException e) {
        e.getMessage().contains("max rows cannot be negative");
    }
    try {
        stmt.setQueryTimeout(-1);
        fail();
    } catch (SQLException e) {
        e.getMessage().contains("Query timeout rows cannot be negative");
    }
    stmt.setEscapeProcessing(false);
}

######


@Test
public void testWarnings() throws SQLException {
    Assume.assumeTrue(isMariadbServer());
    Statement stmt = sharedConnection.createStatement();
    stmt.executeQuery("select now() = 1");
    SQLWarning warning = stmt.getWarnings();
    assertTrue(warning.getMessage().contains("ncorrect datetime value: '1'"));
    stmt.clearWarnings();
    assertNull(stmt.getWarnings());
}

######


@Test
public void testNonImplemented() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    try {
        stmt.setCursorName("name");
        fail();
    } catch (SQLFeatureNotSupportedException e) {
        e.getMessage().contains("Cursors are not supported");
    }
}

######


@Test
public void testNoQuery() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    ResultSet rs = stmt.getGeneratedKeys();
    assertFalse(rs.next());
    assertEquals(-1, stmt.getLargeUpdateCount());
    assertEquals(ResultSet.FETCH_FORWARD, stmt.getFetchDirection());
    stmt.setFetchDirection(ResultSet.FETCH_FORWARD);
    assertEquals(0, stmt.executeLargeBatch().length);
}

######


@Test
public void isPoolable() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    assertFalse(stmt.isPoolable());
    stmt.setPoolable(true);
}

######


@Test
public void setFetch() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    try {
        stmt.setFetchSize(-10);
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("invalid fetch size"));
    }
}

######


@Test
public void scrollType() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    assertEquals(ResultSet.TYPE_FORWARD_ONLY, stmt.getResultSetType());
    stmt = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, stmt.getResultSetType());
}

######


@Test
public void addBatchNull() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    try {
        stmt.addBatch(null);
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("null cannot be set to addBatch( String sql)"));
    }
}

######


@Override
public void validateBuild() throws IndexerException {
    Long numFound = getDocumentCount(statResultCore);
    if (numFound <= MINIMUM_DOCUMENT_COUNT)
        throw new IndexerException(new ValidationException("Actual statistical-result document count is " + numFound + "."));
    if (numFound != documentCount)
        logger.warn("WARNING: Added " + documentCount + " statistical-result documents but SOLR reports " + numFound + " documents.");
    else
        logger.info("validateBuild(): Indexed " + documentCount + " statistical-result documents.");
}

######


@Override
public void initialise(String[] args) throws IndexerException {
    super.initialise(args);
    try {
        connection = komp2DataSource.getConnection();
        logger.info("Populating impress maps");
        pipelineMap = IndexerMap.getImpressPipelines(connection);
        procedureMap = IndexerMap.getImpressProcedures(connection);
        parameterMap = IndexerMap.getImpressParameters(connection);
        organisationMap = IndexerMap.getOrganisationMap(connection);
        logger.info("Populating biological data map");
        populateBiologicalDataMap();
        logger.info("Populating resource map");
        populateResourceDataMap();
    } catch (SQLException e) {
        throw new IndexerException(e);
    }
    printConfiguration();
}

######


public static void main(String[] args) throws IndexerException {
    StatisticalResultIndexer main = new StatisticalResultIndexer();
    main.initialise(args);
    main.run();
    main.validateBuild();
    logger.info("Process finished.  Exiting.");
}

######


@Override
protected Logger getLogger() {
    return logger;
}

######


@Override
public void run() throws IndexerException {
    Long start = System.currentTimeMillis();
    logger.info("Populating statistical-results solr core");
    populateStatisticalResultsSolrCore();
    logger.info("Populating statistical-results solr core - done [took: {}s]", (System.currentTimeMillis() - start) / 1000.0);
}

######


public static void updatePosition(int driverId, Cities newCity, String status) {
    Vector<Integer> requestsId = null;
    requestsId = RequestDataBase.getRequests(driverId, newCity);
    for (Integer requestId : requestsId) {
        updateStatus(requestId, newCity.toString(), status);
    }
}

######


public static void updateStatus(int request_id, String current_city, String status) {
    String query;
    java.util.Date myDate = new java.util.Date();
    java.sql.Date sqlDate = new java.sql.Date(myDate.getTime());
    Time time = new Time(myDate.getTime());
    query = "INSERT INTO " + tableName + " (";
    query += "id, request_id, current_city, date, time, status) ";
    query += "VALUES ( NULL";
    query += ", " + request_id;
    if (current_city == null)
        query += ", NULL";
    else
        query += ", " + "\"" + current_city + "\"";
    query += ", " + "\"" + sqlDate + "\"";
    query += ", " + "\"" + time + "\"";
    query += ", " + "\"" + status + "\"";
    query += ")";
    DataBase.sqlInsert(query);
}

######


public static String getLastCity(int request_id) {
    SQLiteStatement sq;
    sq = sqlSelect("SELECT current_city FROM " + tableName + " WHERE request_id = " + request_id + " ORDER BY date DESC, time DESC");
    try {
        if (sq.step())
            return sq.columnString(0);
    } catch (SQLiteException e) {
        e.printStackTrace();
    }
    return null;
}

######


public static String getLastDate(int request_id) {
    SQLiteStatement sq;
    sq = sqlSelect("SELECT date FROM " + tableName + " WHERE request_id = " + request_id + " ORDER BY date DESC, time DESC");
    try {
        if (sq.step())
            return sq.columnString(0);
    } catch (SQLiteException e) {
        e.printStackTrace();
    }
    return null;
}

######


String fetchData(String url) throws IOException {
    Log.d(LOG_TAG, "url: " + url);
    Request request = new Request.Builder().url(url).build();
    Response response = client.newCall(request).execute();
    return response.body().string();
}

######


public void run() {
    Toast.makeText(mContext, msgId, Toast.LENGTH_SHORT).show();
}

######


public static void selectTwoSetsOfTwoAuthors(int p1, int p2, ResultSet[] rs1, ResultSet[] rs2) throws SQLException {
    Connection conn = DriverManager.getConnection("jdbc:default:connection");
    PreparedStatement ps1 = conn.prepareStatement("select * from author where id in (?,?)");
    ps1.setInt(1, p1);
    ps1.setInt(2, p2);
    rs1[0] = ps1.executeQuery();
    PreparedStatement ps2 = conn.prepareStatement("select * from author where id in (?,?)");
    ps2.setInt(1, p2);
    ps2.setInt(2, p1);
    rs2[0] = ps2.executeQuery();
    conn.close();
}

######


public static void insertAuthor(int id, String username, String password, String email) throws SQLException {
    Connection conn = DriverManager.getConnection("jdbc:default:connection");
    try {
        PreparedStatement ps = conn.prepareStatement("INSERT INTO author (id, username, password, email) VALUES (?,?,?,?)");
        ps.setInt(1, id);
        ps.setString(2, username);
        ps.setString(3, password);
        ps.setString(4, email);
        ps.executeUpdate();
    } finally {
        conn.close();
    }
}

######


public static void selectAuthorViaOutParams(int id, String[] username, String[] password, String[] email, String[] bio) throws SQLException {
    Connection conn = DriverManager.getConnection("jdbc:default:connection");
    PreparedStatement ps = conn.prepareStatement("select * from author where id = ?");
    ps.setInt(1, id);
    ResultSet rs = ps.executeQuery();
    rs.next();
    username[0] = rs.getString("username");
    password[0] = rs.getString("password");
    email[0] = rs.getString("email");
    bio[0] = rs.getString("bio");
    conn.close();
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createProcedure("useParameterName", "(a int) begin select a; end");
    createProcedure("useWrongParameterName", "(a int) begin select a; end");
    createProcedure("multiResultSets", "() BEGIN  SELECT 1; SELECT 2; END");
    createProcedure("inoutParam", "(INOUT p1 INT) begin set p1 = p1 + 1; end\n");
    createProcedure("testGetProcedures", "(INOUT p1 INT) begin set p1 = p1 + 1; end\n");
    createProcedure("withStrangeParameter", "(IN a DECIMAL(10,2)) begin select a; end");
    createProcedure("TEST_SP1", "() BEGIN\n" + "SELECT @Something := 'Something';\n" + "SIGNAL SQLSTATE '70100'\n" + "SET MESSAGE_TEXT = 'Test error from SP'; \n" + "END");
    createTable("table_10", "val int");
    createTable("table_5", "val int");
    if (testSingleHost) {
        try (Statement stmt = sharedConnection.createStatement()) {
            stmt.execute("INSERT INTO table_10 VALUES (1),(2),(3),(4),(5),(6),(7),(8),(9),(10)");
            stmt.execute("INSERT INTO table_5 VALUES (1),(2),(3),(4),(5)");
        }
    }
}

######


@Test
public void testStoreProcedureStreaming() throws Exception {
    Assume.assumeFalse(sharedIsAurora());
    cancelForVersion(10, 2, 2);
    cancelForVersion(10, 2, 3);
    cancelForVersion(10, 2, 4);
    createProcedure("StoredWithOutput", "(out MAX_PARAM TINYINT, out MIN_PARAM TINYINT, out NULL_PARAM TINYINT)" + "begin select 1,0,null into MAX_PARAM, MIN_PARAM, NULL_PARAM from dual; SELECT * from table_10; SELECT * from table_5;end");
    try (CallableStatement callableStatement = sharedConnection.prepareCall("{call StoredWithOutput(?,?,?)}")) {
        callableStatement.setFetchSize(1);
        callableStatement.registerOutParameter(1, Types.BIT);
        callableStatement.registerOutParameter(2, Types.BIT);
        callableStatement.registerOutParameter(3, Types.BIT);
        callableStatement.execute();
        ResultSet rs = callableStatement.getResultSet();
        for (int i = 1; i <= 10; i++) {
            assertTrue(rs.next());
            assertEquals(i, rs.getInt(1));
        }
        assertFalse(rs.next());
        assertEquals(true, callableStatement.getBoolean(1));
        assertEquals(false, callableStatement.getBoolean(2));
        assertEquals(false, callableStatement.getBoolean(3));
        assertTrue(callableStatement.getMoreResults());
        rs = callableStatement.getResultSet();
        for (int i = 1; i <= 5; i++) {
            assertTrue(rs.next());
            assertEquals(i, rs.getInt(1));
        }
        assertFalse(rs.next());
    }
}

######


@Test
public void testStoreProcedureStreamingWithAnotherQuery() throws Exception {
    Assume.assumeFalse(sharedIsAurora());
    cancelForVersion(10, 2, 2);
    cancelForVersion(10, 2, 3);
    cancelForVersion(10, 2, 4);
    createProcedure("StreamInterrupted", "(out MAX_PARAM TINYINT, out MIN_PARAM TINYINT, out NULL_PARAM TINYINT)" + "begin select 1,0,null into MAX_PARAM, MIN_PARAM, NULL_PARAM from dual; SELECT * from table_10; SELECT * from table_5;end");
    try (CallableStatement callableStatement = sharedConnection.prepareCall("{call StreamInterrupted(?,?,?)}")) {
        callableStatement.setFetchSize(1);
        callableStatement.registerOutParameter(1, Types.BIT);
        callableStatement.registerOutParameter(2, Types.BIT);
        callableStatement.registerOutParameter(3, Types.BIT);
        callableStatement.execute();
        ResultSet rs = callableStatement.getResultSet();
        assertTrue(rs.next());
        assertEquals(1, rs.getInt(1));
        try (Statement stmt = sharedConnection.createStatement()) {
            ResultSet otherRs = stmt.executeQuery("SELECT 'test'");
            assertTrue(otherRs.next());
            assertEquals("test", otherRs.getString(1));
        }
        for (int i = 2; i <= 10; i++) {
            assertTrue(rs.next());
            assertEquals(i, rs.getInt(1));
        }
        assertFalse(rs.next());
        assertEquals(true, callableStatement.getBoolean(1));
        assertEquals(false, callableStatement.getBoolean(2));
        assertEquals(false, callableStatement.getBoolean(3));
        assertTrue(callableStatement.getMoreResults());
        rs = callableStatement.getResultSet();
        for (int i = 1; i <= 5; i++) {
            assertTrue(rs.next());
            assertEquals(i, rs.getInt(1));
        }
        assertFalse(rs.next());
    }
}

######


@Test
public void testStoreProcedureStreamingWithoutOutput() throws Exception {
    createProcedure("StreamWithoutOutput", "(IN MAX_PARAM TINYINT)" + "begin SELECT * from table_10; SELECT * from table_5;end");
    try (CallableStatement callableStatement = sharedConnection.prepareCall("{call StreamWithoutOutput(?)}")) {
        callableStatement.setFetchSize(1);
        callableStatement.setInt(1, 100);
        callableStatement.execute();
        ResultSet rs = callableStatement.getResultSet();
        for (int i = 1; i <= 10; i++) {
            assertTrue(rs.next());
            assertEquals(i, rs.getInt(1));
        }
        assertFalse(rs.next());
        assertTrue(callableStatement.getMoreResults());
        rs = callableStatement.getResultSet();
        for (int i = 1; i <= 5; i++) {
            assertTrue(rs.next());
            assertEquals(i, rs.getInt(1));
        }
        assertFalse(rs.next());
    }
}

######


@Before
public void checkSp() throws SQLException {
    requireMinimumVersion(5, 0);
}

######


@Test
public void callSimple() throws SQLException {
    CallableStatement st = sharedConnection.prepareCall("{? = call pow(?,?)}");
    st.setInt(2, 2);
    st.setInt(3, 2);
    st.execute();
    int result = st.getInt(1);
    assertEquals(result, 4);
}

######


@Test
public void callSimpleWithNewlines() throws SQLException {
    CallableStatement st = sharedConnection.prepareCall("{\r\n ? =  call pow(?,  ?  )   }");
    st.setInt(2, 2);
    st.setInt(3, 2);
    st.execute();
    int result = st.getInt(1);
    assertEquals(result, 4);
    st = sharedConnection.prepareCall("{\n ? = call pow(?, ?)}");
    st.setInt(2, 2);
    st.setInt(3, 2);
    st.execute();
    result = st.getInt(1);
    assertEquals(result, 4);
    st = sharedConnection.prepareCall("{? = call pow  (\n?, ?  )}");
    st.setInt(2, 2);
    st.setInt(3, 2);
    st.execute();
    result = st.getInt(1);
    assertEquals(result, 4);
    st = sharedConnection.prepareCall("\r\n{\r\n?\r\n=\r\ncall\r\npow\r\n(\n?,\r\n?\r\n)\r\n}");
    st.setInt(2, 2);
    st.setInt(3, 2);
    st.execute();
    result = st.getInt(1);
    assertEquals(result, 4);
}

######


@Test
public void callWithOutParameter() throws SQLException {
    cancelForVersion(10, 2, 2);
    cancelForVersion(10, 2, 3);
    cancelForVersion(10, 2, 4);
    createProcedure("prepareStmtWithOutParameter", "(x int, INOUT y int)\n" + "BEGIN\n" + "SELECT 1;end\n");
    CallableStatement callableStatement = sharedConnection.prepareCall("{call prepareStmtWithOutParameter(?,?)}");
    callableStatement.registerOutParameter(2, Types.INTEGER);
    callableStatement.setInt(1, 2);
    callableStatement.setInt(2, 3);
    callableStatement.execute();
    assertEquals(3, callableStatement.getInt(2));
}

######


@Test
public void callWithResultSet() throws Exception {
    createProcedure("withResultSet", "(a int) begin select a; end");
    CallableStatement stmt = sharedConnection.prepareCall("{call withResultSet(?)}");
    stmt.setInt(1, 1);
    ResultSet rs = stmt.executeQuery();
    assertTrue(rs.next());
    int res = rs.getInt(1);
    assertEquals(res, 1);
}

######


@Test
public void callUseParameterName() throws Exception {
    CallableStatement stmt = sharedConnection.prepareCall("{call useParameterName(?)}");
    stmt.setInt("a", 1);
    ResultSet rs = stmt.executeQuery();
    assertTrue(rs.next());
    int res = rs.getInt(1);
    assertEquals(res, 1);
}

######


@Test(expected = SQLException.class)
public void callUseWrongParameterName() throws Exception {
    CallableStatement stmt = sharedConnection.prepareCall("{call useParameterName(?)}");
    stmt.setInt("b", 1);
    fail("must fail");
}

######


@Test
public void callMultiResultSets() throws Exception {
    executeAndCheckResult(sharedConnection.prepareCall("{call multiResultSets()}"));
}

######


@Test
public void prepareMultiResultSets() throws Exception {
    executeAndCheckResult(sharedConnection.prepareStatement("{call multiResultSets()}"));
}

######


private void executeAndCheckResult(PreparedStatement stmt) throws Exception {
    stmt.execute();
    ResultSet rs = stmt.getResultSet();
    assertTrue(rs.next());
    assertEquals(1, rs.getInt(1));
    assertFalse(rs.next());
    assertTrue(stmt.getMoreResults());
    rs = stmt.getResultSet();
    assertTrue(rs.next());
    assertEquals(2, rs.getInt(1));
    assertFalse(rs.next());
}

######


@Test
public void callInoutParam() throws SQLException {
    cancelForVersion(10, 2, 2);
    cancelForVersion(10, 2, 3);
    cancelForVersion(10, 2, 4);
    CallableStatement storedProc = sharedConnection.prepareCall("{call inOutParam(?)}");
    storedProc.registerOutParameter(1, Types.INTEGER);
    storedProc.setInt(1, 1);
    storedProc.execute();
    assertEquals(2, storedProc.getObject(1));
}

######


@Test
public void callWithStrangeParameter() throws SQLException {
    try (CallableStatement stmt = sharedConnection.prepareCall("{call withStrangeParameter(?)}")) {
        double expected = 5.43;
        stmt.setDouble("a", expected);
        try (ResultSet rs = stmt.executeQuery()) {
            assertTrue(rs.next());
            double res = rs.getDouble(1);
            assertEquals(expected, res, 0);
            double tooMuch = 34.987;
            stmt.setDouble("a", tooMuch);
            try (ResultSet rs2 = stmt.executeQuery()) {
                assertTrue(rs2.next());
                assertThat(rs2.getDouble(1), is(not(tooMuch)));
            }
        }
    }
}

######


@Test
public void meta() throws Exception {
    createProcedure("callabletest1", "()\nBEGIN\nSELECT 1;end\n");
    ResultSet rs = sharedConnection.getMetaData().getProcedures(null, null, "callabletest1");
    if (rs.next()) {
        assertTrue("callabletest1".equals(rs.getString(3)));
    } else {
        fail();
    }
}

######


@Override
@SuppressWarnings("unchecked")
public List<Strain> getAllStrains() {
    return getCurrentSession().createQuery("from Strain").list();
}

######


@Transactional(readOnly = true)
public Strain getStrainByName(String name) {
    return (Strain) getCurrentSession().createQuery("from Strain as s where s.name= ?").setString(0, name).uniqueResult();
}

######


@Transactional(readOnly = true)
public Strain getStrainByAcc(String acc) {
    return (Strain) getCurrentSession().createQuery("from Strain as s where s.id.accession= ?").setString(0, acc).uniqueResult();
}

######


@Transactional(readOnly = true)
public Strain getStrainBySynonym(String name) {
    return (Strain) getCurrentSession().createQuery("from Strain as strain left join strain.synonyms as synonym where synonym.symbol = ?").setString(0, name).uniqueResult();
}

######


@Transactional(readOnly = false)
public void saveStrain(Strain strain) {
    try {
        getCurrentSession().merge(strain);
    } catch (Exception e) {
        e.printStackTrace();
        getCurrentSession().saveOrUpdate(strain);
    }
}

######


@Transactional(readOnly = false)
public void saveOrUpdateStrain(Strain strain) {
    getCurrentSession().saveOrUpdate(strain);
    getCurrentSession().flush();
}

######


@Override
public String toString() {
    return "Student{" + "id=" + super.getId() + ", name=" + super.getName() + ", personalIdNumber=" + super.getPersonalIdNumber() + ", education=" + education.getName() + '}';
}

######


@Override
public boolean equals(Object obj) {
    return super.equals(obj);
}

######


@Override
public int hashCode() {
    return super.hashCode();
}

######


public Education getEducation() {
    return education;
}

######


public void setEducation(Education education) {
    this.education = education;
}

######


@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getSupportActionBar().hide();
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
    setContentView(R.layout.student_activity_layout);
    Intent intent = getIntent();
    student_id = intent.getStringExtra("ID");
    dbHelper = MydatabaseHelper.getInstance(this);
}

######


public void select(View v) {
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    builder.setTitle("个人信息");
    StringBuilder sb = new StringBuilder();
    SQLiteDatabase db = dbHelper.getReadableDatabase();
    Cursor cursor = db.rawQuery("select * from student where id=?", new String[] { student_id });
    while (cursor.moveToNext()) {
        String id = cursor.getString(cursor.getColumnIndex("id"));
        String name = cursor.getString(cursor.getColumnIndex("name"));
        String password = cursor.getString(cursor.getColumnIndex("password"));
        String phone = cursor.getString(cursor.getColumnIndex("phone"));
        int mathScore = cursor.getInt(cursor.getColumnIndex("mathScore"));
        int chineseScore = cursor.getInt(cursor.getColumnIndex("chineseScore"));
        int englishScore = cursor.getInt(cursor.getColumnIndex("englishScore"));
        int ranking = cursor.getInt(cursor.getColumnIndex("ranking"));
        sb.append("姓名：" + name + "\n");
        sb.append("学号：" + id + "\n");
        sb.append("手机号：" + phone + "\n");
        sb.append("密码：" + password + "\n");
        sb.append("数学成绩：" + mathScore + "\n");
        sb.append("语文成绩：" + chineseScore + "\n");
        sb.append("英语成绩：" + englishScore + "\n");
        int sum = mathScore + chineseScore + englishScore;
        sb.append("总成绩：" + sum + "\n");
        sb.append("名次：" + ranking + "\n");
    }
    cursor.close();
    ;
    builder.setMessage(sb.toString());
    builder.create().show();
}

######


@Override
public void onClick(DialogInterface dialog, int which) {
    String first_pass = first.getText().toString().trim();
    String second_pass = second.getText().toString().trim();
    if (!TextUtils.isEmpty(first_pass) && !TextUtils.isEmpty(second_pass)) {
        if (first_pass.matches("[0-9]{6}") && second_pass.matches("[0-9]{6}")) {
            if (second_pass.equals(first_pass)) {
                SQLiteDatabase db = dbHelper.getReadableDatabase();
                db.execSQL("update student set password=? where id=?", new String[] { second_pass, student_id });
                Toast.makeText(Student_activity.this, "密码修改成功!", Toast.LENGTH_LONG).show();
                Intent intent = new Intent(Student_activity.this, Student_login_Activity.class);
                startActivity(intent);
                Toast.makeText(Student_activity.this, "请重新登录!", Toast.LENGTH_LONG).show();
            } else {
                Toast.makeText(Student_activity.this, "两次密码不一致!", Toast.LENGTH_LONG).show();
            }
        } else {
            Toast.makeText(Student_activity.this, "密码必须为6位纯数字!", Toast.LENGTH_LONG).show();
        }
    } else {
        Toast.makeText(Student_activity.this, "密码不能为空!", Toast.LENGTH_LONG).show();
    }
}

######


public void update(View v) {
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    LayoutInflater factory = LayoutInflater.from(this);
    final View textEntryView = factory.inflate(R.layout.student_change_pass_layout, null);
    builder.setView(textEntryView);
    builder.setTitle("修改密码");
    builder.setNegativeButton("取消", null);
    builder.setPositiveButton("确定", new DialogInterface.OnClickListener() {

        EditText first = textEntryView.findViewById(R.id.student_change_password);

        EditText second = textEntryView.findViewById(R.id.student_change_password_second_password);

        @Override
        public void onClick(DialogInterface dialog, int which) {
            String first_pass = first.getText().toString().trim();
            String second_pass = second.getText().toString().trim();
            if (!TextUtils.isEmpty(first_pass) && !TextUtils.isEmpty(second_pass)) {
                if (first_pass.matches("[0-9]{6}") && second_pass.matches("[0-9]{6}")) {
                    if (second_pass.equals(first_pass)) {
                        SQLiteDatabase db = dbHelper.getReadableDatabase();
                        db.execSQL("update student set password=? where id=?", new String[] { second_pass, student_id });
                        Toast.makeText(Student_activity.this, "密码修改成功!", Toast.LENGTH_LONG).show();
                        Intent intent = new Intent(Student_activity.this, Student_login_Activity.class);
                        startActivity(intent);
                        Toast.makeText(Student_activity.this, "请重新登录!", Toast.LENGTH_LONG).show();
                    } else {
                        Toast.makeText(Student_activity.this, "两次密码不一致!", Toast.LENGTH_LONG).show();
                    }
                } else {
                    Toast.makeText(Student_activity.this, "密码必须为6位纯数字!", Toast.LENGTH_LONG).show();
                }
            } else {
                Toast.makeText(Student_activity.this, "密码不能为空!", Toast.LENGTH_LONG).show();
            }
        }
    });
    builder.create().show();
}

######


public void exit(View v) {
    finish();
}

######


@Override
public void onClick(View v) {
    String student_ID = login_ID.getText().toString().trim();
    String student_pass = login_pass.getText().toString().trim();
    if (!TextUtils.isEmpty(student_ID) && !TextUtils.isEmpty(student_pass)) {
        SQLiteDatabase db = dbHelper.getReadableDatabase();
        Cursor cursor = db.rawQuery("select password from student where id=?", new String[] { student_ID });
        if (cursor.moveToNext()) {
            String password = cursor.getString(cursor.getColumnIndex("password"));
            if (password.equals(student_pass)) {
                Intent intent = new Intent(Student_login_Activity.this, Student_activity.class);
                intent.putExtra("ID", student_ID);
                startActivity(intent);
                Toast.makeText(Student_login_Activity.this, "登录成功", Toast.LENGTH_LONG).show();
            } else {
                Toast.makeText(Student_login_Activity.this, "密码错误请重新输入!", Toast.LENGTH_LONG).show();
            }
        } else {
            Toast.makeText(Student_login_Activity.this, "该学号尚未注册,请联系教务处!", Toast.LENGTH_LONG).show();
        }
    } else {
        Toast.makeText(Student_login_Activity.this, "学号, 密码不能为空!", Toast.LENGTH_LONG).show();
    }
}

######


@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getSupportActionBar().hide();
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
    setContentView(R.layout.student_login_layout);
    initViews();
    login.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            String student_ID = login_ID.getText().toString().trim();
            String student_pass = login_pass.getText().toString().trim();
            if (!TextUtils.isEmpty(student_ID) && !TextUtils.isEmpty(student_pass)) {
                SQLiteDatabase db = dbHelper.getReadableDatabase();
                Cursor cursor = db.rawQuery("select password from student where id=?", new String[] { student_ID });
                if (cursor.moveToNext()) {
                    String password = cursor.getString(cursor.getColumnIndex("password"));
                    if (password.equals(student_pass)) {
                        Intent intent = new Intent(Student_login_Activity.this, Student_activity.class);
                        intent.putExtra("ID", student_ID);
                        startActivity(intent);
                        Toast.makeText(Student_login_Activity.this, "登录成功", Toast.LENGTH_LONG).show();
                    } else {
                        Toast.makeText(Student_login_Activity.this, "密码错误请重新输入!", Toast.LENGTH_LONG).show();
                    }
                } else {
                    Toast.makeText(Student_login_Activity.this, "该学号尚未注册,请联系教务处!", Toast.LENGTH_LONG).show();
                }
            } else {
                Toast.makeText(Student_login_Activity.this, "学号, 密码不能为空!", Toast.LENGTH_LONG).show();
            }
        }
    });
}

######


public void initViews() {
    login_ID = findViewById(R.id.student_login_ID_input);
    login_pass = findViewById(R.id.student_login_pass_input);
    login = findViewById(R.id.student_login);
    dbHelper = MydatabaseHelper.getInstance(this);
}

######


@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getSupportActionBar().hide();
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
    setContentView(R.layout.student_total_layout);
    dbHelper = MydatabaseHelper.getInstance(this);
    ListView lv_score = findViewById(R.id.lv_score);
    initInfo();
    Student_Score_Adapter adapter = new Student_Score_Adapter(this, R.layout.student_score_irem, student_score_list);
    lv_score.setAdapter(adapter);
}

######


public void initInfo() {
    SQLiteDatabase db = dbHelper.getReadableDatabase();
    Cursor cursor = db.rawQuery("select * from student order by mathScore+chineseScore+englishScore desc", null);
    int i = 0;
    while (cursor.moveToNext()) {
        i++;
        String id = cursor.getString(cursor.getColumnIndex("id"));
        String name = cursor.getString(cursor.getColumnIndex("name"));
        String password = cursor.getString(cursor.getColumnIndex("password"));
        String sex = cursor.getString(cursor.getColumnIndex("sex"));
        String phone = cursor.getString(cursor.getColumnIndex("phone"));
        int mathScore = cursor.getInt(cursor.getColumnIndex("mathScore"));
        int chineseScore = cursor.getInt(cursor.getColumnIndex("chineseScore"));
        int englishScore = cursor.getInt(cursor.getColumnIndex("englishScore"));
        db.execSQL("update student set ranking=? where id=?", new String[] { String.valueOf(i), id });
        student_score_list.add(new Student_info(chineseScore, englishScore, mathScore, id, name, sex, phone, password, i));
    }
    cursor.close();
}

######


public static List<Subject> getLessons() throws SQLException {
    List<Subject> subjects = new ArrayList<>();
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_getSubjects);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                String name = resultSet.getString("name");
                boolean isActive = resultSet.getBoolean("isActive");
                if (isActive)
                    subjects.add(new Subject(id, name));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return subjects;
}

######


public static List<Teacher> getSubjectTeachersByID(int id) throws SQLException {
    List<Teacher> teachers = new ArrayList<>();
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(getSql_getSubjectTeachers);
            preparedStatement.setInt(1, id);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                int courseID = resultSet.getInt("courseID");
                int teacherID = resultSet.getInt("teacherID");
                int subjectID = resultSet.getInt("subjectID");
                String teacherName = resultSet.getString("teacherName");
                String teacherSurname = resultSet.getString("teacherSurname");
                teachers.add(new Teacher(teacherID, teacherName, teacherSurname));
            }
        } catch (SQLException e) {
            e.getMessage();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return teachers;
}

######


public static boolean checkSubject(String name) throws SQLException {
    boolean isActive = false;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_checkSubject);
            preparedStatement.setString(1, name);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                if (!isActive) {
                    isActive = resultSet.getBoolean("isActive");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else {
        throw new SQLException();
    }
    return isActive;
}

######


public static boolean checkSubjectByID(int subjectID) throws SQLException {
    boolean isActive;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_checkSubjectByID);
            preparedStatement.setInt(1, subjectID);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                isActive = resultSet.getBoolean("isActive");
                if (isActive) {
                    return isActive;
                }
            }
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return false;
}

######


public static boolean insertSubject(String name) throws SQLException {
    boolean result = true;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_insertSubject);
            preparedStatement.setString(1, name);
            int rows = preparedStatement.executeUpdate();
            if (rows == 0) {
                result = false;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else {
        throw new SQLException();
    }
    return result;
}

######


public static boolean checkSubjectOnCourses(int id) throws SQLException {
    boolean isActive = false;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_checkSubjectOnCourses);
            preparedStatement.setInt(1, id);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                isActive = resultSet.getBoolean("isActive");
                if (isActive) {
                    return true;
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else {
        throw new SQLException();
    }
    return isActive;
}

######


public static boolean deleteSubject(int id) throws SQLException {
    boolean deleted = false;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement deleteStatement = connection.prepareStatement(sql_deleteSubject);
            deleteStatement.setInt(1, id);
            deleteStatement.executeUpdate();
            deleted = true;
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else {
        throw new SQLException();
    }
    return deleted;
}

######


public int write_news(String aStudent, ArrayList<String> names, ArrayList<String> values, String table) throws SQLException {
    DBHelper db = new DBHelper();
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    try {
        conn = db.getConnetion();
        String sql = "Select * From " + table + " Where user_number=" + aStudent + " ;";
        stmt = conn.prepareStatement(sql);
        rs = stmt.executeQuery();
        System.out.print("aaaaaaaaaaaaaaaaaaaaaa" + rs.getMetaData().getColumnCount() + "aaaaaaaaaaa");
        for (int a = 0; a < names.size(); a++) {
            String temp = names.get(a).toLowerCase();
            int c = 0;
            for (int b = 1; b <= rs.getMetaData().getColumnCount(); b++) {
                boolean flag = (boolean) (rs.getMetaData().getColumnName(b).equalsIgnoreCase(temp));
                if (flag) {
                    sql = "update " + table + " set " + temp + "='" + values.get(a) + "' where user_number=" + aStudent + " ;";
                    stmt = conn.prepareStatement(sql);
                    stmt.executeUpdate(sql);
                    c++;
                    break;
                }
            }
            System.out.print("\n");
            if (c == 0) {
                sql = "alter table " + table + " add " + temp + " varchar(250)";
                stmt = conn.prepareStatement(sql);
                stmt.executeUpdate(sql);
                System.out.print("ssssssssssssssssssssssssssssssss");
                sql = "update student_basic_news set " + temp + "=\"" + values.get(a) + "\" where user_number=" + aStudent + " ;";
                stmt = conn.prepareStatement(sql);
                stmt.executeUpdate(sql);
                System.out.print("修改成功2！！");
            }
        }
        return 1;
    } catch (Exception e) {
        e.printStackTrace();
        return 0;
    } finally {
        if (rs != null) {
            try {
                rs.close();
                rs = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        if (stmt != null) {
            try {
                stmt.close();
                stmt = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        try {
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

######


public Map<String, String> getAllKeys(String aStudent, String table) throws Exception {
    DBHelper db = new DBHelper();
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    Map<String, String> dataMap = new HashMap<String, String>();
    String sql = "Select * From " + table + " Where user_number=" + aStudent + " ;";
    try {
        conn = db.getConnetion();
        stmt = conn.prepareStatement(sql);
        rs = stmt.executeQuery();
        while (rs.next()) {
            for (int b = 1; b <= rs.getMetaData().getColumnCount(); b++) {
                String name = rs.getMetaData().getColumnName(b);
                String value = rs.getString(name);
                dataMap.put(name, value);
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
        dataMap.put("错误", "00000");
        return dataMap;
    } finally {
        if (rs != null) {
            try {
                rs.close();
                rs = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        if (stmt != null) {
            try {
                stmt.close();
                stmt = null;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }
    return dataMap;
}

######


public static void main(String[] args) {
    Submit_news_to_database a = new Submit_news_to_database();
    try {
        @SuppressWarnings("rawtypes") Map b = a.getAllKeys("201321091074", "student_basic_news");
        System.out.print(b.get("zhiwei"));
        System.out.print(b.get("tiyulv"));
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


@Query("SELECT sp FROM SubscriptionPeriod sp WHERE sp.status = 'active'")
public List<SubscriptionPeriod> findActive();

######


@Query("SELECT sp FROM SubscriptionPeriod sp WHERE sp.code = :code")
public SubscriptionPeriod findByCode(@Param("code") String code);

######


@Query("SELECT s FROM Subscription s WHERE s.user = :user")
public Subscription findByUser(@Param("user") User user);

######


public String getPersonNameByIdWithXml(int id);

######


@Select("select firstName from ibtest.names where id=${value}")
public String getPersonNameByIdWithAnnotsValue(int id);

######


@Select("select firstName from ibtest.names where id=${_parameter}")
public String getPersonNameByIdWithAnnotsParameter(int id);

######


@Select("select firstName from ibtest.names where id=${named}")
public String getPersonNameByIdWithAnnotsParamAnnot(@Param("named") int id);

######


public long getAyahNumber() {
    return ayahNumber;
}

######


public void setAyahNumber(int ayahNumber) {
    this.ayahNumber = ayahNumber;
}

######


public String getArabicText() {
    return arabicText;
}

######


public void setArabicText(String arabicText) {
    this.arabicText = arabicText;
}

######


public String getBanglaText() {
    return banglaText;
}

######


public void setBanglaText(String banglaText) {
    this.banglaText = banglaText;
}

######


public List<SurahDetails> getSurahDetails(int surahId) {
    PreparedStatement prepareStatement = null;
    ResultSet result;
    String query = "select  surah_id, verse_id, arabic, bn_bayan from quran where surah_id = " + surahId;
    try {
        prepareStatement = conn.prepareStatement(query);
        result = prepareStatement.executeQuery();
        List<SurahDetails> nameList = new ArrayList<>();
        while (result.next()) {
            SurahDetails surah = new SurahDetails();
            int surahNumber = result.getInt("verse_id");
            String arabicText = result.getString("arabic");
            String banglaText = result.getString("bn_bayan");
            surah.setAyahNumber(surahNumber);
            surah.setArabicText(arabicText);
            surah.setBanglaText(banglaText);
            nameList.add(surah);
        }
        return nameList;
    } catch (Exception e) {
    } finally {
        if (prepareStatement != null) {
            try {
                prepareStatement.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
    return null;
}

######


public List<SurveyModel> getSurveys() {
    Query query = getEntitymanager().createQuery("SELECT e FROM SurveyModel e WHERE e.expirationTime > :date ORDER BY e.creationTime DESC");
    query.setParameter("date", new Date());
    return query.getResultList();
}

######


public List<OptionModel> getOptionsBySurvey(SurveyModel surveyModel) {
    Query query = getEntitymanager().createQuery("SELECT e FROM OptionModel e WHERE e.survey = :SURVEY_MODEL " + "ORDER BY e.sortOrderNo ASC");
    query.setParameter("SURVEY_MODEL", surveyModel);
    return query.getResultList();
}

######


public List<OptionModel> getNumberOfVotes(SurveyModel surveyModel) {
    Query query = getEntitymanager().createQuery("SELECT SUM(e.count) FROM OptionModel e WHERE e.survey = :survey_model");
    query.setParameter("survey_model", surveyModel);
    return query.getResultList();
}

######


@Transactional
public void persist(Switch switch_) {
    em.persist(switch_);
}

######


@Transactional
public void saveOrUpdate(SwitchGPIO switchGpio) {
    em.persist(switchGpio);
}

######


public List<SwitchGPIO> getAllManagedSwitches() {
    Query query = em.createQuery("SELECT e FROM SwitchGPIO e");
    return (List<SwitchGPIO>) query.getResultList();
}

######


public List<SwitchGPIO> getAllMqttSwitches() {
    Query query = em.createQuery("SELECT e FROM SwitchGPIO e where e.switchType=1 and e.mqttTopic is not null");
    return (List<SwitchGPIO>) query.getResultList();
}

######


public List<Switch> getAllSwitches() {
    Query query = em.createQuery("SELECT e FROM Switch e");
    return (List<Switch>) query.getResultList();
}

######


public Switch getSwitchByName(String name) {
    return em.find(Switch.class, name);
}

######


public String getLastSwitchStateChangeUser(Switch switch_, SwitchState state) {
    Query query = em.createQuery("SELECT e FROM SwitchLog e where e.switch_=:switch and e.state=:state and e.id=(select max(f.id) from SwitchLog f where f.switch_=:switch and f.state=:state)");
    query.setParameter("switch", switch_);
    query.setParameter("state", state);
    SwitchLog sw = ((SwitchLog) query.getResultList().get(0));
    return sw.getUser() != null ? sw.getUser().getFullName() : sw.getRuleUser();
}

######


public SwitchState getLastState(Switch switch_) {
    Query query = em.createQuery("SELECT e.state FROM SwitchLog e where e.switch_.name=:switchName and e.id=(SELECT max(f.id) FROM SwitchLog f where f.switch_.name in :switchName)");
    query.setParameter("switchName", switch_.getName());
    List result = query.getResultList();
    if (result == null || result.size() == 0)
        return SwitchState.OFF;
    return (SwitchState) result.get(0);
}

######


public Date getLastSwitchStateChangeTime(Switch switch_) {
    Query query = em.createQuery("SELECT e.date FROM SwitchLog e where e.switch_.name=:switchName and e.id=(SELECT max(f.id) FROM SwitchLog f where f.switch_.name in :switchName)");
    query.setParameter("switchName", switch_.getName());
    List<Timestamp> results = query.getResultList();
    if (results.size() == 0)
        return null;
    Date date = new Date(((Timestamp) results.get(0)).getTime());
    LOGGER.debug("getLastSwitchStateChangeTime " + date);
    return date;
}

######


public Date getLastManagedSwitchStateChangeTime(SwitchGPIO switchGpio) {
    Query query = em.createQuery("SELECT e.date FROM SwitchGpioLog e where e.switchGpio.description=:switchName and e.id=(SELECT max(f.id) FROM SwitchGpioLog f where f.switchGpio.gpioNumber in :switchName)");
    query.setParameter("switchName", switchGpio.getGpioNumber());
    List<Timestamp> results = query.getResultList();
    if (results.size() == 0)
        return null;
    Date date = new Date(((Timestamp) results.get(0)).getTime());
    LOGGER.debug("getLastManagedSwitchStateChangeTime " + date);
    return date;
}

######


private List<Integer> getGpioList(Switch switch_) {
    List<Integer> gpioList = new ArrayList<>();
    for (SwitchGPIO switchGPIO : switch_.getGpios()) {
        gpioList.add(switchGPIO.getGpioNumber());
    }
    return gpioList;
}

######


@Transactional
public void updateGpioActive(Integer gpioNumber, boolean active) {
    SwitchGPIO switchGPIO = em.find(SwitchGPIO.class, gpioNumber);
    switchGPIO.setActive(active);
    saveOrUpdate(switchGPIO);
}

######


public SwitchGPIO getSwitchGpioByNumber(Integer gpioNumber) {
    return em.find(SwitchGPIO.class, gpioNumber);
}

######


public SwitchGPIO getManagedSwitchByName(String name) {
    Query query = em.createQuery("SELECT e FROM SwitchGPIO e where e.description=:switchName");
    query.setParameter("switchName", name);
    List<SwitchGPIO> results = query.getResultList();
    if (results.size() > 0) {
        return results.get(0);
    }
    return null;
}

######


public SwitchGPIO getSwitchByMQTTTopic(String topic) {
    Query query = em.createQuery("SELECT e FROM SwitchGPIO e where e.mqttTopic=:mqttTopic");
    query.setParameter("mqttTopic", topic);
    List<SwitchGPIO> results = query.getResultList();
    if (results.size() > 0) {
        return results.get(0);
    }
    return null;
}

######


@Transactional
public void persist(SwitchLog switchLog) {
    em.persist(switchLog);
}

######


@Transactional
public void persist(SwitchGpioLog switchLog) {
    em.persist(switchLog);
}

######


public List<SwitchLog> getSwitchLog(int number, List<String> switches) {
    if (switches == null || switches.size() == 0) {
        return new ArrayList<>();
    }
    Query query = em.createQuery("SELECT e FROM SwitchLog e where e.switch_.name in (:switchesNames) order by id desc");
    query.setParameter("switchesNames", switches);
    query.setMaxResults(number);
    return (List<SwitchLog>) query.getResultList();
}

######


public List<SwitchGpioLog> getSwitchGpioLog(int number, List<String> switches) {
    if (switches == null || switches.size() == 0) {
        return new ArrayList<>();
    }
    Query query = em.createQuery("SELECT e FROM SwitchGpioLog e where e.switchGpio.parent.name in (:switchesNames) order by id desc");
    query.setParameter("switchesNames", switches);
    query.setMaxResults(number);
    return (List<SwitchGpioLog>) query.getResultList();
}

######


public List<SwitchLog> getLogsForDate(Switch switch_, Date dateFrom, Date dateTo) {
    List<SwitchLog> resultsToReturn = new ArrayList<>();
    Query query = em.createQuery("SELECT e FROM SwitchLog e where e.switch_=:switch and e.date>:dateFrom and e.date<=:dateTo order by e.id asc");
    query.setParameter("switch", switch_);
    query.setParameter("dateFrom", dateFrom);
    query.setParameter("dateTo", dateTo);
    List<SwitchLog> results = query.getResultList();
    Query firstEntry = em.createQuery("SELECT e FROM SwitchLog e where e.switch_=:switch and e.date<:dateFrom and e.id=(SELECT max(f.id) FROM SwitchLog f where f.switch_=:switch and f.date<:dateFrom)");
    firstEntry.setParameter("switch", switch_);
    firstEntry.setParameter("dateFrom", dateFrom);
    Query lastEntry = em.createQuery("SELECT e FROM SwitchLog e where e.switch_=:switch and e.date>:dateTo and e.id=(SELECT min(f.id) FROM SwitchLog f where f.switch_=:switch and f.date>:dateTo)");
    lastEntry.setParameter("switch", switch_);
    lastEntry.setParameter("dateTo", dateTo);
    List<SwitchLog> firstResults = (List<SwitchLog>) firstEntry.getResultList();
    List<SwitchLog> lastResults = (List<SwitchLog>) lastEntry.getResultList();
    if (results.size() == 0 && firstResults.size() == 0 && lastResults.size() == 0) {
        return resultsToReturn;
    }
    if (firstResults != null && firstResults.size() > 0) {
        SwitchLog firstResult = firstResults.get(0);
        firstResult.setDate(dateFrom);
        resultsToReturn.add(firstResult);
    } else {
        SwitchLog firstMock = new SwitchLog();
        firstMock.setDate(dateFrom);
        firstMock.setState(SwitchState.OFF);
        firstMock.setSwitch_(switch_);
        resultsToReturn.add(firstMock);
    }
    resultsToReturn.addAll(results);
    if (lastResults != null && lastResults.size() > 0) {
        LOGGER.debug("Last result for " + switch_.getName() + " = " + lastResults.get(0));
        SwitchLog lastResult = lastResults.get(0);
        lastResult.setDate(dateTo);
        resultsToReturn.add((SwitchLog) lastResults.get(0));
    } else {
        if (results.size() > 0) {
        } else {
            SwitchLog lastMock = new SwitchLog();
            lastMock.setDate(dateTo);
            lastMock.setState(resultsToReturn.get(0).getState());
            lastMock.setSwitch_(switch_);
            resultsToReturn.add(lastMock);
        }
    }
    return resultsToReturn;
}

######


public List<SwitchGpioLog> getManagedSwitchLogsForDate(SwitchGPIO switch_, Date dateFrom, Date dateTo) {
    List<SwitchGpioLog> resultsToReturn = new ArrayList<>();
    Query query = em.createQuery("SELECT e FROM SwitchGpioLog e where e.switchGpio=:switch and e.date>:dateFrom and e.date<=:dateTo order by e.id asc");
    query.setParameter("switch", switch_);
    query.setParameter("dateFrom", dateFrom);
    query.setParameter("dateTo", dateTo);
    List<SwitchGpioLog> results = query.getResultList();
    Query firstEntry = em.createQuery("SELECT e FROM SwitchGpioLog e where e.switchGpio=:switch and e.date<:dateFrom and e.id=(SELECT max(f.id) FROM SwitchGpioLog f where f.switchGpio=:switch and f.date<:dateFrom)");
    firstEntry.setParameter("switch", switch_);
    firstEntry.setParameter("dateFrom", dateFrom);
    Query lastEntry = em.createQuery("SELECT e FROM SwitchGpioLog e where e.switchGpio=:switch and e.date>:dateTo and e.id=(SELECT min(f.id) FROM SwitchGpioLog f where f.switchGpio=:switch and f.date>:dateTo)");
    lastEntry.setParameter("switch", switch_);
    lastEntry.setParameter("dateTo", dateTo);
    List<SwitchGpioLog> firstResults = (List<SwitchGpioLog>) firstEntry.getResultList();
    List<SwitchGpioLog> lastResults = (List<SwitchGpioLog>) lastEntry.getResultList();
    if (results.size() == 0 && firstResults.size() == 0 && lastResults.size() == 0) {
        return resultsToReturn;
    }
    if (firstResults != null && firstResults.size() > 0) {
        SwitchGpioLog firstResult = firstResults.get(0);
        firstResult.setDate(dateFrom);
        resultsToReturn.add(firstResult);
    } else {
        SwitchGpioLog firstMock = new SwitchGpioLog();
        firstMock.setDate(dateFrom);
        firstMock.setState(SwitchState.OFF);
        firstMock.setSwitchGpio(switch_);
        resultsToReturn.add(firstMock);
    }
    resultsToReturn.addAll(results);
    if (lastResults != null && lastResults.size() > 0) {
        LOGGER.debug("Last result for " + switch_.getDescription() + " = " + lastResults.get(0));
        SwitchGpioLog lastResult = lastResults.get(0);
        lastResult.setDate(dateTo);
        resultsToReturn.add((SwitchGpioLog) lastResults.get(0));
    } else {
        if (results.size() > 0) {
        } else {
            SwitchGpioLog lastMock = new SwitchGpioLog();
            lastMock.setDate(dateTo);
            lastMock.setState(resultsToReturn.get(0).getState());
            lastMock.setSwitchGpio(switch_);
            resultsToReturn.add(lastMock);
        }
    }
    return resultsToReturn;
}

######


public int fixReports() {
    int count = 0;
    Report[] all = loadReportsAll(0, countReports());
    if (all == null || all.length < 1)
        return -1;
    for (Report r : all) {
        try {
            r.getAuthor().getUniqueId();
            r.getSubject().getUniqueId();
            r.getCategory().name();
            r.getDate().getTime();
        } catch (Exception e) {
            deleteReport(r);
            count++;
        }
    }
    return count;
}

######


public int countReports() {
    try {
        Statement st = db.getConnection().createStatement();
        ResultSet rs = st.executeQuery(COUNT_QUERY);
        int count = 0;
        while (rs.next()) count++;
        return count;
    } catch (SQLException e) {
        return -1;
    }
}

######


public int countReports(Category c) {
    try {
        PreparedStatement st = db.getConnection().prepareStatement(COUNT_QUERY_CAT);
        st.setString(1, c.name());
        ResultSet rs = st.executeQuery();
        int count = 0;
        while (rs.next()) count++;
        return count;
    } catch (SQLException e) {
        return -1;
    }
}

######


public boolean saveReport(Report r) {
    try {
        PreparedStatement ps = db.getConnection().prepareStatement(SAVE_QUERY);
        ps.setDate(1, r.getDate());
        ps.setString(2, r.getAuthor().getUniqueId().toString());
        ps.setString(3, r.getSubject().getUniqueId().toString());
        ps.setString(4, r.getCategory().toString());
        ps.executeUpdate();
    } catch (SQLException e) {
        e.printStackTrace();
        return false;
    }
    return true;
}

######


public Report loadReport(int uid) {
    try {
        ResultSet rs = db.getConnection().prepareStatement(LOAD_QUERY).executeQuery();
        if (!rs.next()) {
            return null;
        }
        Report report = new Report(Category.valueOf(rs.getString("category")), Bukkit.getPlayer(UUID.fromString(rs.getString("uuid"))), Bukkit.getPlayer(UUID.fromString(rs.getString("subject"))), rs.getDate("date"));
        report.setId(rs.getInt("uid"));
        return report;
    } catch (SQLException e) {
        return null;
    }
}

######


public boolean deleteReport(Report r) {
    try {
        PreparedStatement ps = db.getConnection().prepareStatement(DELETE_QUERY);
        ps.setInt(1, r.getId());
        ps.executeUpdate();
    } catch (SQLException e) {
        return false;
    }
    return true;
}

######


public Report[] loadReportsAll(int min, int max) {
    if (min < 0 || min > max || max < 0)
        return null;
    if (max > countReports())
        max = countReports();
    Report[] reports = new Report[max - min];
    try {
        ResultSet rs = db.getConnection().prepareStatement(LOAD_ALL_QUERY).executeQuery();
        int pos = 0, index = 0;
        while (rs.next()) {
            if (index < min) {
                index++;
                continue;
            }
            Report report = null;
            try {
                report = new Report(Category.valueOf(rs.getString("category")), Bukkit.getPlayer(UUID.fromString(rs.getString("uuid"))), Bukkit.getPlayer(UUID.fromString(rs.getString("subject"))), rs.getDate("date"));
            } catch (Exception e) {
                report = new Report(rs.getString("category"), rs.getString("uuid"), rs.getString("subject"), rs.getString("date"));
            }
            report.setId(rs.getInt("uid"));
            reports[pos] = report;
            pos++;
            index++;
            if (pos >= reports.length)
                break;
        }
    } catch (SQLException e) {
        return reports;
    }
    return reports;
}

######


public Report[] loadReports(int min, int max, Category cat) {
    if (min < 0 || min > max || max < 0)
        return null;
    if (max > countReports(cat))
        max = countReports(cat);
    Report[] reports = new Report[max - min];
    try {
        PreparedStatement ps = db.getConnection().prepareStatement(LOAD_ALL_QUERY_BY_CAT);
        ps.setString(1, cat.name());
        ResultSet rs = ps.executeQuery();
        int pos = 0, index = 0;
        while (rs.next()) {
            if (index < min) {
                index++;
                continue;
            }
            Report report = null;
            try {
                report = new Report(Category.valueOf(rs.getString("category")), Bukkit.getPlayer(UUID.fromString(rs.getString("uuid"))), Bukkit.getPlayer(UUID.fromString(rs.getString("subject"))), rs.getDate("date"));
            } catch (Exception e) {
                report = new Report(rs.getString("category"), rs.getString("uuid"), rs.getString("subject"), rs.getString("date"));
            }
            report.setId(rs.getInt("uid"));
            reports[pos] = report;
            pos++;
            index++;
            if (pos >= reports.length)
                break;
        }
    } catch (SQLException e) {
        return reports;
    }
    return reports;
}

######


@Override
public void initialize(URL location, ResourceBundle resources) {
    formatdayPicker();
    try {
        dataBaseInput();
        fillComboBox();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    filTer();
    tableItemClick();
    btnXoasv.setOnAction(e -> {
        deleteSinhVien();
    });
}

######


private void dataBaseInput() throws SQLException {
    obsv.clear();
    Connection conn = sample.LoginApp.database.SQLiteConnection.connector();
    ResultSet rs = null;
    PreparedStatement preparedStatement = null;
    String qr = "select * from SINHVIEN";
    try {
        preparedStatement = conn.prepareStatement(qr);
        rs = preparedStatement.executeQuery();
        while (rs.next()) {
            obsv.add(new SinhVienModel(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4), rs.getString(5), rs.getString(6), rs.getString(7), rs.getString(8)));
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        rs.close();
        preparedStatement.close();
    }
    idsv.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("IdSv"));
    hosv.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("HoSv"));
    tensv.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("TenSv"));
    ngaysinhsv.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("NgaysinhSv"));
    sexsv.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("SexSv"));
    phonesv.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("PhoneSv"));
    diachisv.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("DiachiSv"));
    lopsv.setCellValueFactory(new PropertyValueFactory<SinhVienModel, String>("Lopsv"));
    tablesv.setItems(obsv);
}

######


private void filTer() {
    FilteredList<SinhVienModel> filter = new FilteredList<>(obsv, e -> true);
    txtFind.setOnAction(e -> {
        txtFind.textProperty().addListener(((observable, oldValue, newValue) -> {
            filter.setPredicate((Predicate<? super SinhVienModel>) sv -> {
                if (newValue == null || newValue.isEmpty()) {
                    return true;
                }
                String lowerCase = newValue.toLowerCase();
                if (sv.getIdSv().toLowerCase().contains(lowerCase)) {
                    return true;
                } else if (sv.getTenSv().toLowerCase().contains(lowerCase)) {
                    return true;
                } else if (sv.getHoSv().toLowerCase().contains(lowerCase)) {
                    return true;
                }
                return false;
            });
        }));
        SortedList<SinhVienModel> sort = new SortedList<>(filter);
        sort.comparatorProperty().bind(tablesv.comparatorProperty());
        tablesv.setItems(sort);
    });
}

######


private boolean radioCheck() {
    if (radNamsv.isSelected() || radNusv.isSelected()) {
        return false;
    } else
        return true;
}

######


@Override
public String toString(LocalDate date) {
    if (date != null) {
        return dateFormatter.format(date);
    } else {
        return "";
    }
}

######


@Override
public LocalDate fromString(String string) {
    if (string != null && !string.isEmpty()) {
        return LocalDate.parse(string, dateFormatter);
    } else {
        return null;
    }
}

######


private void formatdayPicker() {
    bDatesv.setConverter(new StringConverter<LocalDate>() {

        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(pattern);

        {
            bDatesv.setPromptText("Ngày sinh");
        }

        @Override
        public String toString(LocalDate date) {
            if (date != null) {
                return dateFormatter.format(date);
            } else {
                return "";
            }
        }

        @Override
        public LocalDate fromString(String string) {
            if (string != null && !string.isEmpty()) {
                return LocalDate.parse(string, dateFormatter);
            } else {
                return null;
            }
        }
    });
}

######


private boolean emtyFeild() {
    if (txtMasv.getText().isEmpty() | txtHosv.getText().isEmpty() | txtTensv.getText().isEmpty() | txtPhonesv.getText().isEmpty() | txtDiachisv.getText().isEmpty()) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị nhập đầy đủ thông tin!!");
        alert.showAndWait();
        return false;
    }
    if (bDatesv.getEditor().getText().isEmpty()) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị nhập Ngày Sinh");
        alert.showAndWait();
        return false;
    }
    if (radioCheck()) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị chọn Giới Tính!");
        alert.showAndWait();
        return false;
    }
    if (comLop.getValue() == null) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("Warring!");
        alert.setHeaderText(null);
        alert.setContentText("Đề nghị chọn Lớp!");
        alert.showAndWait();
        return false;
    }
    return true;
}

######


private void tableItemClick() {
    tablesv.setOnMouseClicked(e -> {
        if (tablesv.getSelectionModel().getSelectedItem() != null) {
            try {
                SinhVienModel sv = tablesv.getSelectionModel().getSelectedItem();
                String qr = "select * from SINHVIEN where ID=?";
                Connection conn = SQLiteConnection.connector();
                PreparedStatement pre;
                ResultSet rs;
                pre = conn.prepareStatement(qr);
                pre.setString(1, sv.getIdSv());
                rs = pre.executeQuery();
                while (rs.next()) {
                    txtMasv.setText(rs.getString(1));
                    txtHosv.setText(rs.getString(2));
                    txtTensv.setText(rs.getString(3));
                    bDatesv.getEditor().setText(rs.getString(4));
                    if (rs.getString(5).equals("Nam")) {
                        radNamsv.setSelected(true);
                    } else
                        radNusv.setSelected(true);
                    txtPhonesv.setText(rs.getString(6));
                    txtDiachisv.setText(rs.getString(7));
                }
                rs.close();
                pre.close();
                conn.close();
            } catch (Exception m) {
                m.printStackTrace();
            }
        }
    });
}

######


private void fillComboBox() {
    Connection connbox = SQLiteConnection.connector();
    PreparedStatement precombox;
    ResultSet rscbox;
    String khoadb = "select DISTINCT MaLop from SINHVIEN order by MaLop asc";
    try {
        precombox = connbox.prepareStatement(khoadb);
        rscbox = precombox.executeQuery();
        while (rscbox.next()) {
            comboxsv.add(rscbox.getString("MaLop"));
        }
        rscbox.close();
        precombox.close();
    } catch (Exception e) {
    }
    comLop.setItems(comboxsv);
}

######


private void clearText() {
    txtHosv.clear();
    txtDiachisv.clear();
    txtTensv.clear();
    txtMasv.clear();
    txtPhonesv.clear();
    bDatesv.setValue(null);
    radNusv.setSelected(false);
    radNamsv.setSelected(false);
}

######


private void editEnableTxt() {
    txtMasv.setEditable(true);
    txtHosv.setEditable(true);
    txtTensv.setEditable(true);
    txtPhonesv.setEditable(true);
    txtDiachisv.setEditable(true);
    radNusv.setDisable(false);
    radNamsv.setDisable(false);
    bDatesv.setDisable(false);
    comLop.setDisable(false);
    btnUpdatesv.setDisable(false);
    btnAddsv.setDisable(false);
}

######


private void editDisableTxt() {
    txtMasv.setEditable(false);
    txtHosv.setEditable(false);
    txtTensv.setEditable(false);
    txtPhonesv.setEditable(false);
    txtDiachisv.setEditable(false);
    radNusv.setDisable(true);
    radNamsv.setDisable(true);
    bDatesv.setDisable(true);
    comLop.setDisable(true);
    btnUpdatesv.setDisable(true);
    btnAddsv.setDisable(true);
}

######


private boolean maSvisCheck() throws SQLException {
    PreparedStatement preCk = null;
    ResultSet rsCk = null;
    Connection connection = SQLiteConnection.connector();
    String gvstr1 = "select ? from SINHVIEN";
    try {
        preCk = connection.prepareStatement(gvstr1);
        preCk.setString(1, txtMasv.getText());
        rsCk = preCk.executeQuery();
        if (rsCk.next()) {
            return true;
        } else {
            Alert alert = new Alert(Alert.AlertType.ERROR);
            alert.setTitle("Lỗi");
            alert.setHeaderText(null);
            alert.setContentText("Không tìm thấy Mã Sinh Viên!");
            alert.showAndWait();
            return false;
        }
    } catch (Exception e) {
        return false;
    } finally {
        rsCk.close();
        preCk.close();
    }
}

######


private void themSinhVien() throws SQLException {
    if (emtyFeild()) {
        if (radNamsv.isSelected()) {
            lblsex = radNamsv.getText();
        } else if (radNusv.isSelected()) {
            lblsex = radNusv.getText();
        }
        Connection conngv = SQLiteConnection.connector();
        PreparedStatement preparegv1 = null;
        String gvstr1 = "insert into SINHVIEN (ID,HoSV,TenSV,NgaySinhSV,GioiTinhSV,PhoneSV,DiaChiSV,MaLop) values (?,?,?,?,?,?,?,?)";
        try {
            preparegv1 = conngv.prepareStatement(gvstr1);
            preparegv1.setString(1, txtMasv.getText());
            preparegv1.setString(2, txtHosv.getText());
            preparegv1.setString(3, txtTensv.getText());
            preparegv1.setString(4, bDatesv.getEditor().getText());
            preparegv1.setString(5, lblsex);
            preparegv1.setString(6, txtPhonesv.getText());
            preparegv1.setString(7, txtDiachisv.getText());
            preparegv1.setString(8, comLop.getSelectionModel().getSelectedItem());
            preparegv1.executeUpdate();
            dataBaseInput();
            clearText();
            preparegv1.close();
            conngv.close();
        } catch (Exception e) {
        } finally {
        }
    }
}

######


private void deleteSinhVien() {
    if (!txtMasv.getText().isEmpty()) {
        Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
        alert.setHeaderText(null);
        alert.setContentText("Bạn có muốn xoá " + txtHosv.getText() + " " + txtTensv.getText() + "\nKhỏi danh sách?");
        Optional<ButtonType> action = alert.showAndWait();
        Connection conn = SQLiteConnection.connector();
        PreparedStatement pred = null;
        if (action.get() == ButtonType.OK) {
            try {
                String qr = "delete from SINHVIEN where ID=?";
                pred = conn.prepareStatement(qr);
                pred.setString(1, txtMasv.getText());
                pred.executeUpdate();
                pred.close();
                dataBaseInput();
                clearText();
                editDisableTxt();
                conn.close();
            } catch (Exception x) {
                x.printStackTrace();
            }
        }
    } else {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setHeaderText(null);
        alert.setContentText("Chọn trong danh sách để xoá!");
        alert.showAndWait();
    }
}

######


private void suaSinhVien() throws SQLException {
    if (emtyFeild()) {
        if (radNamsv.isSelected()) {
            lblsex = radNamsv.getText();
        } else if (radNusv.isSelected()) {
            lblsex = radNusv.getText();
        }
        Connection conngv = SQLiteConnection.connector();
        PreparedStatement preparegvs = null;
        String str2 = "update SINHVIEN set HoSV = ?,TenSV = ?,NgaySinhSV = ?,GioiTinhSV = ?,PhoneSV = ?,DiaChiSV = ?,MaLop = ? where ID = ?";
        try {
            preparegvs = conngv.prepareStatement(str2);
            preparegvs.setString(1, txtHosv.getText());
            preparegvs.setString(2, txtTensv.getText());
            preparegvs.setString(3, bDatesv.getEditor().getText());
            preparegvs.setString(4, lblsex);
            preparegvs.setString(5, txtPhonesv.getText());
            preparegvs.setString(6, txtDiachisv.getText());
            preparegvs.setString(7, comLop.getSelectionModel().getSelectedItem());
            preparegvs.setString(8, txtMasv.getText());
            preparegvs.executeUpdate();
            dataBaseInput();
            preparegvs.close();
            conngv.close();
            clearText();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
        }
    }
}

######


@FXML
void onThemSuaSv(ActionEvent event) {
    if (event.getSource() == btnSuasv) {
        editEnableTxt();
        btnAddsv.setDisable(true);
        btnUpdatesv.setOnAction(e -> {
            try {
                if (maSvisCheck()) {
                    suaSinhVien();
                    editDisableTxt();
                }
            } catch (SQLException s) {
                s.printStackTrace();
            }
        });
    }
    if (event.getSource() == btnThemsv) {
        clearText();
        editEnableTxt();
        btnUpdatesv.setDisable(true);
        btnAddsv.setOnAction(e -> {
            try {
                themSinhVien();
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
            editDisableTxt();
        });
    }
}

######


@Override
public void changed(ObservableValue<? extends TaskCardModel> observable, TaskCardModel oldValue, TaskCardModel newValue) {
    if (oldValue == null) {
        tasksScreenFiller.setVisible(false);
    }
    if (newValue == null) {
        tasksScreenFiller.setVisible(true);
    }
    currentModel = newValue;
    setTaskFields(newValue);
}

######


@Override
public void initialize(URL location, ResourceBundle resources) {
    btn_addTask.setOnAction(e -> newTaskWin());
    String query = "select * from mupp_task t left join mupp_project u on t.project_id=u.project_id where t.assignee=" + MainWinController.currentUser.getUserId() + ";";
    try {
        String result = TCPConnection.getInstance().sendAndRecieve(query);
        System.out.println(result);
        Object resultJson = new JSONParser().parse(result);
        JSONObject resultObject = (JSONObject) resultJson;
        JSONArray resultsArray = (JSONArray) resultObject.get("result");
        for (Object e : resultsArray) {
            JSONObject obj = (JSONObject) e;
            TaskCardModel model = new TaskCardModel(obj);
            tasksList.add(model);
        }
        listView_tasks.setItems(tasksList);
        listView_tasks.setCellFactory(new TaskCellFactory());
        listView_tasks.getSelectionModel().selectedItemProperty().addListener(new ChangeListener<TaskCardModel>() {

            @Override
            public void changed(ObservableValue<? extends TaskCardModel> observable, TaskCardModel oldValue, TaskCardModel newValue) {
                if (oldValue == null) {
                    tasksScreenFiller.setVisible(false);
                }
                if (newValue == null) {
                    tasksScreenFiller.setVisible(true);
                }
                currentModel = newValue;
                setTaskFields(newValue);
            }
        });
        taskPriorityCBX.setItems(priorityList);
        taskStatusCBX.setItems(statusList);
        taskUpdateBtn.setOnAction(e -> updateTask());
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ParseException e) {
        e.printStackTrace();
    }
}

######


private void newTaskWin() {
    try {
        Stage newTaskWin = new Stage();
        newTaskWin.initModality(Modality.APPLICATION_MODAL);
        newTaskWin.setTitle("Создание новой задачи");
        newTaskWin.setWidth(300);
        newTaskWin.setHeight(400);
        Parent root = FXMLLoader.load(getClass().getResource("newTaskWin.fxml"));
        newTaskWin.setScene(new Scene(root, 300, 400));
        newTaskWin.show();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

######


private void updateTask() {
    for (int i = 0; i < tasksList.size(); i++) {
        if (currentModel == tasksList.get(i)) {
            tasksList.get(i).getTask().setTaskPercent((int) taskPercentProgressbar.getValue());
            tasksList.get(i).getTask().setTaskUpdateText(taskUpdTextArea.getText());
            tasksList.get(i).getTask().setTaskPriority(taskPriorityCBX.getSelectionModel().getSelectedIndex());
            tasksList.get(i).getTask().setTaskStatus(taskStatusCBX.getSelectionModel().getSelectedIndex());
            tasksList.get(i).getTask().setTaskLastUpdateDate((int) LocalDate.now().toEpochDay());
            listView_tasks.refresh();
            String sendQuery = "update mupp_task set percent=" + tasksList.get(i).getTask().getTaskPercent() + ", update_text=\"" + tasksList.get(i).getTask().getTaskUpdateText() + "\"," + "priority=" + tasksList.get(i).getTask().getTaskPriority() + "," + "status=" + tasksList.get(i).getTask().getTaskStatus() + "," + "last_update_date=" + tasksList.get(i).getTask().getTaskLastUpdateDate() + " where " + "task_id=" + tasksList.get(i).getTask().getTaskId() + ";";
            try {
                TCPConnection.getInstance().send(sendQuery);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

######


private void setTaskFields(TaskCardModel value) {
    taskNameLabel.setText(value.getTask().getTaskName());
    projNameLabel.setText("Проект: " + value.getProject().getProjectName());
    String query = "select fullname from mupp_user where user_id=" + value.getProject().getProjectManager() + ";";
    String managerName = "Undefined manager";
    try {
        String result = TCPConnection.getInstance().sendAndRecieve(query);
        System.out.println(result);
        Object resultJson = new JSONParser().parse(result);
        JSONObject resultObject = (JSONObject) resultJson;
        JSONArray resultsArray = (JSONArray) resultObject.get("result");
        JSONObject obj = (JSONObject) resultsArray.get(0);
        managerName = (String) obj.get("fullname");
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ParseException e) {
        e.printStackTrace();
    }
    projManagerLabel.setText("Наблюдатель: " + managerName);
    taskUpdTextArea.setText(value.getTask().getTaskUpdateText());
    taskPercentProgressbar.setValue((double) value.getTask().getTaskPercent());
    taskPriorityCBX.getSelectionModel().select(value.getTask().getTaskPriority());
    taskStatusCBX.getSelectionModel().select(value.getTask().getTaskStatus());
}

######


@Override
public String toString() {
    return "Teacher{" + "id=" + super.getId() + ", name=" + super.getName() + ", personalIdNumber=" + super.getPersonalIdNumber() + ", salary=" + salary + ", courses=" + courses + '}';
}

######


@Override
public boolean equals(Object obj) {
    return super.equals(obj);
}

######


@Override
public int hashCode() {
    return super.hashCode();
}

######


public int getSalary() {
    return salary;
}

######


public void setSalary(int salary) {
    this.salary = salary;
}

######


public List<Course> getCourses() {
    if (courses == null) {
        courses = new ArrayList<>();
    }
    return courses;
}

######


public void setCourses(List<Course> courses) {
    this.courses = courses;
}

######


public void addCourse(Course course) {
    getCourses().add(course);
    course.setTeacher(this);
}

######


public void removeCourse(Course course) {
    getCourses().remove(course);
    course.setTeacher(null);
}

######


public static boolean[] isAviable(int teacherID, String date) throws SQLException {
    boolean[] aviable = { true, true, true };
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_isAviable);
            preparedStatement.setString(1, date);
            preparedStatement.setInt(2, teacherID);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                String status = resultSet.getString("status");
                if (status.equals("booked")) {
                    int slot = resultSet.getInt("slot");
                    aviable[slot - 1] = false;
                }
            }
        } catch (SQLException e) {
            e.getMessage();
        } catch (ArrayIndexOutOfBoundsException e) {
            System.err.println(e.getMessage());
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return aviable;
}

######


public static boolean checkTeacher(String surname, String name) throws SQLException {
    boolean isActive = true;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_checkTeacher);
            preparedStatement.setString(1, surname);
            preparedStatement.setString(2, name);
            ResultSet resultSet = preparedStatement.executeQuery();
            if (resultSet.next()) {
                isActive = resultSet.getBoolean("isActive");
            } else {
                isActive = false;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else {
        throw new SQLException();
    }
    return isActive;
}

######


public static boolean insertTeacher(String surname, String name) throws SQLException {
    boolean result = true;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_insertTeacher);
            preparedStatement.setString(1, surname);
            preparedStatement.setString(2, name);
            int rows = preparedStatement.executeUpdate();
            if (rows == 0) {
                result = false;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return result;
}

######


public static List<Teacher> getAllTeachers() throws SQLException {
    List<Teacher> teachers = new ArrayList<>();
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_getAllTeachers);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                String name = resultSet.getString("name");
                String surname = resultSet.getString("surname");
                Boolean isActive = resultSet.getBoolean("isActive");
                if (isActive) {
                    teachers.add(new Teacher(id, name, surname));
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return teachers;
}

######


public static boolean checkTeacherOnCourses(int id) throws SQLException {
    boolean isActive = false;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_checkTeacherOnCourses);
            preparedStatement.setInt(1, id);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                isActive = resultSet.getBoolean("isActive");
                if (isActive) {
                    return true;
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else {
        throw new SQLException();
    }
    return isActive;
}

######


public static boolean deleteTeacher(int id) throws SQLException {
    boolean deleted = false;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement deleteStatement = connection.prepareStatement(sql_deleteTeacher);
            deleteStatement.setInt(1, id);
            deleteStatement.executeUpdate();
            deleted = true;
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else {
        throw new SQLException();
    }
    return deleted;
}

######


public static boolean checkTeacherByID(int teacherID) throws SQLException {
    boolean isActive;
    Connection connection = ManagerDAO.connect();
    if (connection != null) {
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql_checkTeacherByID);
            preparedStatement.setInt(1, teacherID);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                isActive = resultSet.getBoolean("isActive");
                if (isActive) {
                    return isActive;
                }
            }
        } finally {
            ManagerDAO.disconnect(connection);
        }
    } else
        throw new SQLException();
    return false;
}

######


public static TestAddress convertDTO(TestAddressDTO dto) {
    return mapper.map(dto, TestAddress.class);
}

######


public static Iterable<TestAddress> batchConvertDTO(Iterable<TestAddressDTO> dtos) {
    List<TestAddress> entities = new ArrayList<>();
    dtos.forEach(d -> entities.add(convertDTO(d)));
    return entities;
}

######


public static Iterable<TestAddressDTO> batchConvert(Iterable<TestAddress> entities) {
    List<TestAddressDTO> dtos = new ArrayList<>();
    entities.forEach(e -> dtos.add(e));
    return dtos;
}

######


@Override
public TestAddressDTO convert(TestAddress source) {
    return source;
}

######


public static testApplyTab convertDTO(testApplyTabDTO dto) {
    return mapper.map(dto, testApplyTab.class);
}

######


public static Iterable<testApplyTab> batchConvertDTO(Iterable<testApplyTabDTO> dtos) {
    List<testApplyTab> entities = new ArrayList<>();
    dtos.forEach(d -> entities.add(convertDTO(d)));
    return entities;
}

######


public static Iterable<testApplyTabDTO> batchConvert(Iterable<testApplyTab> entities) {
    List<testApplyTabDTO> dtos = new ArrayList<>();
    entities.forEach(e -> dtos.add(e));
    return dtos;
}

######


@Override
public testApplyTabDTO convert(testApplyTab source) {
    return source;
}

######


public static TestCat convertDTO(TestCatDTO dto) {
    return mapper.map(dto, TestCat.class);
}

######


public static Iterable<TestCat> batchConvertDTO(Iterable<TestCatDTO> dtos) {
    List<TestCat> entities = new ArrayList<>();
    dtos.forEach(d -> entities.add(convertDTO(d)));
    return entities;
}

######


public static Iterable<TestCatDTO> batchConvert(Iterable<TestCat> entities) {
    List<TestCatDTO> dtos = new ArrayList<>();
    entities.forEach(e -> dtos.add(e));
    return dtos;
}

######


@Override
public TestCatDTO convert(TestCat source) {
    return source;
}

######


public static void main(String[] args) {
}

######


private static void testInsertion() {
    System.out.println("Antall rader f�r: " + Database.getRowCount("Reservasjon", "Avtale_ID"));
    testExecuteUpdate("INSERT INTO Reservasjon(ID, Avtale_ID, Romnr) VALUES (3,4,5)");
    System.out.println("Antall rader etter: " + Database.getRowCount("Reservasjon", "Avtale_ID"));
}

######


private static void testDeletion() {
    System.out.println("Antall rader f�r: " + Database.getRowCount("Reservasjon", "Avtale_ID"));
    Database.executeUpdate("DELETE FROM Reservasjon WHERE ID = 3;");
    System.out.println("Antall rader etter: " + Database.getRowCount("Reservasjon", "Avtale_ID"));
}

######


private static void testExecute(String sql) {
    try {
        ResultSet rs = Database.execute(sql);
        while (rs.next()) {
            int id = rs.getInt("ID");
            int avtaleID = rs.getInt("Avtale_ID");
            int romnr = rs.getInt("Romnr");
            System.out.println("ID: " + id);
            System.out.println("Avtale-ID: " + avtaleID);
            System.out.println("Romnr: " + romnr);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}

######


private static void testExecuteUpdate(String sql) {
    Database.executeUpdate(sql);
}

######


public static TestMM convertDTO(TestMMDTO dto) {
    return mapper.map(dto, TestMM.class);
}

######


public static Iterable<TestMM> batchConvertDTO(Iterable<TestMMDTO> dtos) {
    List<TestMM> entities = new ArrayList<>();
    dtos.forEach(d -> entities.add(convertDTO(d)));
    return entities;
}

######


public static Iterable<TestMMDTO> batchConvert(Iterable<TestMM> entities) {
    List<TestMMDTO> dtos = new ArrayList<>();
    entities.forEach(e -> dtos.add(e));
    return dtos;
}

######


@Override
public TestMMDTO convert(TestMM source) {
    return source;
}

######


public static TestOrder convertDTO(TestOrderDTO dto) {
    return mapper.map(dto, TestOrder.class);
}

######


public static Iterable<TestOrder> batchConvertDTO(Iterable<TestOrderDTO> dtos) {
    List<TestOrder> entities = new ArrayList<>();
    dtos.forEach(d -> entities.add(convertDTO(d)));
    return entities;
}

######


public static Iterable<TestOrderDTO> batchConvert(Iterable<TestOrder> entities) {
    List<TestOrderDTO> dtos = new ArrayList<>();
    entities.forEach(e -> dtos.add(e));
    return dtos;
}

######


@Override
public TestOrderDTO convert(TestOrder source) {
    return source;
}

######


public static TestOrg convertDTO(TestOrgDTO dto) {
    return mapper.map(dto, TestOrg.class);
}

######


public static Iterable<TestOrg> batchConvertDTO(Iterable<TestOrgDTO> dtos) {
    List<TestOrg> entities = new ArrayList<>();
    dtos.forEach(d -> entities.add(convertDTO(d)));
    return entities;
}

######


public static Iterable<TestOrgDTO> batchConvert(Iterable<TestOrg> entities) {
    List<TestOrgDTO> dtos = new ArrayList<>();
    entities.forEach(e -> dtos.add(e));
    return dtos;
}

######


@Override
public TestOrgDTO convert(TestOrg source) {
    return source;
}

######


public void testIf() {
    Configuration configuration = new Configuration();
    SqlTemplate template = configuration.getTemplate("select * from user_#{demo} where <if test='id != null ' > id  = #{id} </if>");
    HashMap<String, Object> map = new HashMap<String, Object>();
    map.put("demo", "2019");
    SqlMeta process = template.process(map);
    System.out.println(process.getSql());
}

######


public void testWhere() {
    Configuration configuration = new Configuration();
    SqlTemplate template = configuration.getTemplate("select * from user <where> <if test='id != null ' > and id  = #{id} </if>  <if test=' name != null' >name =#{name}</if> </where>");
    HashMap<String, Object> map = new HashMap<String, Object>();
    map.put("name", "1fffdsfdf1");
    SqlMeta process = template.process(map);
    System.out.println(process);
}

######


public void testSet() {
    Configuration configuration = new Configuration();
    SqlTemplate template = configuration.getTemplate("update user  <set> <if test='id != null '> id = #{id} ,</if><if test='name != null '> name = #{name} ,</if> </set> ");
    HashMap<String, Object> map = new HashMap<String, Object>();
    map.put("id", "123");
    map.put("name", "1fffdsfdf1");
    SqlMeta process = template.process(map);
    System.out.println(process);
}

######


public void testChoose() {
    Configuration configuration = new Configuration();
    SqlTemplate template = configuration.getTemplate("select  * from user <where><choose><when test=' id!= null '> and id = #{id} </when><when test=' name!= null '> and name = #{name} </when></choose> </where>");
    HashMap<String, Object> map = new HashMap<String, Object>();
    map.put("id", "123");
    map.put("name", "hhh1");
    SqlMeta process = template.process(map);
    System.out.println(process);
}

######


public void testForEach() {
    Configuration configuration = new Configuration();
    SqlTemplate template = configuration.getTemplate("select  * from user <where> id in <foreach item=\"item\" index=\"index\" collection=\"list\"    open=\"(\" separator=\",\" close=\")\">   ${item}   ${index}  </foreach></where>");
    HashMap<String, Object> map = new HashMap<String, Object>();
    HashMap<String, Object> map2 = new HashMap<String, Object>();
    map2.put("11", "11-11");
    map2.put("22", "22-22");
    map.put("list", map2);
    SqlMeta process = template.process(map);
    System.out.println(process);
}

######


public static TestUser convertDTO(TestUserDTO dto) {
    return mapper.map(dto, TestUser.class);
}

######


public static Iterable<TestUser> batchConvertDTO(Iterable<TestUserDTO> dtos) {
    List<TestUser> entities = new ArrayList<>();
    dtos.forEach(d -> entities.add(convertDTO(d)));
    return entities;
}

######


public static Iterable<TestUserDTO> batchConvert(Iterable<TestUser> entities) {
    List<TestUserDTO> dtos = new ArrayList<>();
    entities.forEach(e -> dtos.add(e));
    return dtos;
}

######


@Override
public TestUserDTO convert(TestUser source) {
    return source;
}

######


@Autowired
public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
    this.jdbcTemplate = jdbcTemplate;
}

######


public Ticket mapRow(ResultSet rs, int rowNum) throws SQLException {
    Ticket tempTicket = new Ticket();
    tempTicket.setTicketId(rs.getInt(1));
    tempTicket.setFirstName(rs.getString(2));
    tempTicket.setLastName(rs.getString(3));
    tempTicket.setDateOfBirth(rs.getString(4));
    tempTicket.setIssueDate(rs.getString(5));
    tempTicket.setLicenseNumber(rs.getString(6));
    tempTicket.setViolation(rs.getInt(7));
    return tempTicket;
}

######


public List<Ticket> getTicket(String licenceNumber) {
    List<Ticket> ticketList = new ArrayList<Ticket>();
    String sql = "select * from user_ticket where licenseNumber = ?";
    try {
        ticketList = jdbcTemplate.query(sql, new Object[] { licenceNumber }, new RowMapper<Ticket>() {

            public Ticket mapRow(ResultSet rs, int rowNum) throws SQLException {
                Ticket tempTicket = new Ticket();
                tempTicket.setTicketId(rs.getInt(1));
                tempTicket.setFirstName(rs.getString(2));
                tempTicket.setLastName(rs.getString(3));
                tempTicket.setDateOfBirth(rs.getString(4));
                tempTicket.setIssueDate(rs.getString(5));
                tempTicket.setLicenseNumber(rs.getString(6));
                tempTicket.setViolation(rs.getInt(7));
                return tempTicket;
            }
        });
    } catch (Exception e) {
        e.printStackTrace();
    }
    return ticketList;
}

######


public Violations mapRow(ResultSet rs, int rowNum) throws SQLException {
    Violations tempViol = new Violations();
    tempViol.setViolationId(rs.getInt(1));
    tempViol.setViolation_type(rs.getString(2));
    tempViol.setViolationCharge(rs.getString(3));
    tempViol.setViolationDescription(rs.getString(4));
    return tempViol;
}

######


public List<Violations> getAllViolation() {
    List<Violations> violationList = new ArrayList<Violations>();
    String sql = "select * from rtvms.user_violations";
    try {
        violationList = jdbcTemplate.query(sql, new Object[] {}, new RowMapper<Violations>() {

            public Violations mapRow(ResultSet rs, int rowNum) throws SQLException {
                Violations tempViol = new Violations();
                tempViol.setViolationId(rs.getInt(1));
                tempViol.setViolation_type(rs.getString(2));
                tempViol.setViolationCharge(rs.getString(3));
                tempViol.setViolationDescription(rs.getString(4));
                return tempViol;
            }
        });
    } catch (Exception e) {
        e.printStackTrace();
    }
    return violationList;
}

######


public boolean issueTicket(TicketForm ticketForm) {
    String insertSql = "INSERT INTO user_ticket (`firstName`, `lastName`, `dateOfBirth`, `issueDate`, `licenseNumber`, `violation`) VALUES (?,?,?,?,?,?)";
    try {
        System.out.println(ticketForm.toString());
        List<Integer> violationIds = ticketForm.getViolationList();
        for (Integer v_id : violationIds) {
            jdbcTemplate.update(insertSql, new Object[] { ticketForm.getFirstName(), ticketForm.getLastName(), ticketForm.getDateOfBirth(), LocalDate.now(), ticketForm.getLicenseNumber(), v_id });
        }
        return true;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    CreateTBtnActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    Ticket_CD_Lbl = new javax.swing.JLabel();
    jPanel1 = new javax.swing.JPanel();
    Hall_Lbl = new javax.swing.JLabel();
    HallTxt = new javax.swing.JTextField();
    Client_Name_Lbl = new javax.swing.JLabel();
    ClientNameTxt = new javax.swing.JTextField();
    Seat_Lbl = new javax.swing.JLabel();
    SeatTxt = new javax.swing.JTextField();
    MovieStartHour_Lbl = new javax.swing.JLabel();
    MovieStartHourTxt = new javax.swing.JTextField();
    CreateTBtn = new javax.swing.JButton();
    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    setSize(getPreferredSize());
    Ticket_CD_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Ticket_CD_Lbl.setText("Ticket Info");
    Ticket_CD_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Hall_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Hall_Lbl.setText("Hall");
    Hall_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    HallTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    Client_Name_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Client_Name_Lbl.setText("Client_Name");
    Client_Name_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    ClientNameTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    Seat_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Seat_Lbl.setText("Seat");
    Seat_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    SeatTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    MovieStartHour_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    MovieStartHour_Lbl.setText("MovieStartHour");
    MovieStartHour_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    MovieStartHourTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    CreateTBtn.setText("Create");
    CreateTBtn.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            CreateTBtnActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
    jPanel1.setLayout(jPanel1Layout);
    jPanel1Layout.setHorizontalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addContainerGap().addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup().addComponent(Client_Name_Lbl, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18, 18, 18)).addGroup(jPanel1Layout.createSequentialGroup().addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false).addComponent(Hall_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(Seat_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(MovieStartHour_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, 98, Short.MAX_VALUE)).addGap(17, 17, 17))).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(HallTxt, javax.swing.GroupLayout.DEFAULT_SIZE, 233, Short.MAX_VALUE).addComponent(ClientNameTxt).addComponent(SeatTxt).addComponent(MovieStartHourTxt)).addContainerGap()).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup().addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(CreateTBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(74, 74, 74)));
    jPanel1Layout.setVerticalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addContainerGap().addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(Hall_Lbl, javax.swing.GroupLayout.PREFERRED_SIZE, 46, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(HallTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 46, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(Client_Name_Lbl, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(ClientNameTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(Seat_Lbl, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(SeatTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(MovieStartHour_Lbl, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(MovieStartHourTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(CreateTBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 52, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(Ticket_CD_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, 371, Short.MAX_VALUE).addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(Ticket_CD_Lbl, javax.swing.GroupLayout.PREFERRED_SIZE, 66, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18, 18, 18).addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    pack();
    setLocationRelativeTo(null);
}

######


private void CreateTBtnActionPerformed(java.awt.event.ActionEvent evt) {
    String Nume = ClientNameTxt.getText();
    if (Nume.length() > 0) {
        try {
            String datetime = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(Calendar.getInstance().getTime());
            String SQL = "Insert into ticket (id_hall,clientName,chairNumber,MovieStartHour,SellingHour) " + "values (" + hall_ID + ",'" + Nume + "'," + seat_NR + ",'" + MovieStartHourTxt.getText() + "','" + datetime + "');";
            Client sclav = new Client();
            sclav.connectToServer();
            sclav.Query(SQL);
            int confExecUpdate = sclav.confExec;
            this.dispose();
            Hall H = new Hall(User, CM, hallNr);
            H.setVisible(true);
            H.setResizable(false);
        } catch (IOException ex) {
            Logger.getLogger(TicketInfo_Create.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(TicketInfo_Create.class.getName()).log(Level.SEVERE, null, ex);
        }
    } else {
        JOptionPane.showMessageDialog(null, "Wrong Name");
    }
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(TicketInfo_Create.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(TicketInfo_Create.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(TicketInfo_Create.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(TicketInfo_Create.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
}

######


public void DatabaseConnect() {
    try {
        Class.forName("com.mysql.jdbc.Driver");
        con = DriverManager.getConnection("jdbc:mysql://localhost:3306/cinemamanagement", "root", "");
    } catch (ClassNotFoundException | SQLException ex) {
        Logger.getLogger(TicketInfo_ReadUpdateDelete.class.getName()).log(Level.SEVERE, null, ex);
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    UpdateBtnActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    DeleteTBtnActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    Ticket_RU_Lbl = new javax.swing.JLabel();
    jPanel1 = new javax.swing.JPanel();
    Hall_Lbl = new javax.swing.JLabel();
    Client_Name_Lbl = new javax.swing.JLabel();
    Seat_Lbl = new javax.swing.JLabel();
    MovieStartHour_Lbl = new javax.swing.JLabel();
    SellingTime_Lbl = new javax.swing.JLabel();
    HallTxt = new javax.swing.JTextField();
    ClientNameTxt = new javax.swing.JTextField();
    SeatTxt = new javax.swing.JTextField();
    MovieStartHourTxt = new javax.swing.JTextField();
    SellingTimeTxt = new javax.swing.JTextField();
    UpdateBtn = new javax.swing.JButton();
    DeleteTBtn = new javax.swing.JButton();
    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    setSize(getPreferredSize());
    Ticket_RU_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Ticket_RU_Lbl.setText("Ticket Info");
    Ticket_RU_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Hall_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Hall_Lbl.setText("Hall");
    Hall_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Client_Name_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Client_Name_Lbl.setText("Client_Name");
    Client_Name_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    Seat_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    Seat_Lbl.setText("Seat");
    Seat_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    MovieStartHour_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    MovieStartHour_Lbl.setText("MovieStartHour");
    MovieStartHour_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    SellingTime_Lbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    SellingTime_Lbl.setText("SellingTime");
    SellingTime_Lbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    HallTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    ClientNameTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    SeatTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    MovieStartHourTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    SellingTimeTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
    jPanel1.setLayout(jPanel1Layout);
    jPanel1Layout.setHorizontalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addContainerGap().addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(SellingTime_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(MovieStartHour_Lbl, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 98, Short.MAX_VALUE).addComponent(Seat_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(Hall_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(Client_Name_Lbl, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(HallTxt, javax.swing.GroupLayout.DEFAULT_SIZE, 262, Short.MAX_VALUE).addComponent(ClientNameTxt).addComponent(SeatTxt).addComponent(MovieStartHourTxt).addComponent(SellingTimeTxt)).addGap(0, 0, Short.MAX_VALUE)));
    jPanel1Layout.setVerticalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addContainerGap().addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(HallTxt).addComponent(Hall_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, 44, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(ClientNameTxt).addComponent(Client_Name_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, 45, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(SeatTxt).addComponent(Seat_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, 44, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(MovieStartHourTxt).addComponent(MovieStartHour_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, 42, Short.MAX_VALUE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(SellingTime_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, 49, Short.MAX_VALUE).addComponent(SellingTimeTxt)).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    jPanel1Layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] { Client_Name_Lbl, Hall_Lbl, MovieStartHour_Lbl, Seat_Lbl, SellingTime_Lbl });
    UpdateBtn.setText("Update");
    UpdateBtn.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            UpdateBtnActionPerformed(evt);
        }
    });
    DeleteTBtn.setText("Delete");
    DeleteTBtn.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            DeleteTBtnActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(Ticket_RU_Lbl, javax.swing.GroupLayout.DEFAULT_SIZE, 392, Short.MAX_VALUE).addGroup(layout.createSequentialGroup().addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addContainerGap()).addGroup(layout.createSequentialGroup().addComponent(UpdateBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 196, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(DeleteTBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(Ticket_RU_Lbl, javax.swing.GroupLayout.PREFERRED_SIZE, 66, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(UpdateBtn, javax.swing.GroupLayout.DEFAULT_SIZE, 48, Short.MAX_VALUE).addComponent(DeleteTBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))));
    pack();
    setLocationRelativeTo(null);
}

######


private void DeleteTBtnActionPerformed(java.awt.event.ActionEvent evt) {
    try {
        String SQL = "DELETE from ticket where chairNumber=" + seat_NR;
        Client sclav = new Client();
        sclav.connectToServer();
        sclav.Query(SQL);
        int deleteResult = sclav.confExec;
        this.dispose();
        Hall H = new Hall(User, CM, hallNr);
        H.setVisible(true);
        H.setResizable(false);
    } catch (IOException ex) {
        Logger.getLogger(TicketInfo_ReadUpdateDelete.class.getName()).log(Level.SEVERE, null, ex);
    } catch (ClassNotFoundException ex) {
        Logger.getLogger(TicketInfo_ReadUpdateDelete.class.getName()).log(Level.SEVERE, null, ex);
    }
}

######


private void UpdateBtnActionPerformed(java.awt.event.ActionEvent evt) {
    try {
        String SQL = "UPDATE ticket set clientName='" + ClientNameTxt.getText() + "' where chairNumber=" + seat_NR;
        Client sclav = new Client();
        sclav.connectToServer();
        sclav.Query(SQL);
        int deleteResult = sclav.confExec;
        this.dispose();
        Hall H = new Hall(User, CM, hallNr);
        H.setVisible(true);
        H.setResizable(false);
    } catch (IOException ex) {
        Logger.getLogger(TicketInfo_ReadUpdateDelete.class.getName()).log(Level.SEVERE, null, ex);
    } catch (ClassNotFoundException ex) {
        Logger.getLogger(TicketInfo_ReadUpdateDelete.class.getName()).log(Level.SEVERE, null, ex);
    }
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(TicketInfo_ReadUpdateDelete.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(TicketInfo_ReadUpdateDelete.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(TicketInfo_ReadUpdateDelete.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(TicketInfo_ReadUpdateDelete.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    if (testSingleHost || !"true".equals(System.getenv("AURORA"))) {
        try (Statement st = sharedConnection.createStatement()) {
            ResultSet rs = st.executeQuery("SELECT count(*) from mysql.time_zone_name " + "where Name in ('Europe/Paris','Canada/Atlantic')");
            assertTrue(rs.next());
            if (rs.getInt(1) == 0) {
                ResultSet rs2 = st.executeQuery("SELECT DATABASE()");
                rs2.next();
                String currentDatabase = rs2.getString(1);
                st.execute("USE mysql");
                ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
                importSql(sharedConnection, classLoader.getResourceAsStream("timezoneTest.sql"));
                st.execute("USE " + currentDatabase);
            }
        }
        previousFormatLocale = Locale.getDefault();
        previousTimeZone = TimeZone.getDefault();
        final TimeZone utcTimeZone = TimeZone.getTimeZone("UTC");
        parisTimeZone = TimeZone.getTimeZone("Europe/Paris");
        canadaTimeZone = TimeZone.getTimeZone("Canada/Atlantic");
        TimeZone.setDefault(parisTimeZone);
        formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
        utcDateFormatISO8601 = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
        utcDateFormatISO8601.setTimeZone(utcTimeZone);
        utcDateFormatSimple = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        utcDateFormatSimple.setTimeZone(utcTimeZone);
        createTable("daylightMysql", " tt DATE");
        if (doPrecisionTest) {
            createTable("timeZoneTime", "id int, tt TIME(6)");
            createTable("ttimeTest", "id int not null primary key auto_increment, dd TIME(3), dd2 TIME(3)");
        }
    }
}

######


@AfterClass()
public static void endClass() {
    if (testSingleHost || !"true".equals(System.getenv("AURORA"))) {
        TimeZone.setDefault(previousTimeZone);
        if (previousFormatLocale != null) {
            Locale.setDefault(previousFormatLocale);
        }
    }
}

######


public static void importSql(Connection conn, InputStream in) throws SQLException {
    Scanner scanner = new Scanner(in);
    scanner.useDelimiter("(;(\r)?\n)|(--\n)");
    try (Statement st = conn.createStatement()) {
        while (scanner.hasNext()) {
            String line = scanner.next();
            if (line.startsWith("/*!") && line.endsWith("*/")) {
                int spaceIndex = line.indexOf(' ');
                line = line.substring(spaceIndex + 1, line.length() - " */".length());
            }
            if (line.trim().length() > 0) {
                st.execute(line);
            }
        }
    }
}

######


@After
public void tearDown() {
    if (previousFormatLocale != null) {
        Locale.setDefault(previousFormatLocale);
    }
    if (previousTimeZone != null) {
        TimeZone.setDefault(previousTimeZone);
    }
}

######


@Test
public void testTimeStamp() throws SQLException {
    Assume.assumeFalse("true".equals(System.getenv("AURORA")));
    TimeZone.setDefault(parisTimeZone);
    try (Connection connection = setConnection("&serverTimezone=Europe/Paris&useServerPrepStmts=true")) {
        setSessionTimeZone(connection, "Europe/Paris");
        Timestamp currentTimeParis = new Timestamp(System.currentTimeMillis());
        PreparedStatement st = connection.prepareStatement("SELECT ?");
        st.setTimestamp(1, currentTimeParis);
        ResultSet rs = st.executeQuery();
        assertTrue(rs.next());
        assertEquals(rs.getTimestamp(1), currentTimeParis);
    }
}

######


@Test
public void testTimeStampUtc() throws SQLException {
    TimeZone.setDefault(parisTimeZone);
    try (Connection connection = setConnection("&serverTimezone=UTC&useServerPrepStmts=true")) {
        setSessionTimeZone(connection, "+00:00");
        Timestamp currentTimeParis = new Timestamp(System.currentTimeMillis());
        PreparedStatement st = connection.prepareStatement("SELECT ?");
        st.setTimestamp(1, currentTimeParis);
        ResultSet rs = st.executeQuery();
        assertTrue(rs.next());
        Timestamp t1 = rs.getTimestamp(1);
        assertEquals(t1, currentTimeParis);
    }
}

######


@Test
public void testTimeStampUtcNow() throws SQLException {
    Assume.assumeFalse("true".equals(System.getenv("AURORA")));
    TimeZone.setDefault(parisTimeZone);
    try (Connection connection = setConnection("&serverTimezone=UTC&useServerPrepStmts=true")) {
        TimeZone.setDefault(parisTimeZone);
        setSessionTimeZone(connection, "+00:00");
        Timestamp currentTimeParis = new Timestamp(System.currentTimeMillis());
        PreparedStatement st = connection.prepareStatement("SELECT NOW()");
        ResultSet rs = st.executeQuery();
        assertTrue(rs.next());
        int offset = parisTimeZone.getOffset(System.currentTimeMillis());
        long timeDifference = currentTimeParis.getTime() - offset - rs.getTimestamp(1).getTime();
        assertTrue(timeDifference < 1000);
    }
}

######


@Test
public void testDifferentTime() throws SQLException {
    Assume.assumeTrue(doPrecisionTest);
    TimeZone.setDefault(parisTimeZone);
    try (Connection connection = setConnection()) {
        PreparedStatement st = connection.prepareStatement("INSERT INTO timeZoneTime (tt) VALUES (?)");
        st.setString(1, "90:00:00.123456");
        st.addBatch();
        st.setString(1, "800:00:00");
        st.addBatch();
        st.setString(1, "800");
        st.addBatch();
        st.setString(1, "-22");
        st.addBatch();
        st.setString(1, "151413");
        st.addBatch();
        st.setString(1, "9:6:3");
        st.addBatch();
        st.setString(1, "00:00:01");
        st.addBatch();
        st.executeBatch();
        st = connection.prepareStatement("SELECT tt FROM timeZoneTime");
        st.executeQuery();
        ResultSet rs = st.getResultSet();
        assertTrue(rs.next());
        assertEquals("90:00:00.123456", rs.getString(1));
        Time tit = rs.getTime(1);
        Time tt2 = Time.valueOf("90:00:00");
        tt2.setTime(tt2.getTime() + 123);
        assertEquals(tit, tt2);
        int offset = 3600000;
        assertEquals(tit.getTime(), (long) 90 * 3600000 + 123 - offset);
        assertEquals(rs.getTimestamp(1), new Timestamp(70, 0, 1, 90, 0, 0, 123456000));
        assertTrue(rs.next());
        assertEquals(rs.getString(1), "800:00:00.000000");
        assertEquals(rs.getTime(1).getTime(), (long) 800 * 3600000 - offset);
        assertEquals(rs.getTimestamp(1), new Timestamp(70, 0, 1, 800, 0, 0, 0));
        assertTrue(rs.next());
        assertEquals(rs.getString(1), "00:08:00.000000");
        assertEquals(rs.getTime(1).getTime(), (long) 8 * 60000 - offset);
        assertEquals(rs.getTimestamp(1), new Timestamp(70, 0, 1, 0, 8, 0, 0));
        assertTrue(rs.next());
        assertEquals(rs.getString(1), "-00:00:22.000000");
        assertEquals(rs.getTimestamp(1), new Timestamp(70, 0, 1, 0, 0, 22, 0));
        assertTrue(rs.next());
        assertEquals(rs.getString(1), "15:14:13.000000");
        assertEquals(rs.getTime(1).getTime(), (long) 15 * 3600000 + 14 * 60000 + 13 * 1000 - offset);
        assertEquals(rs.getTimestamp(1), new Timestamp(70, 0, 1, 15, 14, 13, 0));
        assertTrue(rs.next());
        assertEquals(rs.getString(1), "09:06:03.000000");
        assertEquals(rs.getTime(1).getTime(), (long) 9 * 3600000 + 6 * 60000 + 3 * 1000 - offset);
        assertEquals(rs.getTimestamp(1), new Timestamp(70, 0, 1, 9, 6, 3, 0));
        assertTrue(rs.next());
        assertEquals(rs.getString(1), "00:00:01.000000");
        Time tt = rs.getTime(1);
        assertEquals(tt.getTime(), (long) 1000 - offset);
    }
}

######


@Test
public void testTimeUtc() throws SQLException {
    Assume.assumeFalse("true".equals(System.getenv("AURORA")));
    Assume.assumeTrue(doPrecisionTest);
    TimeZone.setDefault(parisTimeZone);
    try (Connection connection = setConnection("&serverTimezone=UTC")) {
        setSessionTimeZone(connection, "+00:00");
        Calendar initTime = Calendar.getInstance(TimeZone.getTimeZone("Europe/Paris"));
        initTime.clear();
        initTime.set(1970, Calendar.JANUARY, 1, 1, 45, 23);
        initTime.set(Calendar.MILLISECOND, 123);
        Time timeParis = new Time(initTime.getTimeInMillis());
        Time timeParis2 = Time.valueOf("01:45:23");
        timeParis2.setTime(timeParis2.getTime() + 123);
        PreparedStatement st1 = connection.prepareStatement("INSERT INTO ttimeTest (dd, dd2) values (?, ?)");
        st1.setTime(1, timeParis);
        st1.setTime(2, timeParis2);
        st1.execute();
        PreparedStatement st = connection.prepareStatement("SELECT dd, dd2 from ttimeTest");
        ResultSet rs = st.executeQuery();
        assertTrue(rs.next());
        assertEquals(rs.getTime(1).getTime(), timeParis.getTime());
        assertEquals(rs.getTime(1), timeParis);
        assertEquals(rs.getTime(2).getTime(), timeParis2.getTime());
        assertEquals(rs.getTime(2), timeParis2);
    }
}

######


@Test
public void testTimeUtcNow() throws SQLException {
    Assume.assumeFalse("true".equals(System.getenv("AURORA")));
    TimeZone.setDefault(parisTimeZone);
    try (Connection connection = setConnection("&serverTimezone=UTC")) {
        setSessionTimeZone(connection, "+00:00");
        Time currentTimeParis = new Time(System.currentTimeMillis());
        PreparedStatement st = sharedConnection.prepareStatement("SELECT NOW()");
        ResultSet rs = st.executeQuery();
        assertTrue(rs.next());
        int offset = parisTimeZone.getOffset(System.currentTimeMillis());
        long timeDifference = currentTimeParis.getTime() - offset - rs.getTimestamp(1).getTime();
        assertTrue(timeDifference < 1000);
    }
}

######


@Test
public void testTimeOffsetNowUseServer() throws SQLException {
    Assume.assumeFalse("true".equals(System.getenv("AURORA")));
    try (Connection connection = setConnection("&useLegacyDatetimeCode=false&serverTimezone=+5:00")) {
        setSessionTimeZone(connection, "+5:00");
        Time currentTimeParis = new Time(System.currentTimeMillis());
        PreparedStatement st = connection.prepareStatement("SELECT NOW()");
        ResultSet rs = st.executeQuery();
        assertTrue(rs.next());
        Timestamp nowServer = rs.getTimestamp(1);
        long timeDifference = currentTimeParis.getTime() - nowServer.getTime();
        assertTrue(timeDifference < 1000);
    }
}

######


@Test
public void testDifferentTimeZoneServer() throws SQLException {
    Assume.assumeFalse("true".equals(System.getenv("AURORA")));
    try (Connection connection = setConnection("&serverTimezone=UTC")) {
        setSessionTimeZone(sharedConnection, "+00:00");
        Time currentTimeParis = new Time(System.currentTimeMillis());
        PreparedStatement st = sharedConnection.prepareStatement("SELECT NOW()");
        ResultSet rs = st.executeQuery();
        assertTrue(rs.next());
        int offset = parisTimeZone.getOffset(System.currentTimeMillis());
        long timeDifference = currentTimeParis.getTime() - offset - rs.getTimestamp(1).getTime();
        assertTrue(timeDifference < 1000);
    }
}

######


@Test
public void testTimeStampOffsetNowUseServer() throws SQLException {
    Assume.assumeFalse("true".equals(System.getenv("AURORA")));
    try (Connection connection = setConnection("&serverTimezone=Europe/Paris")) {
        Timestamp currentTimeParis = new Timestamp(System.currentTimeMillis());
        PreparedStatement st = connection.prepareStatement("SELECT NOW()");
        ResultSet rs = st.executeQuery();
        assertTrue(rs.next());
        int offset = parisTimeZone.getOffset(System.currentTimeMillis());
        long timeDifference = currentTimeParis.getTime() - offset - rs.getTimestamp(1).getTime();
        assertTrue(timeDifference < 1000);
    }
}

######


@Test
public void testDayLightLegacy() throws SQLException {
    testDayLight(true);
}

######


@Test
public void testDayLight() throws SQLException {
    testDayLight(false);
}

######


public boolean startTask(String taskName) {
    String time = LocalDateTime.now().toString();
    Statement stm = null;
    Connection c = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        stm = c.createStatement();
        String sql = "INSERT INTO Logs (name,start)VALUES (?, ? )";
        PreparedStatement pstmt = c.prepareStatement(sql);
        pstmt.setString(1, taskName);
        pstmt.setString(2, time);
        pstmt.executeUpdate();
        stm.close();
        c.commit();
        c.close();
    } catch (Exception e) {
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
        System.exit(0);
    }
    return true;
}

######


public boolean stopTask(String taskName) {
    String time = LocalDateTime.now().toString();
    Connection c = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        String sql = "UPDATE Logs set stop = ? where name = ?";
        PreparedStatement pstmt = c.prepareStatement(sql);
        pstmt.setString(2, taskName);
        pstmt.setString(1, time);
        pstmt.executeUpdate();
        c.commit();
    } catch (Exception e) {
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
    }
    return true;
}

######


public boolean sizeTask(String taskName, String size) {
    Connection c = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        String sql = "UPDATE Logs set size = ? where name = ?";
        PreparedStatement pstmt = c.prepareStatement(sql);
        pstmt.setString(1, size);
        pstmt.setString(2, taskName);
        pstmt.executeUpdate();
        c.commit();
    } catch (Exception e) {
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
    }
    return true;
}

######


public boolean deleteTask(String taskName) {
    Connection c = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        String sql = "DELETE FROM Logs WHERE  name = ?";
        PreparedStatement pstmt = c.prepareStatement(sql);
        pstmt.setString(1, taskName);
        pstmt.executeUpdate();
        c.commit();
    } catch (Exception e) {
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
    }
    return true;
}

######


public boolean describeTask(String taskName, String description) {
    Connection c = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        String sql = "UPDATE Logs set description = ? where name = ?";
        PreparedStatement pstmt = c.prepareStatement(sql);
        pstmt.setString(1, description);
        pstmt.setString(2, taskName);
        pstmt.executeUpdate();
        c.commit();
    } catch (Exception e) {
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
    }
    return true;
}

######


public boolean renameTask(String oldName, String newName) {
    Connection c = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        String sql = "UPDATE Logs set name = ? where name = ?";
        PreparedStatement pstmt = c.prepareStatement(sql);
        pstmt.setString(1, newName);
        pstmt.setString(2, oldName);
        pstmt.executeUpdate();
        c.commit();
    } catch (Exception e) {
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
    }
    return true;
}

######


public String taskElapsedTime(String taskName) {
    List<Long> arr = new ArrayList<>();
    Connection c = null;
    Statement stmt = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        stmt = c.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM Logs");
        while (rs.next()) {
            if (rs.getString("name").equals(taskName)) {
                LocalDateTime start = LocalDateTime.parse(rs.getString("start"));
                LocalDateTime stop = LocalDateTime.parse(rs.getString("stop"));
                long elpasedTime = ChronoUnit.SECONDS.between(start, stop);
                arr.add(elpasedTime);
            }
        }
    } catch (Exception e) {
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
    }
    long total = 0;
    for (int i = 0; i < arr.size(); i++) {
        total += arr.get(i);
    }
    String timeSpent = total / 3600 + ":" + total / 60 + ":" + total % 60;
    return String.valueOf(timeSpent);
}

######


public String taskSize(String taskName) {
    Connection c = null;
    Statement stmt = null;
    String size = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        stmt = c.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM Logs");
        while (rs.next()) {
            if (rs.getString("name").equals(taskName) && !(rs.getString("size").isEmpty())) {
                size = rs.getString("size");
            }
        }
    } catch (Exception e) {
        e.getMessage();
    }
    return size;
}

######


public String taskDescription(String taskName) {
    Connection c = null;
    Statement stmt = null;
    String description = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        stmt = c.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM Logs");
        while (rs.next()) {
            if (rs.getString("name").equals(taskName) && !rs.getString("size").isEmpty()) {
                description = rs.getString("description");
            }
        }
    } catch (Exception e) {
        e.getMessage();
    }
    return description;
}

######


public String minTimeForSize(String size) {
    TreeSet<String> set = new TreeSet<>();
    for (String s : taskNamesForSize(size)) {
        set.add(taskElapsedTime(s));
    }
    return set.first().toString();
}

######


public String maxTimeForSize(String size) {
    TreeSet<String> set = new TreeSet<>();
    for (String s : taskNamesForSize(size)) {
        set.add(taskElapsedTime(s));
    }
    return set.last().toString();
}

######


public String avgTimeForSize(String size) {
    Connection c = null;
    Statement stmt = null;
    String name = null;
    String start = null;
    String stop = null;
    ArrayList<Long> arr = new ArrayList<>();
    long elapsedSeconds = 0;
    long total = 0;
    String avg = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        stmt = c.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM Logs");
        while (rs.next()) {
            if (rs.getString("size").equals(size) && !rs.getString("size").isEmpty()) {
                start = rs.getString("start");
                stop = rs.getString("stop");
                elapsedSeconds = ChronoUnit.SECONDS.between(LocalDateTime.parse(start), LocalDateTime.parse(stop));
                arr.add(elapsedSeconds);
            }
        }
    } catch (Exception e) {
        e.getMessage();
    }
    for (int i = 0; i < arr.size(); i++) {
        total = total + arr.get(i);
    }
    total = total / arr.size();
    avg = total / 3600 + ":" + total / 60 + ":" + total % 60;
    return avg;
}

######


public Set<String> taskNamesForSize(String size) {
    Set<String> set = new TreeSet<>();
    Connection c = null;
    Statement stmt = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        stmt = c.createStatement();
        String sql = "select * from Logs";
        ResultSet rs = stmt.executeQuery(sql);
        while (rs.next()) {
            if (rs.getString("size").equals(size))
                set.add(rs.getString("name"));
        }
    } catch (Exception e) {
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
    }
    return set;
}

######


public String elapsedTimeForAllTasks() {
    ArrayList<String> elapseTime = new ArrayList<>();
    Connection c = null;
    Statement stmt = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        stmt = c.createStatement();
        String sql = "select name from Logs";
        ResultSet rs = stmt.executeQuery(sql);
        while (rs.next()) {
            elapseTime.add(taskElapsedTime(rs.getString("name")));
        }
    } catch (Exception e) {
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
    }
    int totalTimeSeconds = 0;
    for (String i : elapseTime) {
        String[] token = i.split("D:|h:|m:|s");
        totalTimeSeconds += Integer.parseInt(token[0]) * 24 * 60 * 60;
        totalTimeSeconds += Integer.parseInt(token[1]) * 60 * 60;
        totalTimeSeconds += Integer.parseInt(token[2]) * 60;
        totalTimeSeconds += Integer.parseInt(token[3]);
    }
    String totalTime = Integer.toString(totalTimeSeconds / 60 / 60) + "h:" + Integer.toString(totalTimeSeconds / 60 % 60) + "m:" + Integer.toString(totalTimeSeconds % 3600) + "s";
    return totalTime;
}

######


public static Set<String> taskNames() {
    Set<String> set = new TreeSet<>();
    Connection c = null;
    Statement stmt = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        stmt = c.createStatement();
        String sql = "select name from Logs";
        ResultSet rs = stmt.executeQuery(sql);
        while (rs.next()) {
            set.add(rs.getString("name"));
        }
    } catch (Exception e) {
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
    }
    return set;
}

######


public Set<String> taskSizes() {
    Set<String> set = new TreeSet<>();
    Connection c = null;
    Statement stmt = null;
    try {
        Class.forName("org.sqlite.JDBC");
        c = DriverManager.getConnection("jdbc:sqlite:Log.db");
        c.setAutoCommit(false);
        stmt = c.createStatement();
        String sql = "select size from Logs";
        ResultSet rs = stmt.executeQuery(sql);
        while (rs.next()) {
            if (rs.getString("size") != null) {
                set.add(rs.getString("size"));
            }
        }
    } catch (Exception e) {
        System.err.println(e.getClass().getName() + ": " + e.getMessage());
    }
    return set;
}

######


public static void create_an_example() {
    String secret_user1 = "Shirin";
    String secret_user2 = "Yannic";
    String public_user = "Shirin";
    try {
        OutputStream os = new FileOutputStream("/Users/tempadmin/Desktop/exps/tomcat/in_dir/example.txt");
        os.write(secret_user1.getBytes());
        os.write(secret_user2.getBytes());
        os.write(public_user.getBytes());
        os.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

######


public static void main(String[] args) {
    if (args.length != 1) {
        System.out.println("Expects file name as parameter");
        return;
    }
    System.out.println("input file= " + args[0]);
    int n = 3;
    String public_user;
    String secret_user1;
    String secret_user2;
    String pw = "1234";
    List<Character> values = new ArrayList<>();
    try (FileInputStream fis = new FileInputStream(args[0])) {
        byte[] bytes = new byte[Character.BYTES];
        while (((fis.read(bytes)) != -1)) {
            char value = ByteBuffer.wrap(bytes).getChar();
            values.add(value);
        }
    } catch (IOException e) {
        System.err.println("Error reading input");
        e.printStackTrace();
        return;
    }
    if (values.size() < n) {
        throw new RuntimeException("Too less data...");
    }
    int m = values.size() / n;
    System.out.println("m=" + m);
    char[] secret1_arr = new char[m];
    for (int i = 0; i < m; i++) {
        secret1_arr[i] = values.get(i);
    }
    secret_user1 = new String(secret1_arr);
    char[] secret2_arr = new char[m];
    for (int i = 0; i < m; i++) {
        secret2_arr[i] = values.get(i + m);
    }
    secret_user2 = new String(secret2_arr);
    char[] public_arr = new char[m];
    for (int i = 0; i < m; i++) {
        public_arr[i] = values.get(i + 2 * m);
    }
    public_user = new String(public_arr);
    System.out.println("secret1_username=" + secret_user1);
    System.out.println("secret2_username=" + secret_user2);
    System.out.println("public_username=" + public_user);
    DataSourceRealm DSR = new DataSourceRealm();
    Connection dbConnection = null;
    dbConnection = DSR.open();
    if (dbConnection == null) {
        System.out.println("DB connection failed...");
    }
    Statement st;
    try {
        st = dbConnection.createStatement();
        st.execute("delete from users;");
        st.execute("insert into users (user_name, user_pass) values ('" + public_user + "', '" + pw + "');");
    } catch (Exception e) {
        System.out.println("Could not insert user in the table...");
        throw new RuntimeException(e);
    }
    Mem.clear();
    DSR.authenticate_unsafe(dbConnection, secret_user1, pw);
    long cost1 = Mem.instrCost;
    System.out.println("cost1=" + cost1);
    Mem.clear();
    DSR.authenticate_unsafe(dbConnection, secret_user2, pw);
    long cost2 = Mem.instrCost;
    System.out.println("cost2=" + cost2);
    Kelinci.addCost(Math.abs(cost1 - cost2));
    System.out.println("|cost1-cost2|=" + Math.abs(cost2 - cost1));
    try {
        st.execute("delete from users;");
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        DSR.close(dbConnection);
    }
    System.out.println("Done.");
}

######


public ArrayList<Transacao> getTransacaos(int idConta) {
    ArrayList<Transacao> resultado = new ArrayList<Transacao>();
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        ps = conexao.prepareStatement("SELECT * FROM transacao WHERE idconta = ?");
        ps.setInt(1, idConta);
        rs = ps.executeQuery();
        while (rs.next()) {
            resultado.add(new Transacao(rs.getInt("idtransacao"), rs.getInt("idconta"), rs.getDate("datatransacao"), rs.getString("tipotransacoa"), rs.getString("valortransacao")));
        }
        rs.close();
        ps.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return resultado;
}

######


@Before
public void before() throws SQLException {
    if (testSingleHost) {
        Statement stmt = sharedConnection.createStatement();
        stmt.execute("drop table if exists tx_fore_key");
        stmt.execute("drop table if exists tx_prim_key");
        createTable("tx_prim_key", "id int not null primary key", "engine=innodb");
        createTable("tx_fore_key", "id int not null primary key, id_ref int not null, " + "foreign key (id_ref) references tx_prim_key(id) on delete restrict on update restrict", "engine=innodb");
    }
}

######


@After
public void after() throws SQLException {
    if (testSingleHost) {
        Statement stmt = sharedConnection.createStatement();
        stmt.execute("drop table if exists tx_fore_key");
        stmt.execute("drop table if exists tx_prim_key");
    }
}

######


@Test
public void testProperRollback() throws Exception {
    try (Statement st = sharedConnection.createStatement()) {
        st.executeUpdate("insert into tx_prim_key(id) values(32)");
        st.executeUpdate("insert into tx_fore_key(id, id_ref) values(42, 32)");
    }
    sharedConnection.setAutoCommit(false);
    try (Statement st = sharedConnection.createStatement()) {
        st.executeUpdate("delete from tx_prim_key where id = 32");
        sharedConnection.commit();
        fail("Expected SQLException");
    } catch (SQLException e) {
        assertTrue(e.getMessage().contains("a foreign key constraint fails"));
        sharedConnection.rollback();
    }
    try (Connection conn2 = openNewConnection(connUri);
        Statement st = conn2.createStatement()) {
        st.setQueryTimeout(30000);
        st.executeUpdate("delete from tx_fore_key where id = 42");
        st.executeUpdate("delete from tx_prim_key where id = 32");
    }
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("TruncateExceptionTest", "id tinyint");
    createTable("TruncateExceptionTest2", "id tinyint not null primary key auto_increment, id2 tinyint ");
}

######


@Test
public void truncationThrowError() {
    try {
        queryTruncation(true);
        fail("Must have thrown SQLException");
    } catch (SQLException e) {
    }
}

######


@Test
public void truncationThrowNoError() {
    try {
        ResultSet resultSet = sharedConnection.createStatement().executeQuery("SELECT @@sql_mode");
        resultSet.next();
        Assume.assumeFalse(resultSet.getString(1).contains("STRICT_TRANS_TABLES"));
        queryTruncation(false);
    } catch (SQLException e) {
        e.printStackTrace();
        fail("Must not have thrown exception");
    }
}

######


public void queryTruncation(boolean truncation) throws SQLException {
    try (Connection connection = setConnection("&jdbcCompliantTruncation=" + truncation)) {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("INSERT INTO TruncateExceptionTest (id) VALUES (999)");
        }
    }
}

######


@Test
public void queryTruncationFetch() throws SQLException {
    int[] autoInc = setAutoInc();
    try (Connection connection = setConnection("&jdbcCompliantTruncation=true")) {
        Statement stmt = connection.createStatement();
        stmt.execute("TRUNCATE TABLE TruncateExceptionTest2");
        stmt.setFetchSize(1);
        PreparedStatement pstmt = connection.prepareStatement("INSERT INTO TruncateExceptionTest2 (id2) VALUES (?)", Statement.RETURN_GENERATED_KEYS);
        pstmt.setInt(1, 45);
        pstmt.addBatch();
        pstmt.setInt(1, 999);
        pstmt.addBatch();
        pstmt.setInt(1, 55);
        pstmt.addBatch();
        try {
            pstmt.executeBatch();
            fail("Must have thrown SQLException");
        } catch (SQLException e) {
        }
        ResultSet rs = pstmt.getGeneratedKeys();
        assertTrue(rs.next());
        assertEquals(autoInc[0] + autoInc[1], rs.getInt(1));
        if (sharedIsRewrite()) {
            assertFalse(rs.next());
        } else {
            assertTrue(rs.next());
            assertEquals(autoInc[1] + autoInc[0] * 2, rs.getInt(1));
            assertFalse(rs.next());
        }
    }
}

######


@Test
public void queryTruncationBatch() throws SQLException {
    int[] autoInc = setAutoInc();
    try (Connection connection = setConnection("&jdbcCompliantTruncation=true&useBatchMultiSendNumber=3&profileSql=true&log=true")) {
        Statement stmt = connection.createStatement();
        stmt.execute("TRUNCATE TABLE TruncateExceptionTest2");
        PreparedStatement pstmt = connection.prepareStatement("INSERT INTO TruncateExceptionTest2 (id2) VALUES (?)", Statement.RETURN_GENERATED_KEYS);
        pstmt.setInt(1, 45);
        pstmt.addBatch();
        pstmt.setInt(1, 46);
        pstmt.addBatch();
        pstmt.setInt(1, 47);
        pstmt.addBatch();
        pstmt.setInt(1, 48);
        pstmt.addBatch();
        pstmt.setInt(1, 999);
        pstmt.addBatch();
        pstmt.setInt(1, 49);
        pstmt.addBatch();
        pstmt.setInt(1, 50);
        pstmt.addBatch();
        try {
            pstmt.executeBatch();
            fail("Must have thrown SQLException");
        } catch (SQLException e) {
        }
        ResultSet rs = pstmt.getGeneratedKeys();
        for (int i = 1; i <= (sharedIsRewrite() ? 4 : 6); i++) {
            assertTrue(rs.next());
            assertEquals(autoInc[1] + autoInc[0] * i, rs.getInt(1));
        }
        assertFalse(rs.next());
    }
}

######


public void onEventMainThread(InitialLoad event) {
    initialLoad();
}

######


private void initialLoad() {
    long t3, t2, t1, t0 = System.currentTimeMillis();
    SQLiteDatabase sqlDb = db.db();
    sqlDb.beginTransaction();
    t1 = System.currentTimeMillis();
    try {
        updateFieldInTable(sqlDb, DatabaseHelper.CATEGORY_TABLE, 0, "title", context.getString(R.string.no_category));
        updateFieldInTable(sqlDb, DatabaseHelper.CATEGORY_TABLE, -1, "title", context.getString(R.string.split));
        updateFieldInTable(sqlDb, DatabaseHelper.PROJECT_TABLE, 0, "title", context.getString(R.string.no_project));
        sqlDb.setTransactionSuccessful();
    } finally {
        sqlDb.endTransaction();
    }
    t2 = System.currentTimeMillis();
    if (MyPreferences.shouldUpdateHomeCurrency(context)) {
        db.setDefaultHomeCurrency();
    }
    CurrencyCache.initialize(db);
    t3 = System.currentTimeMillis();
    if (MyPreferences.shouldRebuildRunningBalance(context)) {
        db.rebuildRunningBalances();
    }
    if (MyPreferences.shouldUpdateAccountsLastTransactionDate(context)) {
        db.updateAccountsLastTransactionDate();
    }
    long t4 = System.currentTimeMillis();
    Log.d("Financisto", "Load time = " + (t4 - t0) + "ms = " + (t2 - t1) + "ms+" + (t3 - t2) + "ms+" + (t4 - t3) + "ms");
}

######


private void updateFieldInTable(SQLiteDatabase db, String table, long id, String field, String value) {
    db.execSQL("update " + table + " set " + field + "=? where _id=?", new Object[] { value, id });
}

######


public void onEventBackgroundThread(GetAccountList event) {
    List<Account> accounts = db.getAllAccountsList(MyPreferences.isHideClosedAccounts(context));
    bus.post(new AccountList(accounts));
}

######


public void onEventBackgroundThread(GetTransactionList event) {
    Cursor c;
    WhereFilter filter = event.filter;
    long accountId = filter.getAccountId();
    if (accountId != -1) {
        c = db.getBlotterForAccount(filter);
    } else {
        c = db.getBlotter(filter);
    }
    bus.post(new TransactionList(accountId, c));
}

######


public void onEventBackgroundThread(GetBlotterTotal event) {
    WhereFilter filter = event.filter;
    TransactionsTotalCalculator calculator = new TransactionsTotalCalculator(db, filter);
    Total total = calculator.getBlotterBalanceInHomeCurrency();
    bus.post(new BlotterTotal(total));
}

######


@BeforeClass()
public static void initClass() throws SQLException {
    createTable("unicode_test", "id int not null primary key auto_increment, test_text varchar(100)", "charset utf8");
    createTable("umlaut_test", "id varchar(100), test_text varchar(100), t int", "charset utf8");
    createTable("unicode_test2", "id int not null primary key auto_increment, test_text varchar(100)", "charset=utf8");
    createTable("unicode_test3", "id int not null primary key auto_increment, test_text varchar(100)", "charset utf8mb4");
}

######


@Test
public void firstTest() throws SQLException {
    String jaString = "\u65e5\u672c\u8a9e\u6587\u5b57\u5217";
    Statement stmt = sharedConnection.createStatement();
    PreparedStatement ps = sharedConnection.prepareStatement("insert into unicode_test (test_text) values (?)");
    ps.setString(1, jaString);
    ps.executeUpdate();
    ResultSet rs = stmt.executeQuery("select test_text from unicode_test");
    assertEquals(true, rs.next());
    assertEquals(jaString, rs.getString(1));
}

######


@SuppressWarnings("unchecked")
@Transactional(readOnly = true)
public List<Float> getControlDataPointsForPopulation(Integer populationId) {
    return (List<Float>) getCurrentSession().createQuery("SELECT c.dataPoint FROM UnidimensionalControlView c WHERE c.populationId=?").setInteger(0, populationId).list();
}

######


@SuppressWarnings("unchecked")
@Transactional(readOnly = true)
public List<Float> getMutantDataPoints(SexType sex, ZygosityType zygosity, Parameter parameter, Integer populationId) {
    return (List<Float>) getCurrentSession().createQuery("SELECT c.dataPoint FROM UnidimensionalMutantView c WHERE c.sex=? AND c.zygosity=? AND c.parameter=?  AND c.populationId=?").setString(0, sex.name()).setString(1, zygosity.name()).setLong(2, parameter.getId()).setInteger(3, populationId).list();
}

######


@Transactional(readOnly = true)
public BiologicalModel getControlBiologicalModelByPopulation(Integer populationId) {
    return (BiologicalModel) getCurrentSession().createQuery("SELECT bs.biologicalModel FROM Observation o inner join o.sample as bs inner join bs.biologicalModel bm WHERE o.populationId=? AND bs.group='control'").setInteger(0, populationId).list().get(0);
}

######


@Transactional(readOnly = true)
public BiologicalModel getMutantBiologicalModelByPopulation(Integer populationId) {
    return (BiologicalModel) getCurrentSession().createQuery("SELECT bs.biologicalModel FROM Observation o inner join o.sample as bs inner join bs.biologicalModel bm WHERE o.populationId=? AND bs.group='experimental'").setInteger(0, populationId).list().get(0);
}

######


@SuppressWarnings("unchecked")
@Transactional(readOnly = true)
public List<BiologicalModel> getBiologicalModelsByParameterAndGene(Parameter parameter, String accessionId) {
    return (List<BiologicalModel>) getCurrentSession().createQuery("SELECT DISTINCT c.biologicalModel FROM UnidimensionalMutantView c inner join c.biologicalModel as bm join bm.genomicFeatures as gf WHERE gf.id.accession=? AND c.parameter=?").setString(0, accessionId).setInteger(1, parameter.getId()).list();
}

######


@SuppressWarnings("unchecked")
@Transactional(readOnly = true)
public List<BiologicalModel> getMutantBiologicalModelsByParameter(Parameter parameter) {
    return (List<BiologicalModel>) getCurrentSession().createQuery("SELECT DISTINCT c.biologicalModel FROM UnidimensionalMutantView c inner join c.biologicalModel as bm join bm.genomicFeatures as gf WHERE  c.parameter=?").setInteger(0, parameter.getId()).list();
}

######


@SuppressWarnings("unchecked")
@Transactional(readOnly = true)
public List<Integer> getPopulationIdsByParameterAndMutantBiologicalModel(Parameter parameter, BiologicalModel biologicalModel) {
    return (List<Integer>) getCurrentSession().createQuery("SELECT DISTINCT populationId FROM UnidimensionalMutantView WHERE parameter=? AND biologicalModel=?").setLong(0, parameter.getId()).setInteger(1, biologicalModel.getId()).list();
}

######


@Transactional(readOnly = true)
public SexType getSexByPopulation(Integer populationId) {
    return (SexType) getCurrentSession().createQuery("SELECT DISTINCT c.sex FROM UnidimensionalMutantView c WHERE c.populationId=?").setInteger(0, populationId).uniqueResult();
}

######


@SuppressWarnings("unchecked")
@Transactional(readOnly = true)
public List<ZygosityType> getZygositiesByPopulation(Integer populationId) {
    return (List<ZygosityType>) getCurrentSession().createQuery("SELECT DISTINCT c.zygosity FROM UnidimensionalMutantView c WHERE c.populationId=?").setInteger(0, populationId).list();
}

######


@SuppressWarnings("unchecked")
@Transactional(readOnly = true)
public List<Organisation> getOrganisationsByColonyAndParameter(String colony, Parameter parameter) {
    return (List<Organisation>) getCurrentSession().createQuery("SELECT DISTINCT c.organisation FROM UnidimensionalMutantView c WHERE c.colony=? and c.parameter=?").setString(0, colony).setInteger(1, parameter.getId()).list();
}

######


@Transactional(readOnly = false)
public void deleteUnidimensionalResultByParameter(Parameter parameter) throws SQLException {
    String query = "DELETE FROM stats_unidimensional_results" + " WHERE parameter_id=" + parameter.getId();
    try (Statement statement = getConnection().createStatement()) {
        statement.executeUpdate(query);
    }
}

######


public Set<ZygosityType> getZygosities(Parameter parameter, Organisation organisation, String colonyId) throws SQLException {
    Connection connection = null;
    PreparedStatement statement = null;
    ResultSet resultSet = null;
    Set<ZygosityType> zygosities = new HashSet<ZygosityType>();
    String query = "SELECT DISTINCT zygosity" + " FROM biological_sample bs" + " JOIN observation o ON o.biological_sample_id = bs.id" + " JOIN live_sample ls ON ls.id = bs.id" + " WHERE o.observation_type = 'unidimensional'" + " AND bs.sample_group = 'experimental'" + " AND bs.organisation_id=?" + " AND o.parameter_id=?" + " AND ls.colony_id=?";
    try {
        connection = getConnection();
        statement = connection.prepareStatement(query);
        statement.setInt(1, organisation.getId());
        statement.setInt(2, parameter.getId());
        statement.setString(3, colonyId);
        resultSet = statement.executeQuery();
        while (resultSet.next()) {
            zygosities.add(ZygosityType.valueOf(resultSet.getString("zygosity")));
        }
    } finally {
        if (resultSet != null)
            try {
                resultSet.close();
            } catch (SQLException e) {
                log.error(e.getLocalizedMessage());
            }
        if (statement != null)
            try {
                statement.close();
            } catch (SQLException e) {
                log.error(e.getLocalizedMessage());
            }
        if (connection != null)
            try {
                connection.close();
            } catch (SQLException e) {
                log.error(e.getLocalizedMessage());
            }
    }
    return zygosities;
}

######


public Set<Integer> getPopulationIds(Parameter parameter, Organisation organisation, String colonyId, ZygosityType zygosity) throws SQLException {
    Set<Integer> populationIds = new HashSet<Integer>();
    String query = "SELECT DISTINCT o.population_id" + " FROM biological_sample bs" + " JOIN observation o ON o.biological_sample_id = bs.id" + " JOIN live_sample ls ON ls.id = bs.id" + " WHERE o.observation_type = 'unidimensional'" + " AND bs.sample_group = 'experimental'" + " AND bs.organisation_id=?" + " AND o.parameter_id=?" + " AND ls.colony_id=?" + " AND ls.zygosity=?";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        statement.setInt(1, organisation.getId());
        statement.setInt(2, parameter.getId());
        statement.setString(3, colonyId);
        statement.setString(4, zygosity.name());
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            populationIds.add(resultSet.getInt("population_id"));
        }
    }
    return populationIds;
}

######


public Set<String> getColoniesByParameter(Parameter parameter) throws SQLException {
    Set<String> colonies = new HashSet<String>();
    String query = "SELECT DISTINCT colony_id" + " FROM stats_mv_experimental_unidimensional_values" + " WHERE parameter_id=?";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        statement.setInt(1, parameter.getId());
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            colonies.add(resultSet.getString("colony_id"));
        }
    }
    return colonies;
}

######


@Override
public Set<UnidimensionalRecordDTO> getUnidimensionalData(Parameter parameter, Organisation organisation, String colonyId, ZygosityType zygosity) throws SQLException {
    Set<UnidimensionalRecordDTO> resultsDTO = new HashSet<UnidimensionalRecordDTO>();
    String query;
    query = "SELECT DISTINCT biological_model_id, biological_sample_id, zygosity, sex, data_point " + " FROM stats_mv_experimental_unidimensional_values" + " WHERE organisation_id=?" + " AND parameter_id=?" + " AND colony_id=?" + " AND zygosity=?";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        statement.setInt(1, organisation.getId());
        statement.setInt(2, parameter.getId());
        statement.setString(3, colonyId);
        statement.setString(4, zygosity.name());
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            UnidimensionalRecordDTO urdto = new UnidimensionalRecordDTO();
            urdto.setIsMutant(true);
            urdto.setColony(colonyId);
            urdto.setGender(resultSet.getString("sex"));
            urdto.setGenotype(colonyId);
            urdto.setMutantModelId(resultSet.getInt("biological_model_id"));
            urdto.setMutantZygosity(ZygosityType.valueOf(resultSet.getString("zygosity")));
            urdto.setOrganisation(organisation);
            urdto.setParameter(parameter);
            urdto.setValue(resultSet.getString("data_point"));
            resultsDTO.add(urdto);
        }
    }
    Set<Integer> populationIds = getPopulationIds(parameter, organisation, colonyId, zygosity);
    query = "SELECT DISTINCT biological_model_id, biological_sample_id, sex, data_point" + " FROM stats_mv_control_unidimensional_values" + " WHERE population_id IN (" + StringUtils.join(populationIds, ", ") + ")";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            UnidimensionalRecordDTO urdto = new UnidimensionalRecordDTO();
            urdto.setIsMutant(false);
            urdto.setColony("+/+");
            urdto.setGender(resultSet.getString("sex"));
            urdto.setGenotype(colonyId);
            urdto.setControlModelId(resultSet.getInt("biological_model_id"));
            urdto.setOrganisation(organisation);
            urdto.setParameter(parameter);
            urdto.setValue(resultSet.getString("data_point"));
            resultsDTO.add(urdto);
        }
    }
    return resultsDTO;
}

######


public List<Map<String, String>> getListOfUniqueParametersAndGenes(int start, int length) throws SQLException {
    String query;
    List<Map<String, String>> resultsList = new ArrayList<Map<String, String>>();
    query = "SELECT DISTINCT vw.biological_model_id, vw.parameter_id, bgf.gf_acc FROM stats_mv_experimental_unidimensional_values vw, biological_model_genomic_feature bgf where bgf.biological_model_id=vw.biological_model_id limit " + start + " , " + length;
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            Map<String, String> row = new HashMap<String, String>();
            row.put("accession", resultSet.getString("gf_acc"));
            row.put("parameter_id", Integer.toString(resultSet.getInt("parameter_id")));
            resultsList.add(row);
        }
    }
    return resultsList;
}

######


public List<Map<String, String>> getListOfUniqueParametersAndGenes(int start, int length, String parameterId) throws SQLException {
    String query;
    List<Map<String, String>> resultsList = new ArrayList<Map<String, String>>();
    query = "SELECT DISTINCT vw.biological_model_id, vw.parameter_id, bgf.gf_acc FROM stats_mv_experimental_unidimensional_values vw, biological_model_genomic_feature bgf where bgf.biological_model_id=vw.biological_model_id and vw.parameter_id='" + parameterId + "' limit " + start + " , " + length;
    System.out.println(query);
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            Map<String, String> row = new HashMap<String, String>();
            row.put("accession", resultSet.getString("gf_acc"));
            row.put("parameter_id", Integer.toString(resultSet.getInt("parameter_id")));
            resultsList.add(row);
        }
    }
    return resultsList;
}

######


public Map<String, Float> getMinAndMaxForParameter(String paramStableId) throws SQLException {
    Map<String, Float> resultsMap = new HashMap<String, Float>();
    String query = "SELECT MIN(uo.data_point), MAX(uo.data_point) FROM unidimensional_observation uo JOIN observation o ON uo.id = o.id WHERE o.parameter_stable_id = '" + paramStableId + "'";
    try (PreparedStatement statement = getConnection().prepareStatement(query)) {
        ResultSet resultSet = statement.executeQuery();
        while (resultSet.next()) {
            resultsMap.put("min", resultSet.getFloat(1));
            resultsMap.put("max", resultSet.getFloat(2));
        }
    }
    return resultsMap;
}

######


@Override
public int getConcurrency() {
    return CONCUR_UPDATABLE;
}

######


private void checkIfUpdatable(Results results) throws SQLException {
    database = null;
    table = null;
    canBeUpdate = true;
    canBeInserted = true;
    canBeRefresh = false;
    for (ColumnInformation columnInformation : columnsInformation) {
        if (columnInformation.getDatabase() == null || columnInformation.getDatabase().isEmpty()) {
            cannotUpdateInsertRow("The result-set contains fields without without any database information");
            return;
        } else {
            if (database != null && !database.equals(columnInformation.getDatabase())) {
                cannotUpdateInsertRow("The result-set contains more than one database");
                return;
            }
            database = columnInformation.getDatabase();
        }
        if (columnInformation.getOriginalTable() == null || columnInformation.getOriginalTable().isEmpty()) {
            cannotUpdateInsertRow("The result-set contains fields without without any table information");
            return;
        } else {
            if (table != null && !table.equals(columnInformation.getOriginalTable())) {
                cannotUpdateInsertRow("The result-set contains fields on different tables");
                return;
            }
            table = columnInformation.getOriginalTable();
        }
    }
    if (database == null) {
        cannotUpdateInsertRow("The result-set does not contain any table information");
        return;
    }
    if (table == null) {
        cannotUpdateInsertRow("The result-set does not contain any table information");
        return;
    }
    if (canBeUpdate) {
        if (results.getStatement() != null && results.getStatement().getConnection() != null) {
            connection = results.getStatement().getConnection();
            Statement stmt = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
            ResultSet rs = stmt.executeQuery("SHOW COLUMNS FROM `" + database + "`.`" + table + "`");
            UpdatableColumnInformation[] updatableColumns = new UpdatableColumnInformation[columnInformationLength];
            boolean primaryFound = false;
            while (rs.next()) {
                String fieldName = rs.getString("Field");
                boolean canBeNull = "YES".equals(rs.getString("Null"));
                boolean hasDefault = rs.getString("Default") == null;
                String extra = rs.getString("Extra");
                boolean generated = extra != null && !extra.isEmpty();
                boolean autoIncrement = extra != null && "auto_increment".equals(extra);
                boolean primary = "PRI".equals(rs.getString("Key"));
                boolean found = false;
                for (int index = 0; index < columnInformationLength; index++) {
                    ColumnInformation columnInformation = columnsInformation[index];
                    if (fieldName.equals(columnInformation.getOriginalName())) {
                        updatableColumns[index] = new UpdatableColumnInformation(columnInformation, canBeNull, hasDefault, generated, primary, autoIncrement);
                        found = true;
                    }
                }
                if (primary) {
                    primaryFound = true;
                }
                if (!found) {
                    if (primary) {
                        cannotUpdateInsertRow("Primary key field `" + fieldName + "` is not in result-set");
                        return;
                    }
                    if (!canBeNull && !hasDefault && !generated) {
                        cannotInsertRow("Field `" + fieldName + "` is not present in query returning " + "fields and cannot be null");
                    }
                }
            }
            if (!primaryFound) {
                cannotUpdateInsertRow("Table `" + database + "`.`" + table + "` has no primary key");
                return;
            } else {
                canBeRefresh = true;
            }
            boolean ensureAllColumnHaveMeta = true;
            for (int index = 0; index < columnInformationLength; index++) {
                if (updatableColumns[index] == null) {
                    cannotUpdateInsertRow("Metadata information not available for table `" + database + "`.`" + table + "`, field `" + columnsInformation[index].getOriginalName() + "`");
                    ensureAllColumnHaveMeta = false;
                }
            }
            if (ensureAllColumnHaveMeta) {
                columnsInformation = updatableColumns;
            }
        } else {
            throw new SQLException("abnormal error : connection is null");
        }
    }
}

######


private UpdatableColumnInformation[] getUpdatableColumns() {
    return (UpdatableColumnInformation[]) columnsInformation;
}

######


private void cannotUpdateInsertRow(String reason) {
    if (exceptionUpdateMsg == null) {
        exceptionUpdateMsg = "ResultSet cannot be updated. " + reason;
    }
    if (exceptionInsertMsg == null) {
        exceptionInsertMsg = "No row can be inserted. " + reason;
    }
    canBeUpdate = false;
    canBeInserted = false;
}

######


private void cannotInsertRow(String reason) {
    if (exceptionInsertMsg == null) {
        exceptionInsertMsg = "No row can be inserted. " + reason;
    }
    canBeInserted = false;
}

######


private void checkUpdatable(int position) throws SQLException {
    if (position <= 0 || position > columnInformationLength) {
        throw new SQLDataException("No such column: " + position, "22023");
    }
    if (state == STATE_STANDARD) {
        state = STATE_UPDATE;
    }
    if (state == STATE_UPDATE) {
        if (getRowPointer() < 0) {
            throw new SQLDataException("Current position is before the first row", "22023");
        }
        if (getRowPointer() >= getDataSize()) {
            throw new SQLDataException("Current position is after the last row", "22023");
        }
        if (!canBeUpdate) {
            throw new SQLException(exceptionUpdateMsg);
        }
    }
    if (state == STATE_INSERT && !canBeInserted) {
        throw new SQLException(exceptionInsertMsg);
    }
}

######


public void updateNull(int columnIndex) throws SQLException {
    checkUpdatable(columnIndex);
    parameterHolders[columnIndex - 1] = new NullParameter();
}

######


public void updateNull(String columnLabel) throws SQLException {
    updateNull(findColumn(columnLabel));
}

######


public void updateBoolean(int columnIndex, boolean bool) throws SQLException {
    checkUpdatable(columnIndex);
    parameterHolders[columnIndex - 1] = new ByteParameter(bool ? (byte) 1 : (byte) 0);
}

######


public void updateBoolean(String columnLabel, boolean value) throws SQLException {
    updateBoolean(findColumn(columnLabel), value);
}

######


public void updateByte(int columnIndex, byte value) throws SQLException {
    checkUpdatable(columnIndex);
    parameterHolders[columnIndex - 1] = new ByteParameter(value);
}

######


public void updateByte(String columnLabel, byte value) throws SQLException {
    updateByte(findColumn(columnLabel), value);
}

######


public void updateShort(int columnIndex, short value) throws SQLException {
    checkUpdatable(columnIndex);
    parameterHolders[columnIndex - 1] = new ShortParameter(value);
}

######


public void updateShort(String columnLabel, short value) throws SQLException {
    updateShort(findColumn(columnLabel), value);
}

######


public void updateInt(int columnIndex, int value) throws SQLException {
    checkUpdatable(columnIndex);
    parameterHolders[columnIndex - 1] = new IntParameter(value);
}

######


public void updateInt(String columnLabel, int value) throws SQLException {
    updateInt(findColumn(columnLabel), value);
}

######


public void updateFloat(int columnIndex, float value) throws SQLException {
    checkUpdatable(columnIndex);
    parameterHolders[columnIndex - 1] = new FloatParameter(value);
}

######


public void updateFloat(String columnLabel, float value) throws SQLException {
    updateFloat(findColumn(columnLabel), value);
}

######


public void updateDouble(int columnIndex, double value) throws SQLException {
    checkUpdatable(columnIndex);
    parameterHolders[columnIndex - 1] = new DoubleParameter(value);
}

######


public void updateDouble(String columnLabel, double value) throws SQLException {
    updateDouble(findColumn(columnLabel), value);
}

######


public void updateBigDecimal(int columnIndex, BigDecimal value) throws SQLException {
    checkUpdatable(columnIndex);
    if (value == null) {
        parameterHolders[columnIndex - 1] = new NullParameter(ColumnType.DECIMAL);
        return;
    }
    parameterHolders[columnIndex - 1] = new BigDecimalParameter(value);
}

######


public void updateBigDecimal(String columnLabel, BigDecimal value) throws SQLException {
    updateBigDecimal(findColumn(columnLabel), value);
}

######


public void updateString(int columnIndex, String value) throws SQLException {
    checkUpdatable(columnIndex);
    if (value == null) {
        parameterHolders[columnIndex - 1] = new NullParameter(ColumnType.STRING);
        return;
    }
    parameterHolders[columnIndex - 1] = new StringParameter(value, noBackslashEscapes);
}

######


public void updateString(String columnLabel, String value) throws SQLException {
    updateString(findColumn(columnLabel), value);
}

######


public void updateBytes(int columnIndex, byte[] value) throws SQLException {
    checkUpdatable(columnIndex);
    if (value == null) {
        parameterHolders[columnIndex - 1] = new NullParameter(ColumnType.BLOB);
        return;
    }
    parameterHolders[columnIndex - 1] = new ByteArrayParameter(value, noBackslashEscapes);
}

######


public void updateBytes(String columnLabel, byte[] value) throws SQLException {
    updateBytes(findColumn(columnLabel), value);
}

######


public void updateDate(int columnIndex, Date date) throws SQLException {
    checkUpdatable(columnIndex);
    if (date == null) {
        parameterHolders[columnIndex - 1] = new NullParameter(ColumnType.DATE);
        return;
    }
    parameterHolders[columnIndex - 1] = new DateParameter(date, TimeZone.getDefault(), options);
}

######


public void updateDate(String columnLabel, Date value) throws SQLException {
    updateDate(findColumn(columnLabel), value);
}

######


public void updateTime(int columnIndex, Time time) throws SQLException {
    checkUpdatable(columnIndex);
    if (time == null) {
        parameterHolders[columnIndex - 1] = new NullParameter(ColumnType.TIME);
        return;
    }
    parameterHolders[columnIndex - 1] = new TimeParameter(time, TimeZone.getDefault(), options.useFractionalSeconds);
}

######


public void updateTime(String columnLabel, Time value) throws SQLException {
    updateTime(findColumn(columnLabel), value);
}

######


public void updateTimestamp(int columnIndex, Timestamp timeStamp) throws SQLException {
    checkUpdatable(columnIndex);
    if (timeStamp == null) {
        parameterHolders[columnIndex - 1] = new NullParameter(ColumnType.DATETIME);
        return;
    }
    parameterHolders[columnIndex - 1] = new TimestampParameter(timeStamp, timeZone, options.useFractionalSeconds);
}

######


public void updateTimestamp(String columnLabel, Timestamp value) throws SQLException {
    updateTimestamp(findColumn(columnLabel), value);
}

######


public void updateAsciiStream(int columnIndex, InputStream inputStream) throws SQLException {
    updateAsciiStream(columnIndex, inputStream, Long.MAX_VALUE);
}

######


public void updateAsciiStream(String columnLabel, InputStream inputStream) throws SQLException {
    updateAsciiStream(findColumn(columnLabel), inputStream);
}

######


public void updateAsciiStream(int columnIndex, InputStream inputStream, int length) throws SQLException {
    updateAsciiStream(columnIndex, inputStream, (long) length);
}

######


public void updateAsciiStream(String columnLabel, InputStream inputStream, int length) throws SQLException {
    updateAsciiStream(findColumn(columnLabel), inputStream, length);
}

######


public void updateAsciiStream(int columnIndex, InputStream inputStream, long length) throws SQLException {
    checkUpdatable(columnIndex);
    if (inputStream == null) {
        parameterHolders[columnIndex - 1] = new NullParameter(ColumnType.BLOB);
        return;
    }
    parameterHolders[columnIndex - 1] = new StreamParameter(inputStream, length, noBackslashEscapes);
}

######


public void updateAsciiStream(String columnLabel, InputStream inputStream, long length) throws SQLException {
    updateAsciiStream(findColumn(columnLabel), inputStream, length);
}

######


public void updateBinaryStream(int columnIndex, InputStream inputStream, int length) throws SQLException {
    updateBinaryStream(columnIndex, inputStream, (long) length);
}

######


public void updateBinaryStream(int columnIndex, InputStream inputStream, long length) throws SQLException {
    checkUpdatable(columnIndex);
    if (inputStream == null) {
        parameterHolders[columnIndex - 1] = new NullParameter(ColumnType.BLOB);
        return;
    }
    parameterHolders[columnIndex - 1] = new StreamParameter(inputStream, length, noBackslashEscapes);
}

######


public void updateBinaryStream(String columnLabel, InputStream inputStream, int length) throws SQLException {
    updateBinaryStream(findColumn(columnLabel), inputStream, (long) length);
}

######


public void updateBinaryStream(String columnLabel, InputStream inputStream, long length) throws SQLException {
    updateBinaryStream(findColumn(columnLabel), inputStream, length);
}

######


public void updateBinaryStream(int columnIndex, InputStream inputStream) throws SQLException {
    updateBinaryStream(columnIndex, inputStream, Long.MAX_VALUE);
}

######


public void updateBinaryStream(String columnLabel, InputStream inputStream) throws SQLException {
    updateBinaryStream(findColumn(columnLabel), inputStream);
}

######


public void updateCharacterStream(int columnIndex, Reader reader, int length) throws SQLException {
    updateCharacterStream(columnIndex, reader, (long) length);
}

######


public void updateCharacterStream(int columnIndex, Reader value) throws SQLException {
    updateCharacterStream(columnIndex, value, Long.MAX_VALUE);
}

######


public void updateCharacterStream(String columnLabel, Reader reader, int length) throws SQLException {
    updateCharacterStream(findColumn(columnLabel), reader, (long) length);
}

######


public void updateCharacterStream(int columnIndex, Reader value, long length) throws SQLException {
    checkUpdatable(columnIndex);
    if (value == null) {
        parameterHolders[columnIndex - 1] = new NullParameter(ColumnType.BLOB);
        return;
    }
    parameterHolders[columnIndex - 1] = new ReaderParameter(value, length, noBackslashEscapes);
}

######


public void updateCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
    updateCharacterStream(findColumn(columnLabel), reader, length);
}

######


public void updateCharacterStream(String columnLabel, Reader reader) throws SQLException {
    updateCharacterStream(findColumn(columnLabel), reader, Long.MAX_VALUE);
}

######


private void updateInternalObject(final int parameterIndex, final Object obj, final int targetSqlType, final long scaleOrLength) throws SQLException {
    switch(targetSqlType) {
        case Types.ARRAY:
        case Types.DATALINK:
        case Types.JAVA_OBJECT:
        case Types.REF:
        case Types.ROWID:
        case Types.SQLXML:
        case Types.STRUCT:
            throw ExceptionMapper.getFeatureNotSupportedException("Type not supported");
        default:
            break;
    }
    if (obj == null) {
        updateNull(parameterIndex);
    } else if (obj instanceof String) {
        if (targetSqlType == Types.BLOB) {
            throw ExceptionMapper.getSqlException("Cannot convert a String to a Blob");
        }
        String str = (String) obj;
        try {
            switch(targetSqlType) {
                case Types.BIT:
                case Types.BOOLEAN:
                    updateBoolean(parameterIndex, !("false".equalsIgnoreCase(str) || "0".equals(str)));
                    break;
                case Types.TINYINT:
                    updateByte(parameterIndex, Byte.parseByte(str));
                    break;
                case Types.SMALLINT:
                    updateShort(parameterIndex, Short.parseShort(str));
                    break;
                case Types.INTEGER:
                    updateInt(parameterIndex, Integer.parseInt(str));
                    break;
                case Types.DOUBLE:
                case Types.FLOAT:
                    updateDouble(parameterIndex, Double.valueOf(str));
                    break;
                case Types.REAL:
                    updateFloat(parameterIndex, Float.valueOf(str));
                    break;
                case Types.BIGINT:
                    updateLong(parameterIndex, Long.valueOf(str));
                    break;
                case Types.DECIMAL:
                case Types.NUMERIC:
                    updateBigDecimal(parameterIndex, new BigDecimal(str));
                    break;
                case Types.CLOB:
                case Types.NCLOB:
                case Types.CHAR:
                case Types.VARCHAR:
                case Types.LONGVARCHAR:
                case Types.NCHAR:
                case Types.NVARCHAR:
                case Types.LONGNVARCHAR:
                    updateString(parameterIndex, str);
                    break;
                case Types.TIMESTAMP:
                    if (str.startsWith("0000-00-00")) {
                        updateTimestamp(parameterIndex, null);
                    } else {
                        updateTimestamp(parameterIndex, Timestamp.valueOf(str));
                    }
                    break;
                case Types.TIME:
                    updateTime(parameterIndex, Time.valueOf((String) obj));
                    break;
                case Types.TIME_WITH_TIMEZONE:
                    parameterHolders[parameterIndex - 1] = new OffsetTimeParameter(OffsetTime.parse(str), timeZone.toZoneId(), options.useFractionalSeconds, options);
                    break;
                case Types.TIMESTAMP_WITH_TIMEZONE:
                    parameterHolders[parameterIndex - 1] = new ZonedDateTimeParameter(ZonedDateTime.parse(str, BasePrepareStatement.SPEC_ISO_ZONED_DATE_TIME), timeZone.toZoneId(), options.useFractionalSeconds, options);
                    break;
                default:
                    throw ExceptionMapper.getSqlException("Could not convert [" + str + "] to " + targetSqlType);
            }
        } catch (IllegalArgumentException e) {
            throw ExceptionMapper.getSqlException("Could not convert [" + str + "] to " + targetSqlType, e);
        }
    } else if (obj instanceof Number) {
        Number bd = (Number) obj;
        switch(targetSqlType) {
            case Types.TINYINT:
                updateByte(parameterIndex, bd.byteValue());
                break;
            case Types.SMALLINT:
                updateShort(parameterIndex, bd.shortValue());
                break;
            case Types.INTEGER:
                updateInt(parameterIndex, bd.intValue());
                break;
            case Types.BIGINT:
                updateLong(parameterIndex, bd.longValue());
                break;
            case Types.FLOAT:
            case Types.DOUBLE:
                updateDouble(parameterIndex, bd.doubleValue());
                break;
            case Types.REAL:
                updateFloat(parameterIndex, bd.floatValue());
                break;
            case Types.DECIMAL:
            case Types.NUMERIC:
                if (obj instanceof BigDecimal) {
                    updateBigDecimal(parameterIndex, (BigDecimal) obj);
                } else if (obj instanceof Double || obj instanceof Float) {
                    updateDouble(parameterIndex, bd.doubleValue());
                } else {
                    updateLong(parameterIndex, bd.longValue());
                }
                break;
            case Types.BIT:
                updateBoolean(parameterIndex, bd.shortValue() != 0);
                break;
            case Types.CHAR:
            case Types.VARCHAR:
                updateString(parameterIndex, bd.toString());
                break;
            default:
                throw ExceptionMapper.getSqlException("Could not convert [" + bd + "] to " + targetSqlType);
        }
    } else if (obj instanceof byte[]) {
        if (targetSqlType == Types.BINARY || targetSqlType == Types.VARBINARY || targetSqlType == Types.LONGVARBINARY) {
            updateBytes(parameterIndex, (byte[]) obj);
        } else {
            throw ExceptionMapper.getSqlException("Can only convert a byte[] to BINARY, VARBINARY or LONGVARBINARY");
        }
    } else if (obj instanceof Time) {
        updateTime(parameterIndex, (Time) obj);
    } else if (obj instanceof Timestamp) {
        updateTimestamp(parameterIndex, (Timestamp) obj);
    } else if (obj instanceof Date) {
        updateDate(parameterIndex, (Date) obj);
    } else if (obj instanceof java.util.Date) {
        long timemillis = ((java.util.Date) obj).getTime();
        if (targetSqlType == Types.DATE) {
            updateDate(parameterIndex, new Date(timemillis));
        } else if (targetSqlType == Types.TIME) {
            updateTime(parameterIndex, new Time(timemillis));
        } else if (targetSqlType == Types.TIMESTAMP) {
            updateTimestamp(parameterIndex, new Timestamp(timemillis));
        }
    } else if (obj instanceof Boolean) {
        updateBoolean(parameterIndex, (Boolean) obj);
    } else if (obj instanceof Blob) {
        updateBlob(parameterIndex, (Blob) obj);
    } else if (obj instanceof Clob) {
        updateClob(parameterIndex, (Clob) obj);
    } else if (obj instanceof InputStream) {
        updateBinaryStream(parameterIndex, (InputStream) obj, scaleOrLength);
    } else if (obj instanceof Reader) {
        updateCharacterStream(parameterIndex, (Reader) obj, scaleOrLength);
    } else if (obj instanceof LocalDateTime) {
        updateTimestamp(parameterIndex, Timestamp.valueOf((LocalDateTime) obj));
    } else if (obj instanceof Instant) {
        updateTimestamp(parameterIndex, Timestamp.from((Instant) obj));
    } else if (obj instanceof LocalDate) {
        updateDate(parameterIndex, Date.valueOf((LocalDate) obj));
    } else if (obj instanceof OffsetDateTime) {
        parameterHolders[parameterIndex - 1] = new ZonedDateTimeParameter(((OffsetDateTime) obj).toZonedDateTime(), timeZone.toZoneId(), options.useFractionalSeconds, options);
    } else if (obj instanceof OffsetTime) {
        parameterHolders[parameterIndex - 1] = new OffsetTimeParameter((OffsetTime) obj, timeZone.toZoneId(), options.useFractionalSeconds, options);
    } else if (obj instanceof ZonedDateTime) {
        parameterHolders[parameterIndex - 1] = new ZonedDateTimeParameter((ZonedDateTime) obj, timeZone.toZoneId(), options.useFractionalSeconds, options);
    } else if (obj instanceof LocalTime) {
        updateTime(parameterIndex, Time.valueOf((LocalTime) obj));
    } else {
        throw ExceptionMapper.getSqlException("Could not set parameter in setObject, could not convert: " + obj.getClass() + " to " + targetSqlType);
    }
}

######


public void updateObject(int columnIndex, Object value, int scaleOrLength) throws SQLException {
    checkUpdatable(columnIndex);
    updateInternalObject(columnIndex, value, columnsInformation[columnIndex - 1].getColumnType().getSqlType(), scaleOrLength);
}

######


public void updateObject(int columnIndex, Object value) throws SQLException {
    checkUpdatable(columnIndex);
    updateInternalObject(columnIndex, value, columnsInformation[columnIndex - 1].getColumnType().getSqlType(), Long.MAX_VALUE);
}

######


public void updateObject(String columnLabel, Object value, int scaleOrLength) throws SQLException {
    updateObject(findColumn(columnLabel), value, scaleOrLength);
}

######


public void updateObject(String columnLabel, Object value) throws SQLException {
    updateObject(findColumn(columnLabel), value);
}

######


public void updateLong(int columnIndex, long value) throws SQLException {
    checkUpdatable(columnIndex);
    parameterHolders[columnIndex - 1] = new LongParameter(value);
}

######


public void updateLong(String columnLabel, long value) throws SQLException {
    updateLong(findColumn(columnLabel), value);
}

######


public void updateRef(int columnIndex, Ref ref) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("REF not supported");
}

######


public void updateRef(String columnLabel, Ref ref) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("REF not supported");
}

######


public void updateBlob(int columnIndex, Blob blob) throws SQLException {
    checkUpdatable(columnIndex);
    if (blob == null) {
        parameterHolders[columnIndex - 1] = new NullParameter(ColumnType.BLOB);
        return;
    }
    parameterHolders[columnIndex - 1] = new StreamParameter(blob.getBinaryStream(), blob.length(), noBackslashEscapes);
}

######


public void updateBlob(String columnLabel, Blob blob) throws SQLException {
    updateBlob(findColumn(columnLabel), blob);
}

######


public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
    updateBlob(columnIndex, inputStream, Long.MAX_VALUE);
}

######


public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
    updateBlob(findColumn(columnLabel), inputStream, Long.MAX_VALUE);
}

######


public void updateBlob(int columnIndex, InputStream inputStream, long length) throws SQLException {
    checkUpdatable(columnIndex);
    if (inputStream == null) {
        parameterHolders[columnIndex - 1] = new NullParameter(ColumnType.BLOB);
        return;
    }
    parameterHolders[columnIndex - 1] = new StreamParameter(inputStream, length, noBackslashEscapes);
}

######


public void updateBlob(String columnLabel, InputStream inputStream, long length) throws SQLException {
    updateBlob(findColumn(columnLabel), inputStream, length);
}

######


public void updateClob(int columnIndex, Clob clob) throws SQLException {
    checkUpdatable(columnIndex);
    if (clob == null) {
        parameterHolders[columnIndex - 1] = new NullParameter(ColumnType.BLOB);
        return;
    }
    parameterHolders[columnIndex - 1] = new ReaderParameter(clob.getCharacterStream(), clob.length(), noBackslashEscapes);
}

######


public void updateClob(String columnLabel, Clob clob) throws SQLException {
    updateClob(findColumn(columnLabel), clob);
}

######


public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {
    updateCharacterStream(columnIndex, reader, length);
}

######


public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {
    updateCharacterStream(findColumn(columnLabel), reader, length);
}

######


public void updateClob(int columnIndex, Reader reader) throws SQLException {
    updateCharacterStream(columnIndex, reader);
}

######


public void updateClob(String columnLabel, Reader reader) throws SQLException {
    updateCharacterStream(findColumn(columnLabel), reader);
}

######


public void updateArray(int columnIndex, Array array) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("Arrays not supported");
}

######


public void updateArray(String columnLabel, Array array) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("Arrays not supported");
}

######


public void updateRowId(int columnIndex, RowId rowId) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("RowIDs not supported");
}

######


public void updateRowId(String columnLabel, RowId rowId) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("RowIDs not supported");
}

######


public void updateNString(int columnIndex, String nstring) throws SQLException {
    updateString(columnIndex, nstring);
}

######


public void updateNString(String columnLabel, String nstring) throws SQLException {
    updateString(columnLabel, nstring);
}

######


public void updateNClob(int columnIndex, NClob nclob) throws SQLException {
    updateClob(columnIndex, nclob);
}

######


public void updateNClob(String columnLabel, NClob nclob) throws SQLException {
    updateClob(columnLabel, nclob);
}

######


public void updateNClob(int columnIndex, Reader reader) throws SQLException {
    updateClob(columnIndex, reader);
}

######


public void updateNClob(String columnLabel, Reader reader) throws SQLException {
    updateClob(columnLabel, reader);
}

######


public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {
    updateClob(columnIndex, reader, length);
}

######


public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {
    updateClob(columnLabel, reader, length);
}

######


@Override
public void updateSQLXML(int columnIndex, SQLXML xmlObject) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("SQlXML not supported");
}

######


@Override
public void updateSQLXML(String columnLabel, SQLXML xmlObject) throws SQLException {
    throw ExceptionMapper.getFeatureNotSupportedException("SQLXML not supported");
}

######


public void updateNCharacterStream(int columnIndex, Reader value, long length) throws SQLException {
    updateCharacterStream(columnIndex, value, length);
}

######


public void updateNCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
    updateCharacterStream(columnLabel, reader, length);
}

######


public void updateNCharacterStream(int columnIndex, Reader reader) throws SQLException {
    updateCharacterStream(columnIndex, reader);
}

######


public void updateNCharacterStream(String columnLabel, Reader reader) throws SQLException {
    updateCharacterStream(columnLabel, reader);
}

######


public void insertRow() throws SQLException {
    if (state == STATE_INSERT) {
        if (insertPreparedStatement == null) {
            StringBuilder insertSql = new StringBuilder("INSERT `" + database + "`.`" + table + "` ( ");
            StringBuilder valueClause = new StringBuilder();
            for (int pos = 0; pos < columnInformationLength; pos++) {
                UpdatableColumnInformation colInfo = getUpdatableColumns()[pos];
                if (pos != 0) {
                    insertSql.append(",");
                    valueClause.append(", ");
                }
                insertSql.append("`").append(colInfo.getOriginalName()).append("`");
                valueClause.append("?");
            }
            insertSql.append(") VALUES (").append(valueClause).append(")");
            insertPreparedStatement = connection.clientPrepareStatement(insertSql.toString());
        }
        int fieldsIndex = 0;
        boolean hasGeneratedPrimaryFields = false;
        int generatedSqlType = 0;
        for (int pos = 0; pos < columnInformationLength; pos++) {
            ParameterHolder value = parameterHolders[pos];
            if (value != null) {
                insertPreparedStatement.setParameter((fieldsIndex++) + 1, value);
            } else {
                UpdatableColumnInformation colInfo = getUpdatableColumns()[pos];
                if (colInfo.isPrimary() && colInfo.isAutoIncrement()) {
                    hasGeneratedPrimaryFields = true;
                    generatedSqlType = colInfo.getColumnType().getSqlType();
                }
                insertPreparedStatement.setParameter((fieldsIndex++) + 1, new DefaultParameter());
            }
        }
        insertPreparedStatement.execute();
        if (hasGeneratedPrimaryFields) {
            ResultSet rsKey = insertPreparedStatement.getGeneratedKeys();
            if (rsKey.next()) {
                prepareRefreshStmt();
                refreshPreparedStatement.setObject(1, rsKey.getObject(1), generatedSqlType);
                SelectResultSet rs = (SelectResultSet) refreshPreparedStatement.executeQuery();
                if (rs.next()) {
                    addRowData(rs.getCurrentRowData());
                }
            }
        } else {
            addRowData(refreshRawData());
        }
        Arrays.fill(parameterHolders, null);
    }
}

######


public void updateRow() throws SQLException {
    if (state == STATE_INSERT) {
        throw new SQLException("Cannot call updateRow() when inserting a new row");
    }
    if (state == STATE_UPDATE) {
        StringBuilder updateSql = new StringBuilder("UPDATE `" + database + "`.`" + table + "` SET ");
        StringBuilder whereClause = new StringBuilder(" WHERE ");
        boolean firstUpdate = true;
        boolean firstPrimary = true;
        int fieldsToUpdate = 0;
        for (int pos = 0; pos < columnInformationLength; pos++) {
            UpdatableColumnInformation colInfo = getUpdatableColumns()[pos];
            ParameterHolder value = parameterHolders[pos];
            if (colInfo.isPrimary()) {
                if (!firstPrimary) {
                    whereClause.append("AND ");
                }
                firstPrimary = false;
                whereClause.append("`").append(colInfo.getOriginalName()).append("` = ? ");
            }
            if (value != null) {
                if (!firstUpdate) {
                    updateSql.append(",");
                }
                firstUpdate = false;
                fieldsToUpdate++;
                updateSql.append("`").append(colInfo.getOriginalName()).append("` = ? ");
            }
        }
        updateSql.append(whereClause.toString());
        ClientSidePreparedStatement preparedStatement = connection.clientPrepareStatement(updateSql.toString());
        int fieldsIndex = 0;
        int fieldsPrimaryIndex = 0;
        for (int pos = 0; pos < columnInformationLength; pos++) {
            UpdatableColumnInformation colInfo = getUpdatableColumns()[pos];
            ParameterHolder value = parameterHolders[pos];
            if (value != null) {
                preparedStatement.setParameter((fieldsIndex++) + 1, value);
            }
            if (colInfo.isPrimary()) {
                preparedStatement.setObject(fieldsToUpdate + (fieldsPrimaryIndex++) + 1, getObject(pos + 1), colInfo.getColumnType().getSqlType());
            }
        }
        preparedStatement.execute();
        state = STATE_UPDATED;
        refreshRow();
        Arrays.fill(parameterHolders, null);
        state = STATE_STANDARD;
    }
}

######


public void deleteRow() throws SQLException {
    if (state == STATE_INSERT) {
        throw new SQLException("Cannot call deleteRow() when inserting a new row");
    }
    if (!canBeUpdate) {
        throw new SQLDataException(exceptionUpdateMsg);
    }
    if (getRowPointer() < 0) {
        throw new SQLDataException("Current position is before the first row", "22023");
    }
    if (getRowPointer() >= getDataSize()) {
        throw new SQLDataException("Current position is after the last row", "22023");
    }
    if (deletePreparedStatement == null) {
        StringBuilder deleteSql = new StringBuilder("DELETE FROM `" + database + "`.`" + table + "` WHERE ");
        boolean firstPrimary = true;
        for (int pos = 0; pos < columnInformationLength; pos++) {
            UpdatableColumnInformation colInfo = getUpdatableColumns()[pos];
            if (colInfo.isPrimary()) {
                if (!firstPrimary) {
                    deleteSql.append("AND ");
                }
                firstPrimary = false;
                deleteSql.append("`").append(colInfo.getOriginalName()).append("` = ? ");
            }
        }
        deletePreparedStatement = connection.clientPrepareStatement(deleteSql.toString());
    }
    int fieldsPrimaryIndex = 1;
    for (int pos = 0; pos < columnInformationLength; pos++) {
        UpdatableColumnInformation colInfo = getUpdatableColumns()[pos];
        if (colInfo.isPrimary()) {
            deletePreparedStatement.setObject(fieldsPrimaryIndex++, getObject(pos + 1), colInfo.getColumnType().getSqlType());
        }
    }
    deletePreparedStatement.executeUpdate();
    deleteCurrentRowData();
}

######


private void prepareRefreshStmt() throws SQLException {
    if (refreshPreparedStatement == null) {
        StringBuilder selectSql = new StringBuilder("SELECT ");
        StringBuilder whereClause = new StringBuilder(" WHERE ");
        boolean firstPrimary = true;
        for (int pos = 0; pos < columnInformationLength; pos++) {
            UpdatableColumnInformation colInfo = getUpdatableColumns()[pos];
            if (pos != 0) {
                selectSql.append(",");
            }
            selectSql.append("`").append(colInfo.getOriginalName()).append("`");
            if (colInfo.isPrimary()) {
                if (!firstPrimary) {
                    whereClause.append("AND ");
                }
                firstPrimary = false;
                whereClause.append("`").append(colInfo.getOriginalName()).append("` = ? ");
            }
        }
        selectSql.append(" FROM `").append(database).append("`.`").append(table).append("`").append(whereClause);
        if (isBinaryEncoded()) {
            refreshPreparedStatement = connection.serverPrepareStatement(selectSql.toString());
        } else {
            refreshPreparedStatement = connection.clientPrepareStatement(selectSql.toString());
        }
    }
}

######


private byte[] refreshRawData() throws SQLException {
    prepareRefreshStmt();
    int fieldsPrimaryIndex = 1;
    for (int pos = 0; pos < columnInformationLength; pos++) {
        UpdatableColumnInformation colInfo = getUpdatableColumns()[pos];
        if (colInfo.isPrimary()) {
            ParameterHolder value = parameterHolders[pos];
            if (state != STATE_STANDARD && value != null) {
                if (isBinaryEncoded()) {
                    ((ServerSidePreparedStatement) refreshPreparedStatement).setParameter(fieldsPrimaryIndex++, value);
                } else {
                    ((ClientSidePreparedStatement) refreshPreparedStatement).setParameter(fieldsPrimaryIndex++, value);
                }
            } else {
                refreshPreparedStatement.setObject(fieldsPrimaryIndex++, getObject(pos + 1), colInfo.getColumnType().getSqlType());
            }
        }
    }
    SelectResultSet rs = (SelectResultSet) refreshPreparedStatement.executeQuery();
    if (rs.next()) {
        return rs.getCurrentRowData();
    }
    return new byte[0];
}

######


public void refreshRow() throws SQLException {
    if (state == STATE_INSERT) {
        throw new SQLException("Cannot call deleteRow() when inserting a new row");
    }
    if (getRowPointer() < 0) {
        throw new SQLDataException("Current position is before the first row", "22023");
    }
    if (getRowPointer() >= getDataSize()) {
        throw new SQLDataException("Current position is after the last row", "22023");
    }
    if (canBeRefresh) {
        updateRowData(refreshRawData());
    }
}

######


public void cancelRowUpdates() {
    Arrays.fill(parameterHolders, null);
    state = STATE_STANDARD;
}

######


public void moveToInsertRow() throws SQLException {
    if (!canBeInserted) {
        throw new SQLException(exceptionInsertMsg);
    }
    Arrays.fill(parameterHolders, null);
    state = STATE_INSERT;
    notInsertRowPointer = getRowPointer();
}

######


public void moveToCurrentRow() {
    Arrays.fill(parameterHolders, null);
    state = STATE_STANDARD;
    setRowPointer(notInsertRowPointer);
}

######


@Override
public void beforeFirst() throws SQLException {
    if (state == STATE_INSERT) {
        state = STATE_UPDATE;
        setRowPointer(notInsertRowPointer);
    }
    super.beforeFirst();
}

######


@Override
public boolean first() throws SQLException {
    if (state == STATE_INSERT) {
        state = STATE_UPDATE;
        setRowPointer(notInsertRowPointer);
    }
    return super.first();
}

######


@Override
public boolean last() throws SQLException {
    if (state == STATE_INSERT) {
        state = STATE_UPDATE;
        setRowPointer(notInsertRowPointer);
    }
    return super.last();
}

######


@Override
public void afterLast() throws SQLException {
    if (state == STATE_INSERT) {
        state = STATE_UPDATE;
        setRowPointer(notInsertRowPointer);
    }
    super.afterLast();
}

######


@Override
public boolean absolute(int row) throws SQLException {
    if (state == STATE_INSERT) {
        state = STATE_UPDATE;
        setRowPointer(notInsertRowPointer);
    }
    return super.absolute(row);
}

######


@Override
public boolean relative(int rows) throws SQLException {
    if (state == STATE_INSERT) {
        state = STATE_UPDATE;
        setRowPointer(notInsertRowPointer);
    }
    return super.relative(rows);
}

######


@Override
public boolean next() throws SQLException {
    if (state == STATE_INSERT) {
        state = STATE_UPDATE;
        setRowPointer(notInsertRowPointer);
    }
    return super.next();
}

######


@Override
public boolean previous() throws SQLException {
    if (state == STATE_INSERT) {
        state = STATE_UPDATE;
        setRowPointer(notInsertRowPointer);
    }
    return super.previous();
}

######


public static void main(String[] args) {
    try {
        Class.forName("com.mysql.jdbc.Driver");
        Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/karthik", "root", "visog");
        PreparedStatement stmt = con.prepareStatement("update employee set name=? where id=?");
        stmt.setString(1, "suresh");
        stmt.setInt(2, 5);
        int i = stmt.executeUpdate();
        System.out.println(i + "records updated");
        con.close();
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


public static void main(String[] args) {
    try {
        Class.forName("com.mysql.jdbc.Driver");
        Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/karthik", "root", "visog");
        PreparedStatement stmt = con.prepareStatement("update employee set name=? where id=?");
        stmt.setString(1, "suresh");
        stmt.setInt(2, 5);
        int i = stmt.executeUpdate();
        System.out.println(i + "records updated");
        con.close();
    } catch (Exception e) {
        System.out.println(e);
    }
}

######


@Test
public void testNoPrimaryKey() throws Exception {
    createTable("testnoprimarykey", "`id` INT NOT NULL," + "`t1` VARCHAR(50) NOT NULL");
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("INSERT INTO testnoprimarykey VALUES (1, 't1'), (2, 't2')");
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT * FROM testnoprimarykey", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery("SELECT * FROM testnoprimarykey");
        assertTrue(rs.next());
        try {
            rs.updateString(1, "1");
            fail();
        } catch (SQLException sqle) {
            assertEquals("ResultSet cannot be updated. Table " + "`" + sharedConnection.getCatalog() + "`.`testnoprimarykey` has no primary key", sqle.getMessage());
        }
    }
}

######


@Test
public void testNoDatabase() throws Exception {
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT 1", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertTrue(rs.next());
        try {
            rs.updateString(1, "1");
            fail();
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage(), sqle.getMessage().contains("The result-set contains fields without without any database information"));
        }
    }
}

######


@Test
public void testMultipleTable() throws Exception {
    createTable("testMultipleTable1", "`id1` INT NOT NULL AUTO_INCREMENT," + "`t1` VARCHAR(50) NULL," + "PRIMARY KEY (`id1`)");
    createTable("testMultipleTable2", "`id2` INT NOT NULL AUTO_INCREMENT," + "`t2` VARCHAR(50) NULL," + "PRIMARY KEY (`id2`)");
    Statement stmt = sharedConnection.createStatement();
    stmt.executeQuery("INSERT INTO testMultipleTable1(t1) values ('1')");
    stmt.executeQuery("INSERT INTO testMultipleTable2(t2) values ('2')");
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT * FROM testMultipleTable1, testMultipleTable2", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertTrue(rs.next());
        try {
            rs.updateString("t1", "new value");
            fail("must have failed since there is different tables");
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage(), sqle.getMessage().contains("ResultSet cannot be updated. " + "The result-set contains fields on different tables"));
        }
    }
}

######


@Test
public void testOneNoTable() throws Exception {
    createTable("testOneNoTable", "`id1` INT NOT NULL AUTO_INCREMENT," + "`t1` VARCHAR(50) NULL," + "PRIMARY KEY (`id1`)");
    Statement stmt = sharedConnection.createStatement();
    stmt.executeQuery("INSERT INTO testOneNoTable(t1) values ('1')");
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT *, now() FROM testOneNoTable", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertTrue(rs.next());
        try {
            rs.updateString("t1", "new value");
            fail("must have failed since there is a field without database");
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage(), sqle.getMessage().contains("ResultSet cannot be updated. " + "The result-set contains fields without without any database information"));
        }
    }
}

######


@Test
public void testMultipleDatabase() throws Exception {
    Statement stmt = sharedConnection.createStatement();
    try {
        stmt.execute("DROP DATABASE testConnectorJ");
    } catch (SQLException sqle) {
    }
    stmt.execute("CREATE DATABASE testConnectorJ");
    createTable(sharedConnection.getCatalog() + ".testMultipleDatabase", "`id1` INT NOT NULL AUTO_INCREMENT," + "`t1` VARCHAR(50) NULL," + "PRIMARY KEY (`id1`)");
    createTable("testConnectorJ.testMultipleDatabase", "`id2` INT NOT NULL AUTO_INCREMENT," + "`t2` VARCHAR(50) NULL," + "PRIMARY KEY (`id2`)");
    stmt.executeQuery("INSERT INTO " + sharedConnection.getCatalog() + ".testMultipleDatabase(t1) values ('1')");
    stmt.executeQuery("INSERT INTO testConnectorJ.testMultipleDatabase(t2) values ('2')");
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT * FROM " + sharedConnection.getCatalog() + ".testMultipleDatabase, testConnectorJ.testMultipleDatabase", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertTrue(rs.next());
        try {
            rs.updateString("t1", "new value");
            fail("must have failed since there is different database");
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage(), sqle.getMessage().contains("The result-set contains more than one database"));
        }
    }
}

######


@Test
public void testUpdateWithoutPrimary() throws Exception {
    createTable("UpdateWithoutPrimary", "`id` INT NOT NULL AUTO_INCREMENT," + "`t1` VARCHAR(50) NOT NULL," + "`t2` VARCHAR(50) NULL default 'default-value'," + "PRIMARY KEY (`id`)");
    Statement stmt = sharedConnection.createStatement();
    stmt.executeQuery("INSERT INTO UpdateWithoutPrimary(t1,t2) values ('1-1','1-2')");
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT t1, t2 FROM UpdateWithoutPrimary", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertTrue(rs.next());
        try {
            rs.updateString(1, "1-1-bis");
            rs.updateRow();
            fail();
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage(), sqle.getMessage().contains("ResultSet cannot be updated. Primary key " + "field `id` is not in result-set"));
        }
        try {
            rs.deleteRow();
            fail();
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage(), sqle.getMessage().contains("ResultSet cannot be updated. " + "Primary key field `id` is not in result-set"));
        }
    }
    int[] autoInc = setAutoInc();
    ResultSet rs = stmt.executeQuery("SELECT id, t1, t2 FROM UpdateWithoutPrimary");
    assertTrue(rs.next());
    assertEquals(autoInc[1] + autoInc[0], rs.getInt(1));
    assertEquals("1-1", rs.getString(2));
    assertEquals("1-2", rs.getString(3));
    assertFalse(rs.next());
}

######


@Test
public void testUpdateWithPrimary() throws Exception {
    createTable("testUpdateWithPrimary", "`id` INT NOT NULL AUTO_INCREMENT," + "`t1` VARCHAR(50) NOT NULL," + "`t2` VARCHAR(50) NULL default 'default-value'," + "PRIMARY KEY (`id`)", "DEFAULT CHARSET=utf8");
    Statement stmt = sharedConnection.createStatement();
    stmt.executeQuery("INSERT INTO testUpdateWithPrimary(t1,t2) values ('1-1','1-2'),('2-1','2-2')");
    String utf8escapeQuote = "你好 '\' \" \\";
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT id, t1, t2 FROM testUpdateWithPrimary", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        rs.moveToInsertRow();
        rs.updateInt(1, -1);
        rs.updateString(2, "0-1");
        rs.updateString(3, "0-2");
        rs.insertRow();
        assertTrue(rs.next());
        assertTrue(rs.next());
        rs.updateString(2, utf8escapeQuote);
        rs.updateRow();
    }
    final int[] autoInc = setAutoInc();
    ResultSet rs = stmt.executeQuery("SELECT id, t1, t2 FROM testUpdateWithPrimary");
    assertTrue(rs.next());
    assertEquals(-1, rs.getInt(1));
    assertEquals("0-1", rs.getString(2));
    assertEquals("0-2", rs.getString(3));
    assertTrue(rs.next());
    assertEquals(autoInc[0] + autoInc[1], rs.getInt(1));
    assertEquals("1-1", rs.getString(2));
    assertEquals("1-2", rs.getString(3));
    assertTrue(rs.next());
    assertEquals(2 * autoInc[0] + autoInc[1], rs.getInt(1));
    assertEquals(utf8escapeQuote, rs.getString(2));
    assertEquals("2-2", rs.getString(3));
    assertFalse(rs.next());
}

######


@Test
public void testUpdateWhenFetch() throws Exception {
    createTable("testUpdateWhenFetch", "`id` INT NOT NULL AUTO_INCREMENT," + "`t1` VARCHAR(50) NOT NULL," + "`t2` VARCHAR(50) NULL default 'default-value'," + "PRIMARY KEY (`id`)", "DEFAULT CHARSET=utf8");
    final Statement stmt = sharedConnection.createStatement();
    PreparedStatement pstmt = sharedConnection.prepareStatement("INSERT INTO testUpdateWhenFetch(t1,t2) values (?, ?)");
    for (int i = 1; i < 100; i++) {
        pstmt.setString(1, i + "-1");
        pstmt.setString(2, i + "-2");
        pstmt.addBatch();
    }
    pstmt.executeBatch();
    String utf8escapeQuote = "你好 '\' \" \\";
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT id, t1, t2 FROM testUpdateWhenFetch", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        preparedStatement.setFetchSize(2);
        ResultSet rs = preparedStatement.executeQuery();
        rs.moveToInsertRow();
        rs.updateInt(1, -1);
        rs.updateString(2, "0-1");
        rs.updateString(3, "0-2");
        rs.insertRow();
        rs.next();
        rs.next();
        rs.updateString(2, utf8escapeQuote);
        rs.updateRow();
    }
    ResultSet rs = stmt.executeQuery("SELECT id, t1, t2 FROM testUpdateWhenFetch");
    assertTrue(rs.next());
    assertEquals(-1, rs.getInt(1));
    assertEquals("0-1", rs.getString(2));
    assertEquals("0-2", rs.getString(3));
    int[] autoInc = setAutoInc();
    assertTrue(rs.next());
    assertEquals(autoInc[0] + autoInc[1], rs.getInt(1));
    assertEquals("1-1", rs.getString(2));
    assertEquals("1-2", rs.getString(3));
    assertTrue(rs.next());
    assertEquals(2 * autoInc[0] + autoInc[1], rs.getInt(1));
    assertEquals(utf8escapeQuote, rs.getString(2));
    assertEquals("2-2", rs.getString(3));
    for (int i = 3; i < 100; i++) {
        assertTrue(rs.next());
        assertEquals(i + "-1", rs.getString(2));
        assertEquals(i + "-2", rs.getString(3));
    }
    assertFalse(rs.next());
}

######


@Test
public void testPrimaryGenerated() throws Exception {
    createTable("PrimaryGenerated", "`id` INT NOT NULL AUTO_INCREMENT," + "`t1` VARCHAR(50) NOT NULL," + "`t2` VARCHAR(50) NULL default 'default-value'," + "PRIMARY KEY (`id`)");
    Statement stmt = sharedConnection.createStatement();
    int[] autoInc = setAutoInc();
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT t1, t2, id FROM PrimaryGenerated", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertFalse(rs.next());
        rs.moveToInsertRow();
        rs.updateString(1, "1-1");
        rs.updateString(2, "1-2");
        rs.insertRow();
        rs.moveToInsertRow();
        rs.updateString(1, "2-1");
        rs.insertRow();
        rs.moveToInsertRow();
        rs.updateString(2, "3-2");
        try {
            rs.insertRow();
            fail("must not occur since t1 cannot be null");
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage(), sqle.getMessage().contains("Field 't1' doesn't have a default value"));
        }
        rs.absolute(1);
        assertEquals("1-1", rs.getString(1));
        assertEquals("1-2", rs.getString(2));
        assertEquals(autoInc[0] + autoInc[1], rs.getInt(3));
        assertTrue(rs.next());
        assertEquals("2-1", rs.getString(1));
        assertEquals("default-value", rs.getString(2));
        assertEquals(2 * autoInc[0] + autoInc[1], rs.getInt(3));
        assertFalse(rs.next());
    }
    ResultSet rs = stmt.executeQuery("SELECT id, t1, t2 FROM PrimaryGenerated");
    assertTrue(rs.next());
    assertEquals(autoInc[0] + autoInc[1], rs.getInt(1));
    assertEquals("1-1", rs.getString(2));
    assertEquals("1-2", rs.getString(3));
    assertTrue(rs.next());
    assertEquals(2 * autoInc[0] + autoInc[1], rs.getInt(1));
    assertEquals("2-1", rs.getString(2));
    assertEquals("default-value", rs.getString(3));
    assertFalse(rs.next());
}

######


@Test
public void testPrimaryGeneratedDefault() throws Exception {
    createTable("testPrimaryGeneratedDefault", "`id` INT NOT NULL AUTO_INCREMENT," + "`t1` VARCHAR(50) NOT NULL default 'default-value1'," + "`t2` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP," + "PRIMARY KEY (`id`)");
    int[] autoInc = setAutoInc();
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT id, t1, t2 FROM testPrimaryGeneratedDefault", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertFalse(rs.next());
        rs.moveToInsertRow();
        rs.insertRow();
        rs.moveToInsertRow();
        rs.insertRow();
        rs.beforeFirst();
        assertTrue(rs.next());
        assertEquals(autoInc[1] + autoInc[0], rs.getInt(1));
        assertEquals("default-value1", rs.getString(2));
        assertNotNull(rs.getDate(3));
        assertTrue(rs.next());
        assertEquals(2 * autoInc[0] + autoInc[1], rs.getInt(1));
        assertEquals("default-value1", rs.getString(2));
        assertNotNull(rs.getDate(3));
        assertFalse(rs.next());
    }
    Statement stmt = sharedConnection.createStatement();
    ResultSet rs = stmt.executeQuery("SELECT id, t1, t2 FROM testPrimaryGeneratedDefault");
    assertTrue(rs.next());
    assertEquals(autoInc[0] + autoInc[1], rs.getInt(1));
    assertEquals("default-value1", rs.getString(2));
    assertNotNull(rs.getDate(3));
    assertTrue(rs.next());
    assertEquals(2 * autoInc[0] + autoInc[1], rs.getInt(1));
    assertEquals("default-value1", rs.getString(2));
    assertNotNull(rs.getDate(3));
    assertFalse(rs.next());
}

######


@Test
public void testDelete() throws Exception {
    createTable("testDelete", "`id` INT NOT NULL," + "`id2` INT NOT NULL," + "`t1` VARCHAR(50)," + "PRIMARY KEY (`id`,`id2`)");
    Statement stmt = sharedConnection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
    stmt.execute("INSERT INTO testDelete values (1,-1,'1'), (2,-2,'2'), (3,-3,'3')");
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT * FROM testDelete", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        try {
            rs.deleteRow();
            fail();
        } catch (SQLException sqle) {
            assertTrue(sqle.getMessage(), sqle.getMessage().contains("Current position is before the first row"));
        }
        assertTrue(rs.next());
        assertTrue(rs.next());
        assertEquals(2, rs.getInt(1));
        rs.deleteRow();
        assertEquals(1, rs.getInt(1));
        assertEquals(-1, rs.getInt(2));
        assertTrue(rs.next());
        assertEquals(3, rs.getInt(1));
        assertEquals(-3, rs.getInt(2));
    }
    ResultSet rs = stmt.executeQuery("SELECT * FROM testDelete");
    assertTrue(rs.next());
    assertEquals(1, rs.getInt(1));
    assertEquals(-1, rs.getInt(2));
    assertTrue(rs.next());
    assertEquals(3, rs.getInt(1));
    assertEquals(-3, rs.getInt(2));
    assertFalse(rs.next());
    rs.absolute(1);
    rs.deleteRow();
    try {
        rs.getInt(1);
        fail();
    } catch (SQLException sqle) {
        assertTrue(sqle.getMessage(), sqle.getMessage().contains("Current position is before the first row"));
    }
}

######


@Test
public void testUpdateChangingMultiplePrimaryKey() throws Exception {
    createTable("testUpdateChangingMultiplePrimaryKey", "`id` INT NOT NULL," + "`id2` INT NOT NULL," + "`t1` VARCHAR(50)," + "PRIMARY KEY (`id`,`id2`)");
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("INSERT INTO testUpdateChangingMultiplePrimaryKey values (1,-1,'1'), (2,-2,'2'), (3,-3,'3')");
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT * FROM testUpdateChangingMultiplePrimaryKey", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertTrue(rs.next());
        assertTrue(rs.next());
        rs.updateInt(1, 4);
        rs.updateInt(2, -4);
        rs.updateString(3, "4");
        rs.updateRow();
        assertEquals(4, rs.getInt(1));
        assertEquals(-4, rs.getInt(2));
        assertEquals("4", rs.getString(3));
    }
    ResultSet rs = stmt.executeQuery("SELECT * FROM testUpdateChangingMultiplePrimaryKey");
    assertTrue(rs.next());
    assertEquals(1, rs.getInt(1));
    assertEquals(-1, rs.getInt(2));
    assertEquals("1", rs.getString(3));
    assertTrue(rs.next());
    assertEquals(3, rs.getInt(1));
    assertEquals(-3, rs.getInt(2));
    assertEquals("3", rs.getString(3));
    assertTrue(rs.next());
    assertEquals(4, rs.getInt(1));
    assertEquals(-4, rs.getInt(2));
    assertEquals("4", rs.getString(3));
    assertFalse(rs.next());
}

######


@Test
public void updateBlob() throws SQLException, IOException {
    createTable("updateBlob", "id int not null primary key, strm blob");
    PreparedStatement stmt = sharedConnection.prepareStatement("insert into updateBlob (id, strm) values (?,?)");
    byte[] theBlob = { 1, 2, 3, 4, 5, 6 };
    InputStream stream = new ByteArrayInputStream(theBlob);
    stmt.setInt(1, 1);
    stmt.setBlob(2, stream);
    stmt.execute();
    byte[] updatedBlob = { 1, 3, 6, 9, 15, 21 };
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("select * from updateBlob", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertTrue(rs.next());
        InputStream updatedStream = new ByteArrayInputStream(updatedBlob);
        rs.updateBlob(2, updatedStream);
        rs.updateRow();
        checkResult(rs, updatedBlob);
    }
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("select * from updateBlob", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertTrue(rs.next());
        checkResult(rs, updatedBlob);
    }
}

######


private void checkResult(ResultSet rs, byte[] updatedBlob) throws SQLException, IOException {
    InputStream readStuff = rs.getBlob("strm").getBinaryStream();
    int ch;
    int pos = 0;
    while ((ch = readStuff.read()) != -1) {
        assertEquals(updatedBlob[pos++], ch);
    }
    readStuff = rs.getBinaryStream("strm");
    pos = 0;
    while ((ch = readStuff.read()) != -1) {
        assertEquals(updatedBlob[pos++], ch);
    }
}

######


@Test
public void updateMeta() throws SQLException {
    DatabaseMetaData meta = sharedConnection.getMetaData();
    assertTrue(meta.ownUpdatesAreVisible(ResultSet.TYPE_FORWARD_ONLY));
    assertTrue(meta.ownDeletesAreVisible(ResultSet.TYPE_FORWARD_ONLY));
    assertTrue(meta.ownInsertsAreVisible(ResultSet.TYPE_FORWARD_ONLY));
    assertTrue(meta.supportsResultSetConcurrency(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY));
    assertTrue(meta.supportsResultSetConcurrency(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE));
    assertTrue(meta.ownUpdatesAreVisible(ResultSet.TYPE_SCROLL_INSENSITIVE));
    assertTrue(meta.ownDeletesAreVisible(ResultSet.TYPE_SCROLL_INSENSITIVE));
    assertTrue(meta.ownInsertsAreVisible(ResultSet.TYPE_SCROLL_INSENSITIVE));
    assertTrue(meta.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY));
    assertTrue(meta.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE));
    assertFalse(meta.ownUpdatesAreVisible(ResultSet.TYPE_SCROLL_SENSITIVE));
    assertFalse(meta.ownDeletesAreVisible(ResultSet.TYPE_SCROLL_SENSITIVE));
    assertFalse(meta.ownInsertsAreVisible(ResultSet.TYPE_SCROLL_SENSITIVE));
    assertFalse(meta.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY));
    assertFalse(meta.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE));
}

######


@Test
public void updateResultSetMeta() throws SQLException {
    Statement stmt = sharedConnection.createStatement();
    assertEquals(ResultSet.CONCUR_READ_ONLY, stmt.getResultSetConcurrency());
    ResultSet rs = stmt.executeQuery("SELECT 1");
    assertEquals(ResultSet.CONCUR_READ_ONLY, rs.getConcurrency());
    stmt = sharedConnection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
    assertEquals(ResultSet.CONCUR_UPDATABLE, stmt.getResultSetConcurrency());
    rs = stmt.executeQuery("SELECT 1");
    assertEquals(ResultSet.CONCUR_UPDATABLE, rs.getConcurrency());
}

######


@Test
public void insertNoRow() throws SQLException {
    createTable("insertNoRow", "id int not null primary key, strm blob");
    Statement st = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
    ResultSet rs = st.executeQuery("select * from insertNoRow");
    assertFalse(rs.next());
    rs.moveToInsertRow();
    try {
        rs.refreshRow();
        fail("Can't refresh when on the insert row.");
    } catch (SQLException sqle) {
    }
    rs.moveToCurrentRow();
}

######


@Test
public void refreshRow() throws SQLException {
    createTable("refreshRow", "id int not null primary key, strm blob");
    Statement st = sharedConnection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
    st.execute("INSERT INTO refreshRow values (1, '555')");
    ResultSet rs = st.executeQuery("select * from refreshRow");
    st.execute("UPDATE refreshRow set strm = '666' WHERE id = 1");
    try {
        rs.refreshRow();
        fail("Can't refresh when not on row.");
    } catch (SQLException sqle) {
    }
    assertTrue(rs.next());
    assertEquals(1, rs.getInt(1));
    assertEquals("555", rs.getString(2));
    rs.refreshRow();
    assertEquals("666", rs.getString(2));
    rs.moveToInsertRow();
    try {
        rs.refreshRow();
        fail("Can't refresh when on insert row");
    } catch (SQLException sqle) {
    }
    rs.moveToCurrentRow();
    assertFalse(rs.next());
    try {
        rs.refreshRow();
        fail("Can't refresh when not on row.");
    } catch (SQLException sqle) {
    }
}

######


@Test
public void testMoveToInsertRow() throws SQLException {
    createTable("testMoveToInsertRow", "t2 text, t1 text, id int primary key");
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("select id, t1, t2 from testMoveToInsertRow", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertNotNull(rs);
        assertEquals(0, rs.getRow());
        rs.moveToInsertRow();
        rs.updateInt(1, 1);
        rs.updateString(2, "t1-value");
        rs.updateString(3, "t2-value");
        rs.insertRow();
        rs.first();
        assertEquals(1, rs.getRow());
        rs.updateInt("id", 2);
        rs.updateString("t1", "t1-bis-value");
        rs.updateRow();
        assertEquals(1, rs.getRow());
        assertEquals(2, rs.getInt("id"));
        assertEquals("t1-bis-value", rs.getString("t1"));
        assertEquals("t2-value", rs.getString("t2"));
        rs.deleteRow();
        assertEquals(0, rs.getRow());
        rs.moveToInsertRow();
        rs.updateInt("id", 3);
        rs.updateString("t1", "other-t1-value");
        rs.insertRow();
        assertEquals(1, rs.getRow());
        try {
            rs.refreshRow();
            fail("Can't refresh when on the insert row.");
        } catch (SQLException sqle) {
            assertEquals("Cannot call deleteRow() when inserting a new row", sqle.getMessage());
        }
        assertEquals(3, rs.getInt("id"));
        assertEquals("other-t1-value", rs.getString("t1"));
        assertNull(rs.getString("t2"));
    }
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("select id, t1, t2 from testMoveToInsertRow", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertTrue(rs.first());
        rs.updateInt("id", 3);
        rs.updateString("t1", "t1-3");
        rs.updateRow();
        assertEquals(3, rs.getInt("id"));
        assertEquals("t1-3", rs.getString("t1"));
        rs.moveToInsertRow();
        rs.updateInt("id", 4);
        rs.updateString("t1", "t1-4");
        rs.insertRow();
        rs.updateInt("id", 5);
        rs.updateString("t1", "t1-5");
        rs.insertRow();
        rs.moveToCurrentRow();
        assertEquals(3, rs.getInt("id"));
        assertEquals("t1-3", rs.getString("t1"));
        assertTrue(rs.next());
        assertEquals(4, rs.getInt("id"));
        assertEquals("t1-4", rs.getString("t1"));
        assertTrue(rs.next());
        assertEquals(5, rs.getInt("id"));
        assertEquals("t1-5", rs.getString("t1"));
    }
}

######


@Test
public void cancelRowUpdatesTest() throws SQLException {
    createTable("cancelRowUpdatesTest", "c text, id int primary key");
    Statement st = sharedConnection.createStatement();
    st.executeUpdate("INSERT INTO cancelRowUpdatesTest(id,c) values (1,'1'), (2,'2'),(3,'3'),(4,'4')");
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("select id,c from cancelRowUpdatesTest order by id", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertTrue(rs.next());
        assertTrue(rs.next());
        assertEquals("2", rs.getString("c"));
        rs.updateString("c", "2bis");
        rs.cancelRowUpdates();
        rs.updateRow();
        assertEquals("2", rs.getString("c"));
        rs.updateString("c", "2bis");
        rs.updateRow();
        assertEquals("2bis", rs.getString("c"));
        assertTrue(rs.first());
        assertTrue(rs.next());
        assertEquals("2bis", rs.getString("c"));
    }
}

######


@Test
public void deleteRowsTest() throws SQLException {
    createTable("deleteRows", "c text, id int primary key");
    Statement st = sharedConnection.createStatement();
    st.executeUpdate("INSERT INTO deleteRows(id,c) values (1,'1'), (2,'2'),(3,'3'),(4,'4')");
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("select id,c from deleteRows order by id", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        assertTrue(rs.next());
        assertEquals(1, rs.getInt("id"));
        rs.deleteRow();
        assertTrue(rs.isBeforeFirst());
        assertTrue(rs.next());
        assertTrue(rs.next());
        assertEquals(3, rs.getInt("id"));
        rs.deleteRow();
        assertEquals(2, rs.getInt("id"));
    }
}

######


@Test
public void updatePosTest() throws SQLException {
    createTable("updatePosTest", "c text, id int primary key");
    Statement st = sharedConnection.createStatement();
    st.executeUpdate("INSERT INTO updatePosTest(id,c) values (1,'1')");
    try (PreparedStatement preparedStatement = sharedConnection.prepareStatement("select id,c from updatePosTest", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet rs = preparedStatement.executeQuery();
        try {
            rs.updateInt(1, 20);
            fail();
        } catch (SQLException sqle) {
            assertEquals("Current position is before the first row", sqle.getMessage());
        }
        try {
            rs.updateRow();
            fail();
        } catch (SQLException sqle) {
            assertEquals("Current position is before the first row", sqle.getMessage());
        }
        try {
            rs.deleteRow();
            fail();
        } catch (SQLException sqle) {
            assertEquals("Current position is before the first row", sqle.getMessage());
        }
        assertTrue(rs.next());
        rs.updateInt(1, 20);
        rs.updateRow();
        rs.deleteRow();
        assertFalse(rs.next());
        try {
            rs.updateInt(1, 20);
            fail();
        } catch (SQLException sqle) {
            assertEquals("Current position is after the last row", sqle.getMessage());
        }
        try {
            rs.updateRow();
            fail();
        } catch (SQLException sqle) {
            assertEquals("Current position is after the last row", sqle.getMessage());
        }
        try {
            rs.deleteRow();
            fail();
        } catch (SQLException sqle) {
            assertEquals("Current position is after the last row", sqle.getMessage());
        }
    }
}

######


@Test
public void repeatedFieldUpdatable() throws SQLException {
    createTable("repeatedFieldUpdatable", "t1 varchar(50) NOT NULL, t2 varchar(50), PRIMARY KEY (t1)");
    Statement stmt = sharedConnection.createStatement();
    stmt.execute("insert into repeatedFieldUpdatable values ('gg', 'hh'), ('jj', 'll')");
    PreparedStatement preparedStatement = sharedConnection.prepareStatement("SELECT t1, t2, t1 as t3 FROM repeatedFieldUpdatable", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
    ResultSet rs = preparedStatement.executeQuery();
    while (rs.next()) {
        rs.getObject(3);
    }
}

######


protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
}

######


protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    HttpSession session1 = request.getSession();
    String newpwd = (String) session1.getAttribute("newpwd");
    String accode = (String) request.getParameter("access");
    String newpass1 = (String) request.getParameter("newpass");
    String confirmpass1 = (String) request.getParameter("confirmpass");
    String code = (String) session1.getAttribute("accesscode");
    String userid = (String) session1.getAttribute("userid");
    String remoteAddr = request.getRemoteAddr();
    ReCaptchaImpl reCaptcha = new ReCaptchaImpl();
    reCaptcha.setPrivateKey("6LcuJvISAAAAAD7BS-MgJGWlwWCuMXemibnqFsuX");
    String challenge = request.getParameter("recaptcha_challenge_field");
    String uresponse = request.getParameter("recaptcha_response_field");
    ReCaptchaResponse reCaptchaResponse = reCaptcha.checkAnswer(remoteAddr, challenge, uresponse);
    if (newpass1.equals(confirmpass1)) {
        if (reCaptchaResponse.isValid()) {
            String pwd = null;
            try {
                pwd = Hashing.createHash(newpass1);
            } catch (NoSuchAlgorithmException | InvalidKeySpecException e1) {
                e1.printStackTrace();
            }
            try {
                Class.forName("com.mysql.jdbc.Driver");
                Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/userVerificationdb", "root", "root");
                Statement st = con.createStatement();
                int i = st.executeUpdate("update account set password='" + pwd + "' where username='" + userid + "'");
                if (i > 0) {
                    response.sendRedirect("successreset.jsp");
                } else {
                    response.sendRedirect("forgotPassword.jsp");
                }
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        } else {
            JOptionPane.showMessageDialog(null, "Captcha value is not correct");
            response.sendRedirect("resetpassword.jsp");
        }
    } else {
        JOptionPane.showMessageDialog(null, "Access code does not match");
    }
}

######


public static Integer getConceptIdForUnits(String units) {
    String appDataDir = OpenmrsUtil.getApplicationDataDirectory();
    Properties props = new Properties();
    String conceptId = null;
    String filePath = appDataDir + System.getProperty("file.separator") + DatabaseUtil.ORDER_ENTRY_UPGRADE_SETTINGS_FILENAME;
    try (FileInputStream fis = new FileInputStream(filePath)) {
        props.load(fis);
        for (Map.Entry prop : props.entrySet()) {
            if (prop.getKey().equals(units)) {
                conceptId = prop.getValue().toString();
                return Integer.valueOf(conceptId);
            }
        }
    } catch (NumberFormatException e) {
        throw new APIException("Your order entry upgrade settings file" + "contains invalid mapping from " + units + " to concept ID " + conceptId + ". ID must be an integer or null. Please refer to upgrade instructions for more details. https://wiki.openmrs.org/x/OALpAw Cause:" + e.getMessage());
    } catch (IOException e) {
        if (e instanceof FileNotFoundException) {
            throw new APIException("Unable to find file named order_entry_upgrade_settings.txt containing order entry upgrade settings in your " + "application data directory: " + appDataDir + "\nPlease refer to upgrade instructions for more details. https://wiki.openmrs.org/x/OALpAw Cause:" + e.getMessage());
        } else {
            throw new APIException(e);
        }
    }
    throw new APIException("Your order entry upgrade settings file" + " does not have mapping for " + units + ". Please refer to upgrade instructions for more details. https://wiki.openmrs.org/x/OALpAw");
}

######


public static String getConceptUuid(Connection connection, int conceptId) throws SQLException {
    try (PreparedStatement select = connection.prepareStatement("select uuid from concept where concept_id = ?")) {
        select.setInt(1, conceptId);
        ResultSet resultSet = select.executeQuery();
        if (resultSet.next()) {
            return resultSet.getString(1);
        } else {
            throw new IllegalArgumentException("Concept not found " + conceptId);
        }
    }
}

######


public static String getGlobalProperty(Connection connection, String gp) throws SQLException {
    try (PreparedStatement select = connection.prepareStatement("select property_value from global_property where property = ?")) {
        select.setString(1, gp);
        ResultSet resultSet = select.executeQuery();
        if (resultSet.next()) {
            return resultSet.getString(1);
        } else {
            throw new IllegalArgumentException("Global property not found " + gp);
        }
    }
}

######


public static List<Integer> getMemberSetIds(Connection connection, String conceptUuid) throws SQLException {
    Integer conceptSetId;
    try (PreparedStatement select = connection.prepareStatement("select concept_id from concept where uuid = ?")) {
        select.setString(1, conceptUuid);
        ResultSet resultSet = select.executeQuery();
        if (resultSet.next()) {
            conceptSetId = resultSet.getInt(1);
        } else {
            throw new IllegalArgumentException("Concept not found " + conceptUuid);
        }
    }
    List<Integer> conceptIds = new ArrayList<>();
    try (PreparedStatement selectConceptIds = connection.prepareStatement("select concept_id from concept_set where concept_set = ?")) {
        selectConceptIds.setInt(1, conceptSetId);
        ResultSet resultSet = selectConceptIds.executeQuery();
        while (resultSet.next()) {
            conceptIds.add(resultSet.getInt(1));
        }
    }
    return conceptIds;
}

######


public static Integer getOrderFrequencyIdForConceptId(Connection connection, Integer conceptIdForFrequency) throws SQLException {
    PreparedStatement orderFrequencyIdQuery = connection.prepareStatement("select order_frequency_id from order_frequency where concept_id = ?");
    orderFrequencyIdQuery.setInt(1, conceptIdForFrequency);
    ResultSet orderFrequencyIdResultSet = orderFrequencyIdQuery.executeQuery();
    if (!orderFrequencyIdResultSet.next()) {
        return null;
    }
    return orderFrequencyIdResultSet.getInt("order_frequency_id");
}

######


public void init() {
    filePath = getServletContext().getInitParameter("file-upload");
}

######


public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    int ab = 0;
    File newName = null;
    int empid = 0;
    java.io.PrintWriter out;
    String fieldName = null;
    String fileName = null;
    String contentType = null;
    String name = null;
    String namecom = null;
    String NewName = "Contract File" + ab;
    ab++;
    isMultipart = ServletFileUpload.isMultipartContent(request);
    response.setContentType("text/html");
    if (!isMultipart) {
        return;
    }
    DiskFileItemFactory factory = new DiskFileItemFactory();
    factory.setSizeThreshold(maxMemSize);
    ServletFileUpload upload = new ServletFileUpload(factory);
    upload.setSizeMax(maxFileSize);
    try {
        List fileItems = upload.parseRequest(request);
        Iterator i = fileItems.iterator();
        while (i.hasNext()) {
            FileItem fi = (FileItem) i.next();
            if (fi.isFormField()) {
                if (fi.getFieldName().equals("nameind")) {
                    name = fi.getString();
                } else if (fi.getFieldName().equals("namecom")) {
                    namecom = fi.getString();
                }
            } else if (!fi.isFormField()) {
                fieldName = fi.getFieldName();
                fileName = fi.getName();
                contentType = fi.getContentType();
                boolean isInMemory = fi.isInMemory();
                long sizeInBytes = fi.getSize();
                if (fileName.lastIndexOf("\\") >= 0) {
                    file = new File(filePath + fileName.substring(fileName.lastIndexOf("\\")));
                } else {
                    file = new File(filePath + fileName.substring(fileName.lastIndexOf("\\") + 1));
                }
                fi.write(file);
            } else {
                break;
            }
        }
        commitData(name, namecom, fieldName, fileName, contentType, filePath);
        RequestDispatcher ReqDis1 = request.getRequestDispatcher("AdminUploadContract_1.jsp");
        ReqDis1.forward(request, response);
    } catch (Exception ex) {
        ex.printStackTrace();
        RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
        ReqDis.forward(request, response);
    }
}

######


private void commitData(String name, String namecom, String fieldName, String fileName, String contentType, String filePath2) throws SQLException {
    String sql = "INSERT INTO `mckc`.`contractupload` (industryname, companyname, filename, type, filepath) VALUES (?,?,?,?,?)";
    Connection con = Connect.getconnection();
    PreparedStatement ps = con.prepareStatement(sql);
    ps.setString(1, name);
    ps.setString(2, namecom);
    ps.setString(3, fileName);
    ps.setString(4, contentType);
    ps.setString(5, filePath2);
    ps.executeUpdate();
}

######


public void init() {
    filePath = getServletContext().getInitParameter("file-upload");
}

######


@SuppressWarnings("null")
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    int empid = 0;
    java.io.PrintWriter out;
    isMultipart = ServletFileUpload.isMultipartContent(request);
    response.setContentType("text/html");
    if (!isMultipart) {
        return;
    }
    DiskFileItemFactory factory = new DiskFileItemFactory();
    factory.setSizeThreshold(maxMemSize);
    ServletFileUpload upload = new ServletFileUpload(factory);
    upload.setSizeMax(maxFileSize);
    try {
        List fileItems = upload.parseRequest(request);
        Iterator i = fileItems.iterator();
        float Backhaul = 0;
        while (i.hasNext()) {
            FileItem fi = (FileItem) i.next();
            if (!fi.isFormField()) {
                String fieldName = fi.getFieldName();
                String fileName = fi.getName();
                String contentType = fi.getContentType();
                boolean isInMemory = fi.isInMemory();
                long sizeInBytes = fi.getSize();
                if (fileName.lastIndexOf("\\") >= 0) {
                    file = new File(filePath + fileName.substring(fileName.lastIndexOf("\\")));
                } else {
                    file = new File(filePath + fileName.substring(fileName.lastIndexOf("\\") + 1));
                }
                fi.write(file);
            } else {
                empid = Integer.parseInt(fi.getString());
                break;
            }
        }
        readExcel(file);
        calculatePTPK(Backhaul);
        if (empid == 11) {
            RequestDispatcher ReqDis1 = request.getRequestDispatcher("AdminUploadResult.jsp");
            ReqDis1.forward(request, response);
        } else {
            RequestDispatcher ReqDis = request.getRequestDispatcher("UploadResult.jsp");
            ReqDis.forward(request, response);
        }
    } catch (Exception ex) {
        ex.printStackTrace();
        if (empid == 11) {
            RequestDispatcher ReqDis = request.getRequestDispatcher("Adminerror.jsp");
            ReqDis.forward(request, response);
        } else {
            RequestDispatcher ReqDis = request.getRequestDispatcher("error.jsp");
            ReqDis.forward(request, response);
        }
    }
}

######


private void readExcel(File fileItem) throws Exception {
    FileInputStream file = new FileInputStream(fileItem);
    XSSFWorkbook workbook = new XSSFWorkbook(file);
    XSSFSheet sheet = workbook.getSheetAt(0);
    Iterator<Row> rowIterator = sheet.iterator();
    Connection con = Connect.getconnection();
    PreparedStatement ps1 = con.prepareStatement("DELETE FROM freightupload");
    ps1.executeUpdate();
    Row nextRow = rowIterator.next();
    while (rowIterator.hasNext()) {
        nextRow = rowIterator.next();
        Iterator<Cell> cellIterator = nextRow.cellIterator();
        PreparedStatement ps = con.prepareStatement("INSERT INTO `mckc`.`freightupload` (`Origin`, `Destination`, `Truck_type`, `Freight_rate`, `Distance`, `lat`, `long`,`Empty`) VALUES  (?,?,?,?,?,?,?,?)");
        while (cellIterator.hasNext()) {
            Cell cell = cellIterator.next();
            switch(cell.getCellType()) {
                case Cell.CELL_TYPE_STRING:
                    if (cell.getColumnIndex() == 0) {
                        ps.setString(1, cell.getStringCellValue());
                        break;
                    } else if (cell.getColumnIndex() == 1) {
                        ps.setString(2, cell.getStringCellValue());
                        break;
                    } else if (cell.getColumnIndex() == 2) {
                        ps.setString(3, cell.getStringCellValue());
                        break;
                    }
                case Cell.CELL_TYPE_NUMERIC:
                    if (cell.getColumnIndex() == 3) {
                        ps.setDouble(4, cell.getNumericCellValue());
                        break;
                    } else if (cell.getColumnIndex() == 4) {
                        ps.setDouble(5, cell.getNumericCellValue());
                        break;
                    } else if (cell.getColumnIndex() == 5) {
                        ps.setDouble(6, cell.getNumericCellValue());
                        break;
                    } else if (cell.getColumnIndex() == 6) {
                        ps.setDouble(7, cell.getNumericCellValue());
                        break;
                    } else if (cell.getColumnIndex() == 7) {
                        ps.setInt(8, (int) cell.getNumericCellValue());
                        break;
                    }
                case Cell.CELL_TYPE_BLANK:
                    break;
            }
        }
        ps.executeUpdate();
    }
    workbook.close();
    file.close();
    con.close();
}

######


void calculatePTPK(float Backhaul) throws Exception {
    Connection con = Connect.getconnection();
    PreparedStatement ps = con.prepareStatement("Select * from `mckc`.`freightupload`");
    ResultSet rs = ps.executeQuery();
    double freight = 0, distance = 0, lat = 0, lon = 0;
    String trucktype = null;
    String start = null, end = null;
    String dest = null;
    int empty;
    while (rs.next()) {
        freight = rs.getDouble("Freight_rate");
        distance = rs.getDouble("Distance");
        trucktype = rs.getString("Truck_type");
        lat = rs.getDouble("Lat");
        lon = rs.getDouble("long");
        dest = rs.getString("Destination");
        empty = rs.getInt("Empty");
        if (empty == 0) {
            commitptpk(freight, distance);
            commitautoptpk((float) distance, trucktype, 0, freight, null, dest, 0);
        } else if (empty == 1) {
            commitptpk(freight, distance);
            NearbyLocations(distance, trucktype, start, end, lat, lon, freight, dest, 100);
        }
    }
    ps.close();
    con.close();
}

######


private void commitptpk(double freight, double distance) throws Exception {
    double ptpk = freight / distance;
    Connection con = Connect.getconnection();
    PreparedStatement ps = con.prepareStatement("UPDATE `mckc`.`freightupload` SET Ptpk=? WHERE Freight_rate=? And Distance=?");
    ps.setDouble(1, ptpk);
    ps.setDouble(2, freight);
    ps.setDouble(3, distance);
    ps.executeUpdate();
    ps.close();
    con.close();
}

######


void NearbyLocations(double distance, String truckType, String start, String end, double lat, double lon, double freight, String dest, float Backhaul) throws Exception {
    double lat1 = 0, lon1 = 0;
    String origin = null;
    Connection con = Connect.getconnection();
    PreparedStatement ps = con.prepareStatement("SELECT * FROM mckc.autoparam WHERE `typeofgood`= ? order by lat");
    ps.setString(1, truckType);
    ResultSet rs = ps.executeQuery();
    while (rs.next()) {
        lat1 = rs.getDouble("lat");
        lon1 = rs.getDouble("long");
        float dist = calculateDistance(lat, lon, lat1, lon1);
        PreparedStatement ps1 = con.prepareStatement("UPDATE mckc.autoparam SET `distance`=? WHERE `typeofgood`=? And `lat`=? And `long`=?");
        ps1.setFloat(1, dist);
        ps1.setString(2, truckType);
        ps1.setDouble(3, lat1);
        ps1.setDouble(4, lon1);
        ps1.executeUpdate();
    }
    float dista = 0;
    PreparedStatement ps2 = con.prepareStatement("SELECT * FROM mckc.autoparam a, priorityslab p WHERE p.Pirority=a.Pirority and a.typeofgood=? order by distance ASC,`Volume Rating` Desc,a.Pirority ASC");
    ps2.setString(1, truckType);
    ResultSet rset = ps2.executeQuery();
    while (rset.next()) {
        if (rset.getInt("a.Pirority") == 1 && rset.getInt("a.Volume Rating") == 3) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 2 && rset.getInt("a.Volume Rating") == 3) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 3 && rset.getInt("a.Volume Rating") == 3) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 1 && rset.getInt("a.Volume Rating") == 2) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 2 && rset.getInt("a.Volume Rating") == 2) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 3 && rset.getInt("a.Volume Rating") == 2) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 1 && rset.getInt("a.Volume Rating") == 1) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 2 && rset.getInt("a.Volume Rating") == 1) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 3 && rset.getInt("a.Volume Rating") == 1) {
            dista = rset.getFloat("distance");
            if (dista >= rset.getInt("p.Min Distance") && dista <= rset.getInt("p.Max Distance")) {
                origin = rset.getString("Origin");
                break;
            }
        } else if (rset.getInt("a.Pirority") == 1) {
            origin = rset.getString("Origin");
            dista = rset.getFloat("distance");
            break;
        }
    }
    PreparedStatement ps0 = con.prepareStatement("SELECT DistanceFactor FROM mckc.Distance_Factor WHERE `long0`< ? and `long2` > ? and `lat2`< ? and `lat0`> ?");
    ps0.setDouble(1, lon);
    ps0.setDouble(2, lon);
    ps0.setDouble(3, lat);
    ps0.setDouble(4, lat);
    ResultSet rs0 = ps0.executeQuery();
    float DistFact = 0;
    while (rs0.next()) {
        DistFact = (float) (rs0.getDouble("DistanceFactor") / 100);
    }
    dista = (float) Math.max(distance * DistFact, dista);
    commitautoptpk((float) (distance + dista), truckType, Backhaul, freight, origin, dest, dista);
}

######


@SuppressWarnings("unused")
private float calculateDistance(double lat, double lon, double lat0, double lon0) {
    float lat1 = (float) lat;
    float lon1 = (float) lon;
    float lat2 = (float) lat0;
    float lon2 = (float) lon0;
    float radlat1 = (float) (Math.PI * lat1 / 180);
    float radlat2 = (float) (Math.PI * lat2 / 180);
    float radlon1 = (float) (Math.PI * lon1 / 180);
    float radlon2 = (float) (Math.PI * lon2 / 180);
    float theta = lon1 - lon2;
    float radtheta = (float) (Math.PI * theta / 180);
    float dist = (float) (Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta));
    dist = (float) Math.acos(dist);
    dist = (float) (dist * 180 / Math.PI);
    dist = (float) (dist * 60 * 1.1515 * 1.609344);
    return dist;
}

######


private void commitautoptpk(float distance, String trucktype, float backhaul, double freight, String origin, String dest, float dista) throws Exception {
    float intrest1 = 0, costOfTyre = 0, costOfTruck = 0, loan = 0, noOfYears = 0, residualValue = 0, noOfTyre = 0, costOfTyreUsed = 0, tyreLife = 0, tyreLifeUsed = 0, mileage = 0, noTrips = 0;
    float mileageWithLoad = 0, diesel = 0, roi = 0;
    int cap = 0;
    Connection con = Connect.getconnection();
    PreparedStatement ps = con.prepareStatement("select * from truckparam where typeofgood=?");
    ps.setString(1, trucktype);
    ResultSet rs = ps.executeQuery();
    while (rs.next()) {
        costOfTruck = rs.getFloat("costoftruck");
        loan = rs.getFloat("loanpercentage");
        intrest1 = rs.getFloat("rateofintrest");
        roi = rs.getFloat("flatroi");
        costOfTyre = rs.getFloat("tyrecost");
        noOfYears = rs.getFloat("yearsemi");
        residualValue = rs.getFloat("residualvalueoftruck");
        noOfTyre = rs.getFloat("tyres");
        costOfTyreUsed = rs.getFloat("reusedtyrecost");
        tyreLife = rs.getFloat("tyrelife");
        tyreLifeUsed = rs.getFloat("reusedtyrelife");
        mileage = rs.getFloat("dieselmileage");
        mileageWithLoad = rs.getFloat("diesealmileagewithload");
        diesel = rs.getFloat("dieselcost");
        cap = rs.getInt("capacity");
    }
    PreparedStatement ps0 = con.prepareStatement("select `NoofTrip` from `slabtable` WHERE `Min Distance` <= ? AND `Max Distance` >?");
    ps0.setInt(1, (int) distance);
    ps0.setInt(2, (int) distance);
    ResultSet rs0 = ps0.executeQuery();
    while (rs0.next()) {
        noTrips = rs0.getFloat("NoofTrip");
    }
    float cost = calculateTyreCostPerKM(noOfTyre, costOfTyre, costOfTyreUsed, tyreLife, tyreLifeUsed);
    float loanamount = calculateLoanAmount(loan, costOfTruck);
    float paid = calculatePaid(costOfTruck, loanamount);
    float residualValueTruck = calulateResidualValueOfTruck(residualValue, costOfTruck);
    float depreciation = calculateDepreciation(costOfTruck, residualValueTruck, noOfYears);
    float interestcost = calculateInterestCostPerMonth(roi, loanamount);
    float netMileage = calculateNetMilage(mileageWithLoad, backhaul, mileage);
    float roundtrip = calculateRoundTrip(distance);
    float distanceTravled = calculateKmRunPerMonthAvg(roundtrip, noTrips);
    float Salary = 0, batta = 0, maintenance = 0, Admin = 0, tarpaulin = 0;
    float expense = 0, totaltoll = 0, insurancepercent = 0, permit = 0, tax = 0;
    float maintenancePerKm = 0, loading = 0;
    float pro = 0;
    PreparedStatement ps2 = con.prepareStatement("select * from routeparam where typeofgood=?");
    ps2.setString(1, trucktype);
    ResultSet rs1 = ps2.executeQuery();
    while (rs1.next()) {
        expense = rs1.getFloat("routeexpenses");
        totaltoll = rs1.getFloat("toll");
        insurancepercent = rs1.getFloat("insuranceaspercentageofvechiclecost");
        permit = rs1.getFloat("roadpermityear");
        tax = rs1.getFloat("roadtaxyear");
        Salary = rs1.getFloat("driver/cleaner salary");
        batta = rs1.getFloat("driver/cleaner bhatta");
        maintenance = rs1.getFloat("maintenancepermonth");
        Admin = rs1.getFloat("admin costs");
        maintenancePerKm = rs1.getFloat("maintenancecostperkm");
        tarpaulin = rs1.getFloat("tarpaulin");
        loading = rs1.getFloat("loadingcharges");
        pro = rs1.getInt("profitmargin");
    }
    float unloading = calculateUnloadingCharges(cap);
    float unloadingloading = unloading + loading;
    float dieselCost = calculateDieselCostPerKm(diesel, netMileage);
    float variableCost = calculateVaribleCostperKm(dieselCost, totaltoll, cost, maintenancePerKm, expense);
    float variable = calculateVaribleCostperMonth(variableCost, distanceTravled, unloadingloading);
    float insuranceMonth = calculateInsurancePerMonth(costOfTruck, insurancepercent);
    float roadPermit = calculateRoadPermitPerMonth(permit);
    float roadTax = calculateRoadTaxPerMonth(tax);
    float fixedcostperMonth = calculatefixedCostPerMonth(roadTax, roadPermit, insuranceMonth, Salary, batta, maintenance, Admin, tarpaulin, depreciation, interestcost);
    float monthlyoperating = calculateMonthlyOperatingCost(fixedcostperMonth, variable);
    float profit = calculateProfitMargin(fixedcostperMonth, pro);
    double perKmCost = calculatePerKmCost(profit, monthlyoperating, distanceTravled);
    float monthlyTon = calculateMonthlyTons(cap, backhaul, noTrips);
    float fixedPTPK = calculateFixedPTPK(fixedcostperMonth, roundtrip, cap, noTrips, backhaul);
    float variablePTPK = calculateVariablePTPK(variable, roundtrip, cap, noTrips, backhaul);
    float profitPTPK = calculateProfitPTPK(profit, roundtrip, cap, noTrips, backhaul);
    float totalPTPK = calculateTotalPTPK(profitPTPK, variablePTPK, fixedPTPK);
    float freightPerTon = calculateFreightPerTon(totalPTPK, (float) distance);
    float costs = cap * distance * totalPTPK;
    float trip_cost = (variable / monthlyTon) + (profit / monthlyTon) + ((fixedcostperMonth + profit) / monthlyTon);
    PreparedStatement ps3 = con.prepareStatement("UPDATE `mckc`.`freightupload` SET Ptpk_auto=?,backhaul=?,emptyhaul=?, TripCost=?, CostTon=? WHERE Truck_type=? and Destination=?");
    ps3.setDouble(1, totalPTPK);
    ps3.setString(2, origin);
    ps3.setFloat(3, dista);
    ps3.setFloat(4, costs);
    ps3.setFloat(5, trip_cost);
    ps3.setString(6, trucktype);
    ps3.setString(7, dest);
    ps3.executeUpdate();
    con.close();
    ps3.close();
    ps2.close();
    ps.close();
}

######


private float calculateProfitMargin(float fixedcostperMonth, float pro) {
    return (fixedcostperMonth * pro) / 100;
}

######


private float calculateProfit(float monthlyoperating) {
    return (float) ((0.0752688172043011) * monthlyoperating);
}

######


private float calculateKmRunPerMonthAvg(float roundtrip, float noTrips) {
    return (roundtrip * noTrips);
}

######


private float calculateVaribleCostperMonth(float variableCost, float distanceTravled, float unloadingloading) {
    return ((variableCost * distanceTravled) + unloadingloading);
}

######


private float calculateTotalPTPK(float profitPTPK, float variablePTPK, float fixedPTPK) {
    return (profitPTPK + variablePTPK + fixedPTPK);
}

######


private float calculateProfitPTPK(float profit, float roundtrip, int cap, float noTrips, float backhaul) {
    return (profit / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateVariablePTPK(float variable, float roundtrip, int cap, float noTrips, float backhaul) {
    return (variable / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateFixedPTPK(float fixedcostperMonth, float roundtrip, int cap, float noTrips, float backhaul) {
    return (fixedcostperMonth / ((roundtrip / 2) * cap * noTrips * (1 + (backhaul / 100))));
}

######


private float calculateFreightPerTon(float totalPTPK, float distance) {
    return (totalPTPK * distance);
}

######


private float calculateRoundTrip(double distance) {
    return (float) (distance * 2);
}

######


private float calculateTotalCostPerTon(float totalPTPK, float distance, int cap) {
    return (totalPTPK * distance * cap);
}

######


private float calculateMonthlyTons(int cap, float backhaul, float noTrips) {
    return (noTrips * cap * (1 + (backhaul / 100)));
}

######


private float calculatePerKmCost(float profitMargin, float monthlyoperating, float distanceTravled) {
    return ((profitMargin + monthlyoperating) / distanceTravled);
}

######


private float calculateMonthlyOperatingCost(float fixedcostperMonth, float variable) {
    return (fixedcostperMonth + variable);
}

######


private float calculatefixedCostPerMonth(float roadTax, float roadPermit, float insuranceMonth, float salary, float batta, float maintenance, float admin, float tarpaulin, float depreciation, float interestcost) {
    return (admin + batta + insuranceMonth + maintenance + roadPermit + roadTax + salary + tarpaulin + depreciation + interestcost);
}

######


private float calculateRoadTaxPerMonth(float tax) {
    return (tax / 12);
}

######


private float calculateRoadPermitPerMonth(float permit) {
    return (permit / 12);
}

######


private float calculateInsurancePerMonth(float costOfTruck, float insurancepercent) {
    return ((costOfTruck * insurancepercent) / 1200);
}

######


private float calculateVaribleCostperKm(float dieselCost, float toll, float cost, float maintenancePerKm, float route) {
    return (dieselCost + toll + cost + maintenancePerKm + route);
}

######


private float calculateRouteExpence(float expense, float distance) {
    return (expense / distance);
}

######


private float calculateUnloadingCharges(int cap) {
    return (45 * cap);
}

######


private float calculateDieselCostPerKm(float diesel, float netMileage) {
    return (diesel / netMileage);
}

######


private float calculateNetMilage(float mileageWithLoad, float backhaul, float mileage) {
    return (((mileageWithLoad * 100 + (mileageWithLoad * backhaul)) + (mileage) * (100 - backhaul)) / 200);
}

######


private float calculateTollPerKm(float totaltoll, float distance) {
    return (totaltoll / distance);
}

######


private float calulateResidualValueOfTruck(float residualValue, float costOfTruck) {
    return (costOfTruck * residualValue / 100);
}

######


private float calculateInterestCostPerMonth(float roi, float loanamount) {
    return ((roi * loanamount) / 1200);
}

######


private float calculateDepreciation(float costOfTruck, float residualValue, float noOfYears) {
    return (((costOfTruck - residualValue) / noOfYears) / 12);
}

######


private float calculatePaid(float costOfTruck, float loanamount) {
    return (costOfTruck - loanamount);
}

######


private float calculateLoanAmount(float loan, float costOfTruck) {
    return ((costOfTruck * loan) / 100);
}

######


private float calculateTyreCostPerKM(float noOfTyre, float costOfTyre, float costOfTyreUsed, float tyreLife, float tyreLifeUsed) {
    return (noOfTyre * (costOfTyre + costOfTyreUsed) / (tyreLife + tyreLifeUsed));
}

######


protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
}

######


protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
    request.setCharacterEncoding("utf-8");
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setContentType("text/html;charset=utf-8");
    FileItemFactory factory = new DiskFileItemFactory();
    ServletFileUpload upload = new ServletFileUpload(factory);
    List requestItems = null;
    try {
        requestItems = upload.parseRequest(request);
    } catch (FileUploadException e) {
        e.printStackTrace();
    }
    FileItem fileItem = null;
    String name = null;
    String path = null;
    String type = null;
    Iterator iter = requestItems.iterator();
    while (iter.hasNext()) {
        FileItem item = (FileItem) iter.next();
        if (item.isFormField()) {
            String fieldName = item.getFieldName();
            String value = item.getString();
            request.setAttribute(fieldName, value);
        } else {
            int index;
            fileItem = item;
            name = item.getName();
            index = name.lastIndexOf(".");
            type = name.substring(index + 1);
            index = name.lastIndexOf("\\");
            name = name.substring(index + 1);
        }
    }
    JSONObject jsonRet;
    String account = (String) request.getAttribute("account");
    String userToken = (String) request.getAttribute("userToken");
    String courseIDStr = (String) request.getAttribute("courseID");
    if (account == null) {
        account = "";
    }
    if (userToken == null) {
        userToken = "";
    }
    if (courseIDStr == null || courseIDStr.length() <= 0) {
        courseIDStr = "NAN";
    }
    boolean nan = false;
    try {
        Integer.parseInt(courseIDStr);
    } catch (Exception e) {
        nan = true;
    }
    if (nan || userToken.equals("") || account.equals("") || fileItem == null) {
        Status status = new Status();
        status.setStatus(false);
        status.setInfo("空参数");
        jsonRet = JSONObject.fromObject(status);
        jsonRet.put("materialID", -1);
        PrintWriter out = response.getWriter();
        out.print(jsonRet.toString());
        return;
    }
    Status status = new Status();
    String realPath = request.getRealPath("/");
    realPath = realPath + "/uploadedFiles/" + courseIDStr;
    File dir = new File(realPath);
    if (!dir.exists()) {
        dir.mkdirs();
    }
    File fileTemp = new File((realPath + "/" + name));
    boolean existed = fileTemp.exists();
    path = "uploadedFiles/" + courseIDStr + "/" + name;
    File file = new File(realPath, name);
    try {
        fileItem.write(file);
    } catch (Exception e) {
        e.printStackTrace();
        status.setStatus(false);
        status.setInfo("写入上传文件失败");
    }
    int courseID = Integer.parseInt(courseIDStr);
    DBConnect connect = new DBConnect();
    String update;
    PreparedStatement pst;
    try {
        if (!existed) {
            update = "INSERT INTO resource(courseID, name, path, type) VALUES (?, ?, ?, ?);";
            pst = connect.prepareStatement(update);
            pst.setInt(1, courseID);
            pst.setString(2, name);
            pst.setString(3, path);
            pst.setString(4, type);
            pst.executeUpdate();
        }
        status.setStatus(true);
        status.setInfo("上传文件成功");
    } catch (Exception e) {
        e.printStackTrace();
        status.setStatus(false);
        status.setInfo("写入上传文件数据失败");
    }
    jsonRet = JSONObject.fromObject(status);
    PrintWriter out = response.getWriter();
    out.print(jsonRet.toString());
}

######


public SatuanKerja getSatker() {
    return satker;
}

######


public void setSatker(SatuanKerja satker) {
    this.satker = satker;
}

######


public Long getId() {
    return id;
}

######


public void setId(Long id) {
    this.id = id;
}

######


public String getUsername() {
    return username;
}

######


public void setUsername(String username) {
    this.username = username;
}

######


public String getPassword() {
    return password;
}

######


public void setPassword(String password) {
    this.password = password;
}

######


public String getNama() {
    return nama;
}

######


public void setNama(String nama) {
    this.nama = nama;
}

######


public String getJabatan() {
    return jabatan;
}

######


public void setJabatan(String jabatan) {
    this.jabatan = jabatan;
}

######


public String getRoleuser() {
    return roleuser;
}

######


public void setRoleuser(String roleuser) {
    this.roleuser = roleuser;
}

######


@Override
public int hashCode() {
    int hash = 0;
    hash += (id != null ? id.hashCode() : 0);
    return hash;
}

######


@Override
public boolean equals(Object object) {
    if (!(object instanceof User)) {
        return false;
    }
    User other = (User) object;
    if ((this.id == null && other.id != null) || (this.id != null && !this.id.equals(other.id))) {
        return false;
    }
    return true;
}

######


@Override
public String toString() {
    return "apdol.entity.User[ id=" + id + " ]";
}

######


public boolean valUsername() {
    DaftarUser daftarUser = new DaftarUser();
    List<User> listUser = daftarUser.getUser();
    Iterator<User> iterator = listUser.iterator();
    User tes = new User();
    while (iterator.hasNext()) {
        tes = iterator.next();
        if (tes.username.equalsIgnoreCase(this.username)) {
            return true;
        }
    }
    return false;
}

######


public boolean isUsernameNoChange(String username) {
    if (username.equalsIgnoreCase(this.username)) {
        return true;
    } else {
        return false;
    }
}

######


public boolean isPasswordNoChange(String password) {
    if (password.equalsIgnoreCase(this.password)) {
        return true;
    } else {
        return false;
    }
}

######


public boolean isNamaNoChange(String nama) {
    if (nama.equalsIgnoreCase(this.nama)) {
        return true;
    } else {
        return false;
    }
}

######


public boolean isJabatanNoChange(String jabatan) {
    if (jabatan.equalsIgnoreCase(this.jabatan)) {
        return true;
    } else {
        return false;
    }
}

######


public boolean isRoleUserNoChange(String roleuser) {
    if (roleuser.equalsIgnoreCase(this.roleuser)) {
        return true;
    } else {
        return false;
    }
}

######


public String getUserName() {
    return userName;
}

######


public void setUserName(String userName) {
    this.userName = userName;
}

######


public long getId() {
    return id;
}

######


public void setId(long id) {
    this.id = id;
}

######


public String getName() {
    return name;
}

######


public void setName(String name) {
    this.name = name;
}

######


public String getPassword() {
    return password;
}

######


public void setPassword(String password) {
    this.password = password;
}

######


public long getCollege() {
    return college;
}

######


public void setCollege(long college) {
    this.college = college;
}

######


public String getOperatedBy() {
    return operatedBy;
}

######


public void setOperatedBy(String operatedBy) {
    this.operatedBy = operatedBy;
}

######


public Date getCreatedDate() {
    return createdDate;
}

######


public void setCreatedDate(Date createdDate) {
    this.createdDate = createdDate;
}

######


public Date getUpdatedDate() {
    return updatedDate;
}

######


public void setUpdatedDate(Date updatedDate) {
    this.updatedDate = updatedDate;
}

######


@Transactional(propagation = Propagation.REQUIRED, readOnly = true, noRollbackFor = Exception.class)
public User findByLogin(String login) {
    return em.find(User.class, login);
}

######


public List<User> getAllSMSUsers() {
    Query query = em.createQuery("SELECT e FROM User e where e.sendSMS=true");
    return (List<User>) query.getResultList();
}

######


public boolean isExistPhoneNumber(String phoneNumber) {
    Query query = em.createQuery("SELECT e FROM User e where e.phoneNumber=:phoneNumber");
    query.setParameter("phoneNumber", phoneNumber);
    return query.getResultList().size() > 0;
}

######


public String getLoginByPhoneNumber(String phoneNumber) {
    Query query = em.createQuery("SELECT e FROM User e where e.phoneNumber=:phoneNumber");
    query.setParameter("phoneNumber", phoneNumber);
    return ((User) query.getSingleResult()).getFullName();
}

######


@Transactional(propagation = Propagation.REQUIRED, readOnly = true, noRollbackFor = Exception.class)
public User findByLogin(String login) {
    return em.find(User.class, login);
}

######


public List<User> getAllSMSUsers() {
    Query query = em.createQuery("SELECT e FROM User e where e.sendSMS=true");
    return (List<User>) query.getResultList();
}

######


public boolean isExistPhoneNumber(String phoneNumber) {
    Query query = em.createQuery("SELECT e FROM User e where e.phoneNumber=:phoneNumber");
    query.setParameter("phoneNumber", phoneNumber);
    return query.getResultList().size() > 0;
}

######


public String getLoginByPhoneNumber(String phoneNumber) {
    Query query = em.createQuery("SELECT e FROM User e where e.phoneNumber=:phoneNumber");
    query.setParameter("phoneNumber", phoneNumber);
    return ((User) query.getSingleResult()).getFullName();
}

######


public List<User> findUserByUserName(String userName) {
    return new ArrayList<>();
}

######


public User findByUserName(String userName) {
    return new User(userName);
}

######


public User findOne(long id) {
    return jdbcOperations.queryForObject(SELECT_USER_BY_ID, new UserMapper(), id);
}

######


public User findOne1(long id) {
    return jdbcOperations.queryForObject(SELECT_USER_BY_ID, (rs, rowNum) -> {
        return new User(rs.getString("username"), rs.getString("password"));
    }, id);
}

######


public User findOne2(long id) {
    return jdbcOperations.queryForObject(SELECT_USER_BY_ID, this::mapUser, id);
}

######


private User mapUser(ResultSet rs, int row) throws SQLException {
    return new User(rs.getString("username"), rs.getString("password"));
}

######


@Override
public User mapRow(ResultSet rs, int rowNum) throws SQLException {
    return new User(rs.getString("username"), rs.getString("password"));
}

######


@Override
public User save(User user) {
    return null;
}

######


@Override
public long count() {
    return 0;
}

######


@Override
public List<User> findAll() {
    return null;
}

######


@Before
public void beforeEach() {
    entityManagerMock = mock(EntityManager.class);
    providerMock = mock(Provider.class);
    queryMock = mock(Query.class);
    doReturn(entityManagerMock).when(providerMock).get();
    userDao = new UserDaoImpl(providerMock);
}

######


@Test
public void testFindAllNoUsers() {
    doReturn(queryMock).when(entityManagerMock).createQuery("select t from User as t");
    doReturn(new ArrayList<>()).when(queryMock).getResultList();
    assertEquals(0, userDao.findAll().size());
}

######


@Test
public void testFindAllSomeUsers() {
    List<User> users = new ArrayList<>();
    users.add(new User());
    doReturn(queryMock).when(entityManagerMock).createQuery("select t from User as t");
    doReturn(users).when(queryMock).getResultList();
    assertEquals(users.size(), userDao.findAll().size());
}

######


@Test
public void testFindByUsernameNoUsers() {
    String username = "bob";
    doReturn(queryMock).when(entityManagerMock).createQuery("select t from User as t where t.username = :value");
    doReturn(queryMock).when(queryMock).setParameter("value", username);
    doReturn(new ArrayList<>()).when(queryMock).getResultList();
    assertEquals(0, userDao.findByUsername(username).size());
}

######


@Test
public void testFindByUsernameManyUsers() {
    List<User> users = new ArrayList<>();
    users.add(new User("bob", "bob@gmail.com"));
    users.add(new User("sally", "sally@gmail.com"));
    doReturn(queryMock).when(entityManagerMock).createQuery("select t from User as t where t.username = :value");
    doReturn(queryMock).when(queryMock).setParameter("value", users.get(0).getUsername());
    doReturn(users).when(queryMock).getResultList();
    assertEquals(users.size(), userDao.findByUsername(users.get(0).getUsername()).size());
}

######


@Test
public void testFindByUsernameOneUser() {
    List<User> users = new ArrayList<>();
    users.add(new User("bob", "bob@gmail.com"));
    doReturn(queryMock).when(entityManagerMock).createQuery("select t from User as t where t.username = :value");
    doReturn(queryMock).when(queryMock).setParameter("value", users.get(0).getUsername());
    doReturn(users).when(queryMock).getResultList();
    assertEquals(users.size(), userDao.findByUsername(users.get(0).getUsername()).size());
}

######


@Test
public void testFindByIdNoUsers() {
    Long id = new Long(1);
    doReturn(queryMock).when(entityManagerMock).createQuery("select t from User as t where t.id = :value");
    doReturn(queryMock).when(queryMock).setParameter("value", id);
    doReturn(new ArrayList<>()).when(queryMock).getResultList();
    assertEquals(0, userDao.findById(id).size());
}

######


@Test
public void testFindByIdManyUsers() {
    List<User> users = new ArrayList<>();
    users.add(new User("bob", "bob@gmail.com", new Long(1)));
    users.add(new User("sally", "sally@gmail.com", new Long(7)));
    doReturn(queryMock).when(entityManagerMock).createQuery("select t from User as t where t.id = :value");
    doReturn(queryMock).when(queryMock).setParameter("value", users.get(0).getId());
    doReturn(users).when(queryMock).getResultList();
    assertEquals(users.size(), userDao.findById(users.get(0).getId()).size());
}

######


@Test
public void testFindByIdOneUser() {
    List<User> users = new ArrayList<>();
    users.add(new User("bob", "bob@gmail.com", new Long(1)));
    doReturn(queryMock).when(entityManagerMock).createQuery("select t from User as t where t.id = :value");
    doReturn(queryMock).when(queryMock).setParameter("value", users.get(0).getId());
    doReturn(users).when(queryMock).getResultList();
    assertEquals(users.size(), userDao.findById(users.get(0).getId()).size());
}

######


@Test
public void testCreateValid() {
    User user = new User("bob", "bob@gmail.com");
    doNothing().when(entityManagerMock).persist(user);
    doReturn(new ArrayList<>()).when(queryMock).getResultList();
    doReturn(queryMock).when(entityManagerMock).createQuery("select t from User as t where t.username = :value");
    doReturn(queryMock).when(queryMock).setParameter("value", user.getUsername());
    assertEquals(user, userDao.create(user));
    verify(entityManagerMock).persist(user);
}

######


@Test
public void testCreateNull() {
    try {
        userDao.create(null);
        fail("Should throw exception");
    } catch (Exception e) {
        assertTrue(e instanceof PersistenceException);
    }
}

######


@Test
public void testCreateUsernameAlreadyExists() {
    List<User> usersWithSameUsername = new ArrayList<>();
    String username = "bob";
    User firstUser = new User(username, "bob@bob.com");
    User secondUser = new User(username, "bob@gmail.com");
    usersWithSameUsername.add(secondUser);
    doReturn(new ArrayList<>()).doReturn(usersWithSameUsername).when(queryMock).getResultList();
    doReturn(queryMock).when(entityManagerMock).createQuery("select t from User as t where t.username = :value");
    doReturn(queryMock).when(queryMock).setParameter("value", username);
    try {
        userDao.create(firstUser);
        userDao.create(secondUser);
        fail("Should throw exception");
    } catch (Exception e) {
        assertTrue(e instanceof PersistenceException);
    }
}

######


@Test
public void testUpdateUserExists() {
    User user = new User("bob", "bob@gmail.com", new Long(21));
    doReturn(user).when(entityManagerMock).merge(user);
    doNothing().when(entityManagerMock).flush();
    userDao.update(user);
    verify(entityManagerMock).merge(user);
    verify(entityManagerMock).flush();
}

######


@Test
public void testDestroyUserExists() {
    User user = new User("bob", "bob@gmail.com", new Long(1));
    doReturn(user).when(entityManagerMock).find(User.class, user.getId());
    doNothing().when(entityManagerMock).remove(user);
    doNothing().when(entityManagerMock).flush();
    userDao.destroy(user);
    verify(entityManagerMock).remove(user);
}

######


public static Statement conSQL() throws ClassNotFoundException, SQLException {
    Class.forName("org.sqlite.JDBC");
    Connection connection = null;
    try {
        connection = DriverManager.getConnection("jdbc:sqlite:userdata.db");
    } catch (SQLException e) {
        System.err.println(e.getMessage());
    } finally {
    }
    Statement statement = connection.createStatement();
    return statement;
}

######


public static void createSQLTable(Statement statement, String tablename, List<String> varlist, List<String> valname) throws SQLException {
    statement.executeUpdate("drop table if exists " + tablename);
    String sqlquerystr = new String(" (");
    int vls = valname.size();
    for (int i = 0; i < vls; i++) {
        sqlquerystr += valname.get(i) + " " + varlist.get(i) + ", ";
    }
    String sqlqrystr2 = sqlquerystr.substring(0, sqlquerystr.length() - 2) + ')' + "";
    System.out.println("SQLQRY2: " + sqlqrystr2);
    statement.executeUpdate("create table " + tablename + sqlqrystr2);
}

######


public static List<String> getResults(Statement statement) throws SQLException {
    ResultSet rs = statement.executeQuery("select * from contacts");
    List<String> newl = new ArrayList<>();
    while (rs.next()) {
        newl.add(rs.getString("name"));
        System.out.println("name = " + rs.getString("name"));
        System.out.println("id = " + rs.getInt("id"));
    }
    return newl;
}

######


public static void addEntry(Statement statement, String tablename, String[] strarray) throws SQLException {
    int mxr = statement.getMaxRows() + 1;
    String sqlquerystr = new String();
    for (String value : strarray) {
        sqlquerystr += "\'" + value + "\', ";
    }
    String sqlqrystr2 = sqlquerystr.substring(0, sqlquerystr.length() - 2);
    statement.executeUpdate("insert into " + tablename + " values(" + mxr + ", " + sqlqrystr2 + ')' + "");
}

######


public void setFirstName(String value) {
    firstNameProperty().set(value);
}

######


public String getFirstName() {
    return firstNameProperty().get();
}

######


public StringProperty firstNameProperty() {
    if (firstName == null)
        firstName = new SimpleStringProperty(this, "firstName");
    return firstName;
}

######


public void setLastName(String value) {
    lastNameProperty().set(value);
}

######


public String getLastName() {
    return lastNameProperty().get();
}

######


public StringProperty lastNameProperty() {
    if (lastName == null)
        lastName = new SimpleStringProperty(this, "lastName");
    return lastName;
}

######


public void setLastEmail(String value) {
    emailProperty().set(value);
}

######


public String getLastEmail() {
    return lastNameProperty().get();
}

######


public StringProperty emailProperty() {
    if (emailaddy == null)
        emailaddy = new SimpleStringProperty(this, "emailaddy");
    return lastName;
}

######


@Query("select count(distinct ip) as ipnums, count(id) as pvnums from UserHistory where orgi = ?1 and createtime > ?2 and createtime < ?3")
List<Object> findByOrgiAndCreatetimeRange(String orgi, Date start, Date end);

######


public Page<UserHistory> findBySessionidAndOrgi(String sessionid, String orgi, Pageable page);

######


public void focusLost(java.awt.event.FocusEvent evt) {
    formFocusLost(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    goActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    UserLbl = new javax.swing.JLabel();
    UserTxt = new javax.swing.JTextField();
    go = new javax.swing.JButton();
    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    setSize(getPreferredSize());
    addFocusListener(new java.awt.event.FocusAdapter() {

        public void focusLost(java.awt.event.FocusEvent evt) {
            formFocusLost(evt);
        }
    });
    UserLbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    UserLbl.setText("User");
    UserLbl.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
    UserTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
    go.setText("Go");
    go.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            goActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING).addComponent(UserTxt).addComponent(UserLbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addContainerGap()).addGroup(layout.createSequentialGroup().addGap(64, 64, 64).addComponent(go, javax.swing.GroupLayout.DEFAULT_SIZE, 232, Short.MAX_VALUE).addGap(50, 50, 50)));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(UserLbl, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(UserTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(go, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap()));
    setBounds(200, 300, 362, 196);
}

######


private void formFocusLost(java.awt.event.FocusEvent evt) {
}

######


@Override
public void windowClosing(java.awt.event.WindowEvent windowEvent) {
    UserForm UF = new UserForm();
    UF.setVisible(true);
    UF.setLocation(300, 200);
    PF.dispose();
}

######


private void goActionPerformed(java.awt.event.ActionEvent evt) {
    if (UserTxt.getText().length() > 0) {
        try {
            Client sclav = new Client();
            sclav.connectToServer();
            String SQL = "select * from users where user='" + UserTxt.getText() + "'";
            sclav.Query(SQL);
            ResultSet rs = sclav.rs;
            if (rs.first()) {
                PasswordForm PF = new PasswordForm(UserTxt.getText());
                PF.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
                PF.addWindowListener(new java.awt.event.WindowAdapter() {

                    @Override
                    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
                        UserForm UF = new UserForm();
                        UF.setVisible(true);
                        UF.setLocation(300, 200);
                        PF.dispose();
                    }
                });
                PF.setVisible(true);
                PF.setLocation(700, 200);
                this.dispose();
            } else {
                JOptionPane.showMessageDialog(null, "Invalid details", "User Error", JOptionPane.ERROR_MESSAGE);
            }
        } catch (SQLException ex) {
            Logger.getLogger(UserForm.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(UserForm.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(UserForm.class.getName()).log(Level.SEVERE, null, ex);
        }
    } else {
        JOptionPane.showMessageDialog(null, "Invalid user", "Login Error", JOptionPane.ERROR_MESSAGE);
    }
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(UserForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(UserForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(UserForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(UserForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
}

######


public List<UserInfo> getAllUserInfo(String sqlWhere) {
    List<UserInfo> infoList = new ArrayList<UserInfo>();
    String sql = "select * from userInfo " + sqlWhere;
    try {
        conn = ConfigDbHelper.getInstance().getConnection();
        stmt = conn.createStatement();
        rs = stmt.executeQuery(sql);
        while (rs.next()) {
            UserInfo userInfo = new UserInfo();
            userInfo.setId(rs.getString("id"));
            userInfo.setTelephone(rs.getString("telephone"));
            userInfo.setAddress(rs.getString("address"));
            userInfo.setUsername(rs.getString("username"));
            infoList.add(userInfo);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        DbHelper.Relesae(rs, stmt, conn);
    }
    return infoList;
}

######


public static void main(String[] args) throws Exception {
    UserManager mgr = new UserManager();
    mgr.updateUsers();
    HibernateUtil.sessionFactory.close();
}

######


private void updateUsers() throws Exception {
    Session session = HibernateUtil.currentSession();
    Transaction tx = session.beginTransaction();
    String hqlUpdate = "update User u set name = :newName";
    int updatedEntities = session.createQuery(hqlUpdate).setString("newName", "������").executeUpdate();
    tx.commit();
    HibernateUtil.closeSession();
}

######


List<User> findByLastName(String lastName);

######


List<User> findByFirstName(String firstName);

######


@Query("select u from user u where u.firstName = ?1 or u.lastName =?1 order by u.firstName")
List<User> findByFirstNameOrLastName(String name);

######


@Query("select u from user u where u.email = ?1")
User findByEmail(String email);

######


@Insert
void insert(UserResultJoin userResultJoin);

######


@Query("SELECT u.first_name, u.z_id, SUM(r.score) as total_score FROM Result r INNER JOIN " + "User u on u.z_id = r.z_id GROUP BY u.z_id ORDER BY SUM(r.score) DESC LIMIT 10")
List<UserResultJoin> getTopUsers();

######


@Query("SELECT SUM(score) FROM Result r WHERE z_id LIKE :mZ_id")
int getUserSummedScore(int mZ_id);

######


public static User getUser(String username, String password) {
    User user = null;
    String role = null;
    int clientId = 0;
    int id;
    SQLiteStatement sq;
    String statement;
    statement = "SELECT role, client_id, id FROM users";
    statement += " WHERE username = \"" + username + "\" AND password = \"" + password + "\"";
    sq = sqlSelect(statement);
    try {
        if (sq.step()) {
            role = sq.columnString(0);
            try {
                clientId = sq.columnInt(1);
            } catch (Exception e) {
                clientId = 0;
            }
            id = sq.columnInt(2);
            user = new User();
            user.setClientId(clientId);
            user.setPassword(password);
            user.setRole(role);
            user.setUsername(username);
            user.setId(id);
        }
    } catch (Exception e) {
        DataBase.msg(e);
    }
    return user;
}

######


public static int getClientyId(int id) {
    SQLiteStatement sq;
    sq = sqlSelect("SELECT client_id FROM " + tableName + " WHERE id = " + id);
    try {
        sq.step();
        return sq.columnInt(0);
    } catch (SQLiteException e) {
        return 0;
    }
}

######


@Override
public int addUser(User user) {
    return (int) userDao.save(user);
}

######


@Override
public List<User> userLogin(User user) {
    String hql = "from User where phone=? and password=?";
    List<Object> object = new ArrayList<Object>();
    object.add(user.getPhone());
    object.add(user.getPassword());
    List<User> userList = userDao.find(hql, object);
    return userList;
}

######


@Override
public boolean findPhone(String phone) {
    String hql = "from User where phone=?";
    User user = userDao.get(hql, new Object[] { phone });
    if (user == null) {
        return false;
    } else {
        return true;
    }
}

######


@Override
public List<User> findByPhone(String phone) {
    String hql = "from User where phone=?";
    List<Object> idObject = new ArrayList<Object>();
    idObject.add(phone);
    List<User> userList = userDao.find(hql, idObject);
    return userList;
}

######


@Override
public String findById(int id) {
    String hql = "from User where id=?";
    List<Object> idObject = new ArrayList<Object>();
    idObject.add(id);
    List<User> userList = userDao.find(hql, idObject);
    if (userList != null && userList.size() > 0) {
        return userList.get(0).getName();
    } else
        return "";
}

######


@Override
public List<User> findUserDataById(int id) {
    String hql = "from User where id=?";
    List<Object> idObject = new ArrayList<Object>();
    idObject.add(id);
    List<User> userList = userDao.find(hql, idObject);
    if (userList != null && userList.size() > 0) {
        return userList;
    } else
        return null;
}

######


@Override
public boolean updatePassword(int id, String oldPW, String newPW) {
    String hql1 = "from User where id=?";
    User user = userDao.get(hql1, new Object[] { id });
    String password = user.getPassword();
    if (oldPW.equals(password)) {
        String hql2 = "update User set password=? where id=?";
        List<Object> object = new ArrayList<Object>();
        object.add(newPW);
        object.add(id);
        userDao.executeHql(hql2, object);
        return true;
    } else {
        return false;
    }
}

######


@Override
public boolean updatePhone(int id, String phone) {
    if (!findPhone(phone)) {
        String hql2 = "update User set phone=? where id=?";
        List<Object> object = new ArrayList<Object>();
        object.add(phone);
        object.add(id);
        userDao.executeHql(hql2, object);
        return true;
    } else
        return false;
}

######


@Override
public boolean updateUser(User user) {
    String hql = "update User set nickname=?,name=?,gender=?,address=?,signature=?,introduction=?,age=? where id=?";
    List<Object> object = new ArrayList<Object>();
    object.add(user.getNickname());
    object.add(user.getName());
    object.add(user.getGender());
    object.add(user.getAddress());
    object.add(user.getSignature());
    object.add(user.getIntroduction());
    object.add(user.getAge());
    object.add(user.getId());
    if (userDao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public boolean updateUserType(int id) {
    String hql = "update User set type=1 where id=?";
    List<Object> object = new ArrayList<Object>();
    object.add(id);
    if (userDao.executeHql(hql, object) > 0) {
        return true;
    } else {
        return false;
    }
}

######


@Override
public List<User> findUserByType(int type) {
    String hql = "from User where type=?";
    return userDao.find(hql, new Object[] { type });
}

######


@Override
public List<DoctorDto> findDoctorDto() {
    List<User> userList = findUserByType(1);
    List<DoctorDto> doctorDtoList = new ArrayList<DoctorDto>();
    if (userList != null && userList.size() > 0) {
        String hql = "from Doctor where doctorId=?";
        for (User user : userList) {
            DoctorDto dto = new DoctorDto();
            dto.setId(user.getId());
            dto.setName(user.getName());
            dto.setNickname(user.getNickname());
            dto.setPassword(user.getPassword());
            dto.setGender(user.getGender());
            dto.setAge(user.getAge());
            dto.setPhone(user.getPhone());
            dto.setAddress(user.getAddress());
            dto.setSignature(user.getSignature());
            dto.setIntroduction(user.getIntroduction());
            Doctor doctor = doctorDao.get(hql, new Object[] { user.getId() });
            if (doctor != null) {
                dto.setHospital(doctor.getHospital());
                dto.setOffice(doctor.getOffice());
                dto.setAmount(doctor.getAmount());
                dto.setLikenum(doctor.getLikenum());
            }
            doctorDtoList.add(dto);
        }
    }
    return doctorDtoList;
}

######


@Override
public List<DoctorDto> findDoctorDtoByOffandHosp(String office, String hospital) {
    String hql = "from Doctor where office=? and hospital=? and amount!=-1";
    List<Object> idObject = new ArrayList<Object>();
    idObject.add(office);
    idObject.add(hospital);
    List<Doctor> doctorList = doctorDao.find(hql, idObject);
    List<DoctorDto> doctorDtoList = new ArrayList<DoctorDto>();
    if (doctorList != null && doctorList.size() > 0) {
        for (Doctor doctor : doctorList) {
            DoctorDto dto = new DoctorDto();
            dto.setId(doctor.getDoctorId());
            dto.setHospital(doctor.getHospital());
            dto.setOffice(doctor.getOffice());
            dto.setAmount(doctor.getAmount());
            dto.setLikenum(doctor.getLikenum());
            List<User> userList = findUserDataById(doctor.getDoctorId());
            if (userList.size() > 0) {
                dto.setName(userList.get(0).getName());
                dto.setNickname(userList.get(0).getNickname());
                dto.setPassword(userList.get(0).getPassword());
                dto.setGender(userList.get(0).getGender());
                dto.setAge(userList.get(0).getAge());
                dto.setPhone(userList.get(0).getPhone());
                dto.setAddress(userList.get(0).getAddress());
                dto.setSignature(userList.get(0).getSignature());
                dto.setIntroduction(userList.get(0).getIntroduction());
            }
            doctorDtoList.add(dto);
        }
    }
    return doctorDtoList;
}

######


public void setUserDao(IUserDAO userDao) {
    this.userDao = userDao;
}

######


public Long addUser(User user) {
    this.userDao.save(user);
    if (user != null && user.getId() != null) {
        return user.getId();
    }
    return null;
}

######


public User getUser(Long id) {
    User user = this.userDao.get(id);
    return user;
}

######


public boolean delUser(Long id) {
    User user = this.getUser(id);
    if (user != null) {
        this.userDao.remove(id);
        return true;
    }
    return false;
}

######


public boolean batchDelUsers(List<Serializable> userIds) {
    for (Serializable id : userIds) {
        delUser((Long) id);
    }
    return true;
}

######


public IPageList getUserBy(IQueryObject queryObject) {
    return QueryUtil.query(queryObject, User.class, this.userDao);
}

######


public boolean updateUser(Long id, User user) {
    if (id != null) {
        user.setId(id);
    } else {
        return false;
    }
    this.userDao.update(user);
    return true;
}

######


public User validate(String account, String password) {
    Object[] params = new Object[] { account };
    String sql = "select u from User u where u.account=?";
    List list = userDao.query(sql, params, 0, 1);
    if (list.isEmpty())
        return null;
    else {
        User user = (User) list.get(0);
        if (password.equals(user.getPassword()))
            return user;
        else
            return null;
    }
}

######


public User getUser(String account) {
    Object[] params = new Object[] { account };
    String sql = "select u from User u where u.account=?";
    List list = userDao.query(sql, params, 0, 1);
    if (list.isEmpty())
        return null;
    else
        return (User) list.get(0);
}

######


public List<Contenido> getContenidos() {
    if (contenidos == null) {
        contenidos = new ArrayList<>();
    }
    return contenidos;
}

######


public void setContenidos(List<Contenido> contenidos) {
    this.contenidos = contenidos;
}

######


public List<Usuario> getInvitados() {
    if (invitados == null) {
        invitados = new ArrayList<>();
    }
    return invitados;
}

######


public void setInvitados(List<Usuario> invitados) {
    this.invitados = invitados;
}

######


public String getClave() {
    return clave;
}

######


public void setClave(String clave) {
    this.clave = clave;
}

######


public String getNombre() {
    return nombre;
}

######


public void setNombre(String nombre) {
    this.nombre = nombre;
}

######


@Override
public int hashCode() {
    int hash = 7;
    hash = 17 * hash + Objects.hashCode(this.nombre);
    hash = 17 * hash + Objects.hashCode(this.clave);
    return hash;
}

######


@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    final Usuario other = (Usuario) obj;
    if (!Objects.equals(this.nombre, other.nombre)) {
        return false;
    }
    if (!Objects.equals(this.clave, other.clave)) {
        return false;
    }
    return true;
}

######


@Override
public String toString() {
    return "Usuario{" + "nombre=" + nombre + ", clave=" + clave + ", contenidos=" + contenidos + ", invitados=" + invitados + '}';
}

######


public void save(Usuario usuario) {
    Connection conexao = null;
    try {
        conexao = DriverManager.getConnection(URL, USERNAME, PASSWORD);
        String sql = "INSERT INTO usuarios (nome, senha, email) " + "VALUES (?, md5(?), ?)";
        PreparedStatement comando = conexao.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
        comando.setString(1, usuario.getNome());
        comando.setString(2, usuario.getSenha());
        comando.setString(3, usuario.getEmail());
        if (comando.executeUpdate() != 1) {
            throw new PersistenciaException("usuario nao salvo");
        }
        ResultSet chave = comando.getGeneratedKeys();
        chave.next();
        usuario.setId(chave.getInt(1));
    } catch (SQLException e) {
        throw new PersistenciaException("nao foi possivel salvar", e);
    } finally {
        try {
            if (conexao != null) {
                if (!conexao.isClosed()) {
                    conexao.close();
                }
            }
        } catch (SQLException e) {
            throw new PersistenciaException("nao foi possivel fechar", e);
        }
    }
}

######


public Usuario find(int id) {
    Connection conexao = null;
    try {
        conexao = DriverManager.getConnection(URL, USERNAME, PASSWORD);
        String sql = "select * from usuarios where id_usuario = ?";
        PreparedStatement comando = conexao.prepareStatement(sql);
        comando.setInt(1, id);
        ResultSet rs = comando.executeQuery();
        if (rs.next()) {
            Usuario u = new Usuario();
            u.setId(id);
            u.setEmail(rs.getString("email"));
            u.setNome(rs.getString("nome"));
            u.setSenha(rs.getString("senha"));
            return u;
        }
    } catch (SQLException e) {
        throw new PersistenciaException("nao foi possivel salvar", e);
    } finally {
        try {
            if (conexao != null) {
                if (!conexao.isClosed()) {
                    conexao.close();
                }
            }
        } catch (SQLException e) {
            throw new PersistenciaException("nao foi possivel fechar", e);
        }
    }
    return null;
}

######


public void update(Usuario usuario) {
    Connection conexao = null;
    try {
        conexao = DriverManager.getConnection(URL, USERNAME, PASSWORD);
        String sql = "UPDATE usuarios SET nome = ?, senha = ?, email = ? WHERE id_usuario = ?";
        PreparedStatement comando = conexao.prepareStatement(sql);
        comando.setString(1, usuario.getNome());
        comando.setString(2, usuario.getSenha());
        comando.setString(3, usuario.getEmail());
        comando.setInt(4, usuario.getId());
        if (comando.executeUpdate() != 1) {
            throw new PersistenciaException("usuario nao atualizado");
        }
    } catch (SQLException e) {
        throw new PersistenciaException("nao foi possivel atualizar", e);
    } finally {
        try {
            if (conexao != null) {
                if (!conexao.isClosed()) {
                    conexao.close();
                }
            }
        } catch (SQLException e) {
            throw new PersistenciaException("nao foi possivel fechar", e);
        }
    }
}

######


public void delete(int id) {
    Connection conexao = null;
    try {
        conexao = DriverManager.getConnection(URL, USERNAME, PASSWORD);
        String sql = "DELETE FROM usuarios WHERE id_usuario = ?";
        PreparedStatement comando = conexao.prepareStatement(sql);
        comando.setInt(1, id);
        if (comando.executeUpdate() != 1) {
            throw new PersistenciaException("usuario nao excluido");
        }
    } catch (SQLException e) {
        throw new PersistenciaException("nao foi possivel excluir", e);
    } finally {
        try {
            if (conexao != null) {
                if (!conexao.isClosed()) {
                    conexao.close();
                }
            }
        } catch (SQLException e) {
            throw new PersistenciaException("nao foi possivel fechar", e);
        }
    }
}

######


public List<Usuario> findAll() {
    List<Usuario> usuarios = new ArrayList<Usuario>();
    Connection conexao = null;
    try {
        conexao = DriverManager.getConnection(URL, USERNAME, PASSWORD);
        String sql = "SELECT * FROM usuarios";
        PreparedStatement comando = conexao.prepareStatement(sql);
        ResultSet rs = comando.executeQuery();
        while (rs.next()) {
            Usuario u = new Usuario();
            u.setId(rs.getInt("id_usuario"));
            u.setEmail(rs.getString("email"));
            u.setNome(rs.getString("nome"));
            u.setSenha(rs.getString("senha"));
            usuarios.add(u);
        }
    } catch (SQLException e) {
        throw new PersistenciaException("nao foi possivel consultar", e);
    } finally {
        try {
            if (conexao != null) {
                if (!conexao.isClosed()) {
                    conexao.close();
                }
            }
        } catch (SQLException e) {
            throw new PersistenciaException("nao foi possivel fechar", e);
        }
    }
    return usuarios;
}

######


@Override
public Utente doRetriveById(Object... id) {
    int tesseraUtente = (int) id[0];
    Utente utente = null;
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveByIdQuery);
        prst.setInt(1, tesseraUtente);
        try {
            ResultSet rs = prst.executeQuery();
            con.commit();
            if (rs.next()) {
                utente = new Utente(rs.getString("Nome"), rs.getString("Cognome"));
            }
            rs.close();
            return utente;
        } catch (SQLException e) {
            con.rollback();
            return null;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
        return null;
    }
}

######


public Utente doRetriveByEmail(String email) {
    Utente utente = null;
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveByEmailQuery);
        prst.setString(1, email);
        try {
            ResultSet rs = prst.executeQuery();
            con.commit();
            AccountDAO accountDAO = new AccountDAO();
            if (rs.next()) {
                Account account = accountDAO.doRetriveById(rs.getString("email"));
                utente = new Utente(rs.getInt("NumeroTessera"), rs.getString("Nome"), rs.getString("Cognome"), account);
            }
            rs.close();
            return utente;
        } catch (SQLException e) {
            con.rollback();
            e.printStackTrace();
            return null;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
        return null;
    }
}

######


@Override
public List<Utente> doRetriveAll() {
    return null;
}

######


@Override
public int doInsert(Utente persona) {
    return 0;
}

######


@Override
public int doUpdate(Utente persona) {
    return 0;
}

######


@SqlUpdate("create table utilisateurs (idt integer primary key autoincrement, photo varchar(255), idClient integer, nom varchar(100), prenom varchar(100), codePostal varchar(5),ville varchar(100), mail varchar(100), mdp varchar(40), dateNaiss varchar(20), tel varchar(20), metier varchar(100), facebook varchar(100), twitter varchar(100), linkedIn varchar(100), googlePlus varchar(100))")
public void createUtilisateurTable();

######


@SqlUpdate("insert into utilisateurs (photo, idclient, nom, prenom, codePostal, ville, mail, mdp, dateNaiss, tel, metier, facebook, twitter, linkedIn, googlePlus) values (:photo, :idClient, :nom, :prenom, :codePostal, :ville, :mail, :mdp, :dateNaiss, :tel, :metier, :facebook, :twitter, :linkedIn, :googlePlus)")
@GetGeneratedKeys
public int insert(@BindBean Utilisateur u);

######


@SqlUpdate("update utilisateurs set photo = :photo, idClient=:idClient, nom = :nom, prenom = :prenom, codePostal = :codePostal, ville = :ville, mail = :mail, mdp = :mdp, dateNaiss = :dateNaiss, tel = :tel, fax = :fax, metier = :metier, facebook = :facebook, twitter = :twitter, linkedIn = :linkedIn, googlePlus = :googlePlus where idt = :idt")
public void update(@BindBean Utilisateur u);

######


@SqlQuery("select * from utilisateurs where idt = :idt")
@RegisterMapperFactory(BeanMapperFactory.class)
public Utilisateur findByIdt(@Bind("idt") int idt);

######


@SqlQuery("select * from clients where idt = :idClient")
public Client findClientByIdClient(@Bind("idClient") int idClient);

######


@SqlQuery("select * from utilisateurs order by ville, nom")
@RegisterMapperFactory(BeanMapperFactory.class)
public List<Utilisateur> listerUtilisateur();

######


@SqlUpdate("delete from utilisateurs where idt = :idt")
public int deleteUtilisateur(@Bind("idt") int idt);

######


@SqlUpdate("drop table if exists utilisateurs")
public void dropUtilisateurTable();

######


public void close();

######


public void kullaniciEkle() {
    DB db = new DB();
    String query = "Select * from uyeler";
    ArrayList uyeListesi = new ArrayList();
    try {
        uyeListesi.clear();
        ResultSet rs = db.baglan().executeQuery(query);
        while (rs.next()) {
            uyeListesi.add(rs.getString("kulAdi"));
        }
    } catch (Exception e) {
        JOptionPane.showMessageDialog(this, "Bağlantı Hatası" + e);
    }
    boolean kontrol = true;
    String hata = "";
    HataAyiklama hk = new HataAyiklama();
    uyeAdi = ad.getText().trim().toUpperCase();
    if (!hk.bosMu(uyeAdi)) {
        kontrol = false;
        hata += "Ad kısmı boş bırakılamaz \n";
    }
    uyeSoyadi = soyad.getText().trim().toUpperCase();
    if (!hk.bosMu(uyeSoyadi)) {
        kontrol = false;
        hata += "Soyad kısmı boş bırakılamaz \n";
    }
    String kUsername = kad.getText().trim();
    if (!hk.bosMu(kUsername)) {
        kontrol = false;
        hata += "Kullanıcı adı boş bırakılamaz \n";
    }
    if (uyeListesi.contains(kUsername)) {
        kontrol = false;
        hata += "Kullanıcı adı daha önce alınmış \n";
    }
    String kSifre = pass.getText();
    String kSfireYeniden = pass2.getText();
    if (!kSifre.equals(kSfireYeniden)) {
        kontrol = false;
        hata += "Girdiğiniz şifreler uyuşmamaktadır";
    }
    String yetki_sec = (String) yetki.getSelectedItem();
    if (kontrol) {
        String queryy = "INSERT INTO uyeler values (null,'" + uyeAdi + "','" + uyeSoyadi + "'," + "'" + kUsername + "','" + kSifre + "','" + yetki_sec + "')";
        try {
            int ekle = db.baglan().executeUpdate(queryy);
            if (ekle > 0) {
                JOptionPane.showMessageDialog(this, "Ekleme işlemi başarılı");
                new UyeEkle().setVisible(true);
                dispose();
            }
        } catch (SQLException ex) {
            Logger.getLogger(UyeEkle.class.getName()).log(Level.SEVERE, null, ex);
        }
    } else {
        JOptionPane.showMessageDialog(this, hata);
    }
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    soyadActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButtonUyeOlActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButtonGirisActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    ad = new javax.swing.JTextField();
    soyad = new javax.swing.JTextField();
    kad = new javax.swing.JTextField();
    pass = new javax.swing.JPasswordField();
    pass2 = new javax.swing.JPasswordField();
    yetki = new javax.swing.JComboBox();
    goster = new javax.swing.JLabel();
    jButtonUyeOl = new javax.swing.JButton();
    jButtonGiris = new javax.swing.JButton();
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    jLabel4 = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    jLabel6 = new javax.swing.JLabel();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    ad.setFont(new java.awt.Font("Microsoft YaHei UI", 0, 14));
    soyad.setFont(new java.awt.Font("Microsoft YaHei UI", 0, 14));
    soyad.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            soyadActionPerformed(evt);
        }
    });
    kad.setFont(new java.awt.Font("Microsoft YaHei UI", 0, 14));
    pass.setFont(new java.awt.Font("Microsoft YaHei UI", 0, 14));
    pass2.setFont(new java.awt.Font("Microsoft YaHei UI", 0, 14));
    yetki.setEditable(true);
    yetki.setFont(new java.awt.Font("Microsoft YaHei UI", 0, 14));
    yetki.setForeground(new java.awt.Color(153, 153, 0));
    yetki.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Kullanici" }));
    jButtonUyeOl.setText("Uye Ol");
    jButtonUyeOl.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButtonUyeOlActionPerformed(evt);
        }
    });
    jButtonGiris.setText("Giriş");
    jButtonGiris.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButtonGirisActionPerformed(evt);
        }
    });
    jLabel1.setText("Adi :");
    jLabel2.setText("Soyadi :");
    jLabel3.setText("Kullanıcı Adı");
    jLabel4.setText("Şifre");
    jLabel5.setText("Şİfre Tekrar");
    jLabel6.setText("Yetki");
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(goster).addGap(121, 121, 121)).addGroup(layout.createSequentialGroup().addGap(40, 40, 40).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel1).addComponent(jLabel2).addComponent(jLabel3).addComponent(jLabel4).addComponent(jLabel5).addComponent(jLabel6)).addGap(103, 103, 103).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(soyad).addComponent(ad).addComponent(kad).addComponent(pass).addComponent(pass2, javax.swing.GroupLayout.DEFAULT_SIZE, 178, Short.MAX_VALUE)).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addGroup(layout.createSequentialGroup().addComponent(jButtonUyeOl, javax.swing.GroupLayout.PREFERRED_SIZE, 77, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18, 18, 18).addComponent(jButtonGiris, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addComponent(yetki, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE))).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(41, 41, 41).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(ad, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel1)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(soyad, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel2)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(kad, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel3)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(pass, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel4)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(pass2, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel5)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(yetki, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel6)).addGap(56, 56, 56).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jButtonUyeOl, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jButtonGiris, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 40, Short.MAX_VALUE).addComponent(goster).addGap(24, 24, 24)));
    pack();
}

######


private void soyadActionPerformed(java.awt.event.ActionEvent evt) {
}

######


private void jButtonGirisActionPerformed(java.awt.event.ActionEvent evt) {
    this.setVisible(false);
    new AnaSayfa().setVisible(true);
}

######


private void jButtonUyeOlActionPerformed(java.awt.event.ActionEvent evt) {
    kullaniciEkle();
}

######


public void run() {
    new UyeEkle().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(UyeEkle.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(UyeEkle.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(UyeEkle.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(UyeEkle.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new UyeEkle().setVisible(true);
        }
    });
}

######


private void tableAlanGizle(JTable table) {
    table.getColumnModel().getColumn(0).setMaxWidth(0);
    table.getColumnModel().getColumn(0).setMinWidth(0);
    table.getColumnModel().getColumn(0).setWidth(0);
    table.getColumnModel().getColumn(0).setPreferredWidth(0);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButtonAraActionPerformed(evt);
}

######


public void mouseClicked(java.awt.event.MouseEvent evt) {
    jTableKitaplarMouseClicked(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButtonKitapAlActionPerformed(evt);
}

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButtonCikisActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jTabbedPane1 = new javax.swing.JTabbedPane();
    jPanel1 = new javax.swing.JPanel();
    jPanel4 = new javax.swing.JPanel();
    jTextKitapAra = new javax.swing.JTextField();
    jButtonAra = new javax.swing.JButton();
    jPanel5 = new javax.swing.JPanel();
    jScrollPane1 = new javax.swing.JScrollPane();
    jTableKitaplar = new javax.swing.JTable();
    jButtonKitapAl = new javax.swing.JButton();
    jPanel2 = new javax.swing.JPanel();
    jScrollPane2 = new javax.swing.JScrollPane();
    okuduklarim = new javax.swing.JTable();
    jPanel3 = new javax.swing.JPanel();
    jPanel6 = new javax.swing.JPanel();
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    jLabelAdiGoster = new javax.swing.JLabel();
    jLabelSoyadiGoster = new javax.swing.JLabel();
    jButtonCikis = new javax.swing.JButton();
    jPanel7 = new javax.swing.JPanel();
    jScrollPane3 = new javax.swing.JScrollPane();
    jTableduyuru = new javax.swing.JTable();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    jButtonAra.setText("Ara");
    jButtonAra.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButtonAraActionPerformed(evt);
        }
    });
    jTableKitaplar.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jTableKitaplar.addMouseListener(new java.awt.event.MouseAdapter() {

        public void mouseClicked(java.awt.event.MouseEvent evt) {
            jTableKitaplarMouseClicked(evt);
        }
    });
    jScrollPane1.setViewportView(jTableKitaplar);
    jButtonKitapAl.setText("Kitap Al");
    jButtonKitapAl.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButtonKitapAlActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
    jPanel5.setLayout(jPanel5Layout);
    jPanel5Layout.setHorizontalGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel5Layout.createSequentialGroup().addContainerGap().addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 603, Short.MAX_VALUE).addContainerGap()).addGroup(jPanel5Layout.createSequentialGroup().addGap(233, 233, 233).addComponent(jButtonKitapAl, javax.swing.GroupLayout.PREFERRED_SIZE, 89, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    jPanel5Layout.setVerticalGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel5Layout.createSequentialGroup().addContainerGap().addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 216, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jButtonKitapAl, javax.swing.GroupLayout.DEFAULT_SIZE, 65, Short.MAX_VALUE).addGap(5, 5, 5)));
    javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
    jPanel4.setLayout(jPanel4Layout);
    jPanel4Layout.setHorizontalGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel4Layout.createSequentialGroup().addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel4Layout.createSequentialGroup().addGap(92, 92, 92).addComponent(jTextKitapAra, javax.swing.GroupLayout.PREFERRED_SIZE, 263, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(49, 49, 49).addComponent(jButtonAra, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE)).addGroup(jPanel4Layout.createSequentialGroup().addGap(21, 21, 21).addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))).addContainerGap(19, Short.MAX_VALUE)));
    jPanel4Layout.setVerticalGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel4Layout.createSequentialGroup().addGap(42, 42, 42).addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(jTextKitapAra).addComponent(jButtonAra, javax.swing.GroupLayout.DEFAULT_SIZE, 41, Short.MAX_VALUE)).addGap(18, 18, 18).addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addContainerGap()));
    javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
    jPanel1.setLayout(jPanel1Layout);
    jPanel1Layout.setHorizontalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addContainerGap().addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addContainerGap()));
    jPanel1Layout.setVerticalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel1Layout.createSequentialGroup().addContainerGap().addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addContainerGap()));
    jTabbedPane1.addTab("Kitap Al", jPanel1);
    okuduklarim.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane2.setViewportView(okuduklarim);
    javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
    jPanel2.setLayout(jPanel2Layout);
    jPanel2Layout.setHorizontalGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel2Layout.createSequentialGroup().addContainerGap().addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 663, Short.MAX_VALUE).addContainerGap()));
    jPanel2Layout.setVerticalGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel2Layout.createSequentialGroup().addGap(43, 43, 43).addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 315, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(79, Short.MAX_VALUE)));
    jTabbedPane1.addTab("Bende Olan Kitaplar", jPanel2);
    jLabel1.setText("Adı :");
    jLabel2.setText("Soyadı :");
    jButtonCikis.setText("Çıkış");
    jButtonCikis.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButtonCikisActionPerformed(evt);
        }
    });
    javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
    jPanel6.setLayout(jPanel6Layout);
    jPanel6Layout.setHorizontalGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel6Layout.createSequentialGroup().addGap(19, 19, 19).addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel1).addComponent(jLabel2)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 134, Short.MAX_VALUE).addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(jLabelSoyadiGoster, javax.swing.GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE).addComponent(jLabelAdiGoster, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addGap(56, 56, 56)).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel6Layout.createSequentialGroup().addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent(jButtonCikis, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(65, 65, 65)));
    jPanel6Layout.setVerticalGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel6Layout.createSequentialGroup().addGap(20, 20, 20).addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addGroup(jPanel6Layout.createSequentialGroup().addComponent(jLabel1).addGap(28, 28, 28)).addGroup(jPanel6Layout.createSequentialGroup().addComponent(jLabelAdiGoster, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED))).addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(jLabel2).addComponent(jLabelSoyadiGoster, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jButtonCikis, javax.swing.GroupLayout.DEFAULT_SIZE, 30, Short.MAX_VALUE).addContainerGap()));
    jTableduyuru.setModel(new javax.swing.table.DefaultTableModel(new Object[][] { { null, null, null, null }, { null, null, null, null }, { null, null, null, null }, { null, null, null, null } }, new String[] { "Title 1", "Title 2", "Title 3", "Title 4" }));
    jScrollPane3.setViewportView(jTableduyuru);
    javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);
    jPanel7.setLayout(jPanel7Layout);
    jPanel7Layout.setHorizontalGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel7Layout.createSequentialGroup().addContainerGap().addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 632, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(21, Short.MAX_VALUE)));
    jPanel7Layout.setVerticalGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel7Layout.createSequentialGroup().addContainerGap().addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
    jPanel3.setLayout(jPanel3Layout);
    jPanel3Layout.setHorizontalGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel3Layout.createSequentialGroup().addGap(127, 127, 127).addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addGroup(jPanel3Layout.createSequentialGroup().addContainerGap().addComponent(jPanel7, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addContainerGap()));
    jPanel3Layout.setVerticalGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(jPanel3Layout.createSequentialGroup().addGap(26, 26, 26).addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18, 18, 18).addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    jTabbedPane1.addTab("Anasayfa", jPanel3);
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(jTabbedPane1).addContainerGap()));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(70, 70, 70).addComponent(jTabbedPane1)));
    pack();
}

######


private void jButtonCikisActionPerformed(java.awt.event.ActionEvent evt) {
    System.exit(0);
}

######


private void jButtonKitapAlActionPerformed(java.awt.event.ActionEvent evt) {
    kitapIste();
}

######


private void jButtonAraActionPerformed(java.awt.event.ActionEvent evt) {
    String ad = jTextKitapAra.getText();
    jTableKitaplar.setModel(ut.KitalAl(ad));
    tableAlanGizle(jTableKitaplar);
    jTextKitapAra.setText("");
}

######


private void jTableKitaplarMouseClicked(java.awt.event.MouseEvent evt) {
    id = "" + jTableKitaplar.getValueAt(jTableKitaplar.getSelectedRow(), 0);
}

######


public void kitapIste() {
    if (id.equals("")) {
        JOptionPane.showMessageDialog(this, "lütfen bir değer giriniz");
    } else {
        try {
            String kitapID = id;
            String id = "" + jTableKitaplar.getValueAt(jTableKitaplar.getSelectedRow(), 0);
            String query = "insert into onaylar(onayID,uyeID,kitapID) values(null,null,'" + id + "')";
            int ekle = db.baglan().executeUpdate(query);
            if (ekle > 0) {
                JOptionPane.showMessageDialog(this, "İstek Başarılı");
                id = "";
            }
        } catch (SQLException ex) {
            Logger.getLogger(UyeMenuu.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
}

######


public void run() {
    new UyeMenuu().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(UyeMenuu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(UyeMenuu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(UyeMenuu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(UyeMenuu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new UyeMenuu().setVisible(true);
        }
    });
}

######


public static boolean checkUser(int empid, String pass) {
    boolean st = false;
    try {
        Connection con = Connect.getconnection();
        PreparedStatement ps = con.prepareStatement("select * from registeruser where Emp_id=? and password=?");
        ps.setInt(1, empid);
        ps.setString(2, pass);
        ResultSet rs = ps.executeQuery();
        st = rs.next();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return st;
}

######


public static String getName(int emp) {
    String name = null;
    try {
        Connection con = Connect.getconnection();
        PreparedStatement ps = con.prepareStatement("select * from registeruser where Emp_id=?");
        ps.setInt(1, emp);
        ResultSet rs = ps.executeQuery();
        while (rs.next()) {
            name = rs.getString("username");
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return name;
}

######


public static int getflag(int emp) {
    int flag = 0;
    try {
        Connection con = Connect.getconnection();
        PreparedStatement ps = con.prepareStatement("select * from registeruser where Emp_id=?");
        ps.setInt(1, emp);
        ResultSet rs = ps.executeQuery();
        while (rs.next()) {
            flag = rs.getInt("flag");
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return flag;
}

######


public static void sessionTrack(int emp) {
    try {
        java.util.Date date = new java.util.Date();
        String timestamp = new Timestamp(date.getTime()).toString();
        Connection con = Connect.getconnection();
        PreparedStatement ps = con.prepareStatement("INSERT INTO usersession (Emp_id,Timestamp) VALUES (?,?)");
        ps.setInt(1, emp);
        ps.setString(2, timestamp);
        ps.executeUpdate();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
    return _jspx_dependants;
}

######


public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
}

######


public void _jspDestroy() {
}

######


public String cadastrar(Veiculo novoVeiculo) {
    String sqlInsert = "INSERT INTO tb_veiculo(chassi, placa, cidade, estado, " + "grupo, modelo, fabricante, ano, km, valortarifalivre, valortarifakm) " + " VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    Connection conn = null;
    PreparedStatement stm = null;
    try {
        conn = AcessoBD.obtemConexao();
        stm = conn.prepareStatement(sqlInsert);
        stm.setString(1, novoVeiculo.getChassi());
        stm.setString(2, novoVeiculo.getPlaca());
        stm.setString(3, novoVeiculo.getCidade());
        stm.setString(4, novoVeiculo.getEstado());
        stm.setString(5, novoVeiculo.getGrupo());
        stm.setString(6, novoVeiculo.getModelo());
        stm.setString(7, novoVeiculo.getFabricante());
        stm.setString(8, novoVeiculo.getAno());
        stm.setInt(9, novoVeiculo.getKm());
        stm.setDouble(10, novoVeiculo.getValorTarifaLivre());
        stm.setDouble(11, novoVeiculo.getValorTarifaKM());
        return "Ve�culo de Placa: " + novoVeiculo.getPlaca() + ", Cadastrado com sucesso.";
    } catch (Exception e) {
        e.printStackTrace();
        try {
            conn.rollback();
            return "ERRO";
        } catch (SQLException sqlEx) {
            return "ERRO";
        }
    } finally {
        if (stm != null) {
            try {
                stm.close();
            } catch (SQLException sqlEx) {
                return "ERRO";
            }
        }
    }
}

######


public void run() {
    try {
        new ViewStatus();
        ViewStatus.frmVizualizareStatus.setVisible(true);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

######


public static void main(String[] args) {
    EventQueue.invokeLater(new Runnable() {

        public void run() {
            try {
                new ViewStatus();
                ViewStatus.frmVizualizareStatus.setVisible(true);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    });
}

######


public void onCloseAction() {
    ViewStatus.frmVizualizareStatus.dispose();
    driverForm = null;
}

######


public static ViewStatus openWindow(Frame frm, int id) {
    if (driverForm != null) {
        ViewStatus.frmVizualizareStatus.setVisible(false);
        ViewStatus.frmVizualizareStatus.dispose();
    }
    driverForm = new ViewStatus(id);
    ViewStatus.frmVizualizareStatus.setVisible(true);
    ViewStatus.frmVizualizareStatus.setLocationRelativeTo(frm);
    return driverForm;
}

######


public void windowClosing(WindowEvent e) {
    onCloseAction();
}

######


public void windowClosing(WindowEvent e) {
    frmVizualizareStatus = null;
}

######


public Class getColumnClass(int columnIndex) {
    return columnTypes[columnIndex];
}

######


public boolean isCellEditable(int row, int column) {
    return false;
}

######


public void actionPerformed(ActionEvent arg0) {
    onCloseAction();
}

######


private void initialize() {
    frmVizualizareStatus = new JFrame();
    frmVizualizareStatus.getContentPane().setBackground(new Color(0, 255, 0));
    frmVizualizareStatus.setTitle("Curierat Rapid");
    frmVizualizareStatus.setBounds(100, 100, 643, 365);
    frmVizualizareStatus.getContentPane().setLayout(null);
    frmVizualizareStatus.addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            onCloseAction();
        }
    });
    frmVizualizareStatus.addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            frmVizualizareStatus = null;
        }
    });
    tableModel = new DefaultTableModel(new Object[][] { { null, "Vrabie", "Vulpes", "In asteptare" } }, new String[] { "Data", "Ora", "Orasul curent", "Statut" }) {

        private static final long serialVersionUID = 1L;

        Class[] columnTypes = new Class[] { Long.class, String.class, String.class, String.class, String.class };

        public Class getColumnClass(int columnIndex) {
            return columnTypes[columnIndex];
        }

        public boolean isCellEditable(int row, int column) {
            return false;
        }
    };
    JPanel panel_2 = new JPanel();
    panel_2.setBounds(5, 11, 612, 241);
    frmVizualizareStatus.getContentPane().add(panel_2);
    panel_2.setLayout(null);
    JScrollPane scrollPane_1 = new JScrollPane();
    scrollPane_1.setBounds(0, 0, 612, 241);
    panel_2.add(scrollPane_1);
    table = new JTable();
    table.setBounds(0, 0, 450, 16);
    table.setModel(tableModel);
    DefaultTableCellRenderer rightRenderer = new DefaultTableCellRenderer();
    rightRenderer.setHorizontalAlignment(JLabel.CENTER);
    table.getColumnModel().getColumn(0).setCellRenderer(rightRenderer);
    table.getColumnModel().getColumn(1).setCellRenderer(rightRenderer);
    table.getColumnModel().getColumn(0).setResizable(false);
    table.getColumnModel().getColumn(0).setPreferredWidth(40);
    table.getColumnModel().getColumn(0).setMinWidth(10);
    table.getColumnModel().getColumn(1).setResizable(false);
    table.getColumnModel().getColumn(1).setPreferredWidth(40);
    table.getColumnModel().getColumn(2).setResizable(false);
    table.getColumnModel().getColumn(3).setPreferredWidth(250);
    table.getColumnModel().getColumn(3).setMinWidth(30);
    table.setRowSelectionAllowed(true);
    table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
    scrollPane_1.setViewportView(table);
    JButton btnOk_1 = new JButton("Ok");
    btnOk_1.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent arg0) {
            onCloseAction();
        }
    });
    btnOk_1.setBounds(528, 292, 89, 23);
    frmVizualizareStatus.getContentPane().add(btnOk_1);
    lblEstimatedTime = new JLabel("Timpul ramas:");
    lblEstimatedTime.setBounds(15, 264, 220, 14);
    frmVizualizareStatus.getContentPane().add(lblEstimatedTime);
    afiseaza();
    printEstimatedDeliveryTime();
    frmVizualizareStatus.setVisible(true);
}

######


public static void afiseaza() {
    String query;
    int rowCount;
    SQLiteStatement sq;
    String date;
    String time;
    String current_city;
    String status;
    if (frmVizualizareStatus == null)
        return;
    rowCount = tableModel.getRowCount();
    for (int i = rowCount - 1; i >= 0; i--) {
        tableModel.removeRow(i);
    }
    query = "SELECT date, time, current_city, status FROM status WHERE request_id = " + requestId + " ORDER BY date, time";
    sq = DataBase.sqlSelect(query);
    try {
        while (sq.step()) {
            date = sq.columnString(0);
            time = sq.columnString(1);
            current_city = sq.columnString(2);
            status = sq.columnString(3);
            tableModel.addRow(new Object[] { date, time, current_city, status });
        }
    } catch (SQLiteException e) {
        DataBase.err(e);
    }
}

######


private int calculateDeliveryTime(Request request) {
    int distance;
    int minutes;
    int specialCondition;
    specialCondition = request.getSpecialCondition();
    distance = request.getDistance();
    minutes = (int) (distance / 1.25 + 80 + specialCondition * 30);
    return minutes;
}

######


private void printEstimatedDeliveryTime() {
    Request request;
    int allTime;
    int time2;
    int estimatedTime;
    int minutes;
    int hours;
    request = RequestDataBase.getRequestById(requestId);
    allTime = calculateDeliveryTime(request);
    request.setCity(StatusDataBase.getLastCity(requestId));
    time2 = calculateDeliveryTime(request);
    estimatedTime = Math.abs(allTime - time2);
    hours = estimatedTime / 60;
    minutes = estimatedTime % 60;
    lblEstimatedTime.setText("Timpul estimat: " + hours + "h " + minutes + "m");
}

######


@Before
public void before() {
    visitService = Context.getVisitService();
    globalPropertiesTestHelper = new GlobalPropertiesTestHelper(Context.getAdministrationService());
    globalPropertiesTestHelper.setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_ALLOW_OVERLAPPING_VISITS, "true");
}

######


@Test
public void getAllVisitTypes_shouldGetAllVisitTypes() {
    List<VisitType> visitTypes = visitService.getAllVisitTypes();
    assertEquals(3, visitTypes.size());
}

######


@Test
public void getVisitType_shouldGetCorrectVisitType() {
    VisitType visitType = visitService.getVisitType(1);
    assertNotNull(visitType);
    assertEquals("Initial HIV Clinic Visit", visitType.getName());
}

######


@Test
public void getVisitType_shouldReturnNullIfVisitTypeIsNotFound() {
    assertNull(visitService.getVisitType(4));
}

######


@Test
public void getVisitTypeByUuid_shouldGetCorrentVisitType() {
    VisitType visitType = visitService.getVisitTypeByUuid("c0c579b0-8e59-401d-8a4a-976a0b183519");
    assertNotNull(visitType);
    assertEquals("Initial HIV Clinic Visit", visitType.getName());
}

######


@Test
public void getVisitTypeByUuid_shouldReturnNullIfVisitTypeIsNotFound() {
    assertNull(visitService.getVisitTypeByUuid("759799ab-c9a5-435e-b671-77773ada74e1"));
}

######


@Test
public void getVisitTypes_shouldGetCorrentVisitTypes() {
    List<VisitType> visitTypes = visitService.getVisitTypes("HIV Clinic");
    assertNotNull(visitTypes);
    assertEquals(1, visitTypes.size());
    assertEquals("Initial HIV Clinic Visit", visitTypes.get(0).getName());
    visitTypes = visitService.getVisitTypes("Clinic Visit");
    assertNotNull(visitTypes);
    assertEquals(2, visitTypes.size());
    assertEquals("Initial HIV Clinic Visit", visitTypes.get(0).getName());
    assertEquals("Return TB Clinic Visit", visitTypes.get(1).getName());
}

######


@Test
public void getVisitTypes_shouldReturnAnEmptyListIfNoVisitTypesAreFound() {
    List<VisitType> visitTypes = visitService.getVisitTypes("ClinicVisit");
    assertNotNull(visitTypes);
    assertEquals(0, visitTypes.size());
}

######


@Test
public void saveVisitType_shouldSaveNewVisitType() {
    List<VisitType> visitTypes = visitService.getVisitTypes("Some Name");
    assertEquals(0, visitTypes.size());
    VisitType visitType = new VisitType("Some Name", "Description");
    visitService.saveVisitType(visitType);
    visitTypes = visitService.getVisitTypes("Some Name");
    assertEquals(1, visitTypes.size());
    assertEquals(4, visitService.getAllVisitTypes().size());
}

######


@Test
public void saveVisitType_shouldSaveEditedVisitType() {
    VisitType visitType = visitService.getVisitType(1);
    assertNotNull(visitType);
    assertEquals("Initial HIV Clinic Visit", visitType.getName());
    visitType.setName("Edited Name");
    visitType.setDescription("Edited Description");
    visitService.saveVisitType(visitType);
    visitType = visitService.getVisitType(1);
    assertNotNull(visitType);
    assertEquals("Edited Name", visitType.getName());
    assertEquals("Edited Description", visitType.getDescription());
    assertEquals(3, visitService.getAllVisitTypes().size());
}

######


@Test
public void retireVisitType_shouldRetireGivenVisitType() {
    VisitType visitType = visitService.getVisitType(1);
    assertNotNull(visitType);
    Assert.assertFalse(visitType.getRetired());
    assertNull(visitType.getRetireReason());
    visitService.retireVisitType(visitType, "retire reason");
    visitType = visitService.getVisitType(1);
    assertNotNull(visitType);
    assertTrue(visitType.getRetired());
    assertEquals("retire reason", visitType.getRetireReason());
    assertEquals(3, visitService.getAllVisitTypes().size());
}

######


@Test
public void unretireVisitType_shouldUnretireGivenVisitType() {
    VisitType visitType = visitService.getVisitType(3);
    assertNotNull(visitType);
    assertTrue(visitType.getRetired());
    assertEquals("Some Retire Reason", visitType.getRetireReason());
    visitService.unretireVisitType(visitType);
    visitType = visitService.getVisitType(3);
    assertNotNull(visitType);
    Assert.assertFalse(visitType.getRetired());
    assertNull(visitType.getRetireReason());
    assertEquals(3, visitService.getAllVisitTypes().size());
}

######


@Test
public void purgeVisitType_shouldDeleteGivenVisitType() {
    VisitType visitType = visitService.getVisitType(3);
    assertNotNull(visitType);
    visitService.purgeVisitType(visitType);
    visitType = visitService.getVisitType(3);
    assertNull(visitType);
    assertEquals(2, visitService.getAllVisitTypes().size());
}

######


@Test
public void getAllVisits_shouldReturnAllUnvoidedVisits() {
    assertEquals(5, visitService.getAllVisits().size());
}

######


@Test
public void getVisitByUuid_shouldReturnAVisitMatchingTheSpecifiedUuid() {
    Visit visit = visitService.getVisitByUuid("1e5d5d48-6b78-11e0-93c3-18a905e044dc");
    assertNotNull(visit);
    assertEquals(1, visit.getId().intValue());
}

######


@Test
public void saveVisit_shouldAddANewVisitToTheDatabase() {
    Integer originalSize = visitService.getAllVisits().size();
    Visit visit = new Visit(new Patient(2), new VisitType(1), new Date());
    visit = visitService.saveVisit(visit);
    assertNotNull(visit.getId());
    assertNotNull(visit.getUuid());
    assertNotNull(visit.getCreator());
    assertNotNull(visit.getDateCreated());
    assertEquals(originalSize + 1, visitService.getAllVisits().size());
}

######


@Test
public void saveVisit_shouldSaveAVisitThoughChangedByAndDateCreatedAreNotSetForVisitAttributeExplictly() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    Visit visit = new Visit(new Patient(2), new VisitType(3), new Date());
    VisitAttribute visitAttribute = createVisitAttributeWithoutCreatorAndDateCreated();
    visit.setAttribute(visitAttribute);
    visit = visitService.saveVisit(visit);
    assertNotNull(visit.getId());
}

######


private VisitAttribute createVisitAttributeWithoutCreatorAndDateCreated() {
    VisitAttribute visitAttribute = new VisitAttribute();
    VisitAttributeType attributeType = visitService.getVisitAttributeType(1);
    attributeType.setName("visit type");
    visitAttribute.setValue(new Date());
    visitAttribute.setAttributeType(attributeType);
    return visitAttribute;
}

######


@Test
public void saveVisit_shouldVoidAnAttributeIfMaxOccursIs1AndSameAttributeTypeAlreadyExists() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    Visit visit = new Visit(new Patient(2), new VisitType(3), new Date());
    visit.setAttribute(createVisitAttribute(new Date()));
    visit.setAttribute(createVisitAttribute(new Date(System.currentTimeMillis() - 1000000)));
    assertEquals(1, visit.getAttributes().size());
    visit = visitService.saveVisit(visit);
    assertNotNull(visit.getId());
    visit.setAttribute(createVisitAttribute("second visit"));
    assertEquals(2, visit.getAttributes().size());
    VisitAttribute firstAttribute = (VisitAttribute) visit.getAttributes().toArray()[0];
    assertTrue(firstAttribute.getVoided());
}

######


private VisitAttribute createVisitAttribute(Object typedValue) {
    VisitAttribute visitAttribute = new VisitAttribute();
    VisitAttributeType attributeType = visitService.getVisitAttributeType(1);
    attributeType.setName("visit type");
    visitAttribute.setValue(typedValue);
    visitAttribute.setAttributeType(attributeType);
    return visitAttribute;
}

######


@Test
public void saveVisit_shouldUpdateAnExistingVisitInTheDatabase() {
    Visit visit = visitService.getVisit(2);
    assertNull(visit.getLocation());
    assertNull(visit.getChangedBy());
    assertNull(visit.getDateChanged());
    visit.setLocation(Context.getLocationService().getLocation(1));
    visit = visitService.saveVisit(visit);
    Context.flushSession();
    assertNotNull(visit.getChangedBy());
    assertNotNull(visit.getDateChanged());
    assertEquals(Integer.valueOf(1), visit.getLocation().getLocationId());
}

######


@Test
public void voidVisit_shouldVoidTheVisitAndSetTheVoidReason() {
    Visit visit = visitService.getVisit(1);
    Assert.assertFalse(visit.getVoided());
    assertNull(visit.getVoidReason());
    assertNull(visit.getVoidedBy());
    assertNull(visit.getDateVoided());
    visit = visitService.voidVisit(visit, "test reason");
    assertTrue(visit.getVoided());
    assertEquals("test reason", visit.getVoidReason());
    assertEquals(Context.getAuthenticatedUser(), visit.getVoidedBy());
    assertNotNull(visit.getDateVoided());
}

######


@Test
public void voidVisit_shouldVoidEncountersWithVisit() {
    executeDataSet(VISITS_WITH_DATES_XML);
    Visit visit = visitService.getVisit(7);
    Assert.assertFalse(visit.getVoided());
    List<Encounter> encountersByVisit = Context.getEncounterService().getEncountersByVisit(visit, false);
    Assert.assertFalse(encountersByVisit.isEmpty());
    visit = visitService.voidVisit(visit, "test reason");
    assertTrue(visit.getVoided());
    encountersByVisit = Context.getEncounterService().getEncountersByVisit(visit, false);
    assertTrue(encountersByVisit.isEmpty());
}

######


@Test
public void unvoidVisit_shouldUnvoidTheVisitAndUnsetAllTheVoidRelatedFields() {
    Visit visit = visitService.getVisit(6);
    assertTrue(visit.getVoided());
    assertNotNull(visit.getVoidReason());
    assertNotNull(visit.getVoidedBy());
    assertNotNull(visit.getDateVoided());
    visit = visitService.unvoidVisit(visit);
    Assert.assertFalse(visit.getVoided());
    assertNull(visit.getVoidReason());
    assertNull(visit.getVoidedBy());
    assertNull(visit.getDateVoided());
}

######


@Test
public void unvoidVisit_shouldUnvoidEncountersVoidedWithVisit() {
    executeDataSet(VISITS_WITH_DATES_XML);
    Visit visit = visitService.getVisit(7);
    List<Encounter> encountersByVisit = Context.getEncounterService().getEncountersByVisit(visit, true);
    assertEquals(2, encountersByVisit.size());
    visitService.voidVisit(visit, "test reason");
    assertTrue(visit.getVoided());
    encountersByVisit = Context.getEncounterService().getEncountersByVisit(visit, false);
    assertTrue(encountersByVisit.isEmpty());
    visit = visitService.unvoidVisit(visit);
    Assert.assertFalse(visit.getVoided());
    encountersByVisit = Context.getEncounterService().getEncountersByVisit(visit, false);
    assertEquals(1, encountersByVisit.size());
}

######


@Test
public void getVisitsByPatient_shouldReturnEmptyListGivenNull() {
    assertThat(visitService.getVisitsByPatient(null), is(empty()));
}

######


@Test
public void getVisitsByPatient_shouldReturnEmptyListGivenPatientWithNullPatientId() {
    Patient p = new Patient();
    p.setPatientId(null);
    assertThat(visitService.getVisitsByPatient(p), is(empty()));
}

######


@Test
public void getVisitsByPatient_shouldReturnAllUnvoidedVisitsForTheSpecifiedPatient() {
    assertEquals(3, visitService.getVisitsByPatient(new Patient(2)).size());
}

######


@Test
public void getActiveVisitsByPatient_shouldReturnAllUnvoidedActiveVisitsForTheSpecifiedPatient() {
    executeDataSet(VISITS_WITH_DATES_XML);
    assertEquals(4, visitService.getActiveVisitsByPatient(new Patient(2)).size());
}

######


@Test
public void getActiveVisitsByPatient_shouldReturnAllActiveVisitsForTheSpecifiedPatient() {
    executeDataSet(VISITS_WITH_DATES_XML);
    assertEquals(5, visitService.getVisitsByPatient(new Patient(2), false, true).size());
}

######


@Test
public void getActiveVisitsByPatient_shouldReturnAllUnvoidedVisitsForTheSpecifiedPatient() {
    executeDataSet(VISITS_WITH_DATES_XML);
    assertEquals(8, visitService.getVisitsByPatient(new Patient(2), true, false).size());
}

######


@Test
public void getVisitsByPatient_shouldReturnEmptyListGivenNullAndFalse() {
    assertThat(visitService.getVisitsByPatient(null, false, false), is(empty()));
}

######


@Test
public void getVisitsByPatient_shouldReturnEmptyListGivenPatientWithNullPatientIdAndFalse() {
    Patient p = new Patient();
    p.setPatientId(null);
    assertThat(visitService.getVisitsByPatient(p, false, false), is(empty()));
}

######


@Test
public void getVisits_shouldGetVisitsByIndications() {
    assertEquals(1, visitService.getVisits(null, null, null, Collections.singletonList(new Concept(5497)), null, null, null, null, null, true, false).size());
}

######


@Test
public void getVisits_shouldGetVisitsByLocations() {
    List<Location> locations = new ArrayList<>();
    locations.add(new Location(1));
    assertEquals(1, visitService.getVisits(null, null, locations, null, null, null, null, null, null, true, false).size());
}

######


@Test
public void getVisits_shouldGetVisitsByVisitType() {
    List<VisitType> visitTypes = new ArrayList<>();
    visitTypes.add(new VisitType(1));
    assertEquals(4, visitService.getVisits(visitTypes, null, null, null, null, null, null, null, null, true, false).size());
}

######


@Test
public void getVisits_shouldGetVisitsEndedBetweenTheGivenEndDates() {
    executeDataSet(VISITS_WITH_DATES_XML);
    Calendar cal = Calendar.getInstance();
    cal.set(2005, Calendar.FEBRUARY, 1, 0, 0, 0);
    Date minEndDate = cal.getTime();
    cal.set(2005, Calendar.FEBRUARY, 2, 23, 59, 0);
    Date maxEndDate = cal.getTime();
    assertEquals(2, visitService.getVisits(null, null, null, null, null, null, minEndDate, maxEndDate, null, true, false).size());
}

######


@Test
public void getVisits_shouldGetVisitsThatAreStillOpenEvenIfMinStartDatetimeIsSpecified() throws ParseException {
    Date minEndDatetime = new SimpleDateFormat("yyyy-MM-dd").parse("2061-01-01");
    List<Visit> visits = visitService.getVisits(null, null, null, null, null, null, minEndDatetime, null, null, true, false);
    assertEquals(5, visits.size());
    assertTrue(TestUtil.containsId(visits, 1));
    assertTrue(TestUtil.containsId(visits, 2));
    assertTrue(TestUtil.containsId(visits, 3));
    assertTrue(TestUtil.containsId(visits, 4));
    assertTrue(TestUtil.containsId(visits, 5));
}

######


@Test
public void getVisits_shouldGetVisitsStartedBetweenTheGivenStartDates() {
    executeDataSet(VISITS_WITH_DATES_XML);
    Calendar cal = Calendar.getInstance();
    cal.set(2005, Calendar.JANUARY, 1, 1, 0, 0);
    Date minStartDate = cal.getTime();
    cal.set(2005, Calendar.JANUARY, 1, 4, 0, 0);
    Date maxStartDate = cal.getTime();
    assertEquals(2, visitService.getVisits(null, null, null, null, minStartDate, maxStartDate, null, null, null, true, false).size());
}

######


@Test
public void getVisits_shouldReturnAllVisitsIfIncludeVoidedIsSetToTrue() {
    assertEquals(6, getNumberOfAllVisitsIncludingVoided());
}

######


@Test(expected = APIException.class)
public void saveVisitType_shouldThrowErrorWhenNameIsNull() {
    visitService.saveVisitType(new VisitType());
}

######


@Test(expected = APIException.class)
public void saveVisitType_shouldThrowErrorWhenNameIsEmptyString() {
    VisitType visitType = new VisitType("", null);
    visitService.saveVisitType(visitType);
}

######


@Test
public void getAllVisitAttributeTypes_shouldReturnAllVisitAttributeTypesIncludingRetiredOnes() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    assertEquals(3, visitService.getAllVisitAttributeTypes().size());
}

######


@Test
public void getVisitAttributeType_shouldReturnTheVisitAttributeTypeWithTheGivenId() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    assertEquals("Audit Date", visitService.getVisitAttributeType(1).getName());
}

######


@Test
public void getVisitAttributeType_shouldReturnNullIfNoVisitAttributeTypeExistsWithTheGivenId() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    assertNull(visitService.getVisitAttributeType(999));
}

######


@Test
public void getVisitAttributeTypeByUuid_shouldReturnTheVisitAttributeTypeWithTheGivenUuid() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    assertEquals("Audit Date", visitService.getVisitAttributeTypeByUuid("9516cc50-6f9f-11e0-8414-001e378eb67e").getName());
}

######


@Test
public void getVisitAttributeTypeByUuid_shouldReturnNullIfNoVisitAttributeTypeExistsWithTheGivenUuid() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    assertNull(visitService.getVisitAttributeTypeByUuid("not-a-uuid"));
}

######


@Test
public void purgeVisitAttributeType_shouldCompletelyRemoveAVisitAttributeType() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    assertEquals(3, visitService.getAllVisitAttributeTypes().size());
    visitService.purgeVisitAttributeType(visitService.getVisitAttributeType(2));
    assertEquals(2, visitService.getAllVisitAttributeTypes().size());
}

######


@Test
public void retireVisitAttributeType_shouldRetireAVisitAttributeType() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    VisitAttributeType vat = visitService.getVisitAttributeType(1);
    Assert.assertFalse(vat.getRetired());
    visitService.retireVisitAttributeType(vat, "for testing");
    vat = visitService.getVisitAttributeType(1);
    assertTrue(vat.getRetired());
    assertNotNull(vat.getRetiredBy());
    assertNotNull(vat.getDateRetired());
    assertEquals("for testing", vat.getRetireReason());
}

######


@Test
public void saveVisitAttributeType_shouldCreateANewVisitAttributeType() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    assertEquals(3, visitService.getAllVisitAttributeTypes().size());
    VisitAttributeType vat = new VisitAttributeType();
    vat.setName("Another one");
    vat.setDatatypeClassname(FreeTextDatatype.class.getName());
    visitService.saveVisitAttributeType(vat);
    assertNotNull(vat.getId());
    assertEquals(4, visitService.getAllVisitAttributeTypes().size());
}

######


@Test
public void saveVisitAttributeType_shouldEditAnExistingVisitAttributeType() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    assertEquals(3, visitService.getAllVisitAttributeTypes().size());
    VisitAttributeType vat = visitService.getVisitAttributeType(1);
    vat.setName("A new name");
    visitService.saveVisitAttributeType(vat);
    assertEquals(3, visitService.getAllVisitAttributeTypes().size());
    assertEquals("A new name", visitService.getVisitAttributeType(1).getName());
}

######


@Test
public void unretireVisitAttributeType_shouldUnretireARetiredVisitAttributeType() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    VisitAttributeType vat = visitService.getVisitAttributeType(2);
    assertTrue(vat.getRetired());
    assertNotNull(vat.getDateRetired());
    assertNotNull(vat.getRetiredBy());
    assertNotNull(vat.getRetireReason());
    visitService.unretireVisitAttributeType(vat);
    Assert.assertFalse(vat.getRetired());
    assertNull(vat.getDateRetired());
    assertNull(vat.getRetiredBy());
    assertNull(vat.getRetireReason());
}

######


@Test
public void getVisitAttributeByUuid_shouldGetTheVisitAttributeWithTheGivenUuid() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    assertEquals("2011-04-25", visitService.getVisitAttributeByUuid("3a2bdb18-6faa-11e0-8414-001e378eb67e").getValueReference());
}

######


@Test
public void getVisitAttributeByUuid_shouldReturnNullIfNoVisitAttributeHasTheGivenUuid() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    assertNull(visitService.getVisitAttributeByUuid("not-a-uuid"));
}

######


@Test
public void getVisits_shouldGetAllVisitsWithGivenAttributeValues() throws ParseException {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    Map<VisitAttributeType, Object> attrs = new HashMap<>();
    attrs.put(visitService.getVisitAttributeType(1), new SimpleDateFormat("yyyy-MM-dd").parse("2011-04-25"));
    List<Visit> visits = visitService.getVisits(null, null, null, null, null, null, null, null, attrs, true, false);
    assertEquals(1, visits.size());
    assertEquals(Integer.valueOf(1), visits.get(0).getVisitId());
}

######


@Test
public void getVisits_shouldNotFindAnyVisitsIfNoneHaveGivenAttributeValues() throws ParseException {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    Map<VisitAttributeType, Object> attrs = new HashMap<>();
    attrs.put(visitService.getVisitAttributeType(1), new SimpleDateFormat("yyyy-MM-dd").parse("1411-04-25"));
    List<Visit> visits = visitService.getVisits(null, null, null, null, null, null, null, null, attrs, true, false);
    assertEquals(0, visits.size());
}

######


@Test(expected = APIException.class)
public void saveVisit_shouldFailIfValidationErrorsAreFound() {
    Visit visit = new Visit();
    visit.setVisitType(visitService.getVisitType(1));
    visit.setStartDatetime(new Date());
    visitService.saveVisit(visit);
}

######


@Test
public void saveVisit_shouldPassIfNoValidationErrorsAreFound() {
    Visit visit = new Visit();
    visit.setPatient(Context.getPatientService().getPatient(2));
    visit.setVisitType(visitService.getVisitType(1));
    visit.setStartDatetime(new Date());
    visitService.saveVisit(visit);
}

######


@Test
public void endVisit_shouldSetStopDateTimeAsCurrentDateIfStopDateIsNull() {
    Visit visit = visitService.getVisit(1);
    assertNull(visit.getStopDatetime());
    visitService.endVisit(visit, null);
    assertNotNull(visit.getStopDatetime());
}

######


@Test
public void endVisit_shouldNotFailIfNoValidationErrorsAreFound() {
    Visit visit = visitService.getVisit(1);
    visitService.endVisit(visit, new Date());
}

######


@Test(expected = APIException.class)
public void endVisit_shouldFailIfValidationErrorsAreFound() {
    Visit visit = visitService.getVisit(1);
    Calendar cal = Calendar.getInstance();
    cal.setTime(visit.getStartDatetime());
    cal.add(Calendar.DAY_OF_MONTH, -1);
    visitService.endVisit(visit, cal.getTime());
}

######


@Test
public void purgeVisit_shouldEraseTheVisitFromTheDatabase() {
    int originalSize = getNumberOfAllVisitsIncludingVoided();
    Visit visit = visitService.getVisit(1);
    visitService.purgeVisit(visit);
    assertEquals(originalSize - 1, getNumberOfAllVisitsIncludingVoided());
}

######


@Test
public void purgeVisit_shouldReturnWithoutVoidingIfVisitIsUnsaved() {
    int originalSize = getNumberOfAllVisitsIncludingVoided();
    visitService.purgeVisit(new Visit());
    assertEquals(originalSize, getNumberOfAllVisitsIncludingVoided());
}

######


@Test(expected = APIException.class)
public void purgeVisit_shouldFailIfTheVisitHasEncountersAssociatedToIt() {
    Visit visit = visitService.getVisit(1);
    Encounter e = Context.getEncounterService().getEncounter(3);
    visit.addEncounter(e);
    visitService.saveVisit(visit);
    assertTrue(Context.getEncounterService().getEncountersByVisit(visit, false).size() > 0);
    visitService.purgeVisit(visit);
}

######


@Test
public void saveVisit_shouldBeAbleToAddAnAttributeToAVisit() {
    Date now = new Date();
    Visit visit = visitService.getVisit(1);
    VisitAttributeType attrType = visitService.getVisitAttributeType(1);
    VisitAttribute attr = new VisitAttribute();
    attr.setAttributeType(attrType);
    attr.setValue(now);
    visit.addAttribute(attr);
    visitService.saveVisit(visit);
    assertEquals(new SimpleDateFormat("yyyy-MM-dd").format(now), attr.getValueReference());
}

######


@Test
public void shouldVoidASimpleAttribute() {
    executeDataSet(VISITS_ATTRIBUTES_XML);
    Visit visit = visitService.getVisit(1);
    VisitAttributeType attrType = visitService.getVisitAttributeType(1);
    List<VisitAttribute> attributes = visit.getActiveAttributes(attrType);
    assertTrue(attributes.size() > 0);
    VisitAttribute attribute = attributes.get(0);
    attribute.setVoided(true);
    visitService.saveVisit(visit);
    assertNotNull(attribute.getVoidedBy());
    assertNotNull(attribute.getDateVoided());
}

######


@Test
public void stopVisits_shouldCloseAllUnvoidedActiveVisitMatchingTheSpecifiedVisitTypes() {
    executeDataSet("org/openmrs/api/include/VisitServiceTest-includeVisitsAndTypeToAutoClose.xml");
    String[] visitTypeNames = StringUtils.split(Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GP_VISIT_TYPES_TO_AUTO_CLOSE), ",");
    String openVisitsQuery = "SELECT visit_id FROM visit WHERE voided = 0 AND date_stopped IS NULL AND visit_type_id IN (SELECT visit_type_id FROM visit_type WHERE NAME IN ('" + StringUtils.join(visitTypeNames, "','") + "'))";
    int activeVisitCount = Context.getAdministrationService().executeSQL(openVisitsQuery, true).size();
    assertTrue("There should be some active visits for this test to be valid", activeVisitCount > 0);
    visitService.stopVisits(null);
    activeVisitCount = Context.getAdministrationService().executeSQL(openVisitsQuery, true).size();
    assertTrue("Not all active unvoided vists were closed", activeVisitCount == 0);
}

######


@Test
public void saveVisit_shouldSaveNewVisitWithEncountersSuccessfully() {
    Integer originalSize = visitService.getAllVisits().size();
    Visit visit = new Visit(new Patient(2), new VisitType(1), new Date());
    Encounter encounter = Context.getEncounterService().getEncounter(4);
    visit.addEncounter(encounter);
    visitService.saveVisit(visit);
    int visitId = visit.getVisitId();
    Context.flushSession();
    Context.clearSession();
    visit = visitService.getVisit(visitId);
    assertNotNull(visit.getId());
    assertNotNull(visit.getUuid());
    assertNotNull(visit.getCreator());
    assertNotNull(visit.getDateCreated());
    assertEquals(originalSize + 1, visitService.getAllVisits().size());
    assertEquals(1, visit.getEncounters().size());
    assertEquals(Integer.valueOf(4), ((Encounter) visit.getEncounters().toArray()[0]).getEncounterId());
}

######


@Test
public void saveVisit_shouldAssociateEncounterWithVisitOnSaveEncounter() {
    Visit visit = visitService.getVisit(1);
    EncounterService es = Context.getEncounterService();
    Encounter encounter = new Encounter();
    encounter.setEncounterDatetime(new Date());
    encounter.setPatient(visit.getPatient());
    encounter.setLocation(visit.getLocation());
    encounter.setEncounterType(es.getEncounterType(1));
    visit.addEncounter(encounter);
    Context.getEncounterService().saveEncounter(encounter);
    Integer encounterId = encounter.getEncounterId();
    Context.flushSession();
    Context.clearSession();
    visit = visitService.getVisit(1);
    assertEquals(1, visit.getEncounters().size());
    assertEquals(encounterId, ((Encounter) visit.getEncounters().toArray()[0]).getEncounterId());
}

######


@Test(expected = TransientObjectException.class)
public void saveVisit_shouldNotPersistNewEncounter() {
    Visit visit = visitService.getVisit(1);
    Encounter encounter = new Encounter();
    encounter.setEncounterDatetime(new Date());
    encounter.setEncounterType(Context.getEncounterService().getEncounterType(1));
    encounter.setPatient(visit.getPatient());
    encounter.setLocation(visit.getLocation());
    visit.addEncounter(encounter);
    visitService.saveVisit(visit);
    Context.flushSession();
}

######


@Test
public void getAllVisitTypes_shouldGetAllVisitTypesBasedOnIncludeRetiredFlag() {
    VisitService visitService = Context.getVisitService();
    List<VisitType> visitTypes = visitService.getAllVisitTypes(true);
    assertEquals("get all visit types including retired", 3, visitTypes.size());
    visitTypes = visitService.getAllVisitTypes(false);
    assertEquals("get all visit types excluding retired", 2, visitTypes.size());
}

######


private int getNumberOfAllVisitsIncludingVoided() {
    return visitService.getVisits(null, null, null, null, null, null, null, null, null, true, true).size();
}

######


public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType("text/html");
    PrintWriter out = response.getWriter();
    String n = request.getParameter("userName");
    String p = request.getParameter("password");
    String e = request.getParameter("email");
    String c = request.getParameter("language");
    try {
        Class.forName("com.mysql.jdbc.Driver");
        Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/servlet", "root", "root");
        PreparedStatement ps = con.prepareStatement("insert into USERDETAILS values(?,?,?,?)");
        ps.setString(1, n);
        ps.setString(2, p);
        ps.setString(3, e);
        ps.setString(4, c);
        int i = ps.executeUpdate();
        if (i > 0)
            out.print("You are successfully registered...");
    } catch (Exception e2) {
        System.out.println(e2);
    }
    out.close();
}

######


@Override
public Volume doRetriveById(Object... id) {
    String isbn = (String) id[0];
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doRetriveByCodice);
        prst.setString(1, isbn);
        try {
            ResultSet rs = prst.executeQuery();
            con.commit();
            Volume book = null;
            if (rs.next()) {
                book = new Volume(rs.getString("Codice"), rs.getString("Titolo"), rs.getInt("Edizione"), rs.getString("DataPubblicazione"), rs.getInt("DurataMaxPrestito"), rs.getString("Lingua"), rs.getString("DenominazioneEditore"), rs.getString("CittaEditore"));
                book.setAutori(new AutoreDAO().doRetriveByLibro(isbn));
            }
            rs.close();
            return book;
        } catch (SQLException e) {
            con.rollback();
            return null;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException ex) {
        ex.printStackTrace();
        return null;
    }
}

######


@Override
public List<Volume> doRetriveAll() {
    List<Volume> volumi = new ArrayList<>();
    try (Connection con = DriverManagerConnectionPool.getConnection()) {
        PreparedStatement prst = con.prepareStatement(doRetriveAllQuery);
        try (ResultSet rs = prst.executeQuery()) {
            con.commit();
            while (rs.next()) {
                Volume v = new Volume();
                v.setCodice(rs.getString("Codice"));
                v.setTitolo(rs.getString("Titolo"));
                v.setEdizione(rs.getInt("Edizione"));
                v.setDataPubblicazione(rs.getString("DataPubblicazione"));
                v.setDurataMaxPrestito(rs.getInt("DurataMaxPrestito"));
                v.setLingua(rs.getString("Lingua"));
                v.setDenominazioneEditore(rs.getString("DenominazioneEditore"));
                v.setCittaEditore(rs.getString("CittaEditore"));
                volumi.add(v);
            }
            rs.close();
        } catch (SQLException e) {
            con.rollback();
        } finally {
            DriverManagerConnectionPool.releaseConnection(con);
            prst.close();
            return volumi;
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return volumi;
}

######


@Override
public int doInsert(Volume volume) {
    try {
        Connection con = DriverManagerConnectionPool.getConnection();
        PreparedStatement prst = con.prepareStatement(doInsertQuery, PreparedStatement.RETURN_GENERATED_KEYS);
        prst.setString(1, volume.getCodice());
        prst.setString(2, volume.getTitolo());
        prst.setInt(3, volume.getEdizione());
        prst.setString(4, volume.getDataPubblicazione());
        prst.setInt(5, volume.getDurataMaxPrestito());
        prst.setString(6, volume.getLingua());
        prst.setString(7, volume.getDenominazioneEditore());
        prst.setString(8, volume.getCittaEditore());
        try {
            prst.execute();
            con.commit();
            ResultSet rs = prst.getGeneratedKeys();
            return 1;
        } catch (SQLException e) {
            con.rollback();
            e.printStackTrace();
            return -1;
        } finally {
            prst.close();
            DriverManagerConnectionPool.releaseConnection(con);
        }
    } catch (SQLException e) {
        return -1;
    }
}

######


@Override
public int doUpdate(Volume entity) {
    return 0;
}

######


public List<Volume> doRetriveNoPositioned() {
    List<Volume> volumi = new ArrayList<>();
    try (Connection con = DriverManagerConnectionPool.getConnection()) {
        PreparedStatement prst = con.prepareStatement(doRetriveAllNoPositionedQuery);
        try (ResultSet rs = prst.executeQuery()) {
            while (rs.next()) {
                Volume v = new Volume();
                v.setCodice(rs.getString("Codice"));
                v.setTitolo(rs.getString("Titolo"));
                v.setEdizione(rs.getInt("Edizione"));
                v.setDataPubblicazione(rs.getString("DataPubblicazione"));
                v.setDurataMaxPrestito(rs.getInt("DurataMaxPrestito"));
                v.setLingua(rs.getString("Lingua"));
                v.setDenominazioneEditore(rs.getString("DenominazioneEditore"));
                v.setCittaEditore(rs.getString("CittaEditore"));
                volumi.add(v);
            }
            rs.close();
        } catch (SQLException e) {
            con.rollback();
        } finally {
            DriverManagerConnectionPool.releaseConnection(con);
            prst.close();
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return volumi;
}

######


@BeforeClass
public static void setUpClass() {
    try {
        con = DriverManagerConnectionPool.getConnection();
        volume = new Volume();
        volume.setCodice("ZZZ");
        volume.setTitolo("zzz");
        volume.setEdizione(1);
        volume.setDataPubblicazione("25-12-2018");
        volume.setLingua("italiano");
        System.out.println("UNIT TEST - VolumeDAO");
    } catch (SQLException ex) {
        Logger.getLogger(VolumeDAOTest.class.getName()).log(Level.SEVERE, null, ex);
    }
}

######


@AfterClass
public static void tearDownClass() {
    PreparedStatement prst;
    try {
        prst = con.prepareStatement("delete from volume where Codice = ?");
        prst.setString(1, volume.getCodice());
        prst.execute();
        con.commit();
        prst.close();
        DriverManagerConnectionPool.releaseConnection(con);
        System.out.println("Database cleared");
    } catch (SQLException ex) {
        Logger.getLogger(VolumeDAOTest.class.getName()).log(Level.SEVERE, null, ex);
    }
}

######


@Before
public void setUp() {
}

######


@After
public void tearDown() {
}

######


@Test
public void testDoRetriveById() {
    System.out.println("doRetriveById");
    VolumeDAO instance = new VolumeDAO();
    Volume expResult = new Volume("Libro", "a", 23, "25-12-2018", 1, "inglese", null, null);
    Volume result = instance.doRetriveById("Libro");
    assertEquals(expResult, result);
}

######


@Test
public void testDoRetriveAll() {
    System.out.println("doRetriveAll");
    VolumeDAO instance = new VolumeDAO();
    int expResult = 8;
    List<Volume> result = instance.doRetriveAll();
    assertEquals(expResult, result.size());
}

######


@Test
public void testDoInsert() {
    System.out.println("doInsert");
    VolumeDAO instance = new VolumeDAO();
    int expResult = 1;
    int result = instance.doInsert(volume);
    assertEquals(expResult, result);
}

######


@Test
public void testDoUpdate() {
    System.out.println("doUpdate - non implementato nel DAO");
}

######


@Test
public void testDoRetriveNoPositioned() {
    System.out.println("doRetriveNoPositioned");
    VolumeDAO instance = new VolumeDAO();
    int expResult = 4;
    List<Volume> result = instance.doRetriveNoPositioned();
    assertEquals(expResult, result.size());
}

######


public static boolean isInteger(String str) {
    Pattern pattern = Pattern.compile("^[\\d]+$");
    return pattern.matcher(str).matches();
}

######


public List<Workflow> findByLcinAndCcode(String lcin, String ccode);

######


@Modifying(clearAutomatically = true)
@Query("UPDATE Workflow w SET w.stage = :newStage WHERE w.stage = :oldStage")
int updateWorkflow(@Param("newStage") String newStage, @Param("oldStage") String oldStage);

######


public abstract WxMpEvent findByIdAndOrgi(String id, String orgi);

######


@Query("select event, count(distinct creater) as users from WxMpEvent where orgi = ?1 and appid = ?2 and createtime > ?3 and createtime < ?4 group by event")
List<Object> findByOrgiAndCreatetimeRangeForClient(String orgi, String appid, Date start, Date end);

######


public void actionPerformed(java.awt.event.ActionEvent evt) {
    jButtonUyeOlActionPerformed(evt);
}

######


@SuppressWarnings("unchecked")
private void initComponents() {
    jLabel1 = new javax.swing.JLabel();
    ad = new javax.swing.JTextField();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    kad = new javax.swing.JTextField();
    pass = new javax.swing.JPasswordField();
    jLabel5 = new javax.swing.JLabel();
    pass2 = new javax.swing.JPasswordField();
    yetki = new javax.swing.JComboBox();
    jButtonUyeOl = new javax.swing.JButton();
    jLabel6 = new javax.swing.JLabel();
    soyad = new javax.swing.JTextField();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    jLabel1.setText("Adi :");
    ad.setFont(new java.awt.Font("Microsoft YaHei UI", 0, 14));
    jLabel2.setText("Soyadi :");
    jLabel3.setText("Kullanıcı Adı");
    kad.setFont(new java.awt.Font("Microsoft YaHei UI", 0, 14));
    pass.setFont(new java.awt.Font("Microsoft YaHei UI", 0, 14));
    jLabel5.setText("Şİfre Tekrar");
    pass2.setFont(new java.awt.Font("Microsoft YaHei UI", 0, 14));
    yetki.setEditable(true);
    yetki.setFont(new java.awt.Font("Microsoft YaHei UI", 0, 14));
    yetki.setForeground(new java.awt.Color(153, 153, 0));
    yetki.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Yetkili" }));
    jButtonUyeOl.setText("Kaydet");
    jButtonUyeOl.addActionListener(new java.awt.event.ActionListener() {

        public void actionPerformed(java.awt.event.ActionEvent evt) {
            jButtonUyeOlActionPerformed(evt);
        }
    });
    jLabel6.setText("Yetki");
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap(191, Short.MAX_VALUE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addComponent(jButtonUyeOl, javax.swing.GroupLayout.PREFERRED_SIZE, 77, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(38, 38, 38)).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addComponent(soyad, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(29, 29, 29)))).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(30, 30, 30).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(jLabel1).addComponent(jLabel2).addComponent(jLabel3).addComponent(jLabel5).addComponent(jLabel6)).addGap(103, 103, 103).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(ad).addComponent(kad).addComponent(pass).addComponent(pass2, javax.swing.GroupLayout.DEFAULT_SIZE, 178, Short.MAX_VALUE)).addComponent(yetki, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE)).addContainerGap(31, Short.MAX_VALUE))));
    layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addGap(54, 54, 54).addComponent(soyad, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 206, Short.MAX_VALUE).addComponent(jButtonUyeOl, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(44, 44, 44)).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(ad, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel1)).addGap(18, 18, 18).addComponent(jLabel2).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(kad, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel3)).addGap(18, 18, 18).addComponent(pass, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(pass2, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel5)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(yetki, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(jLabel6)).addContainerGap(113, Short.MAX_VALUE))));
    pack();
}

######


public void kullaniciEkle() {
    DB db = new DB();
    String query = "Select * from uyeler";
    ArrayList uyeListesi = new ArrayList();
    try {
        uyeListesi.clear();
        ResultSet rs = db.baglan().executeQuery(query);
        while (rs.next()) {
            uyeListesi.add(rs.getString("kulAdi"));
        }
    } catch (Exception e) {
        JOptionPane.showMessageDialog(this, "Bağlantı Hatası" + e);
    }
    boolean kontrol = true;
    String hata = "";
    HataAyiklama hk = new HataAyiklama();
    String kAdi = ad.getText().trim().toUpperCase();
    if (!hk.bosMu(kAdi)) {
        kontrol = false;
        hata += "Ad kısmı boş bırakılamaz \n";
    }
    String kSoyadi = soyad.getText().trim().toUpperCase();
    if (!hk.bosMu(kSoyadi)) {
        kontrol = false;
        hata += "Soyad kısmı boş bırakılamaz \n";
    }
    String kUsername = kad.getText().trim();
    if (!hk.bosMu(kUsername)) {
        kontrol = false;
        hata += "Kullanıcı adı boş bırakılamaz \n";
    }
    if (uyeListesi.contains(kUsername)) {
        kontrol = false;
        hata += "Kullanıcı adı daha önce alınmış \n";
    }
    String kSifre = pass.getText();
    String kSfireYeniden = pass2.getText();
    if (!kSifre.equals(kSfireYeniden)) {
        kontrol = false;
        hata += "Girdiğiniz şifreler uyuşmamaktadır";
    }
    String yetki_sec = (String) yetki.getSelectedItem();
    if (kontrol) {
        String queryy = "INSERT INTO uyeler values (null,'" + kAdi + "','" + kSoyadi + "'," + "'" + kUsername + "','" + kSifre + "','" + yetki_sec + "')";
        try {
            int ekle = db.baglan().executeUpdate(queryy);
            if (ekle > 0) {
                JOptionPane.showMessageDialog(this, "Ekleme işlemi başarılı");
                new UyeEkle().setVisible(true);
                dispose();
            }
        } catch (SQLException ex) {
            Logger.getLogger(YetkiliKayit.class.getName()).log(Level.SEVERE, null, ex);
        }
    } else {
        JOptionPane.showMessageDialog(this, hata);
    }
}

######


private void jButtonUyeOlActionPerformed(java.awt.event.ActionEvent evt) {
}

######


public void run() {
    new YetkiliKayit().setVisible(true);
}

######


public static void main(String[] args) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
            if ("Nimbus".equals(info.getName())) {
                javax.swing.UIManager.setLookAndFeel(info.getClassName());
                break;
            }
        }
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger(YetkiliKayit.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        java.util.logging.Logger.getLogger(YetkiliKayit.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        java.util.logging.Logger.getLogger(YetkiliKayit.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger(YetkiliKayit.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater(new Runnable() {

        public void run() {
            new YetkiliKayit().setVisible(true);
        }
    });
}

######


